#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BodyDriverPlugin

#include "Basic.hpp"

#include "AnimGraphRuntime_structs.hpp"


namespace SDK
{

// Enum BodyDriverPlugin.BodyDriverMessageType
// NumValues: 0x0017
enum class EBodyDriverMessageType : uint8
{
	kMessageImpulseTypeDefault               = 0,
	kMessageImpulseTypeMelee                 = 1,
	kMessageImpulseTypeBullet                = 2,
	kMessageTriggerRagdollActivation         = 3,
	kMessageFreezeRagdollAndDisableCollision = 4,
	kMessageCharacterCollision               = 5,
	kMessageExplosion_Contact                = 6,
	kMessageExplosion_FreeOrigin             = 7,
	kMessageExplosion_MeleeUnstructuredFall  = 8,
	kMessageExplosion_BulletUnstructuredFall = 9,
	kMessageInitializeData                   = 10,
	kMessageForceSwitchToAnimated            = 11,
	kMessage_END_LaunchSmallClose            = 12,
	kMessage_END_LaunchSmallFar              = 13,
	kMessage_END_BlowSmallClose              = 14,
	kMessage_END_BlowSmallFar                = 15,
	kMessage_END_LaunchLargeClose            = 16,
	kMessage_END_LaunchLargeFar              = 17,
	kMessage_END_BlowLargeClose              = 18,
	kMessage_END_BlowLargeFar                = 19,
	kMessage_END_Strike                      = 20,
	kMessageFallFromBike_END                 = 21,
	BodyDriverMessageType_MAX                = 22,
};

// Enum BodyDriverPlugin.eBodyParts
// NumValues: 0x003A
enum class EeBodyParts : uint8
{
	kPartPelvis                              = 0,
	kPartSpineBase                           = 1,
	kPartSpine1                              = 2,
	kPartSpine2                              = 3,
	kPartSpine3                              = 4,
	kPartSpine4                              = 5,
	kPartNeckBase                            = 6,
	kPartNeck1                               = 7,
	kPartNeck2                               = 8,
	kPartNeck3                               = 9,
	kPartNeck4                               = 10,
	kPartTailBase                            = 11,
	kPartTail1                               = 12,
	kPartTail2                               = 13,
	kPartTail3                               = 14,
	kPartTail4                               = 15,
	kPartLeftArmBase                         = 16,
	kPartLeftArm1                            = 17,
	kPartLeftArm2                            = 18,
	kPartLeftArm3                            = 19,
	kPartLeftArm4                            = 20,
	kPartRightArmBase                        = 21,
	kPartRightArm1                           = 22,
	kPartRightArm2                           = 23,
	kPartRightArm3                           = 24,
	kPartRightArm4                           = 25,
	kPartLeftLegBase                         = 26,
	kPartLeftLeg1                            = 27,
	kPartLeftLeg2                            = 28,
	kPartLeftLeg3                            = 29,
	kPartLeftLeg4                            = 30,
	kPartRightLegBase                        = 31,
	kPartRightLeg1                           = 32,
	kPartRightLeg2                           = 33,
	kPartRightLeg3                           = 34,
	kPartRightLeg4                           = 35,
	kAppendage1                              = 36,
	kAppendage2                              = 37,
	kAppendage3                              = 38,
	kAppendage4                              = 39,
	kAppendage5                              = 40,
	kAppendage6                              = 41,
	kAppendage7                              = 42,
	kAppendage8                              = 43,
	kAppendage9                              = 44,
	kAppendage10                             = 45,
	kAppendage11                             = 46,
	kAppendage12                             = 47,
	kAppendage13                             = 48,
	kAppendage14                             = 49,
	kAppendage15                             = 50,
	kAppendage16                             = 51,
	kAppendage17                             = 52,
	kAppendage18                             = 53,
	kAppendage19                             = 54,
	kInvalidPart                             = 55,
	kNumPossibleParts                        = 56,
	eBodyParts_MAX                           = 57,
};

// Enum BodyDriverPlugin.eCharacterType
// NumValues: 0x0006
enum class EeCharacterType : uint8
{
	kBiped                                   = 0,
	kQuadruped                               = 1,
	kSnake                                   = 2,
	kUnstructured                            = 3,
	kUnset                                   = 4,
	eCharacterType_MAX                       = 5,
};

// ScriptStruct BodyDriverPlugin.PartImpulseOverride
// 0x0008 (0x0008 - 0x0000)
struct FPartImpulseOverride final
{
public:
	EeBodyParts                                   Part;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Impulse;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPartImpulseOverride) == 0x000004, "Wrong alignment on FPartImpulseOverride");
static_assert(sizeof(FPartImpulseOverride) == 0x000008, "Wrong size on FPartImpulseOverride");
static_assert(offsetof(FPartImpulseOverride, Part) == 0x000000, "Member 'FPartImpulseOverride::Part' has a wrong offset!");
static_assert(offsetof(FPartImpulseOverride, Impulse) == 0x000004, "Member 'FPartImpulseOverride::Impulse' has a wrong offset!");

// ScriptStruct BodyDriverPlugin.AnimNode_BodyDriver
// 0x0840 (0x08B0 - 0x0070)
#pragma pack(push, 0x1)
struct alignas(0x10) FAnimNode_BodyDriver : public FAnimNode_SkeletalControlBase
{
public:
	class UBodyDriver_BaseDataTuningSet*          BaseData;                                          // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBodyDriver_BipedFallTuningSet*         BipedFall;                                         // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBodyDriver_BipedBalanceTuningSet*      BalanceRecovery;                                   // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBodyDriver_BipedBalanceTuningSet*      Staggerfall;                                       // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBodyDriver_DebugImpulseTuningSet*      DebugImpulses;                                     // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          IdleAnim;                                          // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBodyDriver_ArchtypeTuningSet*          ArchtypeData;                                      // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          ArchtypeSkeletalMesh;                              // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBodyDriver_BaseDataTuningSet*          ArchtypeBaseData;                                  // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBodyDriver_BipedFallTuningSet*         ArchtypeBipedFall;                                 // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBodyDriver_BipedBalanceTuningSet*      ArchtypeBalanceRecovery;                           // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBodyDriver_BipedBalanceTuningSet*      ArchtypeStaggerfall;                               // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBodyDriver_DebugImpulseTuningSet*      ArchtypeDebugImpulses;                             // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ArchtypeIdleAnim;                                  // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x1E0];                                     // 0x00E0(0x01E0)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputObject_BodyDriver*                m_InputObject;                                     // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0x5E0];                                    // 0x02C8(0x05E0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
#pragma pack(pop)
static_assert(alignof(FAnimNode_BodyDriver) == 0x000010, "Wrong alignment on FAnimNode_BodyDriver");
static_assert(sizeof(FAnimNode_BodyDriver) == 0x0008B0, "Wrong size on FAnimNode_BodyDriver");
static_assert(offsetof(FAnimNode_BodyDriver, BaseData) == 0x000070, "Member 'FAnimNode_BodyDriver::BaseData' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, BipedFall) == 0x000078, "Member 'FAnimNode_BodyDriver::BipedFall' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, BalanceRecovery) == 0x000080, "Member 'FAnimNode_BodyDriver::BalanceRecovery' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, Staggerfall) == 0x000088, "Member 'FAnimNode_BodyDriver::Staggerfall' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, DebugImpulses) == 0x000090, "Member 'FAnimNode_BodyDriver::DebugImpulses' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, IdleAnim) == 0x000098, "Member 'FAnimNode_BodyDriver::IdleAnim' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, ArchtypeData) == 0x0000A0, "Member 'FAnimNode_BodyDriver::ArchtypeData' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, ArchtypeSkeletalMesh) == 0x0000A8, "Member 'FAnimNode_BodyDriver::ArchtypeSkeletalMesh' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, ArchtypeBaseData) == 0x0000B0, "Member 'FAnimNode_BodyDriver::ArchtypeBaseData' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, ArchtypeBipedFall) == 0x0000B8, "Member 'FAnimNode_BodyDriver::ArchtypeBipedFall' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, ArchtypeBalanceRecovery) == 0x0000C0, "Member 'FAnimNode_BodyDriver::ArchtypeBalanceRecovery' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, ArchtypeStaggerfall) == 0x0000C8, "Member 'FAnimNode_BodyDriver::ArchtypeStaggerfall' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, ArchtypeDebugImpulses) == 0x0000D0, "Member 'FAnimNode_BodyDriver::ArchtypeDebugImpulses' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, ArchtypeIdleAnim) == 0x0000D8, "Member 'FAnimNode_BodyDriver::ArchtypeIdleAnim' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyDriver, m_InputObject) == 0x0002C0, "Member 'FAnimNode_BodyDriver::m_InputObject' has a wrong offset!");

// ScriptStruct BodyDriverPlugin.GravityAndAirResistanceControl
// 0x003C (0x003C - 0x0000)
struct FGravityAndAirResistanceControl final
{
public:
	bool                                          EnableGravityControl;                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GravityControlStartTime;                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityControlRampUpTime;                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityControlEndTime;                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraGravityMultiplier;                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableAirResistanceControl;                        // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AirResistanceOnlyPlanar;                           // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AirResistanceControlStartTime;                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirResistanceControlRampUpTime;                    // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirResistanceControlEndTime;                       // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirResistanceMaxSpeed;                             // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirResistanceStrength;                             // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularDamping;                                    // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CleanupTime;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableCollision;                                  // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DisableCollisionStartTime;                         // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGravityAndAirResistanceControl) == 0x000004, "Wrong alignment on FGravityAndAirResistanceControl");
static_assert(sizeof(FGravityAndAirResistanceControl) == 0x00003C, "Wrong size on FGravityAndAirResistanceControl");
static_assert(offsetof(FGravityAndAirResistanceControl, EnableGravityControl) == 0x000000, "Member 'FGravityAndAirResistanceControl::EnableGravityControl' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, GravityControlStartTime) == 0x000004, "Member 'FGravityAndAirResistanceControl::GravityControlStartTime' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, GravityControlRampUpTime) == 0x000008, "Member 'FGravityAndAirResistanceControl::GravityControlRampUpTime' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, GravityControlEndTime) == 0x00000C, "Member 'FGravityAndAirResistanceControl::GravityControlEndTime' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, ExtraGravityMultiplier) == 0x000010, "Member 'FGravityAndAirResistanceControl::ExtraGravityMultiplier' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, EnableAirResistanceControl) == 0x000014, "Member 'FGravityAndAirResistanceControl::EnableAirResistanceControl' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, AirResistanceOnlyPlanar) == 0x000015, "Member 'FGravityAndAirResistanceControl::AirResistanceOnlyPlanar' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, AirResistanceControlStartTime) == 0x000018, "Member 'FGravityAndAirResistanceControl::AirResistanceControlStartTime' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, AirResistanceControlRampUpTime) == 0x00001C, "Member 'FGravityAndAirResistanceControl::AirResistanceControlRampUpTime' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, AirResistanceControlEndTime) == 0x000020, "Member 'FGravityAndAirResistanceControl::AirResistanceControlEndTime' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, AirResistanceMaxSpeed) == 0x000024, "Member 'FGravityAndAirResistanceControl::AirResistanceMaxSpeed' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, AirResistanceStrength) == 0x000028, "Member 'FGravityAndAirResistanceControl::AirResistanceStrength' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, AngularDamping) == 0x00002C, "Member 'FGravityAndAirResistanceControl::AngularDamping' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, CleanupTime) == 0x000030, "Member 'FGravityAndAirResistanceControl::CleanupTime' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, DisableCollision) == 0x000034, "Member 'FGravityAndAirResistanceControl::DisableCollision' has a wrong offset!");
static_assert(offsetof(FGravityAndAirResistanceControl, DisableCollisionStartTime) == 0x000038, "Member 'FGravityAndAirResistanceControl::DisableCollisionStartTime' has a wrong offset!");

// ScriptStruct BodyDriverPlugin.Impulse
// 0x0160 (0x0160 - 0x0000)
struct FImpulse final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Impulse;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseArms;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseHands;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseLegs;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseMultWhenFallen;                             // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseTime;                                       // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ImpulseRelativeToPartMass;                         // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AmountOfDecayPerStage;                             // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNumDecayStages;                                 // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceRandomizedValidHitPart;                       // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseMaxInitialPartVelocityOverrides;                // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxInitialPartLinearVelocity;                      // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxInitialPartAngularVelocity;                     // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EeBodyParts>                           OverrideHitParts;                                  // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ChanceOfPartOverride;                              // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPartImpulseOverride>           PartImpulseOverrides;                              // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ClampAngleVertically;                              // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinVerticalAngle;                                  // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVerticalAngle;                                  // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ClampAngleToFacingCone;                            // 0x006C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxConeAngleFromFacing;                            // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactMagnitude;                                   // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactMultWhenFallen;                              // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactOutMagRatio;                                 // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactMagnitudeLowerBody;                          // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactMagnitudeArms;                               // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactMagnitudeHands;                              // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactTime;                                        // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactOutTime;                                     // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactDecayRate;                                   // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ImpactMaxNumDecayStages;                           // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ImpactRelativeToPartMass;                          // 0x009C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPartImpulseOverride>           PartImpactOverrides;                               // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         StayUprightTorqueMagnitude;                        // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StayUprightLiftMagnitude;                          // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StayUprightMinTimeLift;                            // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StayUprightMaxTimeLift;                            // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StayUprightMinTimeTorque;                          // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StayUprightMaxTimeTorque;                          // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StayUprightMinMagAngle;                            // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StayUprightMaxMagAngle;                            // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StayUprightBailBodyAngle;                          // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EeBodyParts>                           StayUprightTorqueParts;                            // 0x00D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          AllowPushDown;                                     // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PainHunchAngle;                                    // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PainPeakStartTime;                                 // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PainPeakDuration;                                  // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PainPeakFalloffTime;                               // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PainOnlyUseForIncludeParts;                        // 0x00FC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EeBodyParts>                           PainIncludeParts;                                  // 0x0100(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EeBodyParts>                           PainExcludeParts;                                  // 0x0110(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGravityAndAirResistanceControl        GravityAndAirResistanceControl;                    // 0x0120(0x003C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FImpulse) == 0x000008, "Wrong alignment on FImpulse");
static_assert(sizeof(FImpulse) == 0x000160, "Wrong size on FImpulse");
static_assert(offsetof(FImpulse, Enabled) == 0x000000, "Member 'FImpulse::Enabled' has a wrong offset!");
static_assert(offsetof(FImpulse, Impulse) == 0x000004, "Member 'FImpulse::Impulse' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpulseArms) == 0x000008, "Member 'FImpulse::ImpulseArms' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpulseHands) == 0x00000C, "Member 'FImpulse::ImpulseHands' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpulseLegs) == 0x000010, "Member 'FImpulse::ImpulseLegs' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpulseMultWhenFallen) == 0x000014, "Member 'FImpulse::ImpulseMultWhenFallen' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpulseTime) == 0x000018, "Member 'FImpulse::ImpulseTime' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpulseRelativeToPartMass) == 0x00001C, "Member 'FImpulse::ImpulseRelativeToPartMass' has a wrong offset!");
static_assert(offsetof(FImpulse, AmountOfDecayPerStage) == 0x000020, "Member 'FImpulse::AmountOfDecayPerStage' has a wrong offset!");
static_assert(offsetof(FImpulse, MaxNumDecayStages) == 0x000024, "Member 'FImpulse::MaxNumDecayStages' has a wrong offset!");
static_assert(offsetof(FImpulse, ForceRandomizedValidHitPart) == 0x000028, "Member 'FImpulse::ForceRandomizedValidHitPart' has a wrong offset!");
static_assert(offsetof(FImpulse, UseMaxInitialPartVelocityOverrides) == 0x000029, "Member 'FImpulse::UseMaxInitialPartVelocityOverrides' has a wrong offset!");
static_assert(offsetof(FImpulse, MaxInitialPartLinearVelocity) == 0x00002C, "Member 'FImpulse::MaxInitialPartLinearVelocity' has a wrong offset!");
static_assert(offsetof(FImpulse, MaxInitialPartAngularVelocity) == 0x000030, "Member 'FImpulse::MaxInitialPartAngularVelocity' has a wrong offset!");
static_assert(offsetof(FImpulse, OverrideHitParts) == 0x000038, "Member 'FImpulse::OverrideHitParts' has a wrong offset!");
static_assert(offsetof(FImpulse, ChanceOfPartOverride) == 0x000048, "Member 'FImpulse::ChanceOfPartOverride' has a wrong offset!");
static_assert(offsetof(FImpulse, PartImpulseOverrides) == 0x000050, "Member 'FImpulse::PartImpulseOverrides' has a wrong offset!");
static_assert(offsetof(FImpulse, ClampAngleVertically) == 0x000060, "Member 'FImpulse::ClampAngleVertically' has a wrong offset!");
static_assert(offsetof(FImpulse, MinVerticalAngle) == 0x000064, "Member 'FImpulse::MinVerticalAngle' has a wrong offset!");
static_assert(offsetof(FImpulse, MaxVerticalAngle) == 0x000068, "Member 'FImpulse::MaxVerticalAngle' has a wrong offset!");
static_assert(offsetof(FImpulse, ClampAngleToFacingCone) == 0x00006C, "Member 'FImpulse::ClampAngleToFacingCone' has a wrong offset!");
static_assert(offsetof(FImpulse, MaxConeAngleFromFacing) == 0x000070, "Member 'FImpulse::MaxConeAngleFromFacing' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpactMagnitude) == 0x000074, "Member 'FImpulse::ImpactMagnitude' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpactMultWhenFallen) == 0x000078, "Member 'FImpulse::ImpactMultWhenFallen' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpactOutMagRatio) == 0x00007C, "Member 'FImpulse::ImpactOutMagRatio' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpactMagnitudeLowerBody) == 0x000080, "Member 'FImpulse::ImpactMagnitudeLowerBody' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpactMagnitudeArms) == 0x000084, "Member 'FImpulse::ImpactMagnitudeArms' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpactMagnitudeHands) == 0x000088, "Member 'FImpulse::ImpactMagnitudeHands' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpactTime) == 0x00008C, "Member 'FImpulse::ImpactTime' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpactOutTime) == 0x000090, "Member 'FImpulse::ImpactOutTime' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpactDecayRate) == 0x000094, "Member 'FImpulse::ImpactDecayRate' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpactMaxNumDecayStages) == 0x000098, "Member 'FImpulse::ImpactMaxNumDecayStages' has a wrong offset!");
static_assert(offsetof(FImpulse, ImpactRelativeToPartMass) == 0x00009C, "Member 'FImpulse::ImpactRelativeToPartMass' has a wrong offset!");
static_assert(offsetof(FImpulse, PartImpactOverrides) == 0x0000A0, "Member 'FImpulse::PartImpactOverrides' has a wrong offset!");
static_assert(offsetof(FImpulse, StayUprightTorqueMagnitude) == 0x0000B0, "Member 'FImpulse::StayUprightTorqueMagnitude' has a wrong offset!");
static_assert(offsetof(FImpulse, StayUprightLiftMagnitude) == 0x0000B4, "Member 'FImpulse::StayUprightLiftMagnitude' has a wrong offset!");
static_assert(offsetof(FImpulse, StayUprightMinTimeLift) == 0x0000B8, "Member 'FImpulse::StayUprightMinTimeLift' has a wrong offset!");
static_assert(offsetof(FImpulse, StayUprightMaxTimeLift) == 0x0000BC, "Member 'FImpulse::StayUprightMaxTimeLift' has a wrong offset!");
static_assert(offsetof(FImpulse, StayUprightMinTimeTorque) == 0x0000C0, "Member 'FImpulse::StayUprightMinTimeTorque' has a wrong offset!");
static_assert(offsetof(FImpulse, StayUprightMaxTimeTorque) == 0x0000C4, "Member 'FImpulse::StayUprightMaxTimeTorque' has a wrong offset!");
static_assert(offsetof(FImpulse, StayUprightMinMagAngle) == 0x0000C8, "Member 'FImpulse::StayUprightMinMagAngle' has a wrong offset!");
static_assert(offsetof(FImpulse, StayUprightMaxMagAngle) == 0x0000CC, "Member 'FImpulse::StayUprightMaxMagAngle' has a wrong offset!");
static_assert(offsetof(FImpulse, StayUprightBailBodyAngle) == 0x0000D0, "Member 'FImpulse::StayUprightBailBodyAngle' has a wrong offset!");
static_assert(offsetof(FImpulse, StayUprightTorqueParts) == 0x0000D8, "Member 'FImpulse::StayUprightTorqueParts' has a wrong offset!");
static_assert(offsetof(FImpulse, AllowPushDown) == 0x0000E8, "Member 'FImpulse::AllowPushDown' has a wrong offset!");
static_assert(offsetof(FImpulse, PainHunchAngle) == 0x0000EC, "Member 'FImpulse::PainHunchAngle' has a wrong offset!");
static_assert(offsetof(FImpulse, PainPeakStartTime) == 0x0000F0, "Member 'FImpulse::PainPeakStartTime' has a wrong offset!");
static_assert(offsetof(FImpulse, PainPeakDuration) == 0x0000F4, "Member 'FImpulse::PainPeakDuration' has a wrong offset!");
static_assert(offsetof(FImpulse, PainPeakFalloffTime) == 0x0000F8, "Member 'FImpulse::PainPeakFalloffTime' has a wrong offset!");
static_assert(offsetof(FImpulse, PainOnlyUseForIncludeParts) == 0x0000FC, "Member 'FImpulse::PainOnlyUseForIncludeParts' has a wrong offset!");
static_assert(offsetof(FImpulse, PainIncludeParts) == 0x000100, "Member 'FImpulse::PainIncludeParts' has a wrong offset!");
static_assert(offsetof(FImpulse, PainExcludeParts) == 0x000110, "Member 'FImpulse::PainExcludeParts' has a wrong offset!");
static_assert(offsetof(FImpulse, GravityAndAirResistanceControl) == 0x000120, "Member 'FImpulse::GravityAndAirResistanceControl' has a wrong offset!");

// ScriptStruct BodyDriverPlugin.Explosion
// 0x0348 (0x0348 - 0x0000)
struct FExplosion final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseBaseRagdollRegardless;                          // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseImpulseDataAsWell;                              // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SkipLinearVelocityControl;                         // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SkipBaseDataVelocityClamp;                         // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinLinearMagnitude;                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLinearMagnitude;                                // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LinearForceApplyTime;                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClosestDistanceToScaleMagnitude;                   // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FarthestDistanceToScaleMagnitude;                  // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAngleFromHorizon;                               // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngleFromHorizon;                               // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FImpulse                               DistanceScaledImpactData;                          // 0x0028(0x0160)(Edit, NativeAccessSpecifierPublic)
	float                                         LinearMagnitudeForContactExplosions;               // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleFromHorizonOverrideForContactExplosions;      // 0x018C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RotationOppositeOfExplosionDirection;              // 0x0190(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RotationUseDesiredBodyVelocity;                    // 0x0191(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RotationConstrainOtherRotVelocity;                 // 0x0192(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_193[0x1];                                      // 0x0193(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationSpeedForContactExplosion;                  // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationStartTime;                                 // 0x0198(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationDuration;                                  // 0x019C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FImpulse                               ContactImpactData;                                 // 0x01A0(0x0160)(Edit, NativeAccessSpecifierPublic)
	float                                         PolarSpinProportion;                               // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EeBodyParts                                   PolarSpinTopPart;                                  // 0x0304(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_305[0x3];                                      // 0x0305(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGravityAndAirResistanceControl        GravityAndAirResistanceControl;                    // 0x0308(0x003C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_344[0x4];                                      // 0x0344(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExplosion) == 0x000008, "Wrong alignment on FExplosion");
static_assert(sizeof(FExplosion) == 0x000348, "Wrong size on FExplosion");
static_assert(offsetof(FExplosion, Enabled) == 0x000000, "Member 'FExplosion::Enabled' has a wrong offset!");
static_assert(offsetof(FExplosion, UseBaseRagdollRegardless) == 0x000001, "Member 'FExplosion::UseBaseRagdollRegardless' has a wrong offset!");
static_assert(offsetof(FExplosion, UseImpulseDataAsWell) == 0x000002, "Member 'FExplosion::UseImpulseDataAsWell' has a wrong offset!");
static_assert(offsetof(FExplosion, SkipLinearVelocityControl) == 0x000003, "Member 'FExplosion::SkipLinearVelocityControl' has a wrong offset!");
static_assert(offsetof(FExplosion, SkipBaseDataVelocityClamp) == 0x000004, "Member 'FExplosion::SkipBaseDataVelocityClamp' has a wrong offset!");
static_assert(offsetof(FExplosion, MinLinearMagnitude) == 0x000008, "Member 'FExplosion::MinLinearMagnitude' has a wrong offset!");
static_assert(offsetof(FExplosion, MaxLinearMagnitude) == 0x00000C, "Member 'FExplosion::MaxLinearMagnitude' has a wrong offset!");
static_assert(offsetof(FExplosion, LinearForceApplyTime) == 0x000010, "Member 'FExplosion::LinearForceApplyTime' has a wrong offset!");
static_assert(offsetof(FExplosion, ClosestDistanceToScaleMagnitude) == 0x000014, "Member 'FExplosion::ClosestDistanceToScaleMagnitude' has a wrong offset!");
static_assert(offsetof(FExplosion, FarthestDistanceToScaleMagnitude) == 0x000018, "Member 'FExplosion::FarthestDistanceToScaleMagnitude' has a wrong offset!");
static_assert(offsetof(FExplosion, MinAngleFromHorizon) == 0x00001C, "Member 'FExplosion::MinAngleFromHorizon' has a wrong offset!");
static_assert(offsetof(FExplosion, MaxAngleFromHorizon) == 0x000020, "Member 'FExplosion::MaxAngleFromHorizon' has a wrong offset!");
static_assert(offsetof(FExplosion, DistanceScaledImpactData) == 0x000028, "Member 'FExplosion::DistanceScaledImpactData' has a wrong offset!");
static_assert(offsetof(FExplosion, LinearMagnitudeForContactExplosions) == 0x000188, "Member 'FExplosion::LinearMagnitudeForContactExplosions' has a wrong offset!");
static_assert(offsetof(FExplosion, AngleFromHorizonOverrideForContactExplosions) == 0x00018C, "Member 'FExplosion::AngleFromHorizonOverrideForContactExplosions' has a wrong offset!");
static_assert(offsetof(FExplosion, RotationOppositeOfExplosionDirection) == 0x000190, "Member 'FExplosion::RotationOppositeOfExplosionDirection' has a wrong offset!");
static_assert(offsetof(FExplosion, RotationUseDesiredBodyVelocity) == 0x000191, "Member 'FExplosion::RotationUseDesiredBodyVelocity' has a wrong offset!");
static_assert(offsetof(FExplosion, RotationConstrainOtherRotVelocity) == 0x000192, "Member 'FExplosion::RotationConstrainOtherRotVelocity' has a wrong offset!");
static_assert(offsetof(FExplosion, RotationSpeedForContactExplosion) == 0x000194, "Member 'FExplosion::RotationSpeedForContactExplosion' has a wrong offset!");
static_assert(offsetof(FExplosion, RotationStartTime) == 0x000198, "Member 'FExplosion::RotationStartTime' has a wrong offset!");
static_assert(offsetof(FExplosion, RotationDuration) == 0x00019C, "Member 'FExplosion::RotationDuration' has a wrong offset!");
static_assert(offsetof(FExplosion, ContactImpactData) == 0x0001A0, "Member 'FExplosion::ContactImpactData' has a wrong offset!");
static_assert(offsetof(FExplosion, PolarSpinProportion) == 0x000300, "Member 'FExplosion::PolarSpinProportion' has a wrong offset!");
static_assert(offsetof(FExplosion, PolarSpinTopPart) == 0x000304, "Member 'FExplosion::PolarSpinTopPart' has a wrong offset!");
static_assert(offsetof(FExplosion, GravityAndAirResistanceControl) == 0x000308, "Member 'FExplosion::GravityAndAirResistanceControl' has a wrong offset!");

}

