#pragma once
#undef GetCurrentTime

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: EndGame

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "SQEXSEAD_structs.hpp"
#include "SQEXSEAD_classes.hpp"
#include "EndGame_structs.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "SlateCore_structs.hpp"
#include "AnimGraphRuntime_classes.hpp"
#include "LevelSequence_classes.hpp"
#include "Slate_structs.hpp"
#include "AnimationCore_structs.hpp"
#include "AnimationBudgetAllocator_classes.hpp"
#include "InputCore_structs.hpp"


namespace SDK
{

// Class EndGame.EndAerialRouteSearchInstance
// 0x0108 (0x0130 - 0x0028)
class UEndAerialRouteSearchInstance final : public UObject
{
public:
	uint8                                         Pad_28[0x108];                                     // 0x0028(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAerialRouteSearchInstance">();
	}
	static class UEndAerialRouteSearchInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAerialRouteSearchInstance>();
	}
};
static_assert(alignof(UEndAerialRouteSearchInstance) == 0x000008, "Wrong alignment on UEndAerialRouteSearchInstance");
static_assert(sizeof(UEndAerialRouteSearchInstance) == 0x000130, "Wrong size on UEndAerialRouteSearchInstance");

// Class EndGame.EndUserWidget
// 0x0160 (0x0360 - 0x0200)
class UEndUserWidget : public UUserWidget
{
public:
	bool                                          bPauseable;                                        // 0x0200(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimationDuplication;                             // 0x0201(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportsPromotionVideo;                           // 0x0202(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_203[0xBD];                                     // 0x0203(0x00BD)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UWidgetAnimation*>    ChachedAnimations;                                 // 0x02C0(0x0050)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class FName, class UWidgetAnimation*>    SharedAnimations;                                  // 0x0310(0x0050)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void AddToOffscreen(int32 ZOrder);
	bool AddToPlayerScreenEx(int32 ZOrder);
	void AddToScene(const struct FVector& InLocation, const struct FRotator& InRotation);
	void AddToViewportEx(int32 ZOrder);
	bool IsAnimationPlayingForwardByName(class FName InAnimationName);
	bool IsAnimationPlayingForwardEx(const class UWidgetAnimation* InAnimation);
	float PauseAnimationByName(class FName InAnimationName);
	float PauseAnimationEx(const class UWidgetAnimation* InAnimation);
	bool PlayAnimationByName(class FName InAnimationName, float StartAtTime, int32 NumLoopsToPlay, EUMGSequencePlayMode PlayMode, float PlaybackSpeed);
	void PlayAnimationEx(class UWidgetAnimation* InAnimation, float StartAtTime, int32 NumLoopsToPlay, EUMGSequencePlayMode PlayMode, float PlaybackSpeed);
	void PlayAnimationExAutoReverse(class UWidgetAnimation* InAnimation, float StartAtTime, int32 NumLoopsToPlay, EUMGSequencePlayMode PlayMode, float PlaybackSpeed, float ReverseSpeed);
	bool PlayAnimationToByName(class FName InAnimationName, float StartAtTime, float EndAtTime, int32 NumLoopsToPlay, EUMGSequencePlayMode PlayMode, float PlaybackSpeed);
	void PlayAnimationToEx(class UWidgetAnimation* InAnimation, float StartAtTime, float EndAtTime, int32 NumLoopsToPlay, EUMGSequencePlayMode PlayMode, float PlaybackSpeed);
	void PopFromFocusStack();
	void PushToFocusStack();
	void RemoveFromViewportEx();
	void ReverseAnimationByName(class FName InAnimationName);
	void ReverseAnimationEx(const class UWidgetAnimation* InAnimation);
	bool SetFocusToChild(class UWidget* InWidget, EFocusCause InFocusCause);
	void SetLocationInScene(const struct FVector& InLocation);
	void SetNumLoopsToPlayByName(class FName InAnimationName, int32 NumLoopsToPlay);
	void SetNumLoopsToPlayEx(const class UWidgetAnimation* InAnimation, int32 NumLoopsToPlay);
	void SetPlaybackSpeedByName(class FName InAnimationName, float PlaybackSpeed);
	void SetPlaybackSpeedEx(const class UWidgetAnimation* InAnimation, float PlaybackSpeed);
	void SetRotationInScene(const struct FRotator& InRotation);
	void StopAllAnimationsEx();
	void StopAnimationByName(class FName InAnimationName);
	void StopAnimationEx(const class UWidgetAnimation* InAnimation);

	float GetAnimationCurrentTimeByName(class FName InAnimationName) const;
	float GetAnimationCurrentTimeEx(const class UWidgetAnimation* InAnimation) const;
	float GetAnimationEndTimeByName(class FName InAnimationName) const;
	float GetAnimationStartTimeByName(class FName InAnimationName) const;
	class UWidget* GetFocusedChildWidget() const;
	struct FVector GetLocationInScene() const;
	struct FRotator GetRotationInScene() const;
	int32 GetZOrderInViewport() const;
	bool IsAnimationPlayingByName(class FName InAnimationName) const;
	bool IsAnimationPlayingEx(const class UWidgetAnimation* InAnimation) const;
	bool IsAnyAnimationPlayingEx() const;
	bool IsInViewportEx() const;
	bool IsPlayingAnimationEx() const;
	bool IsPlayingAnimationIgnoreStopped() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndUserWidget">();
	}
	static class UEndUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndUserWidget>();
	}
};
static_assert(alignof(UEndUserWidget) == 0x000008, "Wrong alignment on UEndUserWidget");
static_assert(sizeof(UEndUserWidget) == 0x000360, "Wrong size on UEndUserWidget");
static_assert(offsetof(UEndUserWidget, bPauseable) == 0x000200, "Member 'UEndUserWidget::bPauseable' has a wrong offset!");
static_assert(offsetof(UEndUserWidget, bAnimationDuplication) == 0x000201, "Member 'UEndUserWidget::bAnimationDuplication' has a wrong offset!");
static_assert(offsetof(UEndUserWidget, bSupportsPromotionVideo) == 0x000202, "Member 'UEndUserWidget::bSupportsPromotionVideo' has a wrong offset!");
static_assert(offsetof(UEndUserWidget, ChachedAnimations) == 0x0002C0, "Member 'UEndUserWidget::ChachedAnimations' has a wrong offset!");
static_assert(offsetof(UEndUserWidget, SharedAnimations) == 0x000310, "Member 'UEndUserWidget::SharedAnimations' has a wrong offset!");

// Class EndGame.EndEventProgressDisplay
// 0x0008 (0x0368 - 0x0360)
class UEndEventProgressDisplay : public UEndUserWidget
{
public:
	float                                         OffsetForNaviMap;                                  // 0x0360(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEventProgressDisplay">();
	}
	static class UEndEventProgressDisplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEventProgressDisplay>();
	}
};
static_assert(alignof(UEndEventProgressDisplay) == 0x000008, "Wrong alignment on UEndEventProgressDisplay");
static_assert(sizeof(UEndEventProgressDisplay) == 0x000368, "Wrong size on UEndEventProgressDisplay");
static_assert(offsetof(UEndEventProgressDisplay, OffsetForNaviMap) == 0x000360, "Member 'UEndEventProgressDisplay::OffsetForNaviMap' has a wrong offset!");

// Class EndGame.AnimNotify_EndEmissiveAnimation
// 0x0020 (0x0058 - 0x0038)
class UAnimNotify_EndEmissiveAnimation final : public UAnimNotify
{
public:
	class FName                                   ColorPaletteId;                                    // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndEmissiveModifierType                      Modifier;                                          // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndEmissiveCurveType                         Curve;                                             // 0x0041(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x004C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartOffset;                                       // 0x0050(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndOffset;                                         // 0x0054(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndEmissiveAnimation">();
	}
	static class UAnimNotify_EndEmissiveAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndEmissiveAnimation>();
	}
};
static_assert(alignof(UAnimNotify_EndEmissiveAnimation) == 0x000008, "Wrong alignment on UAnimNotify_EndEmissiveAnimation");
static_assert(sizeof(UAnimNotify_EndEmissiveAnimation) == 0x000058, "Wrong size on UAnimNotify_EndEmissiveAnimation");
static_assert(offsetof(UAnimNotify_EndEmissiveAnimation, ColorPaletteId) == 0x000038, "Member 'UAnimNotify_EndEmissiveAnimation::ColorPaletteId' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEmissiveAnimation, Modifier) == 0x000040, "Member 'UAnimNotify_EndEmissiveAnimation::Modifier' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEmissiveAnimation, Curve) == 0x000041, "Member 'UAnimNotify_EndEmissiveAnimation::Curve' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEmissiveAnimation, Duration) == 0x000044, "Member 'UAnimNotify_EndEmissiveAnimation::Duration' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEmissiveAnimation, BlendInTime) == 0x000048, "Member 'UAnimNotify_EndEmissiveAnimation::BlendInTime' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEmissiveAnimation, BlendOutTime) == 0x00004C, "Member 'UAnimNotify_EndEmissiveAnimation::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEmissiveAnimation, StartOffset) == 0x000050, "Member 'UAnimNotify_EndEmissiveAnimation::StartOffset' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEmissiveAnimation, EndOffset) == 0x000054, "Member 'UAnimNotify_EndEmissiveAnimation::EndOffset' has a wrong offset!");

// Class EndGame.EndEnvQueryContext_DangerDamageSource
// 0x0000 (0x0028 - 0x0028)
class UEndEnvQueryContext_DangerDamageSource final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryContext_DangerDamageSource">();
	}
	static class UEndEnvQueryContext_DangerDamageSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryContext_DangerDamageSource>();
	}
};
static_assert(alignof(UEndEnvQueryContext_DangerDamageSource) == 0x000008, "Wrong alignment on UEndEnvQueryContext_DangerDamageSource");
static_assert(sizeof(UEndEnvQueryContext_DangerDamageSource) == 0x000028, "Wrong size on UEndEnvQueryContext_DangerDamageSource");

// Class EndGame.EndAerialIgnoreComponent
// 0x0020 (0x02D0 - 0x02B0)
class UEndAerialIgnoreComponent final : public USceneComponent
{
public:
	class FName                                   AerialVolumeName;                                  // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAerialIgnoreShapeType                        MeshShapeType;                                     // 0x02B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B9[0x3];                                      // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BoxExtent;                                         // 0x02BC(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SphereRadius;                                      // 0x02C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAerialIgnoreComponent">();
	}
	static class UEndAerialIgnoreComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAerialIgnoreComponent>();
	}
};
static_assert(alignof(UEndAerialIgnoreComponent) == 0x000008, "Wrong alignment on UEndAerialIgnoreComponent");
static_assert(sizeof(UEndAerialIgnoreComponent) == 0x0002D0, "Wrong size on UEndAerialIgnoreComponent");
static_assert(offsetof(UEndAerialIgnoreComponent, AerialVolumeName) == 0x0002B0, "Member 'UEndAerialIgnoreComponent::AerialVolumeName' has a wrong offset!");
static_assert(offsetof(UEndAerialIgnoreComponent, MeshShapeType) == 0x0002B8, "Member 'UEndAerialIgnoreComponent::MeshShapeType' has a wrong offset!");
static_assert(offsetof(UEndAerialIgnoreComponent, BoxExtent) == 0x0002BC, "Member 'UEndAerialIgnoreComponent::BoxExtent' has a wrong offset!");
static_assert(offsetof(UEndAerialIgnoreComponent, SphereRadius) == 0x0002C8, "Member 'UEndAerialIgnoreComponent::SphereRadius' has a wrong offset!");

// Class EndGame.EndEnvQueryTest_ProjectionGeneratorInitialScore
// 0x0000 (0x01C0 - 0x01C0)
class UEndEnvQueryTest_ProjectionGeneratorInitialScore final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryTest_ProjectionGeneratorInitialScore">();
	}
	static class UEndEnvQueryTest_ProjectionGeneratorInitialScore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryTest_ProjectionGeneratorInitialScore>();
	}
};
static_assert(alignof(UEndEnvQueryTest_ProjectionGeneratorInitialScore) == 0x000008, "Wrong alignment on UEndEnvQueryTest_ProjectionGeneratorInitialScore");
static_assert(sizeof(UEndEnvQueryTest_ProjectionGeneratorInitialScore) == 0x0001C0, "Wrong size on UEndEnvQueryTest_ProjectionGeneratorInitialScore");

// Class EndGame.AnimNotify_EndAim
// 0x0010 (0x0040 - 0x0030)
class UAnimNotify_EndAim final : public UAnimNotifyState
{
public:
	TArray<class FName>                           EffectorSettingNames;                              // 0x0030(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndAim">();
	}
	static class UAnimNotify_EndAim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndAim>();
	}
};
static_assert(alignof(UAnimNotify_EndAim) == 0x000008, "Wrong alignment on UAnimNotify_EndAim");
static_assert(sizeof(UAnimNotify_EndAim) == 0x000040, "Wrong size on UAnimNotify_EndAim");
static_assert(offsetof(UAnimNotify_EndAim, EffectorSettingNames) == 0x000030, "Member 'UAnimNotify_EndAim::EffectorSettingNames' has a wrong offset!");

// Class EndGame.EndEnvQueryContext_AIPCCommandTarget
// 0x0000 (0x0028 - 0x0028)
class UEndEnvQueryContext_AIPCCommandTarget final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryContext_AIPCCommandTarget">();
	}
	static class UEndEnvQueryContext_AIPCCommandTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryContext_AIPCCommandTarget>();
	}
};
static_assert(alignof(UEndEnvQueryContext_AIPCCommandTarget) == 0x000008, "Wrong alignment on UEndEnvQueryContext_AIPCCommandTarget");
static_assert(sizeof(UEndEnvQueryContext_AIPCCommandTarget) == 0x000028, "Wrong size on UEndEnvQueryContext_AIPCCommandTarget");

// Class EndGame.EndAerialIgnoreVolume
// 0x0008 (0x0380 - 0x0378)
class AEndAerialIgnoreVolume final : public AActor
{
public:
	class UEndAerialIgnoreComponent*              AerialIgnoreComponent;                             // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAerialIgnoreVolume">();
	}
	static class AEndAerialIgnoreVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndAerialIgnoreVolume>();
	}
};
static_assert(alignof(AEndAerialIgnoreVolume) == 0x000008, "Wrong alignment on AEndAerialIgnoreVolume");
static_assert(sizeof(AEndAerialIgnoreVolume) == 0x000380, "Wrong size on AEndAerialIgnoreVolume");
static_assert(offsetof(AEndAerialIgnoreVolume, AerialIgnoreComponent) == 0x000378, "Member 'AEndAerialIgnoreVolume::AerialIgnoreComponent' has a wrong offset!");

// Class EndGame.EndFieldActionTriggerComponent
// 0x0020 (0x0740 - 0x0720)
class UEndFieldActionTriggerComponent : public UBoxComponent
{
public:
	EFieldActionActorType                         ActionType;                                        // 0x0720(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_721[0x3];                                      // 0x0721(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                IconOffsetLocation;                                // 0x0724(0x000C)(Edit, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               IconOffsetRotation;                                // 0x0730(0x000C)(Edit, DisableEditOnTemplate, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          DrawPlane;                                         // 0x073C(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_73D[0x3];                                      // 0x073D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionTriggerComponent">();
	}
	static class UEndFieldActionTriggerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndFieldActionTriggerComponent>();
	}
};
static_assert(alignof(UEndFieldActionTriggerComponent) == 0x000010, "Wrong alignment on UEndFieldActionTriggerComponent");
static_assert(sizeof(UEndFieldActionTriggerComponent) == 0x000740, "Wrong size on UEndFieldActionTriggerComponent");
static_assert(offsetof(UEndFieldActionTriggerComponent, ActionType) == 0x000720, "Member 'UEndFieldActionTriggerComponent::ActionType' has a wrong offset!");
static_assert(offsetof(UEndFieldActionTriggerComponent, IconOffsetLocation) == 0x000724, "Member 'UEndFieldActionTriggerComponent::IconOffsetLocation' has a wrong offset!");
static_assert(offsetof(UEndFieldActionTriggerComponent, IconOffsetRotation) == 0x000730, "Member 'UEndFieldActionTriggerComponent::IconOffsetRotation' has a wrong offset!");
static_assert(offsetof(UEndFieldActionTriggerComponent, DrawPlane) == 0x00073C, "Member 'UEndFieldActionTriggerComponent::DrawPlane' has a wrong offset!");

// Class EndGame.EndMonkeyBarTriggerComponent
// 0x0010 (0x0750 - 0x0740)
class UEndMonkeyBarTriggerComponent final : public UEndFieldActionTriggerComponent
{
public:
	uint16                                        Index_0;                                           // 0x0740(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_742[0xE];                                      // 0x0742(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMonkeyBarTriggerComponent">();
	}
	static class UEndMonkeyBarTriggerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMonkeyBarTriggerComponent>();
	}
};
static_assert(alignof(UEndMonkeyBarTriggerComponent) == 0x000010, "Wrong alignment on UEndMonkeyBarTriggerComponent");
static_assert(sizeof(UEndMonkeyBarTriggerComponent) == 0x000750, "Wrong size on UEndMonkeyBarTriggerComponent");
static_assert(offsetof(UEndMonkeyBarTriggerComponent, Index_0) == 0x000740, "Member 'UEndMonkeyBarTriggerComponent::Index_0' has a wrong offset!");

// Class EndGame.EndBattleDamageSourceComponent
// 0x0368 (0x0460 - 0x00F8)
class UEndBattleDamageSourceComponent : public UActorComponent
{
public:
	uint8                                         Pad_F8[0x268];                                     // 0x00F8(0x0268)(Fixing Size After Last Property [ Dumper-7 ])
	class AEndCollisionActor*                     PushCollisionActor;                                // 0x0360(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_368[0xF8];                                     // 0x0368(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetDir() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleDamageSourceComponent">();
	}
	static class UEndBattleDamageSourceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleDamageSourceComponent>();
	}
};
static_assert(alignof(UEndBattleDamageSourceComponent) == 0x000008, "Wrong alignment on UEndBattleDamageSourceComponent");
static_assert(sizeof(UEndBattleDamageSourceComponent) == 0x000460, "Wrong size on UEndBattleDamageSourceComponent");
static_assert(offsetof(UEndBattleDamageSourceComponent, PushCollisionActor) == 0x000360, "Member 'UEndBattleDamageSourceComponent::PushCollisionActor' has a wrong offset!");

// Class EndGame.EndBattleDamageSourceComponentRocketPunch
// 0x0010 (0x0470 - 0x0460)
class UEndBattleDamageSourceComponentRocketPunch final : public UEndBattleDamageSourceComponent
{
public:
	uint8                                         Pad_460[0x10];                                     // 0x0460(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleDamageSourceComponentRocketPunch">();
	}
	static class UEndBattleDamageSourceComponentRocketPunch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleDamageSourceComponentRocketPunch>();
	}
};
static_assert(alignof(UEndBattleDamageSourceComponentRocketPunch) == 0x000008, "Wrong alignment on UEndBattleDamageSourceComponentRocketPunch");
static_assert(sizeof(UEndBattleDamageSourceComponentRocketPunch) == 0x000470, "Wrong size on UEndBattleDamageSourceComponentRocketPunch");

// Class EndGame.AnimNotify_EndAimExtension
// 0x0000 (0x0030 - 0x0030)
class UAnimNotify_EndAimExtension final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndAimExtension">();
	}
	static class UAnimNotify_EndAimExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndAimExtension>();
	}
};
static_assert(alignof(UAnimNotify_EndAimExtension) == 0x000008, "Wrong alignment on UAnimNotify_EndAimExtension");
static_assert(sizeof(UAnimNotify_EndAimExtension) == 0x000030, "Wrong size on UAnimNotify_EndAimExtension");

// Class EndGame.AnimNotify_EndCharacterBoneAcceleration
// 0x0030 (0x0060 - 0x0030)
class UAnimNotify_EndCharacterBoneAcceleration final : public UAnimNotifyState
{
public:
	class FName                                   BoneName;                                          // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MaxVelocity;                                       // 0x0038(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               BeginAcceleration;                                 // 0x0044(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               EndAcceleration;                                   // 0x0050(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndCharacterBoneAcceleration">();
	}
	static class UAnimNotify_EndCharacterBoneAcceleration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndCharacterBoneAcceleration>();
	}
};
static_assert(alignof(UAnimNotify_EndCharacterBoneAcceleration) == 0x000008, "Wrong alignment on UAnimNotify_EndCharacterBoneAcceleration");
static_assert(sizeof(UAnimNotify_EndCharacterBoneAcceleration) == 0x000060, "Wrong size on UAnimNotify_EndCharacterBoneAcceleration");
static_assert(offsetof(UAnimNotify_EndCharacterBoneAcceleration, BoneName) == 0x000030, "Member 'UAnimNotify_EndCharacterBoneAcceleration::BoneName' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndCharacterBoneAcceleration, MaxVelocity) == 0x000038, "Member 'UAnimNotify_EndCharacterBoneAcceleration::MaxVelocity' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndCharacterBoneAcceleration, BeginAcceleration) == 0x000044, "Member 'UAnimNotify_EndCharacterBoneAcceleration::BeginAcceleration' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndCharacterBoneAcceleration, EndAcceleration) == 0x000050, "Member 'UAnimNotify_EndCharacterBoneAcceleration::EndAcceleration' has a wrong offset!");

// Class EndGame.EndBattleLevelSequenceActor
// 0x0180 (0x05D0 - 0x0450)
class AEndBattleLevelSequenceActor final : public ALevelSequenceActor
{
public:
	uint8                                         Pad_450[0x18];                                     // 0x0450(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AEndBattleCameraActor*                  CameraActor;                                       // 0x0468(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_470[0x160];                                    // 0x0470(0x0160)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleLevelSequenceActor">();
	}
	static class AEndBattleLevelSequenceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleLevelSequenceActor>();
	}
};
static_assert(alignof(AEndBattleLevelSequenceActor) == 0x000008, "Wrong alignment on AEndBattleLevelSequenceActor");
static_assert(sizeof(AEndBattleLevelSequenceActor) == 0x0005D0, "Wrong size on AEndBattleLevelSequenceActor");
static_assert(offsetof(AEndBattleLevelSequenceActor, CameraActor) == 0x000468, "Member 'AEndBattleLevelSequenceActor::CameraActor' has a wrong offset!");

// Class EndGame.AnimNotify_EndDisableBoneLocalRotate
// 0x0000 (0x0030 - 0x0030)
class UAnimNotify_EndDisableBoneLocalRotate final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndDisableBoneLocalRotate">();
	}
	static class UAnimNotify_EndDisableBoneLocalRotate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndDisableBoneLocalRotate>();
	}
};
static_assert(alignof(UAnimNotify_EndDisableBoneLocalRotate) == 0x000008, "Wrong alignment on UAnimNotify_EndDisableBoneLocalRotate");
static_assert(sizeof(UAnimNotify_EndDisableBoneLocalRotate) == 0x000030, "Wrong size on UAnimNotify_EndDisableBoneLocalRotate");

// Class EndGame.AnimNotify_EndDisableGlobalWind
// 0x0000 (0x0030 - 0x0030)
class UAnimNotify_EndDisableGlobalWind final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndDisableGlobalWind">();
	}
	static class UAnimNotify_EndDisableGlobalWind* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndDisableGlobalWind>();
	}
};
static_assert(alignof(UAnimNotify_EndDisableGlobalWind) == 0x000008, "Wrong alignment on UAnimNotify_EndDisableGlobalWind");
static_assert(sizeof(UAnimNotify_EndDisableGlobalWind) == 0x000030, "Wrong size on UAnimNotify_EndDisableGlobalWind");

// Class EndGame.EndEnvQueryContext_AIPCMoveToLocation
// 0x0000 (0x0028 - 0x0028)
class UEndEnvQueryContext_AIPCMoveToLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryContext_AIPCMoveToLocation">();
	}
	static class UEndEnvQueryContext_AIPCMoveToLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryContext_AIPCMoveToLocation>();
	}
};
static_assert(alignof(UEndEnvQueryContext_AIPCMoveToLocation) == 0x000008, "Wrong alignment on UEndEnvQueryContext_AIPCMoveToLocation");
static_assert(sizeof(UEndEnvQueryContext_AIPCMoveToLocation) == 0x000028, "Wrong size on UEndEnvQueryContext_AIPCMoveToLocation");

// Class EndGame.EndMainSaveLoadMenu
// 0x0100 (0x0460 - 0x0360)
class UEndMainSaveLoadMenu : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0xF8];                                     // 0x0360(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndUserWidget*                         Throbber;                                          // 0x0458(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnSaveDataCancelled();
	void OnSaveDataPressedItem(int32 ItemIndex);
	void OnSaveDataSelectedIndexChanged(int32 ItemIndex);
	void OnSaveDataSetupItem(class UWidget* ItemWidget, int32 ItemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainSaveLoadMenu">();
	}
	static class UEndMainSaveLoadMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainSaveLoadMenu>();
	}
};
static_assert(alignof(UEndMainSaveLoadMenu) == 0x000008, "Wrong alignment on UEndMainSaveLoadMenu");
static_assert(sizeof(UEndMainSaveLoadMenu) == 0x000460, "Wrong size on UEndMainSaveLoadMenu");
static_assert(offsetof(UEndMainSaveLoadMenu, Throbber) == 0x000458, "Member 'UEndMainSaveLoadMenu::Throbber' has a wrong offset!");

// Class EndGame.EndBikeTriggerBoxResetPhysActor
// 0x0010 (0x0390 - 0x0380)
class AEndBikeTriggerBoxResetPhysActor final : public ATriggerBox
{
public:
	class AEndCharacter*                          mTriggerTarget;                                    // 0x0380(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AEndBikeTriggerBoxSavePhysActor*        SaveTrigger;                                       // 0x0388(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikeTriggerBoxResetPhysActor">();
	}
	static class AEndBikeTriggerBoxResetPhysActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBikeTriggerBoxResetPhysActor>();
	}
};
static_assert(alignof(AEndBikeTriggerBoxResetPhysActor) == 0x000008, "Wrong alignment on AEndBikeTriggerBoxResetPhysActor");
static_assert(sizeof(AEndBikeTriggerBoxResetPhysActor) == 0x000390, "Wrong size on AEndBikeTriggerBoxResetPhysActor");
static_assert(offsetof(AEndBikeTriggerBoxResetPhysActor, mTriggerTarget) == 0x000380, "Member 'AEndBikeTriggerBoxResetPhysActor::mTriggerTarget' has a wrong offset!");
static_assert(offsetof(AEndBikeTriggerBoxResetPhysActor, SaveTrigger) == 0x000388, "Member 'AEndBikeTriggerBoxResetPhysActor::SaveTrigger' has a wrong offset!");

// Class EndGame.EndAerialNavBoxComponent
// 0x0010 (0x0730 - 0x0720)
class UEndAerialNavBoxComponent final : public UBoxComponent
{
public:
	uint8                                         BoxID;                                             // 0x0720(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_721[0xF];                                      // 0x0721(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAerialNavBoxComponent">();
	}
	static class UEndAerialNavBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAerialNavBoxComponent>();
	}
};
static_assert(alignof(UEndAerialNavBoxComponent) == 0x000010, "Wrong alignment on UEndAerialNavBoxComponent");
static_assert(sizeof(UEndAerialNavBoxComponent) == 0x000730, "Wrong size on UEndAerialNavBoxComponent");
static_assert(offsetof(UEndAerialNavBoxComponent, BoxID) == 0x000720, "Member 'UEndAerialNavBoxComponent::BoxID' has a wrong offset!");

// Class EndGame.AnimNotify_EndDisableLipSyncAudioAttack
// 0x0000 (0x0030 - 0x0030)
class UAnimNotify_EndDisableLipSyncAudioAttack final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndDisableLipSyncAudioAttack">();
	}
	static class UAnimNotify_EndDisableLipSyncAudioAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndDisableLipSyncAudioAttack>();
	}
};
static_assert(alignof(UAnimNotify_EndDisableLipSyncAudioAttack) == 0x000008, "Wrong alignment on UAnimNotify_EndDisableLipSyncAudioAttack");
static_assert(sizeof(UAnimNotify_EndDisableLipSyncAudioAttack) == 0x000030, "Wrong size on UAnimNotify_EndDisableLipSyncAudioAttack");

// Class EndGame.EndAerialNavDebugDrawComponent
// 0x0000 (0x00F8 - 0x00F8)
class UEndAerialNavDebugDrawComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAerialNavDebugDrawComponent">();
	}
	static class UEndAerialNavDebugDrawComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAerialNavDebugDrawComponent>();
	}
};
static_assert(alignof(UEndAerialNavDebugDrawComponent) == 0x000008, "Wrong alignment on UEndAerialNavDebugDrawComponent");
static_assert(sizeof(UEndAerialNavDebugDrawComponent) == 0x0000F8, "Wrong size on UEndAerialNavDebugDrawComponent");

// Class EndGame.AnimNotify_EndDisableWeaponAutoSetVisibility
// 0x0000 (0x0030 - 0x0030)
class UAnimNotify_EndDisableWeaponAutoSetVisibility final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndDisableWeaponAutoSetVisibility">();
	}
	static class UAnimNotify_EndDisableWeaponAutoSetVisibility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndDisableWeaponAutoSetVisibility>();
	}
};
static_assert(alignof(UAnimNotify_EndDisableWeaponAutoSetVisibility) == 0x000008, "Wrong alignment on UAnimNotify_EndDisableWeaponAutoSetVisibility");
static_assert(sizeof(UAnimNotify_EndDisableWeaponAutoSetVisibility) == 0x000030, "Wrong size on UAnimNotify_EndDisableWeaponAutoSetVisibility");

// Class EndGame.EndBizarreBugWallActor
// 0x00D8 (0x0450 - 0x0378)
class AEndBizarreBugWallActor final : public AActor
{
public:
	uint8                                         Pad_378[0x10];                                     // 0x0378(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEndBizarreBugWallInstanceContext> InstanceContexts;                                  // 0x0388(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	float                                         SpawnCycle;                                        // 0x0398(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineMoveSpeed;                                   // 0x039C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideFadeInTime;                                // 0x03A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideFadeOutTime;                               // 0x03A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndBizarreBugWallMoveType                    MoveType;                                          // 0x03A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A9[0x3];                                      // 0x03A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Direction;                                         // 0x03AC(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BeginAnimationFrame;                               // 0x03B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndAnimationFrame;                                 // 0x03BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationFrameRate;                                // 0x03C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationPlayRate;                                 // 0x03C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USplineComponent*                       SplineComponent;                                   // 0x03C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          InstancedMeshComponent;                            // 0x03D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D8[0x78];                                     // 0x03D8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Play(float BlendTime);
	void Stop(float BlendTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBizarreBugWallActor">();
	}
	static class AEndBizarreBugWallActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBizarreBugWallActor>();
	}
};
static_assert(alignof(AEndBizarreBugWallActor) == 0x000008, "Wrong alignment on AEndBizarreBugWallActor");
static_assert(sizeof(AEndBizarreBugWallActor) == 0x000450, "Wrong size on AEndBizarreBugWallActor");
static_assert(offsetof(AEndBizarreBugWallActor, InstanceContexts) == 0x000388, "Member 'AEndBizarreBugWallActor::InstanceContexts' has a wrong offset!");
static_assert(offsetof(AEndBizarreBugWallActor, SpawnCycle) == 0x000398, "Member 'AEndBizarreBugWallActor::SpawnCycle' has a wrong offset!");
static_assert(offsetof(AEndBizarreBugWallActor, SplineMoveSpeed) == 0x00039C, "Member 'AEndBizarreBugWallActor::SplineMoveSpeed' has a wrong offset!");
static_assert(offsetof(AEndBizarreBugWallActor, OverrideFadeInTime) == 0x0003A0, "Member 'AEndBizarreBugWallActor::OverrideFadeInTime' has a wrong offset!");
static_assert(offsetof(AEndBizarreBugWallActor, OverrideFadeOutTime) == 0x0003A4, "Member 'AEndBizarreBugWallActor::OverrideFadeOutTime' has a wrong offset!");
static_assert(offsetof(AEndBizarreBugWallActor, MoveType) == 0x0003A8, "Member 'AEndBizarreBugWallActor::MoveType' has a wrong offset!");
static_assert(offsetof(AEndBizarreBugWallActor, Direction) == 0x0003AC, "Member 'AEndBizarreBugWallActor::Direction' has a wrong offset!");
static_assert(offsetof(AEndBizarreBugWallActor, BeginAnimationFrame) == 0x0003B8, "Member 'AEndBizarreBugWallActor::BeginAnimationFrame' has a wrong offset!");
static_assert(offsetof(AEndBizarreBugWallActor, EndAnimationFrame) == 0x0003BC, "Member 'AEndBizarreBugWallActor::EndAnimationFrame' has a wrong offset!");
static_assert(offsetof(AEndBizarreBugWallActor, AnimationFrameRate) == 0x0003C0, "Member 'AEndBizarreBugWallActor::AnimationFrameRate' has a wrong offset!");
static_assert(offsetof(AEndBizarreBugWallActor, AnimationPlayRate) == 0x0003C4, "Member 'AEndBizarreBugWallActor::AnimationPlayRate' has a wrong offset!");
static_assert(offsetof(AEndBizarreBugWallActor, SplineComponent) == 0x0003C8, "Member 'AEndBizarreBugWallActor::SplineComponent' has a wrong offset!");
static_assert(offsetof(AEndBizarreBugWallActor, InstancedMeshComponent) == 0x0003D0, "Member 'AEndBizarreBugWallActor::InstancedMeshComponent' has a wrong offset!");

// Class EndGame.EndAIAcceptAerialRootMove
// 0x0000 (0x0030 - 0x0030)
class UEndAIAcceptAerialRootMove final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAIAcceptAerialRootMove">();
	}
	static class UEndAIAcceptAerialRootMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAIAcceptAerialRootMove>();
	}
};
static_assert(alignof(UEndAIAcceptAerialRootMove) == 0x000008, "Wrong alignment on UEndAIAcceptAerialRootMove");
static_assert(sizeof(UEndAIAcceptAerialRootMove) == 0x000030, "Wrong size on UEndAIAcceptAerialRootMove");

// Class EndGame.AnimNotify_EndEmissiveAnimationRange
// 0x0020 (0x0050 - 0x0030)
class UAnimNotify_EndEmissiveAnimationRange final : public UAnimNotifyState
{
public:
	class FName                                   ColorPaletteId;                                    // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndEmissiveModifierType                      Modifier;                                          // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndEmissiveCurveType                         Curve;                                             // 0x0039(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCallStopOnEnd;                                    // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndEmissiveAnimationRange">();
	}
	static class UAnimNotify_EndEmissiveAnimationRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndEmissiveAnimationRange>();
	}
};
static_assert(alignof(UAnimNotify_EndEmissiveAnimationRange) == 0x000008, "Wrong alignment on UAnimNotify_EndEmissiveAnimationRange");
static_assert(sizeof(UAnimNotify_EndEmissiveAnimationRange) == 0x000050, "Wrong size on UAnimNotify_EndEmissiveAnimationRange");
static_assert(offsetof(UAnimNotify_EndEmissiveAnimationRange, ColorPaletteId) == 0x000030, "Member 'UAnimNotify_EndEmissiveAnimationRange::ColorPaletteId' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEmissiveAnimationRange, Modifier) == 0x000038, "Member 'UAnimNotify_EndEmissiveAnimationRange::Modifier' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEmissiveAnimationRange, Curve) == 0x000039, "Member 'UAnimNotify_EndEmissiveAnimationRange::Curve' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEmissiveAnimationRange, Duration) == 0x00003C, "Member 'UAnimNotify_EndEmissiveAnimationRange::Duration' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEmissiveAnimationRange, BlendInTime) == 0x000040, "Member 'UAnimNotify_EndEmissiveAnimationRange::BlendInTime' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEmissiveAnimationRange, BlendOutTime) == 0x000044, "Member 'UAnimNotify_EndEmissiveAnimationRange::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEmissiveAnimationRange, bCallStopOnEnd) == 0x000048, "Member 'UAnimNotify_EndEmissiveAnimationRange::bCallStopOnEnd' has a wrong offset!");

// Class EndGame.EndAIAvoidanceAPI
// 0x0000 (0x0028 - 0x0028)
class UEndAIAvoidanceAPI final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAIAvoidanceAPI">();
	}
	static class UEndAIAvoidanceAPI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAIAvoidanceAPI>();
	}
};
static_assert(alignof(UEndAIAvoidanceAPI) == 0x000008, "Wrong alignment on UEndAIAvoidanceAPI");
static_assert(sizeof(UEndAIAvoidanceAPI) == 0x000028, "Wrong size on UEndAIAvoidanceAPI");

// Class EndGame.AnimNotify_EndEmotion
// 0x0010 (0x0040 - 0x0030)
class UAnimNotify_EndEmotion final : public UAnimNotifyState
{
public:
	class FName                                   Emotion;                                           // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndEmotion">();
	}
	static class UAnimNotify_EndEmotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndEmotion>();
	}
};
static_assert(alignof(UAnimNotify_EndEmotion) == 0x000008, "Wrong alignment on UAnimNotify_EndEmotion");
static_assert(sizeof(UAnimNotify_EndEmotion) == 0x000040, "Wrong size on UAnimNotify_EndEmotion");
static_assert(offsetof(UAnimNotify_EndEmotion, Emotion) == 0x000030, "Member 'UAnimNotify_EndEmotion::Emotion' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEmotion, BlendInTime) == 0x000038, "Member 'UAnimNotify_EndEmotion::BlendInTime' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEmotion, BlendOutTime) == 0x00003C, "Member 'UAnimNotify_EndEmotion::BlendOutTime' has a wrong offset!");

// Class EndGame.EndHighlightFrameWindow
// 0x0008 (0x0368 - 0x0360)
class UEndHighlightFrameWindow : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x8];                                      // 0x0360(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndHighlightFrameWindow">();
	}
	static class UEndHighlightFrameWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndHighlightFrameWindow>();
	}
};
static_assert(alignof(UEndHighlightFrameWindow) == 0x000008, "Wrong alignment on UEndHighlightFrameWindow");
static_assert(sizeof(UEndHighlightFrameWindow) == 0x000368, "Wrong size on UEndHighlightFrameWindow");

// Class EndGame.EndMainMenuWindow
// 0x00D0 (0x0430 - 0x0360)
class UEndMainMenuWindow : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0xD0];                                     // 0x0360(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainMenuWindow">();
	}
	static class UEndMainMenuWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainMenuWindow>();
	}
};
static_assert(alignof(UEndMainMenuWindow) == 0x000008, "Wrong alignment on UEndMainMenuWindow");
static_assert(sizeof(UEndMainMenuWindow) == 0x000430, "Wrong size on UEndMainMenuWindow");

// Class EndGame.EndBattleReportMenu
// 0x0170 (0x05A0 - 0x0430)
class UEndBattleReportMenu : public UEndMainMenuWindow
{
public:
	class UEndSortWindow*                         SortList;                                          // 0x0430(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_438[0xC0];                                     // 0x0438(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FSoftObjectPath>   _ReportImages;                                     // 0x04F8(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<class FString, struct FSoftObjectPath>   _ReportBgImages;                                   // 0x0548(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_598[0x8];                                      // 0x0598(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnReportMenuSelectedIndexChanged(int32 CellIndex);
	void OnReportMenuSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnSortListPressedItem(int32 CellIndex);
	void SetReportBgImage(const struct FSoftObjectPath& Path);
	void SetReportImage(const struct FSoftObjectPath& Path);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleReportMenu">();
	}
	static class UEndBattleReportMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleReportMenu>();
	}
};
static_assert(alignof(UEndBattleReportMenu) == 0x000008, "Wrong alignment on UEndBattleReportMenu");
static_assert(sizeof(UEndBattleReportMenu) == 0x0005A0, "Wrong size on UEndBattleReportMenu");
static_assert(offsetof(UEndBattleReportMenu, SortList) == 0x000430, "Member 'UEndBattleReportMenu::SortList' has a wrong offset!");
static_assert(offsetof(UEndBattleReportMenu, _ReportImages) == 0x0004F8, "Member 'UEndBattleReportMenu::_ReportImages' has a wrong offset!");
static_assert(offsetof(UEndBattleReportMenu, _ReportBgImages) == 0x000548, "Member 'UEndBattleReportMenu::_ReportBgImages' has a wrong offset!");

// Class EndGame.AnimNotify_EndEnableFall
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_EndEnableFall final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndEnableFall">();
	}
	static class UAnimNotify_EndEnableFall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndEnableFall>();
	}
};
static_assert(alignof(UAnimNotify_EndEnableFall) == 0x000008, "Wrong alignment on UAnimNotify_EndEnableFall");
static_assert(sizeof(UAnimNotify_EndEnableFall) == 0x000038, "Wrong size on UAnimNotify_EndEnableFall");

// Class EndGame.AnimNotify_EndEnableRagdollPhysics
// 0x0038 (0x0070 - 0x0038)
class UAnimNotify_EndEnableRagdollPhysics final : public UAnimNotify
{
public:
	uint8                                         bAddImpulse : 1;                                   // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EEndPhysicsImpulseType                        Type;                                              // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Impulse;                                           // 0x0040(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyImpulseToAllBones;                           // 0x004C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0050(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0058(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x005C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBikeUseRoadForward;                               // 0x0060(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSimpleBehaviorBodyDriverForRiders;             // 0x0061(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x2];                                       // 0x0062(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bBodyDriverRagdoll : 1;                            // 0x0064(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinActivationTime;                                 // 0x0068(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxActivationTime;                                 // 0x006C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndEnableRagdollPhysics">();
	}
	static class UAnimNotify_EndEnableRagdollPhysics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndEnableRagdollPhysics>();
	}
};
static_assert(alignof(UAnimNotify_EndEnableRagdollPhysics) == 0x000008, "Wrong alignment on UAnimNotify_EndEnableRagdollPhysics");
static_assert(sizeof(UAnimNotify_EndEnableRagdollPhysics) == 0x000070, "Wrong size on UAnimNotify_EndEnableRagdollPhysics");
static_assert(offsetof(UAnimNotify_EndEnableRagdollPhysics, Type) == 0x00003C, "Member 'UAnimNotify_EndEnableRagdollPhysics::Type' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEnableRagdollPhysics, Impulse) == 0x000040, "Member 'UAnimNotify_EndEnableRagdollPhysics::Impulse' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEnableRagdollPhysics, bApplyImpulseToAllBones) == 0x00004C, "Member 'UAnimNotify_EndEnableRagdollPhysics::bApplyImpulseToAllBones' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEnableRagdollPhysics, BoneName) == 0x000050, "Member 'UAnimNotify_EndEnableRagdollPhysics::BoneName' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEnableRagdollPhysics, Radius) == 0x000058, "Member 'UAnimNotify_EndEnableRagdollPhysics::Radius' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEnableRagdollPhysics, Strength) == 0x00005C, "Member 'UAnimNotify_EndEnableRagdollPhysics::Strength' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEnableRagdollPhysics, bBikeUseRoadForward) == 0x000060, "Member 'UAnimNotify_EndEnableRagdollPhysics::bBikeUseRoadForward' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEnableRagdollPhysics, bUseSimpleBehaviorBodyDriverForRiders) == 0x000061, "Member 'UAnimNotify_EndEnableRagdollPhysics::bUseSimpleBehaviorBodyDriverForRiders' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEnableRagdollPhysics, MinActivationTime) == 0x000068, "Member 'UAnimNotify_EndEnableRagdollPhysics::MinActivationTime' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEnableRagdollPhysics, MaxActivationTime) == 0x00006C, "Member 'UAnimNotify_EndEnableRagdollPhysics::MaxActivationTime' has a wrong offset!");

// Class EndGame.EndDataObjectBase
// 0x0010 (0x0038 - 0x0028)
class UEndDataObjectBase : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBase">();
	}
	static class UEndDataObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBase>();
	}
};
static_assert(alignof(UEndDataObjectBase) == 0x000008, "Wrong alignment on UEndDataObjectBase");
static_assert(sizeof(UEndDataObjectBase) == 0x000038, "Wrong size on UEndDataObjectBase");

// Class EndGame.EndDataObjectUniqueActionActorAttack
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectUniqueActionActorAttack final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectUniqueActionActorAttack">();
	}
	static class UEndDataObjectUniqueActionActorAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectUniqueActionActorAttack>();
	}
};
static_assert(alignof(UEndDataObjectUniqueActionActorAttack) == 0x000008, "Wrong alignment on UEndDataObjectUniqueActionActorAttack");
static_assert(sizeof(UEndDataObjectUniqueActionActorAttack) == 0x000088, "Wrong size on UEndDataObjectUniqueActionActorAttack");

// Class EndGame.EndImageSet
// 0x0068 (0x0160 - 0x00F8)
class UEndImageSet final : public UWidget
{
public:
	TArray<struct FEndMenuImage>                  Images;                                            // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorAndOpacity;                                   // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ColorAndOpacityDelegate;                           // 0x0118(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	EBlendMode                                    BlendMode;                                         // 0x0128(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x3];                                      // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SelectedIndex;                                     // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimpleMode;                                       // 0x0130(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x3];                                      // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Size;                                              // 0x0134(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(const struct FGeometry& MyGeometry, struct FPointerEvent& MouseEvent)> OnMouseButtonDownEvent;                            // 0x0140(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_150[0x10];                                     // 0x0150(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBlendMode(EBlendMode InBlendMode);
	void SetColorAndOpacity(const struct FLinearColor& InColorAndOpacity);
	void SetOpacity(float InOpacity);
	void SetSelectedIndex(int32 Index_0);
	void SetSimpleMode(bool bInSimpleMode);
	void SetSize(const struct FVector2D& InSize);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndImageSet">();
	}
	static class UEndImageSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndImageSet>();
	}
};
static_assert(alignof(UEndImageSet) == 0x000008, "Wrong alignment on UEndImageSet");
static_assert(sizeof(UEndImageSet) == 0x000160, "Wrong size on UEndImageSet");
static_assert(offsetof(UEndImageSet, Images) == 0x0000F8, "Member 'UEndImageSet::Images' has a wrong offset!");
static_assert(offsetof(UEndImageSet, ColorAndOpacity) == 0x000108, "Member 'UEndImageSet::ColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UEndImageSet, ColorAndOpacityDelegate) == 0x000118, "Member 'UEndImageSet::ColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UEndImageSet, BlendMode) == 0x000128, "Member 'UEndImageSet::BlendMode' has a wrong offset!");
static_assert(offsetof(UEndImageSet, SelectedIndex) == 0x00012C, "Member 'UEndImageSet::SelectedIndex' has a wrong offset!");
static_assert(offsetof(UEndImageSet, bSimpleMode) == 0x000130, "Member 'UEndImageSet::bSimpleMode' has a wrong offset!");
static_assert(offsetof(UEndImageSet, Size) == 0x000134, "Member 'UEndImageSet::Size' has a wrong offset!");
static_assert(offsetof(UEndImageSet, OnMouseButtonDownEvent) == 0x000140, "Member 'UEndImageSet::OnMouseButtonDownEvent' has a wrong offset!");

// Class EndGame.EndBattleLockonMarkerIcon
// 0x0010 (0x0370 - 0x0360)
class UEndBattleLockonMarkerIcon : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x10];                                     // 0x0360(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleLockonMarkerIcon">();
	}
	static class UEndBattleLockonMarkerIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleLockonMarkerIcon>();
	}
};
static_assert(alignof(UEndBattleLockonMarkerIcon) == 0x000008, "Wrong alignment on UEndBattleLockonMarkerIcon");
static_assert(sizeof(UEndBattleLockonMarkerIcon) == 0x000370, "Wrong size on UEndBattleLockonMarkerIcon");

// Class EndGame.AnimNotify_EndEnableRagdollPhysicsHitImpulse
// 0x0028 (0x0060 - 0x0038)
class UAnimNotify_EndEnableRagdollPhysicsHitImpulse final : public UAnimNotify
{
public:
	float                                         Yaw;                                               // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawVariation;                                      // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pitch;                                             // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchVariation;                                    // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBikeUseRoadForward;                               // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSimpleBehaviorBodyDriverForRiders;             // 0x0049(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ImpulseMultiplier;                                 // 0x004C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyImpulseToAllBones;                           // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreInertia;                                    // 0x0051(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0054(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndEnableRagdollPhysicsHitImpulse">();
	}
	static class UAnimNotify_EndEnableRagdollPhysicsHitImpulse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndEnableRagdollPhysicsHitImpulse>();
	}
};
static_assert(alignof(UAnimNotify_EndEnableRagdollPhysicsHitImpulse) == 0x000008, "Wrong alignment on UAnimNotify_EndEnableRagdollPhysicsHitImpulse");
static_assert(sizeof(UAnimNotify_EndEnableRagdollPhysicsHitImpulse) == 0x000060, "Wrong size on UAnimNotify_EndEnableRagdollPhysicsHitImpulse");
static_assert(offsetof(UAnimNotify_EndEnableRagdollPhysicsHitImpulse, Yaw) == 0x000038, "Member 'UAnimNotify_EndEnableRagdollPhysicsHitImpulse::Yaw' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEnableRagdollPhysicsHitImpulse, YawVariation) == 0x00003C, "Member 'UAnimNotify_EndEnableRagdollPhysicsHitImpulse::YawVariation' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEnableRagdollPhysicsHitImpulse, Pitch) == 0x000040, "Member 'UAnimNotify_EndEnableRagdollPhysicsHitImpulse::Pitch' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEnableRagdollPhysicsHitImpulse, PitchVariation) == 0x000044, "Member 'UAnimNotify_EndEnableRagdollPhysicsHitImpulse::PitchVariation' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEnableRagdollPhysicsHitImpulse, bBikeUseRoadForward) == 0x000048, "Member 'UAnimNotify_EndEnableRagdollPhysicsHitImpulse::bBikeUseRoadForward' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEnableRagdollPhysicsHitImpulse, bUseSimpleBehaviorBodyDriverForRiders) == 0x000049, "Member 'UAnimNotify_EndEnableRagdollPhysicsHitImpulse::bUseSimpleBehaviorBodyDriverForRiders' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEnableRagdollPhysicsHitImpulse, ImpulseMultiplier) == 0x00004C, "Member 'UAnimNotify_EndEnableRagdollPhysicsHitImpulse::ImpulseMultiplier' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEnableRagdollPhysicsHitImpulse, bApplyImpulseToAllBones) == 0x000050, "Member 'UAnimNotify_EndEnableRagdollPhysicsHitImpulse::bApplyImpulseToAllBones' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEnableRagdollPhysicsHitImpulse, bIgnoreInertia) == 0x000051, "Member 'UAnimNotify_EndEnableRagdollPhysicsHitImpulse::bIgnoreInertia' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEnableRagdollPhysicsHitImpulse, BoneName) == 0x000054, "Member 'UAnimNotify_EndEnableRagdollPhysicsHitImpulse::BoneName' has a wrong offset!");

// Class EndGame.EndAIBehaviorTreeComponent
// 0x0000 (0x0290 - 0x0290)
class UEndAIBehaviorTreeComponent final : public UBehaviorTreeComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAIBehaviorTreeComponent">();
	}
	static class UEndAIBehaviorTreeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAIBehaviorTreeComponent>();
	}
};
static_assert(alignof(UEndAIBehaviorTreeComponent) == 0x000008, "Wrong alignment on UEndAIBehaviorTreeComponent");
static_assert(sizeof(UEndAIBehaviorTreeComponent) == 0x000290, "Wrong size on UEndAIBehaviorTreeComponent");

// Class EndGame.AnimNotify_EndEnableResidentBlend
// 0x0010 (0x0048 - 0x0038)
class UAnimNotify_EndEnableResidentBlend final : public UAnimNotify
{
public:
	bool                                          Enabled;                                           // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Key;                                               // 0x003C(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndEnableResidentBlend">();
	}
	static class UAnimNotify_EndEnableResidentBlend* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndEnableResidentBlend>();
	}
};
static_assert(alignof(UAnimNotify_EndEnableResidentBlend) == 0x000008, "Wrong alignment on UAnimNotify_EndEnableResidentBlend");
static_assert(sizeof(UAnimNotify_EndEnableResidentBlend) == 0x000048, "Wrong size on UAnimNotify_EndEnableResidentBlend");
static_assert(offsetof(UAnimNotify_EndEnableResidentBlend, Enabled) == 0x000038, "Member 'UAnimNotify_EndEnableResidentBlend::Enabled' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEnableResidentBlend, Key) == 0x00003C, "Member 'UAnimNotify_EndEnableResidentBlend::Key' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEnableResidentBlend, BlendTime) == 0x000044, "Member 'UAnimNotify_EndEnableResidentBlend::BlendTime' has a wrong offset!");

// Class EndGame.EndBattleEnvQueryContext
// 0x0000 (0x0030 - 0x0030)
class UEndBattleEnvQueryContext final : public UEnvQueryContext_BlueprintBase
{
public:
	TArray<class AEndCharacter*> GetTargetContexts(class UEndEnvQueryComponent* InQuery, bool InParty, float InDistance) const;
	TArray<struct FVector> GetTargetLocationContexts(class UEndEnvQueryComponent* InQuery, bool InParty, float InDistance) const;
	void ProvideActorsSet(class UObject* QuerierObject, class AActor* QuerierActor, TArray<class AActor*>* ResultingActorsSet) const;
	void ProvideLocationsSet(class UObject* QuerierObject, class AActor* QuerierActor, TArray<struct FVector>* ResultingLocationSet) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleEnvQueryContext">();
	}
	static class UEndBattleEnvQueryContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleEnvQueryContext>();
	}
};
static_assert(alignof(UEndBattleEnvQueryContext) == 0x000008, "Wrong alignment on UEndBattleEnvQueryContext");
static_assert(sizeof(UEndBattleEnvQueryContext) == 0x000030, "Wrong size on UEndBattleEnvQueryContext");

// Class EndGame.EndStringListBox
// 0x0078 (0x0170 - 0x00F8)
class UEndStringListBox final : public UWidget
{
public:
	EOrientation                                  Orientation;                                       // 0x00F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UWidget>                    ContentClass;                                      // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Items;                                             // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         DesiredCount;                                      // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(class UWidget* ItemWidget, int32 ItemIndex, const class FString& ItemString)> OnSetupItem;                                       // 0x0120(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPressedItem;                                     // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_140[0x10];                                     // 0x0140(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UWidget*>                        ContentWidgets;                                    // 0x0150(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UWidget*>                        CachedWidgets;                                     // 0x0160(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void SetDesiredCount(int32 InDesiredCount);
	void SetItems(const TArray<class FString>& InItems);

	int32 GetSelectedIndex(int32 UserIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndStringListBox">();
	}
	static class UEndStringListBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndStringListBox>();
	}
};
static_assert(alignof(UEndStringListBox) == 0x000008, "Wrong alignment on UEndStringListBox");
static_assert(sizeof(UEndStringListBox) == 0x000170, "Wrong size on UEndStringListBox");
static_assert(offsetof(UEndStringListBox, Orientation) == 0x0000F8, "Member 'UEndStringListBox::Orientation' has a wrong offset!");
static_assert(offsetof(UEndStringListBox, ContentClass) == 0x000100, "Member 'UEndStringListBox::ContentClass' has a wrong offset!");
static_assert(offsetof(UEndStringListBox, Items) == 0x000108, "Member 'UEndStringListBox::Items' has a wrong offset!");
static_assert(offsetof(UEndStringListBox, DesiredCount) == 0x000118, "Member 'UEndStringListBox::DesiredCount' has a wrong offset!");
static_assert(offsetof(UEndStringListBox, OnSetupItem) == 0x000120, "Member 'UEndStringListBox::OnSetupItem' has a wrong offset!");
static_assert(offsetof(UEndStringListBox, OnPressedItem) == 0x000130, "Member 'UEndStringListBox::OnPressedItem' has a wrong offset!");
static_assert(offsetof(UEndStringListBox, ContentWidgets) == 0x000150, "Member 'UEndStringListBox::ContentWidgets' has a wrong offset!");
static_assert(offsetof(UEndStringListBox, CachedWidgets) == 0x000160, "Member 'UEndStringListBox::CachedWidgets' has a wrong offset!");

// Class EndGame.AnimNotifyState_EndEnableResidentBlend
// 0x0018 (0x0048 - 0x0030)
class UAnimNotifyState_EndEnableResidentBlend final : public UAnimNotifyState
{
public:
	bool                                          Enabled;                                           // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Key;                                               // 0x0034(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_EndEnableResidentBlend">();
	}
	static class UAnimNotifyState_EndEnableResidentBlend* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_EndEnableResidentBlend>();
	}
};
static_assert(alignof(UAnimNotifyState_EndEnableResidentBlend) == 0x000008, "Wrong alignment on UAnimNotifyState_EndEnableResidentBlend");
static_assert(sizeof(UAnimNotifyState_EndEnableResidentBlend) == 0x000048, "Wrong size on UAnimNotifyState_EndEnableResidentBlend");
static_assert(offsetof(UAnimNotifyState_EndEnableResidentBlend, Enabled) == 0x000030, "Member 'UAnimNotifyState_EndEnableResidentBlend::Enabled' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_EndEnableResidentBlend, Key) == 0x000034, "Member 'UAnimNotifyState_EndEnableResidentBlend::Key' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_EndEnableResidentBlend, BlendInTime) == 0x00003C, "Member 'UAnimNotifyState_EndEnableResidentBlend::BlendInTime' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_EndEnableResidentBlend, BlendOutTime) == 0x000040, "Member 'UAnimNotifyState_EndEnableResidentBlend::BlendOutTime' has a wrong offset!");

// Class EndGame.AnimNotify_EndEnableWeaponRagdollPhysics
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_EndEnableWeaponRagdollPhysics final : public UAnimNotify
{
public:
	bool                                          bSpecificWeaponSlotOnly;                           // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponSlot                                   WeaponSlot;                                        // 0x0039(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndEnableWeaponRagdollPhysics">();
	}
	static class UAnimNotify_EndEnableWeaponRagdollPhysics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndEnableWeaponRagdollPhysics>();
	}
};
static_assert(alignof(UAnimNotify_EndEnableWeaponRagdollPhysics) == 0x000008, "Wrong alignment on UAnimNotify_EndEnableWeaponRagdollPhysics");
static_assert(sizeof(UAnimNotify_EndEnableWeaponRagdollPhysics) == 0x000040, "Wrong size on UAnimNotify_EndEnableWeaponRagdollPhysics");
static_assert(offsetof(UAnimNotify_EndEnableWeaponRagdollPhysics, bSpecificWeaponSlotOnly) == 0x000038, "Member 'UAnimNotify_EndEnableWeaponRagdollPhysics::bSpecificWeaponSlotOnly' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndEnableWeaponRagdollPhysics, WeaponSlot) == 0x000039, "Member 'UAnimNotify_EndEnableWeaponRagdollPhysics::WeaponSlot' has a wrong offset!");

// Class EndGame.EndDataObjectWanderingParamList
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectWanderingParamList final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectWanderingParamList">();
	}
	static class UEndDataObjectWanderingParamList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectWanderingParamList>();
	}
};
static_assert(alignof(UEndDataObjectWanderingParamList) == 0x000008, "Wrong alignment on UEndDataObjectWanderingParamList");
static_assert(sizeof(UEndDataObjectWanderingParamList) == 0x000088, "Wrong size on UEndDataObjectWanderingParamList");

// Class EndGame.EndBonamikWindData
// 0x0060 (0x0090 - 0x0030)
class UEndBonamikWindData final : public UDataAsset
{
public:
	EEndBonamikWindType                           Type;                                              // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BaseForce;                                         // 0x0034(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Power;                                             // 0x0040(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AdditiveDirectionalForce;                          // 0x0044(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RandomRange;                                       // 0x0050(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomTime;                                        // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AdditiveWaveForce;                                 // 0x0060(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WaveAmplitude;                                     // 0x006C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WavePeriod;                                        // 0x0078(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WaveFrequency;                                     // 0x0084(0x000C)(Edit, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBonamikWindData">();
	}
	static class UEndBonamikWindData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBonamikWindData>();
	}
};
static_assert(alignof(UEndBonamikWindData) == 0x000008, "Wrong alignment on UEndBonamikWindData");
static_assert(sizeof(UEndBonamikWindData) == 0x000090, "Wrong size on UEndBonamikWindData");
static_assert(offsetof(UEndBonamikWindData, Type) == 0x000030, "Member 'UEndBonamikWindData::Type' has a wrong offset!");
static_assert(offsetof(UEndBonamikWindData, BaseForce) == 0x000034, "Member 'UEndBonamikWindData::BaseForce' has a wrong offset!");
static_assert(offsetof(UEndBonamikWindData, Power) == 0x000040, "Member 'UEndBonamikWindData::Power' has a wrong offset!");
static_assert(offsetof(UEndBonamikWindData, AdditiveDirectionalForce) == 0x000044, "Member 'UEndBonamikWindData::AdditiveDirectionalForce' has a wrong offset!");
static_assert(offsetof(UEndBonamikWindData, RandomRange) == 0x000050, "Member 'UEndBonamikWindData::RandomRange' has a wrong offset!");
static_assert(offsetof(UEndBonamikWindData, RandomTime) == 0x00005C, "Member 'UEndBonamikWindData::RandomTime' has a wrong offset!");
static_assert(offsetof(UEndBonamikWindData, AdditiveWaveForce) == 0x000060, "Member 'UEndBonamikWindData::AdditiveWaveForce' has a wrong offset!");
static_assert(offsetof(UEndBonamikWindData, WaveAmplitude) == 0x00006C, "Member 'UEndBonamikWindData::WaveAmplitude' has a wrong offset!");
static_assert(offsetof(UEndBonamikWindData, WavePeriod) == 0x000078, "Member 'UEndBonamikWindData::WavePeriod' has a wrong offset!");
static_assert(offsetof(UEndBonamikWindData, WaveFrequency) == 0x000084, "Member 'UEndBonamikWindData::WaveFrequency' has a wrong offset!");

// Class EndGame.EndParticleModuleBase
// 0x0000 (0x0038 - 0x0038)
class UEndParticleModuleBase : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndParticleModuleBase">();
	}
	static class UEndParticleModuleBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndParticleModuleBase>();
	}
};
static_assert(alignof(UEndParticleModuleBase) == 0x000008, "Wrong alignment on UEndParticleModuleBase");
static_assert(sizeof(UEndParticleModuleBase) == 0x000038, "Wrong size on UEndParticleModuleBase");

// Class EndGame.VfxParticleModulePostProcessBase
// 0x0000 (0x0038 - 0x0038)
class UVfxParticleModulePostProcessBase : public UEndParticleModuleBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VfxParticleModulePostProcessBase">();
	}
	static class UVfxParticleModulePostProcessBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVfxParticleModulePostProcessBase>();
	}
};
static_assert(alignof(UVfxParticleModulePostProcessBase) == 0x000008, "Wrong alignment on UVfxParticleModulePostProcessBase");
static_assert(sizeof(UVfxParticleModulePostProcessBase) == 0x000038, "Wrong size on UVfxParticleModulePostProcessBase");

// Class EndGame.VfxParticleModulePostProcessDirectionalBlur
// 0x0148 (0x0180 - 0x0038)
class UVfxParticleModulePostProcessDirectionalBlur final : public UVfxParticleModulePostProcessBase
{
public:
	uint8                                         bOverride_DirectionalBlurDistortionIntensity : 1;  // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DirectionalBlurDistortionGradient : 1;   // 0x0038(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DirectionalBlurDistortionField : 1;      // 0x0038(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DirectionalBlurDistortionFrequency : 1;  // 0x0038(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DirectionalBlurDistortionPosition : 1;   // 0x0038(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  m_DirectionalBlurDistortionIntensity;              // 0x0040(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_DirectionalBlurDistortionGradient;               // 0x0080(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_DirectionalBlurDistortionField;                  // 0x00C0(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_DirectionalBlurDistortionFrequency;              // 0x0100(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_DirectionalBlurDistortionPosition;               // 0x0140(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VfxParticleModulePostProcessDirectionalBlur">();
	}
	static class UVfxParticleModulePostProcessDirectionalBlur* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVfxParticleModulePostProcessDirectionalBlur>();
	}
};
static_assert(alignof(UVfxParticleModulePostProcessDirectionalBlur) == 0x000008, "Wrong alignment on UVfxParticleModulePostProcessDirectionalBlur");
static_assert(sizeof(UVfxParticleModulePostProcessDirectionalBlur) == 0x000180, "Wrong size on UVfxParticleModulePostProcessDirectionalBlur");
static_assert(offsetof(UVfxParticleModulePostProcessDirectionalBlur, m_DirectionalBlurDistortionIntensity) == 0x000040, "Member 'UVfxParticleModulePostProcessDirectionalBlur::m_DirectionalBlurDistortionIntensity' has a wrong offset!");
static_assert(offsetof(UVfxParticleModulePostProcessDirectionalBlur, m_DirectionalBlurDistortionGradient) == 0x000080, "Member 'UVfxParticleModulePostProcessDirectionalBlur::m_DirectionalBlurDistortionGradient' has a wrong offset!");
static_assert(offsetof(UVfxParticleModulePostProcessDirectionalBlur, m_DirectionalBlurDistortionField) == 0x0000C0, "Member 'UVfxParticleModulePostProcessDirectionalBlur::m_DirectionalBlurDistortionField' has a wrong offset!");
static_assert(offsetof(UVfxParticleModulePostProcessDirectionalBlur, m_DirectionalBlurDistortionFrequency) == 0x000100, "Member 'UVfxParticleModulePostProcessDirectionalBlur::m_DirectionalBlurDistortionFrequency' has a wrong offset!");
static_assert(offsetof(UVfxParticleModulePostProcessDirectionalBlur, m_DirectionalBlurDistortionPosition) == 0x000140, "Member 'UVfxParticleModulePostProcessDirectionalBlur::m_DirectionalBlurDistortionPosition' has a wrong offset!");

// Class EndGame.EndAIController
// 0x0920 (0x0D90 - 0x0470)
class AEndAIController : public AAIController
{
public:
	uint8                                         Pad_470[0xE0];                                     // 0x0470(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 LookAtTarget;                                      // 0x0550(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FixRootQuantity;                                   // 0x0558(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55C[0x24];                                     // 0x055C(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ForceRun;                                          // 0x0580(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceDash;                                         // 0x0581(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceStrafe;                                       // 0x0582(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceStraight;                                     // 0x0583(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanOtherMove;                                     // 0x0584(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_585[0x3];                                      // 0x0585(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OtherMoveInterval;                                 // 0x0588(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OtherMoveIntervalRandom;                           // 0x058C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_590[0x174];                                    // 0x0590(0x0174)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAcceptAerialRootMotionMove;                       // 0x0704(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAcceptAerialRootMotionTurn;                       // 0x0705(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAcceptAerialAITurn;                               // 0x0706(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOtherWallMode;                                 // 0x0707(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAerialMotionFixIdle;                              // 0x0708(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAcceptAeriaAutoRunWalkIdle;                       // 0x0709(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70A[0x2];                                      // 0x070A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroundMoveCheckDistance;                           // 0x070C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        SwapPathLocations;                                 // 0x0710(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        PathLocations;                                     // 0x0720(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   OverrideAnimSetName;                               // 0x0730(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_738[0x1E0];                                    // 0x0738(0x01E0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        PathLeapLocations;                                 // 0x0918(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_928[0x8];                                      // 0x0928(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOtherGroundMoveRun;                               // 0x0930(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOtherMoveRun;                                     // 0x0931(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_932[0x14E];                                    // 0x0932(0x014E)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AcceptMoveOnAngle;                                 // 0x0A80(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A84[0x14];                                     // 0x0A84(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpTimeQuantity;                                  // 0x0A98(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpBias;                                          // 0x0A9C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          AerialAcceptPitch;                                 // 0x0AA0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AA1[0x3];                                      // 0x0AA1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AerialLateralForce;                                // 0x0AA4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AerialActorLateralForce;                           // 0x0AA8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAerialHitWall;                                    // 0x0AAC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAerialHitTerrain;                                 // 0x0AAD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAerialHitObject;                                  // 0x0AAE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AAF[0x1];                                      // 0x0AAF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AerialHeight;                                      // 0x0AB0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AerialConfront;                                    // 0x0AB4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AerialFrontAcc;                                    // 0x0AB8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AerialBackAcc;                                     // 0x0ABC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AerialSideAcc;                                     // 0x0AC0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AerialFrontMax;                                    // 0x0AC4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AerialBackMax;                                     // 0x0AC8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AerialSideMax;                                     // 0x0ACC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AerialUpMax;                                       // 0x0AD0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AerialDownMax;                                     // 0x0AD4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          AerialStrafe;                                      // 0x0AD8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AD9[0x3];                                      // 0x0AD9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AerialStrafeThreshold;                             // 0x0ADC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          AerialForceMoveDirectionTurn;                      // 0x0AE0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AE1[0x3];                                      // 0x0AE1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AerialInertia;                                     // 0x0AE4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AerialBreak;                                       // 0x0AE8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          AerialInertiaAtCannotMove;                         // 0x0AEC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          AerialGoalDistBreak;                               // 0x0AED(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AEE[0x2];                                      // 0x0AEE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AerialAccuratelyCheckPoint;                        // 0x0AF0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AerialAccuratelyGoal;                              // 0x0AF4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AerialGoalAttractionDistance;                      // 0x0AF8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AerialGoalAttraction;                              // 0x0AFC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AerialRunThreshold;                                // 0x0B00(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AerialOutPathCheckSoconds;                         // 0x0B04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AerialOutPathBreak;                                // 0x0B08(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AerialRequestInterval;                             // 0x0B0C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AerialRotateMagnification;                         // 0x0B10(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlyCollisionInterval;                              // 0x0B14(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AerialAcceptMoveVelocity;                          // 0x0B18(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B1C[0x10];                                     // 0x0B1C(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ToWallJumpSkipEndTime;                             // 0x0B2C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B30[0x254];                                    // 0x0B30(0x0254)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          EnableDebugDrawJumpLandingLocation;                // 0x0D84(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D85[0xB];                                      // 0x0D85(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivatePhysicalConstraint(float BlendTime);
	void ActivateResidentBlendMotion(class FName Key, float BlendTime);
	void CorrectRotate(float correctTime);
	void DeactivatePhysicalConstraint(float BlendTime);
	void DeactivateResidentBlendMotion(class FName Key, float BlendTime);
	bool GetAIFlag(EAIInfoFlag InType);
	float GetAIParam(EAIInfoParam InType);
	struct FVector GetCharacterLocation();
	struct FVector GetCharacterRootLocation();
	struct FRotator GetCharacterRotation();
	float GetLocationAngle(const struct FVector& Loc, class AEndCharacter* Target);
	float GetLocationAngleAbs(const struct FVector& Loc, class AEndCharacter* Target);
	bool IsAerial();
	bool IsJumping();
	bool IsLatestOtherPathBoader(bool ContainSemi);
	bool IsMoveModeMigration();
	bool IsValidAerialPoint(const struct FVector& InLocation);
	void MoveToGround(float MoveTime, float groundTime, float groundOffsetZ, bool checkNavArea);
	void MoveToGroundByGravity(EMoveToGroundHeightType heightType, float specifiedHeight, float groundOffsetZ, float GravityScale, float MaxVelocity, bool checkNavArea);
	void OnCompleteGraviticJump();
	void OnCompleteJump();
	bool OverwriteGraviticJumpLandingLocation(const struct FVector& overwriteLocation, const struct FVector& overwriteLookAt);
	bool OverwriteGraviticJumpLandingLocationAndForward(const struct FVector& overwriteLocation, const struct FVector& overwriteForward);
	void ResetAerialAccelerationMove();
	void ResetOtherWallLock();
	void ResetPrimaryAnimPack();
	void SaveVelocity(float DeltaTime);
	void SetAerialFixTurn(bool InFix, float InAngle, float InLeapSpeed);
	void SetAIFlag(EAIInfoFlag InType, bool InFlag);
	void SetAIFlagFromOther(EAIInfoFlag InType, bool InFlag);
	void SetAIParam(EAIInfoParam InType, float InParam);
	void SetCharacterLocation(const struct FVector& InLocation);
	void SetCharacterRotation(const struct FRotator& InRotation);
	void SetForceAerialTurn(bool InForce);
	void SetMoveMode(EEndAiMoveMode InType, bool Skip);
	void SetNextJumpMotion(class FName Begin, class FName Loop, class FName End);
	void SetNextJumpWallCollision(bool bHit);
	void SetOverrideAerialHeight(bool InOverride, float InHeight);
	void SetOverrideJumpBias(bool InOverride, float InBias);
	void SetOverrideJumpTime(bool InOverride, float InTime);
	void SetOverrideNextJumpForward(bool InOverride, const struct FVector& InForward);
	void SetOverrideTurn(bool InOverride, float InAngle);
	void SetPrimaryAnimPack(const class FName InName);
	void StopMove();
	void ToEndJump(bool InTrace, bool IsTraceStartMaxHeightOwn);
	void ToGraviticJump(const struct FVector& landingLocation, float Height, float PeakBias, float turningDuration, const struct FVector& UpVector, const struct FVector& forwardVector, bool bToTerrain);
	void ToGraviticLookAtJump(const struct FVector& landingLocation, float Height, float PeakBias, float turningDuration, const struct FVector& lookAt, bool bToTerrain);
	void ToJump(bool bToTerrain);
	void ToJumpFromName(class FName InName, bool bToTerrain);
	void ToJumpFromNav(class AEndNavModifierVolume* InNav, bool bToTerrain);
	void ToJumpLocation(const struct FVector& Location, bool bRotateYaw, const struct FVector& lookAt, bool bToTerrain, bool bLocationShift);

	EEndAiMoveMode GetLatestMoveMode() const;
	EEndAiMoveMode GetMoveMode() const;
	bool IsMoveMode(EEndAiMoveMode InType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAIController">();
	}
	static class AEndAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndAIController>();
	}
};
static_assert(alignof(AEndAIController) == 0x000008, "Wrong alignment on AEndAIController");
static_assert(sizeof(AEndAIController) == 0x000D90, "Wrong size on AEndAIController");
static_assert(offsetof(AEndAIController, LookAtTarget) == 0x000550, "Member 'AEndAIController::LookAtTarget' has a wrong offset!");
static_assert(offsetof(AEndAIController, FixRootQuantity) == 0x000558, "Member 'AEndAIController::FixRootQuantity' has a wrong offset!");
static_assert(offsetof(AEndAIController, ForceRun) == 0x000580, "Member 'AEndAIController::ForceRun' has a wrong offset!");
static_assert(offsetof(AEndAIController, ForceDash) == 0x000581, "Member 'AEndAIController::ForceDash' has a wrong offset!");
static_assert(offsetof(AEndAIController, ForceStrafe) == 0x000582, "Member 'AEndAIController::ForceStrafe' has a wrong offset!");
static_assert(offsetof(AEndAIController, ForceStraight) == 0x000583, "Member 'AEndAIController::ForceStraight' has a wrong offset!");
static_assert(offsetof(AEndAIController, bCanOtherMove) == 0x000584, "Member 'AEndAIController::bCanOtherMove' has a wrong offset!");
static_assert(offsetof(AEndAIController, OtherMoveInterval) == 0x000588, "Member 'AEndAIController::OtherMoveInterval' has a wrong offset!");
static_assert(offsetof(AEndAIController, OtherMoveIntervalRandom) == 0x00058C, "Member 'AEndAIController::OtherMoveIntervalRandom' has a wrong offset!");
static_assert(offsetof(AEndAIController, bAcceptAerialRootMotionMove) == 0x000704, "Member 'AEndAIController::bAcceptAerialRootMotionMove' has a wrong offset!");
static_assert(offsetof(AEndAIController, bAcceptAerialRootMotionTurn) == 0x000705, "Member 'AEndAIController::bAcceptAerialRootMotionTurn' has a wrong offset!");
static_assert(offsetof(AEndAIController, bAcceptAerialAITurn) == 0x000706, "Member 'AEndAIController::bAcceptAerialAITurn' has a wrong offset!");
static_assert(offsetof(AEndAIController, bUseOtherWallMode) == 0x000707, "Member 'AEndAIController::bUseOtherWallMode' has a wrong offset!");
static_assert(offsetof(AEndAIController, bAerialMotionFixIdle) == 0x000708, "Member 'AEndAIController::bAerialMotionFixIdle' has a wrong offset!");
static_assert(offsetof(AEndAIController, bAcceptAeriaAutoRunWalkIdle) == 0x000709, "Member 'AEndAIController::bAcceptAeriaAutoRunWalkIdle' has a wrong offset!");
static_assert(offsetof(AEndAIController, GroundMoveCheckDistance) == 0x00070C, "Member 'AEndAIController::GroundMoveCheckDistance' has a wrong offset!");
static_assert(offsetof(AEndAIController, SwapPathLocations) == 0x000710, "Member 'AEndAIController::SwapPathLocations' has a wrong offset!");
static_assert(offsetof(AEndAIController, PathLocations) == 0x000720, "Member 'AEndAIController::PathLocations' has a wrong offset!");
static_assert(offsetof(AEndAIController, OverrideAnimSetName) == 0x000730, "Member 'AEndAIController::OverrideAnimSetName' has a wrong offset!");
static_assert(offsetof(AEndAIController, PathLeapLocations) == 0x000918, "Member 'AEndAIController::PathLeapLocations' has a wrong offset!");
static_assert(offsetof(AEndAIController, bOtherGroundMoveRun) == 0x000930, "Member 'AEndAIController::bOtherGroundMoveRun' has a wrong offset!");
static_assert(offsetof(AEndAIController, bOtherMoveRun) == 0x000931, "Member 'AEndAIController::bOtherMoveRun' has a wrong offset!");
static_assert(offsetof(AEndAIController, AcceptMoveOnAngle) == 0x000A80, "Member 'AEndAIController::AcceptMoveOnAngle' has a wrong offset!");
static_assert(offsetof(AEndAIController, JumpTimeQuantity) == 0x000A98, "Member 'AEndAIController::JumpTimeQuantity' has a wrong offset!");
static_assert(offsetof(AEndAIController, JumpBias) == 0x000A9C, "Member 'AEndAIController::JumpBias' has a wrong offset!");
static_assert(offsetof(AEndAIController, AerialAcceptPitch) == 0x000AA0, "Member 'AEndAIController::AerialAcceptPitch' has a wrong offset!");
static_assert(offsetof(AEndAIController, AerialLateralForce) == 0x000AA4, "Member 'AEndAIController::AerialLateralForce' has a wrong offset!");
static_assert(offsetof(AEndAIController, AerialActorLateralForce) == 0x000AA8, "Member 'AEndAIController::AerialActorLateralForce' has a wrong offset!");
static_assert(offsetof(AEndAIController, bAerialHitWall) == 0x000AAC, "Member 'AEndAIController::bAerialHitWall' has a wrong offset!");
static_assert(offsetof(AEndAIController, bAerialHitTerrain) == 0x000AAD, "Member 'AEndAIController::bAerialHitTerrain' has a wrong offset!");
static_assert(offsetof(AEndAIController, bAerialHitObject) == 0x000AAE, "Member 'AEndAIController::bAerialHitObject' has a wrong offset!");
static_assert(offsetof(AEndAIController, AerialHeight) == 0x000AB0, "Member 'AEndAIController::AerialHeight' has a wrong offset!");
static_assert(offsetof(AEndAIController, AerialConfront) == 0x000AB4, "Member 'AEndAIController::AerialConfront' has a wrong offset!");
static_assert(offsetof(AEndAIController, AerialFrontAcc) == 0x000AB8, "Member 'AEndAIController::AerialFrontAcc' has a wrong offset!");
static_assert(offsetof(AEndAIController, AerialBackAcc) == 0x000ABC, "Member 'AEndAIController::AerialBackAcc' has a wrong offset!");
static_assert(offsetof(AEndAIController, AerialSideAcc) == 0x000AC0, "Member 'AEndAIController::AerialSideAcc' has a wrong offset!");
static_assert(offsetof(AEndAIController, AerialFrontMax) == 0x000AC4, "Member 'AEndAIController::AerialFrontMax' has a wrong offset!");
static_assert(offsetof(AEndAIController, AerialBackMax) == 0x000AC8, "Member 'AEndAIController::AerialBackMax' has a wrong offset!");
static_assert(offsetof(AEndAIController, AerialSideMax) == 0x000ACC, "Member 'AEndAIController::AerialSideMax' has a wrong offset!");
static_assert(offsetof(AEndAIController, AerialUpMax) == 0x000AD0, "Member 'AEndAIController::AerialUpMax' has a wrong offset!");
static_assert(offsetof(AEndAIController, AerialDownMax) == 0x000AD4, "Member 'AEndAIController::AerialDownMax' has a wrong offset!");
static_assert(offsetof(AEndAIController, AerialStrafe) == 0x000AD8, "Member 'AEndAIController::AerialStrafe' has a wrong offset!");
static_assert(offsetof(AEndAIController, AerialStrafeThreshold) == 0x000ADC, "Member 'AEndAIController::AerialStrafeThreshold' has a wrong offset!");
static_assert(offsetof(AEndAIController, AerialForceMoveDirectionTurn) == 0x000AE0, "Member 'AEndAIController::AerialForceMoveDirectionTurn' has a wrong offset!");
static_assert(offsetof(AEndAIController, AerialInertia) == 0x000AE4, "Member 'AEndAIController::AerialInertia' has a wrong offset!");
static_assert(offsetof(AEndAIController, AerialBreak) == 0x000AE8, "Member 'AEndAIController::AerialBreak' has a wrong offset!");
static_assert(offsetof(AEndAIController, AerialInertiaAtCannotMove) == 0x000AEC, "Member 'AEndAIController::AerialInertiaAtCannotMove' has a wrong offset!");
static_assert(offsetof(AEndAIController, AerialGoalDistBreak) == 0x000AED, "Member 'AEndAIController::AerialGoalDistBreak' has a wrong offset!");
static_assert(offsetof(AEndAIController, AerialAccuratelyCheckPoint) == 0x000AF0, "Member 'AEndAIController::AerialAccuratelyCheckPoint' has a wrong offset!");
static_assert(offsetof(AEndAIController, AerialAccuratelyGoal) == 0x000AF4, "Member 'AEndAIController::AerialAccuratelyGoal' has a wrong offset!");
static_assert(offsetof(AEndAIController, AerialGoalAttractionDistance) == 0x000AF8, "Member 'AEndAIController::AerialGoalAttractionDistance' has a wrong offset!");
static_assert(offsetof(AEndAIController, AerialGoalAttraction) == 0x000AFC, "Member 'AEndAIController::AerialGoalAttraction' has a wrong offset!");
static_assert(offsetof(AEndAIController, AerialRunThreshold) == 0x000B00, "Member 'AEndAIController::AerialRunThreshold' has a wrong offset!");
static_assert(offsetof(AEndAIController, AerialOutPathCheckSoconds) == 0x000B04, "Member 'AEndAIController::AerialOutPathCheckSoconds' has a wrong offset!");
static_assert(offsetof(AEndAIController, AerialOutPathBreak) == 0x000B08, "Member 'AEndAIController::AerialOutPathBreak' has a wrong offset!");
static_assert(offsetof(AEndAIController, AerialRequestInterval) == 0x000B0C, "Member 'AEndAIController::AerialRequestInterval' has a wrong offset!");
static_assert(offsetof(AEndAIController, AerialRotateMagnification) == 0x000B10, "Member 'AEndAIController::AerialRotateMagnification' has a wrong offset!");
static_assert(offsetof(AEndAIController, FlyCollisionInterval) == 0x000B14, "Member 'AEndAIController::FlyCollisionInterval' has a wrong offset!");
static_assert(offsetof(AEndAIController, AerialAcceptMoveVelocity) == 0x000B18, "Member 'AEndAIController::AerialAcceptMoveVelocity' has a wrong offset!");
static_assert(offsetof(AEndAIController, ToWallJumpSkipEndTime) == 0x000B2C, "Member 'AEndAIController::ToWallJumpSkipEndTime' has a wrong offset!");
static_assert(offsetof(AEndAIController, EnableDebugDrawJumpLandingLocation) == 0x000D84, "Member 'AEndAIController::EnableDebugDrawJumpLandingLocation' has a wrong offset!");

// Class EndGame.EndNavModifierVolumeBase
// 0x0068 (0x0428 - 0x03C0)
class AEndNavModifierVolumeBase : public ANavModifierVolume
{
public:
	uint8                                         Pad_3C0[0x10];                                     // 0x03C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndTextRenderComponent*                TextRenderComponent;                               // 0x03D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<uint64>                                AffectedPolysCacheRef;                             // 0x03D8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FNavPriorRegistInfo                    NavPriorInfo;                                      // 0x03E8(0x0028)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_410[0x18];                                     // 0x0410(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavModifierVolumeBase">();
	}
	static class AEndNavModifierVolumeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndNavModifierVolumeBase>();
	}
};
static_assert(alignof(AEndNavModifierVolumeBase) == 0x000008, "Wrong alignment on AEndNavModifierVolumeBase");
static_assert(sizeof(AEndNavModifierVolumeBase) == 0x000428, "Wrong size on AEndNavModifierVolumeBase");
static_assert(offsetof(AEndNavModifierVolumeBase, TextRenderComponent) == 0x0003D0, "Member 'AEndNavModifierVolumeBase::TextRenderComponent' has a wrong offset!");
static_assert(offsetof(AEndNavModifierVolumeBase, AffectedPolysCacheRef) == 0x0003D8, "Member 'AEndNavModifierVolumeBase::AffectedPolysCacheRef' has a wrong offset!");
static_assert(offsetof(AEndNavModifierVolumeBase, NavPriorInfo) == 0x0003E8, "Member 'AEndNavModifierVolumeBase::NavPriorInfo' has a wrong offset!");

// Class EndGame.EndNavSwitchingVolume
// 0x0020 (0x0448 - 0x0428)
class AEndNavSwitchingVolume : public AEndNavModifierVolumeBase
{
public:
	ECollisionProfileType                         CollisionProfileType;                              // 0x0428(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_429[0x1F];                                     // 0x0429(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavSwitchingVolume">();
	}
	static class AEndNavSwitchingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndNavSwitchingVolume>();
	}
};
static_assert(alignof(AEndNavSwitchingVolume) == 0x000008, "Wrong alignment on AEndNavSwitchingVolume");
static_assert(sizeof(AEndNavSwitchingVolume) == 0x000448, "Wrong size on AEndNavSwitchingVolume");
static_assert(offsetof(AEndNavSwitchingVolume, CollisionProfileType) == 0x000428, "Member 'AEndNavSwitchingVolume::CollisionProfileType' has a wrong offset!");

// Class EndGame.EndBattleNotifyState
// 0x0010 (0x0040 - 0x0030)
class UEndBattleNotifyState final : public UAnimNotifyState
{
public:
	EBattleNotifyState                            State;                                             // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StringArgment;                                     // 0x0034(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleNotifyState">();
	}
	static class UEndBattleNotifyState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleNotifyState>();
	}
};
static_assert(alignof(UEndBattleNotifyState) == 0x000008, "Wrong alignment on UEndBattleNotifyState");
static_assert(sizeof(UEndBattleNotifyState) == 0x000040, "Wrong size on UEndBattleNotifyState");
static_assert(offsetof(UEndBattleNotifyState, State) == 0x000030, "Member 'UEndBattleNotifyState::State' has a wrong offset!");
static_assert(offsetof(UEndBattleNotifyState, StringArgment) == 0x000034, "Member 'UEndBattleNotifyState::StringArgment' has a wrong offset!");

// Class EndGame.EndStaminaIcon
// 0x0030 (0x0390 - 0x0360)
class UEndStaminaIcon final : public UEndUserWidget
{
public:
	struct FLinearColor                           Dash;                                              // 0x0360(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HiDash;                                            // 0x0370(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Stan;                                              // 0x0380(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndStaminaIcon">();
	}
	static class UEndStaminaIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndStaminaIcon>();
	}
};
static_assert(alignof(UEndStaminaIcon) == 0x000008, "Wrong alignment on UEndStaminaIcon");
static_assert(sizeof(UEndStaminaIcon) == 0x000390, "Wrong size on UEndStaminaIcon");
static_assert(offsetof(UEndStaminaIcon, Dash) == 0x000360, "Member 'UEndStaminaIcon::Dash' has a wrong offset!");
static_assert(offsetof(UEndStaminaIcon, HiDash) == 0x000370, "Member 'UEndStaminaIcon::HiDash' has a wrong offset!");
static_assert(offsetof(UEndStaminaIcon, Stan) == 0x000380, "Member 'UEndStaminaIcon::Stan' has a wrong offset!");

// Class EndGame.AnimNotify_EndForceDeactiveCutSceneFacial
// 0x0008 (0x0038 - 0x0030)
class UAnimNotify_EndForceDeactiveCutSceneFacial final : public UAnimNotifyState
{
public:
	float                                         BlendOutTime;                                      // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0034(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndForceDeactiveCutSceneFacial">();
	}
	static class UAnimNotify_EndForceDeactiveCutSceneFacial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndForceDeactiveCutSceneFacial>();
	}
};
static_assert(alignof(UAnimNotify_EndForceDeactiveCutSceneFacial) == 0x000008, "Wrong alignment on UAnimNotify_EndForceDeactiveCutSceneFacial");
static_assert(sizeof(UAnimNotify_EndForceDeactiveCutSceneFacial) == 0x000038, "Wrong size on UAnimNotify_EndForceDeactiveCutSceneFacial");
static_assert(offsetof(UAnimNotify_EndForceDeactiveCutSceneFacial, BlendOutTime) == 0x000030, "Member 'UAnimNotify_EndForceDeactiveCutSceneFacial::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndForceDeactiveCutSceneFacial, BlendInTime) == 0x000034, "Member 'UAnimNotify_EndForceDeactiveCutSceneFacial::BlendInTime' has a wrong offset!");

// Class EndGame.AnimNotify_EndForceEnableBoneLocalRotate
// 0x0000 (0x0030 - 0x0030)
class UAnimNotify_EndForceEnableBoneLocalRotate final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndForceEnableBoneLocalRotate">();
	}
	static class UAnimNotify_EndForceEnableBoneLocalRotate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndForceEnableBoneLocalRotate>();
	}
};
static_assert(alignof(UAnimNotify_EndForceEnableBoneLocalRotate) == 0x000008, "Wrong alignment on UAnimNotify_EndForceEnableBoneLocalRotate");
static_assert(sizeof(UAnimNotify_EndForceEnableBoneLocalRotate) == 0x000030, "Wrong size on UAnimNotify_EndForceEnableBoneLocalRotate");

// Class EndGame.EndAIIntentionContactSetting
// 0x00A8 (0x00D8 - 0x0030)
class UEndAIIntentionContactSetting final : public UDataAsset
{
public:
	struct FVector2D                              LookAtCoolDownTimeRange;                           // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtWeightIdle;                                  // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LookAtDurationRangeIdle;                           // 0x003C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LookAtActiveBlendTimeRangeIdle;                    // 0x0044(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LookAtDeactiveBlendTimeRangeIdle;                  // 0x004C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtWeightWalk;                                  // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LookAtDurationRangeWalk;                           // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LookAtActiveBlendTimeRangeWalk;                    // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LookAtDeactiveBlendTimeRangeWalk;                  // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtWeightRun;                                   // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LookAtDurationRangeRun;                            // 0x0074(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LookAtActiveBlendTimeRangeRun;                     // 0x007C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LookAtDeactiveBlendTimeRangeRun;                   // 0x0084(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AnimationCoolDownTimeRange;                        // 0x008C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationContactOverrideLocomotionTime;            // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationContactWalkTime;                          // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationContactWalkBlendTime;                     // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationContactRunBlendTime;                      // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationContactWalkUpperBodyBlendTime;            // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationContactRunUpperBodyBlendTime;             // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationContactWalkRotationRate;                  // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationContactRunRotationRate;                   // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationContactWalkNoInputSuspendTime;            // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationContactRunNoInputSuspendTime;             // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              HipMoveCoolDownTimeRange;                          // 0x00BC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HipMoveValue;                                      // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HipDownValue;                                      // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HipMoveTime;                                       // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HipMoveBlendInTime;                                // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HipMoveBlendOutTime;                               // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAIIntentionContactSetting">();
	}
	static class UEndAIIntentionContactSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAIIntentionContactSetting>();
	}
};
static_assert(alignof(UEndAIIntentionContactSetting) == 0x000008, "Wrong alignment on UEndAIIntentionContactSetting");
static_assert(sizeof(UEndAIIntentionContactSetting) == 0x0000D8, "Wrong size on UEndAIIntentionContactSetting");
static_assert(offsetof(UEndAIIntentionContactSetting, LookAtCoolDownTimeRange) == 0x000030, "Member 'UEndAIIntentionContactSetting::LookAtCoolDownTimeRange' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionContactSetting, LookAtWeightIdle) == 0x000038, "Member 'UEndAIIntentionContactSetting::LookAtWeightIdle' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionContactSetting, LookAtDurationRangeIdle) == 0x00003C, "Member 'UEndAIIntentionContactSetting::LookAtDurationRangeIdle' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionContactSetting, LookAtActiveBlendTimeRangeIdle) == 0x000044, "Member 'UEndAIIntentionContactSetting::LookAtActiveBlendTimeRangeIdle' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionContactSetting, LookAtDeactiveBlendTimeRangeIdle) == 0x00004C, "Member 'UEndAIIntentionContactSetting::LookAtDeactiveBlendTimeRangeIdle' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionContactSetting, LookAtWeightWalk) == 0x000054, "Member 'UEndAIIntentionContactSetting::LookAtWeightWalk' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionContactSetting, LookAtDurationRangeWalk) == 0x000058, "Member 'UEndAIIntentionContactSetting::LookAtDurationRangeWalk' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionContactSetting, LookAtActiveBlendTimeRangeWalk) == 0x000060, "Member 'UEndAIIntentionContactSetting::LookAtActiveBlendTimeRangeWalk' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionContactSetting, LookAtDeactiveBlendTimeRangeWalk) == 0x000068, "Member 'UEndAIIntentionContactSetting::LookAtDeactiveBlendTimeRangeWalk' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionContactSetting, LookAtWeightRun) == 0x000070, "Member 'UEndAIIntentionContactSetting::LookAtWeightRun' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionContactSetting, LookAtDurationRangeRun) == 0x000074, "Member 'UEndAIIntentionContactSetting::LookAtDurationRangeRun' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionContactSetting, LookAtActiveBlendTimeRangeRun) == 0x00007C, "Member 'UEndAIIntentionContactSetting::LookAtActiveBlendTimeRangeRun' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionContactSetting, LookAtDeactiveBlendTimeRangeRun) == 0x000084, "Member 'UEndAIIntentionContactSetting::LookAtDeactiveBlendTimeRangeRun' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionContactSetting, AnimationCoolDownTimeRange) == 0x00008C, "Member 'UEndAIIntentionContactSetting::AnimationCoolDownTimeRange' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionContactSetting, AnimationContactOverrideLocomotionTime) == 0x000094, "Member 'UEndAIIntentionContactSetting::AnimationContactOverrideLocomotionTime' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionContactSetting, AnimationContactWalkTime) == 0x000098, "Member 'UEndAIIntentionContactSetting::AnimationContactWalkTime' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionContactSetting, AnimationContactWalkBlendTime) == 0x00009C, "Member 'UEndAIIntentionContactSetting::AnimationContactWalkBlendTime' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionContactSetting, AnimationContactRunBlendTime) == 0x0000A0, "Member 'UEndAIIntentionContactSetting::AnimationContactRunBlendTime' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionContactSetting, AnimationContactWalkUpperBodyBlendTime) == 0x0000A4, "Member 'UEndAIIntentionContactSetting::AnimationContactWalkUpperBodyBlendTime' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionContactSetting, AnimationContactRunUpperBodyBlendTime) == 0x0000A8, "Member 'UEndAIIntentionContactSetting::AnimationContactRunUpperBodyBlendTime' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionContactSetting, AnimationContactWalkRotationRate) == 0x0000AC, "Member 'UEndAIIntentionContactSetting::AnimationContactWalkRotationRate' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionContactSetting, AnimationContactRunRotationRate) == 0x0000B0, "Member 'UEndAIIntentionContactSetting::AnimationContactRunRotationRate' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionContactSetting, AnimationContactWalkNoInputSuspendTime) == 0x0000B4, "Member 'UEndAIIntentionContactSetting::AnimationContactWalkNoInputSuspendTime' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionContactSetting, AnimationContactRunNoInputSuspendTime) == 0x0000B8, "Member 'UEndAIIntentionContactSetting::AnimationContactRunNoInputSuspendTime' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionContactSetting, HipMoveCoolDownTimeRange) == 0x0000BC, "Member 'UEndAIIntentionContactSetting::HipMoveCoolDownTimeRange' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionContactSetting, HipMoveValue) == 0x0000C4, "Member 'UEndAIIntentionContactSetting::HipMoveValue' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionContactSetting, HipDownValue) == 0x0000C8, "Member 'UEndAIIntentionContactSetting::HipDownValue' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionContactSetting, HipMoveTime) == 0x0000CC, "Member 'UEndAIIntentionContactSetting::HipMoveTime' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionContactSetting, HipMoveBlendInTime) == 0x0000D0, "Member 'UEndAIIntentionContactSetting::HipMoveBlendInTime' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionContactSetting, HipMoveBlendOutTime) == 0x0000D4, "Member 'UEndAIIntentionContactSetting::HipMoveBlendOutTime' has a wrong offset!");

// Class EndGame.EndDataObjectItemDrop
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectItemDrop final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectItemDrop">();
	}
	static class UEndDataObjectItemDrop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectItemDrop>();
	}
};
static_assert(alignof(UEndDataObjectItemDrop) == 0x000008, "Wrong alignment on UEndDataObjectItemDrop");
static_assert(sizeof(UEndDataObjectItemDrop) == 0x000088, "Wrong size on UEndDataObjectItemDrop");

// Class EndGame.AnimNotify_EndForceFeedback
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_EndForceFeedback final : public UAnimNotify
{
public:
	EEndForceFeedbackTrack                        Track;                                             // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndForceFeedbackEffect                       Effect;                                            // 0x0039(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWithPriorityControl;                              // 0x003A(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayForcibly;                                     // 0x003B(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndForceFeedback">();
	}
	static class UAnimNotify_EndForceFeedback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndForceFeedback>();
	}
};
static_assert(alignof(UAnimNotify_EndForceFeedback) == 0x000008, "Wrong alignment on UAnimNotify_EndForceFeedback");
static_assert(sizeof(UAnimNotify_EndForceFeedback) == 0x000040, "Wrong size on UAnimNotify_EndForceFeedback");
static_assert(offsetof(UAnimNotify_EndForceFeedback, Track) == 0x000038, "Member 'UAnimNotify_EndForceFeedback::Track' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndForceFeedback, Effect) == 0x000039, "Member 'UAnimNotify_EndForceFeedback::Effect' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndForceFeedback, bWithPriorityControl) == 0x00003A, "Member 'UAnimNotify_EndForceFeedback::bWithPriorityControl' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndForceFeedback, bPlayForcibly) == 0x00003B, "Member 'UAnimNotify_EndForceFeedback::bPlayForcibly' has a wrong offset!");

// Class EndGame.AnimNotify_EndForceFeedbackRange
// 0x0008 (0x0038 - 0x0030)
class UAnimNotify_EndForceFeedbackRange final : public UAnimNotifyState
{
public:
	EEndForceFeedbackTrack                        Track;                                             // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndForceFeedbackEffect                       Effect;                                            // 0x0031(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWithPriorityControl;                              // 0x0032(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayForcibly;                                     // 0x0033(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bContinue;                                         // 0x0034(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndForceFeedbackRange">();
	}
	static class UAnimNotify_EndForceFeedbackRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndForceFeedbackRange>();
	}
};
static_assert(alignof(UAnimNotify_EndForceFeedbackRange) == 0x000008, "Wrong alignment on UAnimNotify_EndForceFeedbackRange");
static_assert(sizeof(UAnimNotify_EndForceFeedbackRange) == 0x000038, "Wrong size on UAnimNotify_EndForceFeedbackRange");
static_assert(offsetof(UAnimNotify_EndForceFeedbackRange, Track) == 0x000030, "Member 'UAnimNotify_EndForceFeedbackRange::Track' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndForceFeedbackRange, Effect) == 0x000031, "Member 'UAnimNotify_EndForceFeedbackRange::Effect' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndForceFeedbackRange, bWithPriorityControl) == 0x000032, "Member 'UAnimNotify_EndForceFeedbackRange::bWithPriorityControl' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndForceFeedbackRange, bPlayForcibly) == 0x000033, "Member 'UAnimNotify_EndForceFeedbackRange::bPlayForcibly' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndForceFeedbackRange, bContinue) == 0x000034, "Member 'UAnimNotify_EndForceFeedbackRange::bContinue' has a wrong offset!");

// Class EndGame.EndDebugTagCommentComponent
// 0x0110 (0x0800 - 0x06F0)
class UEndDebugTagCommentComponent final : public UPrimitiveComponent
{
public:
	uint8                                         Pad_6F0[0x110];                                    // 0x06F0(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDebugTagCommentComponent">();
	}
	static class UEndDebugTagCommentComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDebugTagCommentComponent>();
	}
};
static_assert(alignof(UEndDebugTagCommentComponent) == 0x000010, "Wrong alignment on UEndDebugTagCommentComponent");
static_assert(sizeof(UEndDebugTagCommentComponent) == 0x000800, "Wrong size on UEndDebugTagCommentComponent");

// Class EndGame.EndImGuiPhysics
// 0x0000 (0x0028 - 0x0028)
class UEndImGuiPhysics final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndImGuiPhysics">();
	}
	static class UEndImGuiPhysics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndImGuiPhysics>();
	}
};
static_assert(alignof(UEndImGuiPhysics) == 0x000008, "Wrong alignment on UEndImGuiPhysics");
static_assert(sizeof(UEndImGuiPhysics) == 0x000028, "Wrong size on UEndImGuiPhysics");

// Class EndGame.EndBorder
// 0x0138 (0x0248 - 0x0110)
class UEndBorder final : public UContentWidget
{
public:
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0111(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bShowEffectWhenDisabled : 1;                       // 0x0112(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_113[0x1];                                      // 0x0113(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ContentColorAndOpacity;                            // 0x0114(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             ContentColorAndOpacityDelegate;                    // 0x0128(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FMargin                                Padding;                                           // 0x0138(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FSlateBrush                            Background;                                        // 0x0148(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TDelegate<void()>                             BackgroundDelegate;                                // 0x01C0(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           BrushColor;                                        // 0x01D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             BrushColorDelegate;                                // 0x01E0(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              DesiredSizeScale;                                  // 0x01F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FGeometry& MyGeometry, struct FPointerEvent& MouseEvent)> OnMouseButtonDownEvent;                            // 0x01F8(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FGeometry& MyGeometry, struct FPointerEvent& MouseEvent)> OnMouseButtonUpEvent;                              // 0x0208(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FGeometry& MyGeometry, struct FPointerEvent& MouseEvent)> OnMouseMoveEvent;                                  // 0x0218(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FGeometry& MyGeometry, struct FPointerEvent& MouseEvent)> OnMouseDoubleClickEvent;                           // 0x0228(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_238[0x10];                                     // 0x0238(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMaterialInstanceDynamic* GetDynamicMaterial();
	void SetBrush(const struct FSlateBrush& InBrush);
	void SetBrushColor(const struct FLinearColor& InBrushColor);
	void SetBrushFromAsset(class USlateBrushAsset* Asset);
	void SetBrushFromMaterial(class UMaterialInterface* Material);
	void SetBrushFromTexture(class UTexture2D* Texture);
	void SetContentColorAndOpacity(const struct FLinearColor& InContentColorAndOpacity);
	void SetDesiredSizeScale(const struct FVector2D& InScale);
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment);
	void SetPadding(const struct FMargin& InPadding);
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBorder">();
	}
	static class UEndBorder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBorder>();
	}
};
static_assert(alignof(UEndBorder) == 0x000008, "Wrong alignment on UEndBorder");
static_assert(sizeof(UEndBorder) == 0x000248, "Wrong size on UEndBorder");
static_assert(offsetof(UEndBorder, HorizontalAlignment) == 0x000110, "Member 'UEndBorder::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UEndBorder, VerticalAlignment) == 0x000111, "Member 'UEndBorder::VerticalAlignment' has a wrong offset!");
static_assert(offsetof(UEndBorder, ContentColorAndOpacity) == 0x000114, "Member 'UEndBorder::ContentColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UEndBorder, ContentColorAndOpacityDelegate) == 0x000128, "Member 'UEndBorder::ContentColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UEndBorder, Padding) == 0x000138, "Member 'UEndBorder::Padding' has a wrong offset!");
static_assert(offsetof(UEndBorder, Background) == 0x000148, "Member 'UEndBorder::Background' has a wrong offset!");
static_assert(offsetof(UEndBorder, BackgroundDelegate) == 0x0001C0, "Member 'UEndBorder::BackgroundDelegate' has a wrong offset!");
static_assert(offsetof(UEndBorder, BrushColor) == 0x0001D0, "Member 'UEndBorder::BrushColor' has a wrong offset!");
static_assert(offsetof(UEndBorder, BrushColorDelegate) == 0x0001E0, "Member 'UEndBorder::BrushColorDelegate' has a wrong offset!");
static_assert(offsetof(UEndBorder, DesiredSizeScale) == 0x0001F0, "Member 'UEndBorder::DesiredSizeScale' has a wrong offset!");
static_assert(offsetof(UEndBorder, OnMouseButtonDownEvent) == 0x0001F8, "Member 'UEndBorder::OnMouseButtonDownEvent' has a wrong offset!");
static_assert(offsetof(UEndBorder, OnMouseButtonUpEvent) == 0x000208, "Member 'UEndBorder::OnMouseButtonUpEvent' has a wrong offset!");
static_assert(offsetof(UEndBorder, OnMouseMoveEvent) == 0x000218, "Member 'UEndBorder::OnMouseMoveEvent' has a wrong offset!");
static_assert(offsetof(UEndBorder, OnMouseDoubleClickEvent) == 0x000228, "Member 'UEndBorder::OnMouseDoubleClickEvent' has a wrong offset!");

// Class EndGame.AnimNotify_EndHandIK
// 0x0040 (0x0070 - 0x0030)
class UAnimNotify_EndHandIK final : public UAnimNotifyState
{
public:
	EEndHandType                                  HandType;                                          // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndHandConstraint                            Constraint;                                        // 0x0031(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConstraintRate;                                    // 0x0034(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ConstraintStringParam0;                            // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ConstraintStringParam1;                            // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ConstraintStringParam2;                            // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ConstraintStringParam3;                            // 0x0050(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ConstraintVectorParam0;                            // 0x0058(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ConstraintRotationParam0;                          // 0x0064(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndHandIK">();
	}
	static class UAnimNotify_EndHandIK* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndHandIK>();
	}
};
static_assert(alignof(UAnimNotify_EndHandIK) == 0x000008, "Wrong alignment on UAnimNotify_EndHandIK");
static_assert(sizeof(UAnimNotify_EndHandIK) == 0x000070, "Wrong size on UAnimNotify_EndHandIK");
static_assert(offsetof(UAnimNotify_EndHandIK, HandType) == 0x000030, "Member 'UAnimNotify_EndHandIK::HandType' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndHandIK, Constraint) == 0x000031, "Member 'UAnimNotify_EndHandIK::Constraint' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndHandIK, ConstraintRate) == 0x000034, "Member 'UAnimNotify_EndHandIK::ConstraintRate' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndHandIK, ConstraintStringParam0) == 0x000038, "Member 'UAnimNotify_EndHandIK::ConstraintStringParam0' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndHandIK, ConstraintStringParam1) == 0x000040, "Member 'UAnimNotify_EndHandIK::ConstraintStringParam1' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndHandIK, ConstraintStringParam2) == 0x000048, "Member 'UAnimNotify_EndHandIK::ConstraintStringParam2' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndHandIK, ConstraintStringParam3) == 0x000050, "Member 'UAnimNotify_EndHandIK::ConstraintStringParam3' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndHandIK, ConstraintVectorParam0) == 0x000058, "Member 'UAnimNotify_EndHandIK::ConstraintVectorParam0' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndHandIK, ConstraintRotationParam0) == 0x000064, "Member 'UAnimNotify_EndHandIK::ConstraintRotationParam0' has a wrong offset!");

// Class EndGame.AnimNotify_EndModifyFootIK
// 0x0010 (0x0040 - 0x0030)
class UAnimNotify_EndModifyFootIK final : public UAnimNotifyState
{
public:
	EEndFootIKModifierType                        ModifierType;                                      // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendInTime;                                       // 0x0034(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndModifyFootIK">();
	}
	static class UAnimNotify_EndModifyFootIK* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndModifyFootIK>();
	}
};
static_assert(alignof(UAnimNotify_EndModifyFootIK) == 0x000008, "Wrong alignment on UAnimNotify_EndModifyFootIK");
static_assert(sizeof(UAnimNotify_EndModifyFootIK) == 0x000040, "Wrong size on UAnimNotify_EndModifyFootIK");
static_assert(offsetof(UAnimNotify_EndModifyFootIK, ModifierType) == 0x000030, "Member 'UAnimNotify_EndModifyFootIK::ModifierType' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndModifyFootIK, BlendInTime) == 0x000034, "Member 'UAnimNotify_EndModifyFootIK::BlendInTime' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndModifyFootIK, BlendOutTime) == 0x000038, "Member 'UAnimNotify_EndModifyFootIK::BlendOutTime' has a wrong offset!");

// Class EndGame.EndCharacter
// 0x1AC0 (0x22C0 - 0x0800)
#pragma pack(push, 0x1)
class alignas(0x10) AEndCharacter : public ACharacter
{
public:
	uint8                                         Pad_800[0x20];                                     // 0x0800(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEndAIModel                            AIModel;                                           // 0x0820(0x0318)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_B38[0xC4];                                     // 0x0B38(0x00C4)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ExtendWeaponSocketName;                            // 0x0BFC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C04[0x4];                                      // 0x0C04(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UActorComponent*>     ComponentTable;                                    // 0x0C08(0x0050)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bResidentEffectIgnoreWorldPause;                   // 0x0C58(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C59[0x7];                                      // 0x0C59(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEndCharacterResidentEffect>    ResidentEffects;                                   // 0x0C60(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FEndCharacterResidentEffect>    ResidentFlyEffects;                                // 0x0C70(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TSubclassOf<class AEndAIController>           FieldAIControllerClass;                            // 0x0C80(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AEndFieldAIController*                  FieldAIController;                                 // 0x0C88(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C90[0x8];                                      // 0x0C90(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AEndBattleAIController*>         BattleAIControllers;                               // 0x0C98(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class AEndBattleAIController*                 BattleAIController;                                // 0x0CA8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CB0[0x18];                                     // 0x0CB0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AEndBikeAIController>> BikeAIControllerClasses;                           // 0x0CC8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class AEndBikeAIController*                   BikeAIController;                                  // 0x0CD8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CE0[0x8];                                      // 0x0CE0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AEndPlayerController*                   PlayerAiController;                                // 0x0CE8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            ActiveAiController;                                // 0x0CF0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CF8[0x8];                                      // 0x0CF8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StackActorLocation;                                // 0x0D00(0x000C)(Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               StackActorRotation;                                // 0x0D0C(0x000C)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         ActorLocationStackPoint;                           // 0x0D18(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ActorRotationStackPoint;                           // 0x0D1C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RelativeLocationCache_ForCut;                      // 0x0D20(0x000C)(Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D2C[0x128];                                    // 0x0D2C(0x0128)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WorkDeltaTime;                                     // 0x0E54(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E58[0x118];                                    // 0x0E58(0x0118)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInterestPointRequestContext>   InterestPointRequestContexts;                      // 0x0F70(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F80[0x38];                                     // 0x0F80(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRecreatePhysicsOnEnableRagdoll;                   // 0x0FB8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FB9[0xEF];                                     // 0x0FB9(0x00EF)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndFootAttributeComponent*             FootAttributeComponent;                            // 0x10A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10B0[0x7B8];                                   // 0x10B0(0x07B8)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndCapsuleOverlapComponent*            EndCapsuleOverlapComponent;                        // 0x1868(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1870[0x220];                                   // 0x1870(0x0220)(Fixing Size After Last Property [ Dumper-7 ])
	class USQEX_KBD_Component*                    KBD;                                               // 0x1A90(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USQEX_KineDriver_Component*             KineDriver;                                        // 0x1A98(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USQEX_Bonamik_Component*                Bonamik;                                           // 0x1AA0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndEnvQueryComponent*                  EnvironmentQueryComponent;                         // 0x1AA8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndBattleTalkCharacterComponent*       BattleTalkCharacterComponent;                      // 0x1AB0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndAerialRouteSearchInstance*          AerialRouteSearchInstance;                         // 0x1AB8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Biped;                                             // 0x1AC0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AC1[0x7];                                     // 0x1AC1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndRig*                                Rig;                                               // 0x1AC8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFacialRig*                          FacialRig;                                         // 0x1AD0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndAIModelPersonalityData*             AIPersonalityData;                                 // 0x1AD8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndAIModelTemplateData*                AITemplateData;                                    // 0x1AE0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEndInterSetting                       InterSetting;                                      // 0x1AE8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, class UHSFLipSyncDataPack*> LipSyncDataPacks;                                  // 0x1B20(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   OverrideAnimSetName;                               // 0x1B70(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ExistOverrideAnimSet;                              // 0x1B78(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B79[0x3];                                     // 0x1B79(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OverrideLevelAnimSetLevelName[0x20];               // 0x1B7C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OverrideLevelAnimSetAnimName[0x20];                // 0x1C7C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtSpeedBias;                                   // 0x1D7C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtAngleBias;                                   // 0x1D80(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtClampHorizontalDistanceBias;                 // 0x1D84(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OverrideAimBaseBoneName;                           // 0x1D88(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EEndLookAtLayer>                       IgnoreLookAtLayers;                                // 0x1D90(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bOverrideAdjustOrientationSetting;                 // 0x1DA0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DA1[0x7];                                     // 0x1DA1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEndAdjustOrientationSetting           AdjustOrientationSetting;                          // 0x1DA8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         AdjustOrientationTransRate;                        // 0x1E38(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAdjustSkeletalMeshLocation : 1;                   // 0x1E3C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1E3D[0x3];                                     // 0x1E3D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bForceUpdateAnimation;                             // 0x1E40(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceUpdateKinematicBonesUpdateToPhysics;         // 0x1E41(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E42[0x6];                                     // 0x1E42(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndEmissiveColorComponent*             EmissiveColorComponent;                            // 0x1E48(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanFieldAttack;                                   // 0x1E50(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E51[0x157];                                   // 0x1E51(0x0157)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FieldExtraRadius;                                  // 0x1FA8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BattleExtraRadius;                                 // 0x1FAC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FEndCharacterPushCollisionData> DisabledSubCollisionDataList;                      // 0x1FB0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC0[0x61];                                    // 0x1FC0(0x0061)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IgnoreRagdollPhysics;                              // 0x2021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2022[0x296];                                   // 0x2022(0x0296)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableKineDriver();
	void DisableRagdollPhysics(float FadeOutTime, bool bCenterActorToHip, bool bResetRelativeTransform);
	void EnableKineDriver();
	void EnableRagdollPhysics(bool bDisableMovement, bool bForceDisableBodyDriver);
	class UEndEnvQueryComponent* GetEQSComponent();
	struct FVector GetFeetLocation();
	struct FVector GetPointDirectionFromOwnPosture(const struct FVector& InLocation);
	struct FRotator GetPointRotationFromOwnPosture(const struct FVector& InLocation);
	void OnBeginCutSceneToBP(const class FName& CutsceneID, float animBlendTime, float ikBlendTime);
	void OnBodyDriverRagdollImpact();
	void OnBodyDriverRagdollReadyForRemoval();
	void OnEndCutSceneToBP(const class FName& CutsceneID, float animBlendTime, float ikBlendTime);
	void OnShowBreakMesh(const class FName& meshName);
	void OverrideDefaultEmissiveColor();
	void PlayEmissiveColorAnimation(class FName RequestID, class FName ColorPaletteId, EEndEmissiveModifierType ModifierType, EEndEmissiveCurveType CurveType, bool bLoop, float Duration, float BlendInTime, float BlendOutTime, float StartOffset, float EndOffset);
	void RequestActivateRagdoll();
	void RequestDeactivateRagdoll();
	void RequestRagdollCollisionOff();
	void RequestRagdollPostActivation();
	void ResetDirectEmissiveColor();
	void ResetEndCutSceneCorrectionHeight();
	void ResetRagdollPhysics();
	void SetChildMesh(class FName meshName, class FName Label);
	void SetDirectEmissiveColor(class FName ColorPaletteId, float IntensityBias);
	void SetIgnoreRagdollPhysics(bool Value);
	void StopEmissiveColorAnimation(class FName RequestID);
	void UseHookShotSimple(const struct FVector& landingLocation, const struct FRotator& LandingRotation);

	bool IsPlayer() const;
	bool IsRagdollPhysicsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCharacter">();
	}
	static class AEndCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndCharacter>();
	}
};
#pragma pack(pop)
static_assert(alignof(AEndCharacter) == 0x000010, "Wrong alignment on AEndCharacter");
static_assert(sizeof(AEndCharacter) == 0x0022C0, "Wrong size on AEndCharacter");
static_assert(offsetof(AEndCharacter, AIModel) == 0x000820, "Member 'AEndCharacter::AIModel' has a wrong offset!");
static_assert(offsetof(AEndCharacter, ExtendWeaponSocketName) == 0x000BFC, "Member 'AEndCharacter::ExtendWeaponSocketName' has a wrong offset!");
static_assert(offsetof(AEndCharacter, ComponentTable) == 0x000C08, "Member 'AEndCharacter::ComponentTable' has a wrong offset!");
static_assert(offsetof(AEndCharacter, bResidentEffectIgnoreWorldPause) == 0x000C58, "Member 'AEndCharacter::bResidentEffectIgnoreWorldPause' has a wrong offset!");
static_assert(offsetof(AEndCharacter, ResidentEffects) == 0x000C60, "Member 'AEndCharacter::ResidentEffects' has a wrong offset!");
static_assert(offsetof(AEndCharacter, ResidentFlyEffects) == 0x000C70, "Member 'AEndCharacter::ResidentFlyEffects' has a wrong offset!");
static_assert(offsetof(AEndCharacter, FieldAIControllerClass) == 0x000C80, "Member 'AEndCharacter::FieldAIControllerClass' has a wrong offset!");
static_assert(offsetof(AEndCharacter, FieldAIController) == 0x000C88, "Member 'AEndCharacter::FieldAIController' has a wrong offset!");
static_assert(offsetof(AEndCharacter, BattleAIControllers) == 0x000C98, "Member 'AEndCharacter::BattleAIControllers' has a wrong offset!");
static_assert(offsetof(AEndCharacter, BattleAIController) == 0x000CA8, "Member 'AEndCharacter::BattleAIController' has a wrong offset!");
static_assert(offsetof(AEndCharacter, BikeAIControllerClasses) == 0x000CC8, "Member 'AEndCharacter::BikeAIControllerClasses' has a wrong offset!");
static_assert(offsetof(AEndCharacter, BikeAIController) == 0x000CD8, "Member 'AEndCharacter::BikeAIController' has a wrong offset!");
static_assert(offsetof(AEndCharacter, PlayerAiController) == 0x000CE8, "Member 'AEndCharacter::PlayerAiController' has a wrong offset!");
static_assert(offsetof(AEndCharacter, ActiveAiController) == 0x000CF0, "Member 'AEndCharacter::ActiveAiController' has a wrong offset!");
static_assert(offsetof(AEndCharacter, StackActorLocation) == 0x000D00, "Member 'AEndCharacter::StackActorLocation' has a wrong offset!");
static_assert(offsetof(AEndCharacter, StackActorRotation) == 0x000D0C, "Member 'AEndCharacter::StackActorRotation' has a wrong offset!");
static_assert(offsetof(AEndCharacter, ActorLocationStackPoint) == 0x000D18, "Member 'AEndCharacter::ActorLocationStackPoint' has a wrong offset!");
static_assert(offsetof(AEndCharacter, ActorRotationStackPoint) == 0x000D1C, "Member 'AEndCharacter::ActorRotationStackPoint' has a wrong offset!");
static_assert(offsetof(AEndCharacter, RelativeLocationCache_ForCut) == 0x000D20, "Member 'AEndCharacter::RelativeLocationCache_ForCut' has a wrong offset!");
static_assert(offsetof(AEndCharacter, WorkDeltaTime) == 0x000E54, "Member 'AEndCharacter::WorkDeltaTime' has a wrong offset!");
static_assert(offsetof(AEndCharacter, InterestPointRequestContexts) == 0x000F70, "Member 'AEndCharacter::InterestPointRequestContexts' has a wrong offset!");
static_assert(offsetof(AEndCharacter, bRecreatePhysicsOnEnableRagdoll) == 0x000FB8, "Member 'AEndCharacter::bRecreatePhysicsOnEnableRagdoll' has a wrong offset!");
static_assert(offsetof(AEndCharacter, FootAttributeComponent) == 0x0010A8, "Member 'AEndCharacter::FootAttributeComponent' has a wrong offset!");
static_assert(offsetof(AEndCharacter, EndCapsuleOverlapComponent) == 0x001868, "Member 'AEndCharacter::EndCapsuleOverlapComponent' has a wrong offset!");
static_assert(offsetof(AEndCharacter, KBD) == 0x001A90, "Member 'AEndCharacter::KBD' has a wrong offset!");
static_assert(offsetof(AEndCharacter, KineDriver) == 0x001A98, "Member 'AEndCharacter::KineDriver' has a wrong offset!");
static_assert(offsetof(AEndCharacter, Bonamik) == 0x001AA0, "Member 'AEndCharacter::Bonamik' has a wrong offset!");
static_assert(offsetof(AEndCharacter, EnvironmentQueryComponent) == 0x001AA8, "Member 'AEndCharacter::EnvironmentQueryComponent' has a wrong offset!");
static_assert(offsetof(AEndCharacter, BattleTalkCharacterComponent) == 0x001AB0, "Member 'AEndCharacter::BattleTalkCharacterComponent' has a wrong offset!");
static_assert(offsetof(AEndCharacter, AerialRouteSearchInstance) == 0x001AB8, "Member 'AEndCharacter::AerialRouteSearchInstance' has a wrong offset!");
static_assert(offsetof(AEndCharacter, Biped) == 0x001AC0, "Member 'AEndCharacter::Biped' has a wrong offset!");
static_assert(offsetof(AEndCharacter, Rig) == 0x001AC8, "Member 'AEndCharacter::Rig' has a wrong offset!");
static_assert(offsetof(AEndCharacter, FacialRig) == 0x001AD0, "Member 'AEndCharacter::FacialRig' has a wrong offset!");
static_assert(offsetof(AEndCharacter, AIPersonalityData) == 0x001AD8, "Member 'AEndCharacter::AIPersonalityData' has a wrong offset!");
static_assert(offsetof(AEndCharacter, AITemplateData) == 0x001AE0, "Member 'AEndCharacter::AITemplateData' has a wrong offset!");
static_assert(offsetof(AEndCharacter, InterSetting) == 0x001AE8, "Member 'AEndCharacter::InterSetting' has a wrong offset!");
static_assert(offsetof(AEndCharacter, LipSyncDataPacks) == 0x001B20, "Member 'AEndCharacter::LipSyncDataPacks' has a wrong offset!");
static_assert(offsetof(AEndCharacter, OverrideAnimSetName) == 0x001B70, "Member 'AEndCharacter::OverrideAnimSetName' has a wrong offset!");
static_assert(offsetof(AEndCharacter, ExistOverrideAnimSet) == 0x001B78, "Member 'AEndCharacter::ExistOverrideAnimSet' has a wrong offset!");
static_assert(offsetof(AEndCharacter, OverrideLevelAnimSetLevelName) == 0x001B7C, "Member 'AEndCharacter::OverrideLevelAnimSetLevelName' has a wrong offset!");
static_assert(offsetof(AEndCharacter, OverrideLevelAnimSetAnimName) == 0x001C7C, "Member 'AEndCharacter::OverrideLevelAnimSetAnimName' has a wrong offset!");
static_assert(offsetof(AEndCharacter, LookAtSpeedBias) == 0x001D7C, "Member 'AEndCharacter::LookAtSpeedBias' has a wrong offset!");
static_assert(offsetof(AEndCharacter, LookAtAngleBias) == 0x001D80, "Member 'AEndCharacter::LookAtAngleBias' has a wrong offset!");
static_assert(offsetof(AEndCharacter, LookAtClampHorizontalDistanceBias) == 0x001D84, "Member 'AEndCharacter::LookAtClampHorizontalDistanceBias' has a wrong offset!");
static_assert(offsetof(AEndCharacter, OverrideAimBaseBoneName) == 0x001D88, "Member 'AEndCharacter::OverrideAimBaseBoneName' has a wrong offset!");
static_assert(offsetof(AEndCharacter, IgnoreLookAtLayers) == 0x001D90, "Member 'AEndCharacter::IgnoreLookAtLayers' has a wrong offset!");
static_assert(offsetof(AEndCharacter, bOverrideAdjustOrientationSetting) == 0x001DA0, "Member 'AEndCharacter::bOverrideAdjustOrientationSetting' has a wrong offset!");
static_assert(offsetof(AEndCharacter, AdjustOrientationSetting) == 0x001DA8, "Member 'AEndCharacter::AdjustOrientationSetting' has a wrong offset!");
static_assert(offsetof(AEndCharacter, AdjustOrientationTransRate) == 0x001E38, "Member 'AEndCharacter::AdjustOrientationTransRate' has a wrong offset!");
static_assert(offsetof(AEndCharacter, bForceUpdateAnimation) == 0x001E40, "Member 'AEndCharacter::bForceUpdateAnimation' has a wrong offset!");
static_assert(offsetof(AEndCharacter, bForceUpdateKinematicBonesUpdateToPhysics) == 0x001E41, "Member 'AEndCharacter::bForceUpdateKinematicBonesUpdateToPhysics' has a wrong offset!");
static_assert(offsetof(AEndCharacter, EmissiveColorComponent) == 0x001E48, "Member 'AEndCharacter::EmissiveColorComponent' has a wrong offset!");
static_assert(offsetof(AEndCharacter, bCanFieldAttack) == 0x001E50, "Member 'AEndCharacter::bCanFieldAttack' has a wrong offset!");
static_assert(offsetof(AEndCharacter, FieldExtraRadius) == 0x001FA8, "Member 'AEndCharacter::FieldExtraRadius' has a wrong offset!");
static_assert(offsetof(AEndCharacter, BattleExtraRadius) == 0x001FAC, "Member 'AEndCharacter::BattleExtraRadius' has a wrong offset!");
static_assert(offsetof(AEndCharacter, DisabledSubCollisionDataList) == 0x001FB0, "Member 'AEndCharacter::DisabledSubCollisionDataList' has a wrong offset!");
static_assert(offsetof(AEndCharacter, IgnoreRagdollPhysics) == 0x002021, "Member 'AEndCharacter::IgnoreRagdollPhysics' has a wrong offset!");

// Class EndGame.EndFA0150ContainerCharacter
// 0x0100 (0x23C0 - 0x22C0)
class AEndFA0150ContainerCharacter final : public AEndCharacter
{
public:
	struct FSQEXSEADSoundKey                      PutOnFloor;                                        // 0x22B8(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSQEXSEADSoundKey                      PutOnContainer;                                    // 0x22F0(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   AttachBoneName;                                    // 0x2328(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSQEXSEADSoundKey                      EnvironmentHit;                                    // 0x2330(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSQEXSEADSoundKey                      ContainerHit;                                      // 0x2368(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class USQEXSEADSound*                         PutOnFloorSoundAsset;                              // 0x23A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USQEXSEADSound*                         PutOnContainerSoundAsset;                          // 0x23A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USQEXSEADSound*                         EnvironmentHitSoundAsset;                          // 0x23B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USQEXSEADSound*                         ContainerHitSoundAsset;                            // 0x23B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFA0150ContainerCharacter">();
	}
	static class AEndFA0150ContainerCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFA0150ContainerCharacter>();
	}
};
static_assert(alignof(AEndFA0150ContainerCharacter) == 0x000010, "Wrong alignment on AEndFA0150ContainerCharacter");
static_assert(sizeof(AEndFA0150ContainerCharacter) == 0x0023C0, "Wrong size on AEndFA0150ContainerCharacter");
static_assert(offsetof(AEndFA0150ContainerCharacter, PutOnFloor) == 0x0022B8, "Member 'AEndFA0150ContainerCharacter::PutOnFloor' has a wrong offset!");
static_assert(offsetof(AEndFA0150ContainerCharacter, PutOnContainer) == 0x0022F0, "Member 'AEndFA0150ContainerCharacter::PutOnContainer' has a wrong offset!");
static_assert(offsetof(AEndFA0150ContainerCharacter, AttachBoneName) == 0x002328, "Member 'AEndFA0150ContainerCharacter::AttachBoneName' has a wrong offset!");
static_assert(offsetof(AEndFA0150ContainerCharacter, EnvironmentHit) == 0x002330, "Member 'AEndFA0150ContainerCharacter::EnvironmentHit' has a wrong offset!");
static_assert(offsetof(AEndFA0150ContainerCharacter, ContainerHit) == 0x002368, "Member 'AEndFA0150ContainerCharacter::ContainerHit' has a wrong offset!");
static_assert(offsetof(AEndFA0150ContainerCharacter, PutOnFloorSoundAsset) == 0x0023A0, "Member 'AEndFA0150ContainerCharacter::PutOnFloorSoundAsset' has a wrong offset!");
static_assert(offsetof(AEndFA0150ContainerCharacter, PutOnContainerSoundAsset) == 0x0023A8, "Member 'AEndFA0150ContainerCharacter::PutOnContainerSoundAsset' has a wrong offset!");
static_assert(offsetof(AEndFA0150ContainerCharacter, EnvironmentHitSoundAsset) == 0x0023B0, "Member 'AEndFA0150ContainerCharacter::EnvironmentHitSoundAsset' has a wrong offset!");
static_assert(offsetof(AEndFA0150ContainerCharacter, ContainerHitSoundAsset) == 0x0023B8, "Member 'AEndFA0150ContainerCharacter::ContainerHitSoundAsset' has a wrong offset!");

// Class EndGame.EndBattleNavQueryContext
// 0x0000 (0x0030 - 0x0030)
class UEndBattleNavQueryContext : public UEnvQueryContext_BlueprintBase
{
public:
	struct FVector GetTargetLocationContext(class AActor* Actor) const;
	void ProvideSingleLocation(class UObject* QuerierObject, class AActor* QuerierActor, struct FVector* ResultingLocation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleNavQueryContext">();
	}
	static class UEndBattleNavQueryContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleNavQueryContext>();
	}
};
static_assert(alignof(UEndBattleNavQueryContext) == 0x000008, "Wrong alignment on UEndBattleNavQueryContext");
static_assert(sizeof(UEndBattleNavQueryContext) == 0x000030, "Wrong size on UEndBattleNavQueryContext");

// Class EndGame.EndSystemSettings
// 0x0018 (0x0040 - 0x0028)
class UEndSystemSettings final : public UObject
{
public:
	class FName                                   Language;                                          // 0x0028(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VoiceLanguage;                                     // 0x0030(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableReplaceBySaveData;                         // 0x0038(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeyboardControlEnabled;                           // 0x0039(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMouseControlEnabled;                              // 0x003A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMouseAndKeyboardControlShortcutsEnabled;          // 0x003B(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndSystemSettings">();
	}
	static class UEndSystemSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndSystemSettings>();
	}
};
static_assert(alignof(UEndSystemSettings) == 0x000008, "Wrong alignment on UEndSystemSettings");
static_assert(sizeof(UEndSystemSettings) == 0x000040, "Wrong size on UEndSystemSettings");
static_assert(offsetof(UEndSystemSettings, Language) == 0x000028, "Member 'UEndSystemSettings::Language' has a wrong offset!");
static_assert(offsetof(UEndSystemSettings, VoiceLanguage) == 0x000030, "Member 'UEndSystemSettings::VoiceLanguage' has a wrong offset!");
static_assert(offsetof(UEndSystemSettings, bDisableReplaceBySaveData) == 0x000038, "Member 'UEndSystemSettings::bDisableReplaceBySaveData' has a wrong offset!");
static_assert(offsetof(UEndSystemSettings, bKeyboardControlEnabled) == 0x000039, "Member 'UEndSystemSettings::bKeyboardControlEnabled' has a wrong offset!");
static_assert(offsetof(UEndSystemSettings, bMouseControlEnabled) == 0x00003A, "Member 'UEndSystemSettings::bMouseControlEnabled' has a wrong offset!");
static_assert(offsetof(UEndSystemSettings, bMouseAndKeyboardControlShortcutsEnabled) == 0x00003B, "Member 'UEndSystemSettings::bMouseAndKeyboardControlShortcutsEnabled' has a wrong offset!");

// Class EndGame.AnimNotify_EndModifyLookAt
// 0x0010 (0x0040 - 0x0030)
class UAnimNotify_EndModifyLookAt final : public UAnimNotifyState
{
public:
	EEndLookAtModifierType                        ModifierType;                                      // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceEnableLookAtMeshSpace;                       // 0x0031(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeightBias;                                        // 0x0034(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeightBiasBlendInTime;                             // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeightBiasBlendOutTime;                            // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndModifyLookAt">();
	}
	static class UAnimNotify_EndModifyLookAt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndModifyLookAt>();
	}
};
static_assert(alignof(UAnimNotify_EndModifyLookAt) == 0x000008, "Wrong alignment on UAnimNotify_EndModifyLookAt");
static_assert(sizeof(UAnimNotify_EndModifyLookAt) == 0x000040, "Wrong size on UAnimNotify_EndModifyLookAt");
static_assert(offsetof(UAnimNotify_EndModifyLookAt, ModifierType) == 0x000030, "Member 'UAnimNotify_EndModifyLookAt::ModifierType' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndModifyLookAt, bForceEnableLookAtMeshSpace) == 0x000031, "Member 'UAnimNotify_EndModifyLookAt::bForceEnableLookAtMeshSpace' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndModifyLookAt, WeightBias) == 0x000034, "Member 'UAnimNotify_EndModifyLookAt::WeightBias' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndModifyLookAt, WeightBiasBlendInTime) == 0x000038, "Member 'UAnimNotify_EndModifyLookAt::WeightBiasBlendInTime' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndModifyLookAt, WeightBiasBlendOutTime) == 0x00003C, "Member 'UAnimNotify_EndModifyLookAt::WeightBiasBlendOutTime' has a wrong offset!");

// Class EndGame.AnimNotify_EndModifyPhysicalConstraint
// 0x0020 (0x0050 - 0x0030)
class UAnimNotify_EndModifyPhysicalConstraint final : public UAnimNotifyState
{
public:
	TArray<class FName>                           BoneNames;                                         // 0x0030(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Stiffness;                                         // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationWeight;                                   // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x004C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndModifyPhysicalConstraint">();
	}
	static class UAnimNotify_EndModifyPhysicalConstraint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndModifyPhysicalConstraint>();
	}
};
static_assert(alignof(UAnimNotify_EndModifyPhysicalConstraint) == 0x000008, "Wrong alignment on UAnimNotify_EndModifyPhysicalConstraint");
static_assert(sizeof(UAnimNotify_EndModifyPhysicalConstraint) == 0x000050, "Wrong size on UAnimNotify_EndModifyPhysicalConstraint");
static_assert(offsetof(UAnimNotify_EndModifyPhysicalConstraint, BoneNames) == 0x000030, "Member 'UAnimNotify_EndModifyPhysicalConstraint::BoneNames' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndModifyPhysicalConstraint, Stiffness) == 0x000040, "Member 'UAnimNotify_EndModifyPhysicalConstraint::Stiffness' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndModifyPhysicalConstraint, AnimationWeight) == 0x000044, "Member 'UAnimNotify_EndModifyPhysicalConstraint::AnimationWeight' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndModifyPhysicalConstraint, BlendInTime) == 0x000048, "Member 'UAnimNotify_EndModifyPhysicalConstraint::BlendInTime' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndModifyPhysicalConstraint, BlendOutTime) == 0x00004C, "Member 'UAnimNotify_EndModifyPhysicalConstraint::BlendOutTime' has a wrong offset!");

// Class EndGame.EndTriggerBox
// 0x0008 (0x0388 - 0x0380)
class AEndTriggerBox : public ATriggerBox
{
public:
	class UEndTextRenderComponent*                TextRenderComponent;                               // 0x0380(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndTriggerBox">();
	}
	static class AEndTriggerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndTriggerBox>();
	}
};
static_assert(alignof(AEndTriggerBox) == 0x000008, "Wrong alignment on AEndTriggerBox");
static_assert(sizeof(AEndTriggerBox) == 0x000388, "Wrong size on AEndTriggerBox");
static_assert(offsetof(AEndTriggerBox, TextRenderComponent) == 0x000380, "Member 'AEndTriggerBox::TextRenderComponent' has a wrong offset!");

// Class EndGame.EndSubtitle
// 0x0010 (0x0370 - 0x0360)
class UEndSubtitle : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x10];                                     // 0x0360(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndSubtitle">();
	}
	static class UEndSubtitle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndSubtitle>();
	}
};
static_assert(alignof(UEndSubtitle) == 0x000008, "Wrong alignment on UEndSubtitle");
static_assert(sizeof(UEndSubtitle) == 0x000370, "Wrong size on UEndSubtitle");

// Class EndGame.AnimNotify_EndModifyPlayRate
// 0x0008 (0x0038 - 0x0030)
class UAnimNotify_EndModifyPlayRate final : public UAnimNotifyState
{
public:
	float                                         PlayRate;                                          // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndModifyPlayRate">();
	}
	static class UAnimNotify_EndModifyPlayRate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndModifyPlayRate>();
	}
};
static_assert(alignof(UAnimNotify_EndModifyPlayRate) == 0x000008, "Wrong alignment on UAnimNotify_EndModifyPlayRate");
static_assert(sizeof(UAnimNotify_EndModifyPlayRate) == 0x000038, "Wrong size on UAnimNotify_EndModifyPlayRate");
static_assert(offsetof(UAnimNotify_EndModifyPlayRate, PlayRate) == 0x000030, "Member 'UAnimNotify_EndModifyPlayRate::PlayRate' has a wrong offset!");

// Class EndGame.AnimNotify_EndModifyRootMotionScale
// 0x0008 (0x0038 - 0x0030)
class UAnimNotify_EndModifyRootMotionScale final : public UAnimNotifyState
{
public:
	float                                         RootMotionScale;                                   // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndModifyRootMotionScale">();
	}
	static class UAnimNotify_EndModifyRootMotionScale* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndModifyRootMotionScale>();
	}
};
static_assert(alignof(UAnimNotify_EndModifyRootMotionScale) == 0x000008, "Wrong alignment on UAnimNotify_EndModifyRootMotionScale");
static_assert(sizeof(UAnimNotify_EndModifyRootMotionScale) == 0x000038, "Wrong size on UAnimNotify_EndModifyRootMotionScale");
static_assert(offsetof(UAnimNotify_EndModifyRootMotionScale, RootMotionScale) == 0x000030, "Member 'UAnimNotify_EndModifyRootMotionScale::RootMotionScale' has a wrong offset!");

// Class EndGame.EndBattleTalkBattleCollideEventBox
// 0x0000 (0x0380 - 0x0380)
class AEndBattleTalkBattleCollideEventBox final : public ATriggerBox
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleTalkBattleCollideEventBox">();
	}
	static class AEndBattleTalkBattleCollideEventBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleTalkBattleCollideEventBox>();
	}
};
static_assert(alignof(AEndBattleTalkBattleCollideEventBox) == 0x000008, "Wrong alignment on AEndBattleTalkBattleCollideEventBox");
static_assert(sizeof(AEndBattleTalkBattleCollideEventBox) == 0x000380, "Wrong size on AEndBattleTalkBattleCollideEventBox");

// Class EndGame.EndNavBlockingModifierVolume
// 0x0008 (0x0450 - 0x0448)
class AEndNavBlockingModifierVolume : public AEndNavSwitchingVolume
{
public:
	bool                                          IsFirstStart;                                      // 0x0448(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEndNavAreaType                               NavAreaType;                                       // 0x0449(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44A[0x6];                                      // 0x044A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavBlockingModifierVolume">();
	}
	static class AEndNavBlockingModifierVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndNavBlockingModifierVolume>();
	}
};
static_assert(alignof(AEndNavBlockingModifierVolume) == 0x000008, "Wrong alignment on AEndNavBlockingModifierVolume");
static_assert(sizeof(AEndNavBlockingModifierVolume) == 0x000450, "Wrong size on AEndNavBlockingModifierVolume");
static_assert(offsetof(AEndNavBlockingModifierVolume, IsFirstStart) == 0x000448, "Member 'AEndNavBlockingModifierVolume::IsFirstStart' has a wrong offset!");
static_assert(offsetof(AEndNavBlockingModifierVolume, NavAreaType) == 0x000449, "Member 'AEndNavBlockingModifierVolume::NavAreaType' has a wrong offset!");

// Class EndGame.EndNavSimpleTerrainVolume
// 0x0000 (0x0450 - 0x0450)
class AEndNavSimpleTerrainVolume : public AEndNavBlockingModifierVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavSimpleTerrainVolume">();
	}
	static class AEndNavSimpleTerrainVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndNavSimpleTerrainVolume>();
	}
};
static_assert(alignof(AEndNavSimpleTerrainVolume) == 0x000008, "Wrong alignment on AEndNavSimpleTerrainVolume");
static_assert(sizeof(AEndNavSimpleTerrainVolume) == 0x000450, "Wrong size on AEndNavSimpleTerrainVolume");

// Class EndGame.AnimNotify_EndModifyRootSmoothing
// 0x0008 (0x0038 - 0x0030)
class UAnimNotify_EndModifyRootSmoothing final : public UAnimNotifyState
{
public:
	float                                         Scale;                                             // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndModifyRootSmoothing">();
	}
	static class UAnimNotify_EndModifyRootSmoothing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndModifyRootSmoothing>();
	}
};
static_assert(alignof(UAnimNotify_EndModifyRootSmoothing) == 0x000008, "Wrong alignment on UAnimNotify_EndModifyRootSmoothing");
static_assert(sizeof(UAnimNotify_EndModifyRootSmoothing) == 0x000038, "Wrong size on UAnimNotify_EndModifyRootSmoothing");
static_assert(offsetof(UAnimNotify_EndModifyRootSmoothing, Scale) == 0x000030, "Member 'UAnimNotify_EndModifyRootSmoothing::Scale' has a wrong offset!");

// Class EndGame.AnimNotify_EndModifyTerminal
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_EndModifyTerminal final : public UAnimNotify
{
public:
	EEndTerminalModifierType                      ModifierType;                                      // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndModifyTerminal">();
	}
	static class UAnimNotify_EndModifyTerminal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndModifyTerminal>();
	}
};
static_assert(alignof(UAnimNotify_EndModifyTerminal) == 0x000008, "Wrong alignment on UAnimNotify_EndModifyTerminal");
static_assert(sizeof(UAnimNotify_EndModifyTerminal) == 0x000040, "Wrong size on UAnimNotify_EndModifyTerminal");
static_assert(offsetof(UAnimNotify_EndModifyTerminal, ModifierType) == 0x000038, "Member 'UAnimNotify_EndModifyTerminal::ModifierType' has a wrong offset!");

// Class EndGame.EndDataObjectPlayerParameter
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectPlayerParameter final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectPlayerParameter">();
	}
	static class UEndDataObjectPlayerParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectPlayerParameter>();
	}
};
static_assert(alignof(UEndDataObjectPlayerParameter) == 0x000008, "Wrong alignment on UEndDataObjectPlayerParameter");
static_assert(sizeof(UEndDataObjectPlayerParameter) == 0x000088, "Wrong size on UEndDataObjectPlayerParameter");

// Class EndGame.EndBattleSummonGaugeIcon
// 0x0098 (0x03F8 - 0x0360)
class UEndBattleSummonGaugeIcon : public UEndUserWidget
{
public:
	struct FVector2D                              _OffsetPosition;                                   // 0x0360(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_368[0x90];                                     // 0x0368(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleSummonGaugeIcon">();
	}
	static class UEndBattleSummonGaugeIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleSummonGaugeIcon>();
	}
};
static_assert(alignof(UEndBattleSummonGaugeIcon) == 0x000008, "Wrong alignment on UEndBattleSummonGaugeIcon");
static_assert(sizeof(UEndBattleSummonGaugeIcon) == 0x0003F8, "Wrong size on UEndBattleSummonGaugeIcon");
static_assert(offsetof(UEndBattleSummonGaugeIcon, _OffsetPosition) == 0x000360, "Member 'UEndBattleSummonGaugeIcon::_OffsetPosition' has a wrong offset!");

// Class EndGame.EndDataObjectBikePhaseEnemy
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBikePhaseEnemy final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBikePhaseEnemy">();
	}
	static class UEndDataObjectBikePhaseEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBikePhaseEnemy>();
	}
};
static_assert(alignof(UEndDataObjectBikePhaseEnemy) == 0x000008, "Wrong alignment on UEndDataObjectBikePhaseEnemy");
static_assert(sizeof(UEndDataObjectBikePhaseEnemy) == 0x000088, "Wrong size on UEndDataObjectBikePhaseEnemy");

// Class EndGame.EndNavLinkProxy
// 0x0000 (0x03C8 - 0x03C8)
class AEndNavLinkProxy : public ANavLinkProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavLinkProxy">();
	}
	static class AEndNavLinkProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndNavLinkProxy>();
	}
};
static_assert(alignof(AEndNavLinkProxy) == 0x000008, "Wrong alignment on AEndNavLinkProxy");
static_assert(sizeof(AEndNavLinkProxy) == 0x0003C8, "Wrong size on AEndNavLinkProxy");

// Class EndGame.EndFieldActionActorBase
// 0x0250 (0x0618 - 0x03C8)
class AEndFieldActionActorBase : public AEndNavLinkProxy
{
public:
	uint8                                         Pad_3C8[0x8];                                      // 0x03C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ForceActiveTargetIcon;                             // 0x03D0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WaitReservation;                                   // 0x03D1(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D2[0x2];                                      // 0x03D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   IgnoreActorGroup;                                  // 0x03D4(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawOffsetLocation;                               // 0x03DC(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3DD[0x3];                                      // 0x03DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LeftPointOffsetLocation;                           // 0x03E0(0x000C)(Edit, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightPointOffsetLocation;                          // 0x03EC(0x000C)(Edit, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftBoxText;                                       // 0x03F8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightBoxText;                                      // 0x0400(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DuringActionText;                                  // 0x0408(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnceOnlyReact;                                     // 0x0410(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_411[0x3];                                      // 0x0411(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DefaultStartStateTrigger;                          // 0x0414(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultEndStateTrigger;                            // 0x041C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftStartStateTrigger;                             // 0x0424(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftEndStateTrigger;                               // 0x042C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightStartStateTrigger;                            // 0x0434(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightEndStateTrigger;                              // 0x043C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_444[0x4];                                      // 0x0444(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FAffectedActorGroup> AffectedActorGroup;                                // 0x0448(0x0050)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class FName                                   CameraOffTriggerName;                              // 0x0498(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextRenderComponent*                TextRenderComponent;                               // 0x04A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNavPriorRegistInfo                    NavPriorInfo;                                      // 0x04A8(0x0028)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D0[0x148];                                    // 0x04D0(0x0148)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorBase">();
	}
	static class AEndFieldActionActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorBase>();
	}
};
static_assert(alignof(AEndFieldActionActorBase) == 0x000008, "Wrong alignment on AEndFieldActionActorBase");
static_assert(sizeof(AEndFieldActionActorBase) == 0x000618, "Wrong size on AEndFieldActionActorBase");
static_assert(offsetof(AEndFieldActionActorBase, ForceActiveTargetIcon) == 0x0003D0, "Member 'AEndFieldActionActorBase::ForceActiveTargetIcon' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBase, WaitReservation) == 0x0003D1, "Member 'AEndFieldActionActorBase::WaitReservation' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBase, IgnoreActorGroup) == 0x0003D4, "Member 'AEndFieldActionActorBase::IgnoreActorGroup' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBase, bDrawOffsetLocation) == 0x0003DC, "Member 'AEndFieldActionActorBase::bDrawOffsetLocation' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBase, LeftPointOffsetLocation) == 0x0003E0, "Member 'AEndFieldActionActorBase::LeftPointOffsetLocation' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBase, RightPointOffsetLocation) == 0x0003EC, "Member 'AEndFieldActionActorBase::RightPointOffsetLocation' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBase, LeftBoxText) == 0x0003F8, "Member 'AEndFieldActionActorBase::LeftBoxText' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBase, RightBoxText) == 0x000400, "Member 'AEndFieldActionActorBase::RightBoxText' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBase, DuringActionText) == 0x000408, "Member 'AEndFieldActionActorBase::DuringActionText' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBase, OnceOnlyReact) == 0x000410, "Member 'AEndFieldActionActorBase::OnceOnlyReact' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBase, DefaultStartStateTrigger) == 0x000414, "Member 'AEndFieldActionActorBase::DefaultStartStateTrigger' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBase, DefaultEndStateTrigger) == 0x00041C, "Member 'AEndFieldActionActorBase::DefaultEndStateTrigger' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBase, LeftStartStateTrigger) == 0x000424, "Member 'AEndFieldActionActorBase::LeftStartStateTrigger' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBase, LeftEndStateTrigger) == 0x00042C, "Member 'AEndFieldActionActorBase::LeftEndStateTrigger' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBase, RightStartStateTrigger) == 0x000434, "Member 'AEndFieldActionActorBase::RightStartStateTrigger' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBase, RightEndStateTrigger) == 0x00043C, "Member 'AEndFieldActionActorBase::RightEndStateTrigger' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBase, AffectedActorGroup) == 0x000448, "Member 'AEndFieldActionActorBase::AffectedActorGroup' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBase, CameraOffTriggerName) == 0x000498, "Member 'AEndFieldActionActorBase::CameraOffTriggerName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBase, TextRenderComponent) == 0x0004A0, "Member 'AEndFieldActionActorBase::TextRenderComponent' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBase, NavPriorInfo) == 0x0004A8, "Member 'AEndFieldActionActorBase::NavPriorInfo' has a wrong offset!");

// Class EndGame.EndFieldActionActorTarzanRope
// 0x0138 (0x0750 - 0x0618)
class AEndFieldActionActorTarzanRope final : public AEndFieldActionActorBase
{
public:
	class UEndFieldActionTriggerComponent*        EnterVolume;                                       // 0x0618(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        ExitVolume;                                        // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        TargetIconEnterComponent;                          // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        TargetIconExitComponent;                           // 0x0630(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          GoalTargetComponent;                               // 0x0638(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TwoStepsMore;                                      // 0x0640(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_641[0x7];                                      // 0x0641(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           AnimationActorNames;                               // 0x0648(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0658(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_660[0xF0];                                     // 0x0660(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorTarzanRope">();
	}
	static class AEndFieldActionActorTarzanRope* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorTarzanRope>();
	}
};
static_assert(alignof(AEndFieldActionActorTarzanRope) == 0x000008, "Wrong alignment on AEndFieldActionActorTarzanRope");
static_assert(sizeof(AEndFieldActionActorTarzanRope) == 0x000750, "Wrong size on AEndFieldActionActorTarzanRope");
static_assert(offsetof(AEndFieldActionActorTarzanRope, EnterVolume) == 0x000618, "Member 'AEndFieldActionActorTarzanRope::EnterVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorTarzanRope, ExitVolume) == 0x000620, "Member 'AEndFieldActionActorTarzanRope::ExitVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorTarzanRope, TargetIconEnterComponent) == 0x000628, "Member 'AEndFieldActionActorTarzanRope::TargetIconEnterComponent' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorTarzanRope, TargetIconExitComponent) == 0x000630, "Member 'AEndFieldActionActorTarzanRope::TargetIconExitComponent' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorTarzanRope, GoalTargetComponent) == 0x000638, "Member 'AEndFieldActionActorTarzanRope::GoalTargetComponent' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorTarzanRope, TwoStepsMore) == 0x000640, "Member 'AEndFieldActionActorTarzanRope::TwoStepsMore' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorTarzanRope, AnimationActorNames) == 0x000648, "Member 'AEndFieldActionActorTarzanRope::AnimationActorNames' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorTarzanRope, ModifierVolume) == 0x000658, "Member 'AEndFieldActionActorTarzanRope::ModifierVolume' has a wrong offset!");

// Class EndGame.AnimNotify_EndModifyWeaponVisibility
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_EndModifyWeaponVisibility final : public UAnimNotify
{
public:
	bool                                          bVisible;                                          // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndModifyWeaponVisibility">();
	}
	static class UAnimNotify_EndModifyWeaponVisibility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndModifyWeaponVisibility>();
	}
};
static_assert(alignof(UAnimNotify_EndModifyWeaponVisibility) == 0x000008, "Wrong alignment on UAnimNotify_EndModifyWeaponVisibility");
static_assert(sizeof(UAnimNotify_EndModifyWeaponVisibility) == 0x000040, "Wrong size on UAnimNotify_EndModifyWeaponVisibility");
static_assert(offsetof(UAnimNotify_EndModifyWeaponVisibility, bVisible) == 0x000038, "Member 'UAnimNotify_EndModifyWeaponVisibility::bVisible' has a wrong offset!");

// Class EndGame.AnimNotify_EndModifyWireReel
// 0x0010 (0x0048 - 0x0038)
class UAnimNotify_EndModifyWireReel final : public UAnimNotify
{
public:
	EEndWireReelModifierType                      ModifierType;                                      // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Param01;                                           // 0x003C(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndModifyWireReel">();
	}
	static class UAnimNotify_EndModifyWireReel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndModifyWireReel>();
	}
};
static_assert(alignof(UAnimNotify_EndModifyWireReel) == 0x000008, "Wrong alignment on UAnimNotify_EndModifyWireReel");
static_assert(sizeof(UAnimNotify_EndModifyWireReel) == 0x000048, "Wrong size on UAnimNotify_EndModifyWireReel");
static_assert(offsetof(UAnimNotify_EndModifyWireReel, ModifierType) == 0x000038, "Member 'UAnimNotify_EndModifyWireReel::ModifierType' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndModifyWireReel, Param01) == 0x00003C, "Member 'UAnimNotify_EndModifyWireReel::Param01' has a wrong offset!");

// Class EndGame.EndBattleSceneBlueprint
// 0x0030 (0x03A8 - 0x0378)
class AEndBattleSceneBlueprint : public AActor
{
public:
	int32                                         Phase;                                             // 0x0378(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTickNewlySpawned;                                 // 0x037C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37D[0x2B];                                     // 0x037D(0x002B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddStatusChange(const class FName CharaName, const TArray<EEndBattleStatusChangeType>& Types);
	void BattleSceneDelay(float Duration, const struct FLatentActionInfo& LatentInfo);
	void ChangePhase(int32 _phase);
	class FName ConvertMultiTalkPlayTriggerID(class FName TalkPlayTriggerId);
	void ForceAIPCUseAbility(EPlayerType PlayerType, class FName AbilityID, class AEndCharacter* Target, class FName TargetPartsID);
	void OnBeginLinkCommand();
	void OnBeginTalkTriggerBoxCollide(class FName TriggerBoxActorName, class FName CollideCharaName);
	void OnCharaPartsBreak(class FName CauserCharaName, class FName BrokenCharaName, class FName partsID, class FName CategoryID, int32 CategoryBreakCount);
	void OnCharaPartsDamage(class FName CauserCharaName, class FName DamagedCharaName, class FName partsID, class FName CategoryID, int32 RemainHP, float RemainHPPer);
	void OnCharaSpecialStatusChange(const class FName& ownerCharaName, const class FName& SpecialStatusChangeID, EEndBattleSpecialStatusChangeType Type, const class FName& StateId, const TArray<float>& Params_0, const TArray<class FName>& ParamIDs, const TArray<class AActor*>& ParamActors);
	void OnCharaSyncAction(const class FName& AttackedCharaName, const class FName& ReceivedCharaName, const class FName& StateId, int32 StateCount, const class FName& syncActionID, const class FName& CauserCharaName);
	void OnCollideBattleTalkColideBox(class FName ColideBoxName, class AEndCharacter* ownerChara, class FName DamageSourceID, const struct FEndDataTableBattleDamageSource& DamageSourceDataTable);
	void OnCompletedTalkState(class FName TalkStateId, bool bInterrupted);
	void OnDLCSummonUltimateMagicEnd();
	void OnEndFreeAct(class FName InName);
	void OnEndLinkCommand();
	void OnEndRailCamera(const class FName& RailCameraID);
	void OnEndTalkTriggerBoxCollide(class FName TriggerBoxActorName, class FName CollideCharaName);
	void OnEntryBattleScene(const class FName& BattleSceneID, const struct FEndDataTableBattleScene& dataTableBattleScene);
	void OnEntryBattleSceneAfter();
	void OnEntryBattleSceneWave(const class FName& BattleSceneID, const class FName& baseBattleSceneId, const struct FEndDataTableBattleScene& dataTableBattleScene);
	void OnExitBattleScene();
	void OnIncrementBattleCountPerID(class FName CauserCharaName, class FName TargetCharaName, EEndBattleCountLogType Type, class FName ID, int32 Count);
	void OnMetaMessage(const class FString& InMessage);
	void OnMotionMessage(class FName CharaName, class FName motionName);
	void OnReadyBattleTalk(class FName BattleSceneID);
	void OnShowMenuGameOver();
	void OnTakeDamage(int32 Damage, const class FName& CauserCharaName, const class FName& DamagedCharaName, const class FName& AbilityID, bool bBind, bool bGuard, bool bDodge, const class FName& hitBoneName, bool bAttributeHit, const class FName& DamageSourceID, EEndBattleAttributeType DmgSrcAttributeType, float justHitRotYaw, const struct FVector& hitPosition, bool bHeal);
	void OnTakeDamageSpecialStatus(class FName characterName, EEndBattleSpecialStatusChangeType specialStatus, class FName abilityName, float damageParcent);
	void RemoveStatusChange(const class FName CharaName, const TArray<EEndBattleStatusChangeType>& Types);
	void SetAIPCControllerTick(EPlayerType PlayerType, bool Flag);
	void SetHPByBattleSceneCharacterIndex(int32 srcCharacterIndex, int32 destCharacterIndex);
	void SetPhase(int32 Value);
	void SwitchCharaState(EEndBattleSceneCharaStateType* State, class FName CharaName, bool bExecInState);

	int32 GetPhase() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleSceneBlueprint">();
	}
	static class AEndBattleSceneBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleSceneBlueprint>();
	}
};
static_assert(alignof(AEndBattleSceneBlueprint) == 0x000008, "Wrong alignment on AEndBattleSceneBlueprint");
static_assert(sizeof(AEndBattleSceneBlueprint) == 0x0003A8, "Wrong size on AEndBattleSceneBlueprint");
static_assert(offsetof(AEndBattleSceneBlueprint, Phase) == 0x000378, "Member 'AEndBattleSceneBlueprint::Phase' has a wrong offset!");
static_assert(offsetof(AEndBattleSceneBlueprint, bTickNewlySpawned) == 0x00037C, "Member 'AEndBattleSceneBlueprint::bTickNewlySpawned' has a wrong offset!");

// Class EndGame.EndBattleScene_btsc_sbil0_90_boss010
// 0x0010 (0x03B8 - 0x03A8)
class AEndBattleScene_btsc_sbil0_90_boss010 final : public AEndBattleSceneBlueprint
{
public:
	uint8                                         Pad_3A8[0x10];                                     // 0x03A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleScene_btsc_sbil0_90_boss010">();
	}
	static class AEndBattleScene_btsc_sbil0_90_boss010* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleScene_btsc_sbil0_90_boss010>();
	}
};
static_assert(alignof(AEndBattleScene_btsc_sbil0_90_boss010) == 0x000008, "Wrong alignment on AEndBattleScene_btsc_sbil0_90_boss010");
static_assert(sizeof(AEndBattleScene_btsc_sbil0_90_boss010) == 0x0003B8, "Wrong size on AEndBattleScene_btsc_sbil0_90_boss010");

// Class EndGame.EndPlayerController
// 0x0318 (0x09F0 - 0x06D8)
class AEndPlayerController : public APlayerController
{
public:
	uint8                                         Pad_6D8[0x8];                                      // 0x06D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 PlayerTrigger;                                     // 0x06E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCapsuleOverlapComponent*            EndCapsuleOverlapComponent;                        // 0x06E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndPlayerExistNavAreaComponent*        PlayerExistNavAreaComponent;                       // 0x06F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AEndCharacter*                          LeaderCharacter;                                   // 0x06F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AEndBattleTalkOnEndBattleActor> BattleTalkOnEndBattleClass;                        // 0x0700(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AEndBattleTalkOnEndBattleActor*         BattleTalkOnEndBattle;                             // 0x0708(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_710[0x208];                                    // 0x0710(0x0208)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxMouseSensitivity;                               // 0x0918(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinMouseSensitivity;                               // 0x091C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_920[0xD0];                                     // 0x0920(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndPlayerController">();
	}
	static class AEndPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndPlayerController>();
	}
};
static_assert(alignof(AEndPlayerController) == 0x000008, "Wrong alignment on AEndPlayerController");
static_assert(sizeof(AEndPlayerController) == 0x0009F0, "Wrong size on AEndPlayerController");
static_assert(offsetof(AEndPlayerController, PlayerTrigger) == 0x0006E0, "Member 'AEndPlayerController::PlayerTrigger' has a wrong offset!");
static_assert(offsetof(AEndPlayerController, EndCapsuleOverlapComponent) == 0x0006E8, "Member 'AEndPlayerController::EndCapsuleOverlapComponent' has a wrong offset!");
static_assert(offsetof(AEndPlayerController, PlayerExistNavAreaComponent) == 0x0006F0, "Member 'AEndPlayerController::PlayerExistNavAreaComponent' has a wrong offset!");
static_assert(offsetof(AEndPlayerController, LeaderCharacter) == 0x0006F8, "Member 'AEndPlayerController::LeaderCharacter' has a wrong offset!");
static_assert(offsetof(AEndPlayerController, BattleTalkOnEndBattleClass) == 0x000700, "Member 'AEndPlayerController::BattleTalkOnEndBattleClass' has a wrong offset!");
static_assert(offsetof(AEndPlayerController, BattleTalkOnEndBattle) == 0x000708, "Member 'AEndPlayerController::BattleTalkOnEndBattle' has a wrong offset!");
static_assert(offsetof(AEndPlayerController, MaxMouseSensitivity) == 0x000918, "Member 'AEndPlayerController::MaxMouseSensitivity' has a wrong offset!");
static_assert(offsetof(AEndPlayerController, MinMouseSensitivity) == 0x00091C, "Member 'AEndPlayerController::MinMouseSensitivity' has a wrong offset!");

// Class EndGame.AnimNotify_EndOverrideAdditiveDamage
// 0x0010 (0x0040 - 0x0030)
class UAnimNotify_EndOverrideAdditiveDamage final : public UAnimNotifyState
{
public:
	bool                                          bPlayAnimation;                                    // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AnimationName;                                     // 0x0034(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndOverrideAdditiveDamage">();
	}
	static class UAnimNotify_EndOverrideAdditiveDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndOverrideAdditiveDamage>();
	}
};
static_assert(alignof(UAnimNotify_EndOverrideAdditiveDamage) == 0x000008, "Wrong alignment on UAnimNotify_EndOverrideAdditiveDamage");
static_assert(sizeof(UAnimNotify_EndOverrideAdditiveDamage) == 0x000040, "Wrong size on UAnimNotify_EndOverrideAdditiveDamage");
static_assert(offsetof(UAnimNotify_EndOverrideAdditiveDamage, bPlayAnimation) == 0x000030, "Member 'UAnimNotify_EndOverrideAdditiveDamage::bPlayAnimation' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndOverrideAdditiveDamage, AnimationName) == 0x000034, "Member 'UAnimNotify_EndOverrideAdditiveDamage::AnimationName' has a wrong offset!");

// Class EndGame.AnimNotify_EndOverrideAttackDirection
// 0x0008 (0x0038 - 0x0030)
class UAnimNotify_EndOverrideAttackDirection final : public UAnimNotifyState
{
public:
	float                                         Yaw;                                               // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pitch;                                             // 0x0034(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndOverrideAttackDirection">();
	}
	static class UAnimNotify_EndOverrideAttackDirection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndOverrideAttackDirection>();
	}
};
static_assert(alignof(UAnimNotify_EndOverrideAttackDirection) == 0x000008, "Wrong alignment on UAnimNotify_EndOverrideAttackDirection");
static_assert(sizeof(UAnimNotify_EndOverrideAttackDirection) == 0x000038, "Wrong size on UAnimNotify_EndOverrideAttackDirection");
static_assert(offsetof(UAnimNotify_EndOverrideAttackDirection, Yaw) == 0x000030, "Member 'UAnimNotify_EndOverrideAttackDirection::Yaw' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndOverrideAttackDirection, Pitch) == 0x000034, "Member 'UAnimNotify_EndOverrideAttackDirection::Pitch' has a wrong offset!");

// Class EndGame.EndDataObjectResidentBattleTalkGroup
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectResidentBattleTalkGroup final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectResidentBattleTalkGroup">();
	}
	static class UEndDataObjectResidentBattleTalkGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectResidentBattleTalkGroup>();
	}
};
static_assert(alignof(UEndDataObjectResidentBattleTalkGroup) == 0x000008, "Wrong alignment on UEndDataObjectResidentBattleTalkGroup");
static_assert(sizeof(UEndDataObjectResidentBattleTalkGroup) == 0x000088, "Wrong size on UEndDataObjectResidentBattleTalkGroup");

// Class EndGame.EndPieImage
// 0x00E8 (0x01E0 - 0x00F8)
class UEndPieImage final : public UWidget
{
public:
	struct FSlateBrush                            Brush;                                             // 0x00F8(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TDelegate<void()>                             BrushDelegate;                                     // 0x0170(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorAndOpacity;                                   // 0x0180(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ColorAndOpacityDelegate;                           // 0x0190(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	EBlendMode                                    BlendMode;                                         // 0x01A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x3];                                      // 0x01A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartAngle;                                        // 0x01A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             StartAngleDelegate;                                // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	float                                         EndAngle;                                          // 0x01B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BC[0x4];                                      // 0x01BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             EndAngleDelegate;                                  // 0x01C0(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D0[0x10];                                     // 0x01D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMaterialInstanceDynamic* GetDynamicMaterial();
	void SetBlendMode(EBlendMode InBlendMode);
	void SetBrush(const struct FSlateBrush& InBrush);
	void SetBrushFromAsset(class USlateBrushAsset* Asset);
	void SetBrushFromMaterial(class UMaterialInterface* Material);
	void SetBrushFromTexture(class UTexture2D* Texture, bool bMatchSize);
	void SetBrushFromTextureDynamic(class UTexture2DDynamic* Texture, bool bMatchSize);
	void SetColorAndOpacity(const struct FLinearColor& InColorAndOpacity);
	void SetEndAngle(float InAngle);
	void SetOpacity(float InOpacity);
	void SetStartAngle(float InAngle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndPieImage">();
	}
	static class UEndPieImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndPieImage>();
	}
};
static_assert(alignof(UEndPieImage) == 0x000008, "Wrong alignment on UEndPieImage");
static_assert(sizeof(UEndPieImage) == 0x0001E0, "Wrong size on UEndPieImage");
static_assert(offsetof(UEndPieImage, Brush) == 0x0000F8, "Member 'UEndPieImage::Brush' has a wrong offset!");
static_assert(offsetof(UEndPieImage, BrushDelegate) == 0x000170, "Member 'UEndPieImage::BrushDelegate' has a wrong offset!");
static_assert(offsetof(UEndPieImage, ColorAndOpacity) == 0x000180, "Member 'UEndPieImage::ColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UEndPieImage, ColorAndOpacityDelegate) == 0x000190, "Member 'UEndPieImage::ColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UEndPieImage, BlendMode) == 0x0001A0, "Member 'UEndPieImage::BlendMode' has a wrong offset!");
static_assert(offsetof(UEndPieImage, StartAngle) == 0x0001A4, "Member 'UEndPieImage::StartAngle' has a wrong offset!");
static_assert(offsetof(UEndPieImage, StartAngleDelegate) == 0x0001A8, "Member 'UEndPieImage::StartAngleDelegate' has a wrong offset!");
static_assert(offsetof(UEndPieImage, EndAngle) == 0x0001B8, "Member 'UEndPieImage::EndAngle' has a wrong offset!");
static_assert(offsetof(UEndPieImage, EndAngleDelegate) == 0x0001C0, "Member 'UEndPieImage::EndAngleDelegate' has a wrong offset!");

// Class EndGame.AnimNotify_EndOverrideLocomotion
// 0x0020 (0x0058 - 0x0038)
class UAnimNotify_EndOverrideLocomotion final : public UAnimNotify
{
public:
	EEndLocomotionAnim                            TargetAnim;                                        // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEndOverrideLocomotionSetting>  Settings;                                          // 0x0040(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         OverrideIntervalMin;                               // 0x0050(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndOverrideLocomotion">();
	}
	static class UAnimNotify_EndOverrideLocomotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndOverrideLocomotion>();
	}
};
static_assert(alignof(UAnimNotify_EndOverrideLocomotion) == 0x000008, "Wrong alignment on UAnimNotify_EndOverrideLocomotion");
static_assert(sizeof(UAnimNotify_EndOverrideLocomotion) == 0x000058, "Wrong size on UAnimNotify_EndOverrideLocomotion");
static_assert(offsetof(UAnimNotify_EndOverrideLocomotion, TargetAnim) == 0x000038, "Member 'UAnimNotify_EndOverrideLocomotion::TargetAnim' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndOverrideLocomotion, Settings) == 0x000040, "Member 'UAnimNotify_EndOverrideLocomotion::Settings' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndOverrideLocomotion, OverrideIntervalMin) == 0x000050, "Member 'UAnimNotify_EndOverrideLocomotion::OverrideIntervalMin' has a wrong offset!");

// Class EndGame.AnimNotifyState_EndResetOverrideLocomotion
// 0x0008 (0x0038 - 0x0030)
class UAnimNotifyState_EndResetOverrideLocomotion final : public UAnimNotifyState
{
public:
	EEndLocomotionAnim                            TargetAnim;                                        // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_EndResetOverrideLocomotion">();
	}
	static class UAnimNotifyState_EndResetOverrideLocomotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_EndResetOverrideLocomotion>();
	}
};
static_assert(alignof(UAnimNotifyState_EndResetOverrideLocomotion) == 0x000008, "Wrong alignment on UAnimNotifyState_EndResetOverrideLocomotion");
static_assert(sizeof(UAnimNotifyState_EndResetOverrideLocomotion) == 0x000038, "Wrong size on UAnimNotifyState_EndResetOverrideLocomotion");
static_assert(offsetof(UAnimNotifyState_EndResetOverrideLocomotion, TargetAnim) == 0x000030, "Member 'UAnimNotifyState_EndResetOverrideLocomotion::TargetAnim' has a wrong offset!");

// Class EndGame.EndBikeAIController
// 0x00D0 (0x0E60 - 0x0D90)
class AEndBikeAIController : public AEndAIController
{
public:
	uint8                                         Pad_D90[0xD0];                                     // 0x0D90(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikeAIController">();
	}
	static class AEndBikeAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBikeAIController>();
	}
};
static_assert(alignof(AEndBikeAIController) == 0x000008, "Wrong alignment on AEndBikeAIController");
static_assert(sizeof(AEndBikeAIController) == 0x000E60, "Wrong size on AEndBikeAIController");

// Class EndGame.EndBikeAIControllerAllyBase
// 0x0110 (0x0F70 - 0x0E60)
class AEndBikeAIControllerAllyBase : public AEndBikeAIController
{
public:
	TMap<EBikeDirection, struct FBikeAllyAbilityList> AbilitySetting;                                    // 0x0E60(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<float, class FName>                      CrisisTalkSetting;                                 // 0x0EB0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   DyingMotionName;                                   // 0x0F00(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBikeAllyCharacterType                        Attacker;                                          // 0x0F08(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F09[0x67];                                     // 0x0F09(0x0067)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikeAIControllerAllyBase">();
	}
	static class AEndBikeAIControllerAllyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBikeAIControllerAllyBase>();
	}
};
static_assert(alignof(AEndBikeAIControllerAllyBase) == 0x000008, "Wrong alignment on AEndBikeAIControllerAllyBase");
static_assert(sizeof(AEndBikeAIControllerAllyBase) == 0x000F70, "Wrong size on AEndBikeAIControllerAllyBase");
static_assert(offsetof(AEndBikeAIControllerAllyBase, AbilitySetting) == 0x000E60, "Member 'AEndBikeAIControllerAllyBase::AbilitySetting' has a wrong offset!");
static_assert(offsetof(AEndBikeAIControllerAllyBase, CrisisTalkSetting) == 0x000EB0, "Member 'AEndBikeAIControllerAllyBase::CrisisTalkSetting' has a wrong offset!");
static_assert(offsetof(AEndBikeAIControllerAllyBase, DyingMotionName) == 0x000F00, "Member 'AEndBikeAIControllerAllyBase::DyingMotionName' has a wrong offset!");
static_assert(offsetof(AEndBikeAIControllerAllyBase, Attacker) == 0x000F08, "Member 'AEndBikeAIControllerAllyBase::Attacker' has a wrong offset!");

// Class EndGame.EndBikeAIControllerWedge
// 0x0060 (0x0FD0 - 0x0F70)
class AEndBikeAIControllerWedge final : public AEndBikeAIControllerAllyBase
{
public:
	class FName                                   DamageMotionNameF1;                                // 0x0F70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DamageMotionNameF2;                                // 0x0F78(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DamageMotionNameB1;                                // 0x0F80(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DamageMotionNameB2;                                // 0x0F88(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DamageMotionNameR1;                                // 0x0F90(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DamageMotionNameR2;                                // 0x0F98(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DamageMotionNameL1;                                // 0x0FA0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DamageMotionNameL2;                                // 0x0FA8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DamageMotionNameExplosion;                         // 0x0FB0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FB8[0x18];                                     // 0x0FB8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikeAIControllerWedge">();
	}
	static class AEndBikeAIControllerWedge* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBikeAIControllerWedge>();
	}
};
static_assert(alignof(AEndBikeAIControllerWedge) == 0x000008, "Wrong alignment on AEndBikeAIControllerWedge");
static_assert(sizeof(AEndBikeAIControllerWedge) == 0x000FD0, "Wrong size on AEndBikeAIControllerWedge");
static_assert(offsetof(AEndBikeAIControllerWedge, DamageMotionNameF1) == 0x000F70, "Member 'AEndBikeAIControllerWedge::DamageMotionNameF1' has a wrong offset!");
static_assert(offsetof(AEndBikeAIControllerWedge, DamageMotionNameF2) == 0x000F78, "Member 'AEndBikeAIControllerWedge::DamageMotionNameF2' has a wrong offset!");
static_assert(offsetof(AEndBikeAIControllerWedge, DamageMotionNameB1) == 0x000F80, "Member 'AEndBikeAIControllerWedge::DamageMotionNameB1' has a wrong offset!");
static_assert(offsetof(AEndBikeAIControllerWedge, DamageMotionNameB2) == 0x000F88, "Member 'AEndBikeAIControllerWedge::DamageMotionNameB2' has a wrong offset!");
static_assert(offsetof(AEndBikeAIControllerWedge, DamageMotionNameR1) == 0x000F90, "Member 'AEndBikeAIControllerWedge::DamageMotionNameR1' has a wrong offset!");
static_assert(offsetof(AEndBikeAIControllerWedge, DamageMotionNameR2) == 0x000F98, "Member 'AEndBikeAIControllerWedge::DamageMotionNameR2' has a wrong offset!");
static_assert(offsetof(AEndBikeAIControllerWedge, DamageMotionNameL1) == 0x000FA0, "Member 'AEndBikeAIControllerWedge::DamageMotionNameL1' has a wrong offset!");
static_assert(offsetof(AEndBikeAIControllerWedge, DamageMotionNameL2) == 0x000FA8, "Member 'AEndBikeAIControllerWedge::DamageMotionNameL2' has a wrong offset!");
static_assert(offsetof(AEndBikeAIControllerWedge, DamageMotionNameExplosion) == 0x000FB0, "Member 'AEndBikeAIControllerWedge::DamageMotionNameExplosion' has a wrong offset!");

// Class EndGame.EndFeelerBarrierActor
// 0x0298 (0x0610 - 0x0378)
class AEndFeelerBarrierActor final : public AActor
{
public:
	uint8                                         Pad_378[0xF8];                                     // 0x0378(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InstanceCount;                                     // 0x0470(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LineCount;                                         // 0x0474(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EffectCount;                                       // 0x0478(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47C[0x4];                                      // 0x047C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        EffectTemplate;                                    // 0x0480(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RandomScaleRange;                                  // 0x0488(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRefreshInstance;                                  // 0x0490(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_491[0x7];                                      // 0x0491(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEndFeelerBarrierInstanceContext> InstanceContexts;                                  // 0x0498(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	struct FEndFeelerBarrierBaseAndRandomBias     HorizontalLoopTime;                                // 0x04A8(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         VerticalHeightOffsetSize;                          // 0x04B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalHeightOffsetPow;                           // 0x04B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEndFeelerBarrierBaseAndRandomBias     PrimaryVerticalLoopTime;                           // 0x04BC(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndFeelerBarrierBaseAndRandomBias     PrimaryVerticalMoveSize;                           // 0x04C8(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndFeelerBarrierBaseAndRandomBias     SecondaryVerticalLoopTime;                         // 0x04D4(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndFeelerBarrierBaseAndRandomBias     SecondaryVerticalMoveSize;                         // 0x04E0(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndFeelerBarrierBaseAndRandomBias     PrimaryRollLoopTime;                               // 0x04EC(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndFeelerBarrierBaseAndRandomBias     PrimaryRollSize;                                   // 0x04F8(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndFeelerBarrierBaseAndRandomBias     SecondaryRollLoopTime;                             // 0x0504(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndFeelerBarrierBaseAndRandomBias     SecondaryRollSize;                                 // 0x0510(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ExtrusionDistanceMax;                              // 0x051C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtrusionMoveDeltaMax;                             // 0x0520(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtrusionDistanceInterpSpeed;                      // 0x0524(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ExtrusionWaitTimeRange;                            // 0x0528(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DeactiveUpSpeedRange;                              // 0x0530(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInverseMovement;                                  // 0x0538(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_539[0x3];                                      // 0x0539(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeInWaitTime;                                    // 0x053C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideFadeInTime;                                // 0x0540(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideFadeOutTime;                               // 0x0544(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SplinePointCount;                                  // 0x0548(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplinePointRadius;                                 // 0x054C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRefreshSpline;                                    // 0x0550(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_551[0x7];                                      // 0x0551(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInterpCurveFloat                      SplineDistanceCurve;                               // 0x0558(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFaceGuardActive;                                // 0x0570(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_571[0x3];                                      // 0x0571(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         minFaceGuardDistance;                              // 0x0574(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BeginAnimationFrame;                               // 0x0578(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndAnimationFrame;                                 // 0x057C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationFrameRate;                                // 0x0580(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationPlayRate;                                 // 0x0584(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsWindActive;                                     // 0x0588(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_589[0x3];                                      // 0x0589(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WindMaxForce;                                      // 0x058C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindMaxDistance;                                   // 0x0590(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_594[0x4];                                      // 0x0594(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       SplineComponent;                                   // 0x0598(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          InstancedMeshComponent;                            // 0x05A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5A8[0x68];                                     // 0x05A8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Play(float BlendTime);
	void Stop(float BlendTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFeelerBarrierActor">();
	}
	static class AEndFeelerBarrierActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFeelerBarrierActor>();
	}
};
static_assert(alignof(AEndFeelerBarrierActor) == 0x000008, "Wrong alignment on AEndFeelerBarrierActor");
static_assert(sizeof(AEndFeelerBarrierActor) == 0x000610, "Wrong size on AEndFeelerBarrierActor");
static_assert(offsetof(AEndFeelerBarrierActor, InstanceCount) == 0x000470, "Member 'AEndFeelerBarrierActor::InstanceCount' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, LineCount) == 0x000474, "Member 'AEndFeelerBarrierActor::LineCount' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, EffectCount) == 0x000478, "Member 'AEndFeelerBarrierActor::EffectCount' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, EffectTemplate) == 0x000480, "Member 'AEndFeelerBarrierActor::EffectTemplate' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, RandomScaleRange) == 0x000488, "Member 'AEndFeelerBarrierActor::RandomScaleRange' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, bRefreshInstance) == 0x000490, "Member 'AEndFeelerBarrierActor::bRefreshInstance' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, InstanceContexts) == 0x000498, "Member 'AEndFeelerBarrierActor::InstanceContexts' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, HorizontalLoopTime) == 0x0004A8, "Member 'AEndFeelerBarrierActor::HorizontalLoopTime' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, VerticalHeightOffsetSize) == 0x0004B4, "Member 'AEndFeelerBarrierActor::VerticalHeightOffsetSize' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, VerticalHeightOffsetPow) == 0x0004B8, "Member 'AEndFeelerBarrierActor::VerticalHeightOffsetPow' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, PrimaryVerticalLoopTime) == 0x0004BC, "Member 'AEndFeelerBarrierActor::PrimaryVerticalLoopTime' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, PrimaryVerticalMoveSize) == 0x0004C8, "Member 'AEndFeelerBarrierActor::PrimaryVerticalMoveSize' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, SecondaryVerticalLoopTime) == 0x0004D4, "Member 'AEndFeelerBarrierActor::SecondaryVerticalLoopTime' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, SecondaryVerticalMoveSize) == 0x0004E0, "Member 'AEndFeelerBarrierActor::SecondaryVerticalMoveSize' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, PrimaryRollLoopTime) == 0x0004EC, "Member 'AEndFeelerBarrierActor::PrimaryRollLoopTime' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, PrimaryRollSize) == 0x0004F8, "Member 'AEndFeelerBarrierActor::PrimaryRollSize' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, SecondaryRollLoopTime) == 0x000504, "Member 'AEndFeelerBarrierActor::SecondaryRollLoopTime' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, SecondaryRollSize) == 0x000510, "Member 'AEndFeelerBarrierActor::SecondaryRollSize' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, ExtrusionDistanceMax) == 0x00051C, "Member 'AEndFeelerBarrierActor::ExtrusionDistanceMax' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, ExtrusionMoveDeltaMax) == 0x000520, "Member 'AEndFeelerBarrierActor::ExtrusionMoveDeltaMax' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, ExtrusionDistanceInterpSpeed) == 0x000524, "Member 'AEndFeelerBarrierActor::ExtrusionDistanceInterpSpeed' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, ExtrusionWaitTimeRange) == 0x000528, "Member 'AEndFeelerBarrierActor::ExtrusionWaitTimeRange' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, DeactiveUpSpeedRange) == 0x000530, "Member 'AEndFeelerBarrierActor::DeactiveUpSpeedRange' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, bInverseMovement) == 0x000538, "Member 'AEndFeelerBarrierActor::bInverseMovement' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, FadeInWaitTime) == 0x00053C, "Member 'AEndFeelerBarrierActor::FadeInWaitTime' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, OverrideFadeInTime) == 0x000540, "Member 'AEndFeelerBarrierActor::OverrideFadeInTime' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, OverrideFadeOutTime) == 0x000544, "Member 'AEndFeelerBarrierActor::OverrideFadeOutTime' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, SplinePointCount) == 0x000548, "Member 'AEndFeelerBarrierActor::SplinePointCount' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, SplinePointRadius) == 0x00054C, "Member 'AEndFeelerBarrierActor::SplinePointRadius' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, bRefreshSpline) == 0x000550, "Member 'AEndFeelerBarrierActor::bRefreshSpline' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, SplineDistanceCurve) == 0x000558, "Member 'AEndFeelerBarrierActor::SplineDistanceCurve' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, bIsFaceGuardActive) == 0x000570, "Member 'AEndFeelerBarrierActor::bIsFaceGuardActive' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, minFaceGuardDistance) == 0x000574, "Member 'AEndFeelerBarrierActor::minFaceGuardDistance' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, BeginAnimationFrame) == 0x000578, "Member 'AEndFeelerBarrierActor::BeginAnimationFrame' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, EndAnimationFrame) == 0x00057C, "Member 'AEndFeelerBarrierActor::EndAnimationFrame' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, AnimationFrameRate) == 0x000580, "Member 'AEndFeelerBarrierActor::AnimationFrameRate' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, AnimationPlayRate) == 0x000584, "Member 'AEndFeelerBarrierActor::AnimationPlayRate' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, bIsWindActive) == 0x000588, "Member 'AEndFeelerBarrierActor::bIsWindActive' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, WindMaxForce) == 0x00058C, "Member 'AEndFeelerBarrierActor::WindMaxForce' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, WindMaxDistance) == 0x000590, "Member 'AEndFeelerBarrierActor::WindMaxDistance' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, SplineComponent) == 0x000598, "Member 'AEndFeelerBarrierActor::SplineComponent' has a wrong offset!");
static_assert(offsetof(AEndFeelerBarrierActor, InstancedMeshComponent) == 0x0005A0, "Member 'AEndFeelerBarrierActor::InstancedMeshComponent' has a wrong offset!");

// Class EndGame.AnimNotify_EndOverridePhysicalConstraint
// 0x0010 (0x0040 - 0x0030)
class UAnimNotify_EndOverridePhysicalConstraint final : public UAnimNotifyState
{
public:
	class UEndPhysicalConstraintSetting*          Constraint;                                        // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndOverridePhysicalConstraint">();
	}
	static class UAnimNotify_EndOverridePhysicalConstraint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndOverridePhysicalConstraint>();
	}
};
static_assert(alignof(UAnimNotify_EndOverridePhysicalConstraint) == 0x000008, "Wrong alignment on UAnimNotify_EndOverridePhysicalConstraint");
static_assert(sizeof(UAnimNotify_EndOverridePhysicalConstraint) == 0x000040, "Wrong size on UAnimNotify_EndOverridePhysicalConstraint");
static_assert(offsetof(UAnimNotify_EndOverridePhysicalConstraint, Constraint) == 0x000030, "Member 'UAnimNotify_EndOverridePhysicalConstraint::Constraint' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndOverridePhysicalConstraint, BlendInTime) == 0x000038, "Member 'UAnimNotify_EndOverridePhysicalConstraint::BlendInTime' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndOverridePhysicalConstraint, BlendOutTime) == 0x00003C, "Member 'UAnimNotify_EndOverridePhysicalConstraint::BlendOutTime' has a wrong offset!");

// Class EndGame.AnimNotify_EndPhysicalConstraintMessage
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_EndPhysicalConstraintMessage final : public UAnimNotify
{
public:
	EEndPhysicalConstraintMessage                 Message;                                           // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Parameter0;                                        // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndPhysicalConstraintMessage">();
	}
	static class UAnimNotify_EndPhysicalConstraintMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndPhysicalConstraintMessage>();
	}
};
static_assert(alignof(UAnimNotify_EndPhysicalConstraintMessage) == 0x000008, "Wrong alignment on UAnimNotify_EndPhysicalConstraintMessage");
static_assert(sizeof(UAnimNotify_EndPhysicalConstraintMessage) == 0x000040, "Wrong size on UAnimNotify_EndPhysicalConstraintMessage");
static_assert(offsetof(UAnimNotify_EndPhysicalConstraintMessage, Message) == 0x000038, "Member 'UAnimNotify_EndPhysicalConstraintMessage::Message' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndPhysicalConstraintMessage, Parameter0) == 0x00003C, "Member 'UAnimNotify_EndPhysicalConstraintMessage::Parameter0' has a wrong offset!");

// Class EndGame.EndDataObjectResponseAreaInOut
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectResponseAreaInOut final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectResponseAreaInOut">();
	}
	static class UEndDataObjectResponseAreaInOut* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectResponseAreaInOut>();
	}
};
static_assert(alignof(UEndDataObjectResponseAreaInOut) == 0x000008, "Wrong alignment on UEndDataObjectResponseAreaInOut");
static_assert(sizeof(UEndDataObjectResponseAreaInOut) == 0x000088, "Wrong size on UEndDataObjectResponseAreaInOut");

// Class EndGame.EndBattleTalkEventTriggerBox
// 0x0008 (0x0388 - 0x0380)
class AEndBattleTalkEventTriggerBox final : public ATriggerBox
{
public:
	class FName                                   BattleSceneID;                                     // 0x0380(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleTalkEventTriggerBox">();
	}
	static class AEndBattleTalkEventTriggerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleTalkEventTriggerBox>();
	}
};
static_assert(alignof(AEndBattleTalkEventTriggerBox) == 0x000008, "Wrong alignment on AEndBattleTalkEventTriggerBox");
static_assert(sizeof(AEndBattleTalkEventTriggerBox) == 0x000388, "Wrong size on AEndBattleTalkEventTriggerBox");
static_assert(offsetof(AEndBattleTalkEventTriggerBox, BattleSceneID) == 0x000380, "Member 'AEndBattleTalkEventTriggerBox::BattleSceneID' has a wrong offset!");

// Class EndGame.AnimNotify_EndPlayParticleEffect
// 0x00B0 (0x00E0 - 0x0030)
class UAnimNotify_EndPlayParticleEffect final : public UAnimNotifyState
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        m_PSTemplate;                                      // 0x0080(0x0018)(Edit, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                m_LocationOffset;                                  // 0x0098(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               m_RotationOffset;                                  // 0x00A4(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         m_Attached : 1;                                    // 0x00B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         m_bDestroyWhenFinished : 1;                        // 0x00B0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         m_bIgnoreWhenFinished : 1;                         // 0x00B0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         m_bEnable : 1;                                     // 0x00B0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         m_bDisableVibrationVolumeSE : 1;                   // 0x00B0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   m_SocketName;                                      // 0x00B4(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   m_StoryFlagName;                                   // 0x00BC(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FEndPlayParticleActorInfo              m_CasterActorInfo;                                 // 0x00C4(0x000C)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPrivate)
	struct FEndPlayParticleActorInfo              m_TargetActorInfo;                                 // 0x00D0(0x000C)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndPlayParticleEffect">();
	}
	static class UAnimNotify_EndPlayParticleEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndPlayParticleEffect>();
	}
};
static_assert(alignof(UAnimNotify_EndPlayParticleEffect) == 0x000008, "Wrong alignment on UAnimNotify_EndPlayParticleEffect");
static_assert(sizeof(UAnimNotify_EndPlayParticleEffect) == 0x0000E0, "Wrong size on UAnimNotify_EndPlayParticleEffect");
static_assert(offsetof(UAnimNotify_EndPlayParticleEffect, m_PSTemplate) == 0x000080, "Member 'UAnimNotify_EndPlayParticleEffect::m_PSTemplate' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndPlayParticleEffect, m_LocationOffset) == 0x000098, "Member 'UAnimNotify_EndPlayParticleEffect::m_LocationOffset' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndPlayParticleEffect, m_RotationOffset) == 0x0000A4, "Member 'UAnimNotify_EndPlayParticleEffect::m_RotationOffset' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndPlayParticleEffect, m_SocketName) == 0x0000B4, "Member 'UAnimNotify_EndPlayParticleEffect::m_SocketName' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndPlayParticleEffect, m_StoryFlagName) == 0x0000BC, "Member 'UAnimNotify_EndPlayParticleEffect::m_StoryFlagName' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndPlayParticleEffect, m_CasterActorInfo) == 0x0000C4, "Member 'UAnimNotify_EndPlayParticleEffect::m_CasterActorInfo' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndPlayParticleEffect, m_TargetActorInfo) == 0x0000D0, "Member 'UAnimNotify_EndPlayParticleEffect::m_TargetActorInfo' has a wrong offset!");

// Class EndGame.AnimNotify_EndPoseMatching
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_EndPoseMatching final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndPoseMatching">();
	}
	static class UAnimNotify_EndPoseMatching* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndPoseMatching>();
	}
};
static_assert(alignof(UAnimNotify_EndPoseMatching) == 0x000008, "Wrong alignment on UAnimNotify_EndPoseMatching");
static_assert(sizeof(UAnimNotify_EndPoseMatching) == 0x000038, "Wrong size on UAnimNotify_EndPoseMatching");

// Class EndGame.EndBattleSummonTargetPoint
// 0x0070 (0x03E8 - 0x0378)
class AEndBattleSummonTargetPoint final : public ATargetPoint
{
public:
	bool                                          bSpawn_All;                                        // 0x0378(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawn_Ifrit;                                      // 0x0379(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawn_Chocobo;                                    // 0x037A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawn_Shiva;                                      // 0x037B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawn_Leviathan;                                  // 0x037C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawn_Bahamut;                                    // 0x037D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawn_DebuChoco;                                  // 0x037E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawn_Carbuncle;                                  // 0x037F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawn_Sabotender;                                 // 0x0380(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawn_BabyChocobo;                                // 0x0381(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawn_Ramuh;                                      // 0x0382(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWarp_Ifrit;                                       // 0x0383(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWarp_Chocobo;                                     // 0x0384(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWarp_Shiva;                                       // 0x0385(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWarp_Leviathan;                                   // 0x0386(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWarp_Bahamut;                                     // 0x0387(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWarp_DebuChoco;                                   // 0x0388(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWarp_Carbuncle;                                   // 0x0389(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWarp_Sabotender;                                  // 0x038A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWarp_BabyChocobo;                                 // 0x038B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWarp_Ramuh;                                       // 0x038C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCutScene;                                         // 0x038D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetLocation;                                    // 0x038E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOmen;                                             // 0x038F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLevelCutScene;                                    // 0x0390(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_391[0x7];                                      // 0x0391(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           BattleScenes;                                      // 0x0398(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 UnavailablePhase;                                  // 0x03A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bFreeze;                                           // 0x03B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B9[0x2F];                                     // 0x03B9(0x002F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleSummonTargetPoint">();
	}
	static class AEndBattleSummonTargetPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleSummonTargetPoint>();
	}
};
static_assert(alignof(AEndBattleSummonTargetPoint) == 0x000008, "Wrong alignment on AEndBattleSummonTargetPoint");
static_assert(sizeof(AEndBattleSummonTargetPoint) == 0x0003E8, "Wrong size on AEndBattleSummonTargetPoint");
static_assert(offsetof(AEndBattleSummonTargetPoint, bSpawn_All) == 0x000378, "Member 'AEndBattleSummonTargetPoint::bSpawn_All' has a wrong offset!");
static_assert(offsetof(AEndBattleSummonTargetPoint, bSpawn_Ifrit) == 0x000379, "Member 'AEndBattleSummonTargetPoint::bSpawn_Ifrit' has a wrong offset!");
static_assert(offsetof(AEndBattleSummonTargetPoint, bSpawn_Chocobo) == 0x00037A, "Member 'AEndBattleSummonTargetPoint::bSpawn_Chocobo' has a wrong offset!");
static_assert(offsetof(AEndBattleSummonTargetPoint, bSpawn_Shiva) == 0x00037B, "Member 'AEndBattleSummonTargetPoint::bSpawn_Shiva' has a wrong offset!");
static_assert(offsetof(AEndBattleSummonTargetPoint, bSpawn_Leviathan) == 0x00037C, "Member 'AEndBattleSummonTargetPoint::bSpawn_Leviathan' has a wrong offset!");
static_assert(offsetof(AEndBattleSummonTargetPoint, bSpawn_Bahamut) == 0x00037D, "Member 'AEndBattleSummonTargetPoint::bSpawn_Bahamut' has a wrong offset!");
static_assert(offsetof(AEndBattleSummonTargetPoint, bSpawn_DebuChoco) == 0x00037E, "Member 'AEndBattleSummonTargetPoint::bSpawn_DebuChoco' has a wrong offset!");
static_assert(offsetof(AEndBattleSummonTargetPoint, bSpawn_Carbuncle) == 0x00037F, "Member 'AEndBattleSummonTargetPoint::bSpawn_Carbuncle' has a wrong offset!");
static_assert(offsetof(AEndBattleSummonTargetPoint, bSpawn_Sabotender) == 0x000380, "Member 'AEndBattleSummonTargetPoint::bSpawn_Sabotender' has a wrong offset!");
static_assert(offsetof(AEndBattleSummonTargetPoint, bSpawn_BabyChocobo) == 0x000381, "Member 'AEndBattleSummonTargetPoint::bSpawn_BabyChocobo' has a wrong offset!");
static_assert(offsetof(AEndBattleSummonTargetPoint, bSpawn_Ramuh) == 0x000382, "Member 'AEndBattleSummonTargetPoint::bSpawn_Ramuh' has a wrong offset!");
static_assert(offsetof(AEndBattleSummonTargetPoint, bWarp_Ifrit) == 0x000383, "Member 'AEndBattleSummonTargetPoint::bWarp_Ifrit' has a wrong offset!");
static_assert(offsetof(AEndBattleSummonTargetPoint, bWarp_Chocobo) == 0x000384, "Member 'AEndBattleSummonTargetPoint::bWarp_Chocobo' has a wrong offset!");
static_assert(offsetof(AEndBattleSummonTargetPoint, bWarp_Shiva) == 0x000385, "Member 'AEndBattleSummonTargetPoint::bWarp_Shiva' has a wrong offset!");
static_assert(offsetof(AEndBattleSummonTargetPoint, bWarp_Leviathan) == 0x000386, "Member 'AEndBattleSummonTargetPoint::bWarp_Leviathan' has a wrong offset!");
static_assert(offsetof(AEndBattleSummonTargetPoint, bWarp_Bahamut) == 0x000387, "Member 'AEndBattleSummonTargetPoint::bWarp_Bahamut' has a wrong offset!");
static_assert(offsetof(AEndBattleSummonTargetPoint, bWarp_DebuChoco) == 0x000388, "Member 'AEndBattleSummonTargetPoint::bWarp_DebuChoco' has a wrong offset!");
static_assert(offsetof(AEndBattleSummonTargetPoint, bWarp_Carbuncle) == 0x000389, "Member 'AEndBattleSummonTargetPoint::bWarp_Carbuncle' has a wrong offset!");
static_assert(offsetof(AEndBattleSummonTargetPoint, bWarp_Sabotender) == 0x00038A, "Member 'AEndBattleSummonTargetPoint::bWarp_Sabotender' has a wrong offset!");
static_assert(offsetof(AEndBattleSummonTargetPoint, bWarp_BabyChocobo) == 0x00038B, "Member 'AEndBattleSummonTargetPoint::bWarp_BabyChocobo' has a wrong offset!");
static_assert(offsetof(AEndBattleSummonTargetPoint, bWarp_Ramuh) == 0x00038C, "Member 'AEndBattleSummonTargetPoint::bWarp_Ramuh' has a wrong offset!");
static_assert(offsetof(AEndBattleSummonTargetPoint, bCutScene) == 0x00038D, "Member 'AEndBattleSummonTargetPoint::bCutScene' has a wrong offset!");
static_assert(offsetof(AEndBattleSummonTargetPoint, bResetLocation) == 0x00038E, "Member 'AEndBattleSummonTargetPoint::bResetLocation' has a wrong offset!");
static_assert(offsetof(AEndBattleSummonTargetPoint, bOmen) == 0x00038F, "Member 'AEndBattleSummonTargetPoint::bOmen' has a wrong offset!");
static_assert(offsetof(AEndBattleSummonTargetPoint, bLevelCutScene) == 0x000390, "Member 'AEndBattleSummonTargetPoint::bLevelCutScene' has a wrong offset!");
static_assert(offsetof(AEndBattleSummonTargetPoint, BattleScenes) == 0x000398, "Member 'AEndBattleSummonTargetPoint::BattleScenes' has a wrong offset!");
static_assert(offsetof(AEndBattleSummonTargetPoint, UnavailablePhase) == 0x0003A8, "Member 'AEndBattleSummonTargetPoint::UnavailablePhase' has a wrong offset!");
static_assert(offsetof(AEndBattleSummonTargetPoint, bFreeze) == 0x0003B8, "Member 'AEndBattleSummonTargetPoint::bFreeze' has a wrong offset!");

// Class EndGame.EndMapJournalMenuWindow
// 0x0128 (0x0488 - 0x0360)
#pragma pack(push, 0x1)
class alignas(0x08) UEndMapJournalMenuWindow : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x128];                                    // 0x0360(0x0128)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMapJournalMenuWindow">();
	}
	static class UEndMapJournalMenuWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMapJournalMenuWindow>();
	}
};
#pragma pack(pop)
static_assert(alignof(UEndMapJournalMenuWindow) == 0x000008, "Wrong alignment on UEndMapJournalMenuWindow");
static_assert(sizeof(UEndMapJournalMenuWindow) == 0x000488, "Wrong size on UEndMapJournalMenuWindow");

// Class EndGame.EndQuestMenu
// 0x0058 (0x04E0 - 0x0488)
class UEndQuestMenu : public UEndMapJournalMenuWindow
{
public:
	uint8                                         Pad_488[0x50];                                     // 0x0488(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       CurrentAnimation;                                  // 0x04D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnQuestScrollBoxPressedItem(int32 ItemIndex);
	void OnQuestScrollBoxSetupItem(class UWidget* ItemWidget, int32 ItemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndQuestMenu">();
	}
	static class UEndQuestMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndQuestMenu>();
	}
};
static_assert(alignof(UEndQuestMenu) == 0x000008, "Wrong alignment on UEndQuestMenu");
static_assert(sizeof(UEndQuestMenu) == 0x0004E0, "Wrong size on UEndQuestMenu");
static_assert(offsetof(UEndQuestMenu, CurrentAnimation) == 0x0004D8, "Member 'UEndQuestMenu::CurrentAnimation' has a wrong offset!");

// Class EndGame.AnimNotify_EndReserveResetBonamikOnEndCutScene
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_EndReserveResetBonamikOnEndCutScene final : public UAnimNotify
{
public:
	bool                                          bResetPose;                                        // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PreRoll;                                           // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndReserveResetBonamikOnEndCutScene">();
	}
	static class UAnimNotify_EndReserveResetBonamikOnEndCutScene* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndReserveResetBonamikOnEndCutScene>();
	}
};
static_assert(alignof(UAnimNotify_EndReserveResetBonamikOnEndCutScene) == 0x000008, "Wrong alignment on UAnimNotify_EndReserveResetBonamikOnEndCutScene");
static_assert(sizeof(UAnimNotify_EndReserveResetBonamikOnEndCutScene) == 0x000040, "Wrong size on UAnimNotify_EndReserveResetBonamikOnEndCutScene");
static_assert(offsetof(UAnimNotify_EndReserveResetBonamikOnEndCutScene, bResetPose) == 0x000038, "Member 'UAnimNotify_EndReserveResetBonamikOnEndCutScene::bResetPose' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndReserveResetBonamikOnEndCutScene, PreRoll) == 0x00003C, "Member 'UAnimNotify_EndReserveResetBonamikOnEndCutScene::PreRoll' has a wrong offset!");

// Class EndGame.AnimNotify_EndSkipAnimIfLaunched
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_EndSkipAnimIfLaunched final : public UAnimNotify
{
public:
	float                                         BlendTime;                                         // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndSkipAnimIfLaunched">();
	}
	static class UAnimNotify_EndSkipAnimIfLaunched* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndSkipAnimIfLaunched>();
	}
};
static_assert(alignof(UAnimNotify_EndSkipAnimIfLaunched) == 0x000008, "Wrong alignment on UAnimNotify_EndSkipAnimIfLaunched");
static_assert(sizeof(UAnimNotify_EndSkipAnimIfLaunched) == 0x000040, "Wrong size on UAnimNotify_EndSkipAnimIfLaunched");
static_assert(offsetof(UAnimNotify_EndSkipAnimIfLaunched, BlendTime) == 0x000038, "Member 'UAnimNotify_EndSkipAnimIfLaunched::BlendTime' has a wrong offset!");

// Class EndGame.EndDataObjectShakeCharaProperty
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectShakeCharaProperty final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectShakeCharaProperty">();
	}
	static class UEndDataObjectShakeCharaProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectShakeCharaProperty>();
	}
};
static_assert(alignof(UEndDataObjectShakeCharaProperty) == 0x000008, "Wrong alignment on UEndDataObjectShakeCharaProperty");
static_assert(sizeof(UEndDataObjectShakeCharaProperty) == 0x000088, "Wrong size on UEndDataObjectShakeCharaProperty");

// Class EndGame.EndBikeAIControllerEnemyBase
// 0x0120 (0x0F80 - 0x0E60)
class AEndBikeAIControllerEnemyBase : public AEndBikeAIController
{
public:
	TArray<struct FEndBikeEnemySwitchAbilitySetByDamage> mSwitchAbilitySetByDamage;                         // 0x0E60(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E70[0x110];                                    // 0x0E70(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikeAIControllerEnemyBase">();
	}
	static class AEndBikeAIControllerEnemyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBikeAIControllerEnemyBase>();
	}
};
static_assert(alignof(AEndBikeAIControllerEnemyBase) == 0x000008, "Wrong alignment on AEndBikeAIControllerEnemyBase");
static_assert(sizeof(AEndBikeAIControllerEnemyBase) == 0x000F80, "Wrong size on AEndBikeAIControllerEnemyBase");
static_assert(offsetof(AEndBikeAIControllerEnemyBase, mSwitchAbilitySetByDamage) == 0x000E60, "Member 'AEndBikeAIControllerEnemyBase::mSwitchAbilitySetByDamage' has a wrong offset!");

// Class EndGame.EndPlayerStatusPanel
// 0x0010 (0x0370 - 0x0360)
class UEndPlayerStatusPanel : public UEndUserWidget
{
public:
	class UEndCanvasPanel*                        All_TopStatus_List;                                // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Nut_Sp;                                            // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnSetupStatusPanel(EPlayerType PlayerType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndPlayerStatusPanel">();
	}
	static class UEndPlayerStatusPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndPlayerStatusPanel>();
	}
};
static_assert(alignof(UEndPlayerStatusPanel) == 0x000008, "Wrong alignment on UEndPlayerStatusPanel");
static_assert(sizeof(UEndPlayerStatusPanel) == 0x000370, "Wrong size on UEndPlayerStatusPanel");
static_assert(offsetof(UEndPlayerStatusPanel, All_TopStatus_List) == 0x000360, "Member 'UEndPlayerStatusPanel::All_TopStatus_List' has a wrong offset!");
static_assert(offsetof(UEndPlayerStatusPanel, Nut_Sp) == 0x000368, "Member 'UEndPlayerStatusPanel::Nut_Sp' has a wrong offset!");

// Class EndGame.AnimNotify_EndUniquePhysicalConstraint
// 0x0010 (0x0040 - 0x0030)
class UAnimNotify_EndUniquePhysicalConstraint final : public UAnimNotifyState
{
public:
	class FName                                   UniqueSettingName;                                 // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPostSetting;                                      // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndUniquePhysicalConstraint">();
	}
	static class UAnimNotify_EndUniquePhysicalConstraint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndUniquePhysicalConstraint>();
	}
};
static_assert(alignof(UAnimNotify_EndUniquePhysicalConstraint) == 0x000008, "Wrong alignment on UAnimNotify_EndUniquePhysicalConstraint");
static_assert(sizeof(UAnimNotify_EndUniquePhysicalConstraint) == 0x000040, "Wrong size on UAnimNotify_EndUniquePhysicalConstraint");
static_assert(offsetof(UAnimNotify_EndUniquePhysicalConstraint, UniqueSettingName) == 0x000030, "Member 'UAnimNotify_EndUniquePhysicalConstraint::UniqueSettingName' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndUniquePhysicalConstraint, bPostSetting) == 0x000038, "Member 'UAnimNotify_EndUniquePhysicalConstraint::bPostSetting' has a wrong offset!");

// Class EndGame.AnimNotify_EndWeaponBoneAcceleration
// 0x0030 (0x0060 - 0x0030)
class UAnimNotify_EndWeaponBoneAcceleration final : public UAnimNotifyState
{
public:
	class FName                                   BoneName;                                          // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MaxVelocity;                                       // 0x0038(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               BeginAcceleration;                                 // 0x0044(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               EndAcceleration;                                   // 0x0050(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndWeaponBoneAcceleration">();
	}
	static class UAnimNotify_EndWeaponBoneAcceleration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndWeaponBoneAcceleration>();
	}
};
static_assert(alignof(UAnimNotify_EndWeaponBoneAcceleration) == 0x000008, "Wrong alignment on UAnimNotify_EndWeaponBoneAcceleration");
static_assert(sizeof(UAnimNotify_EndWeaponBoneAcceleration) == 0x000060, "Wrong size on UAnimNotify_EndWeaponBoneAcceleration");
static_assert(offsetof(UAnimNotify_EndWeaponBoneAcceleration, BoneName) == 0x000030, "Member 'UAnimNotify_EndWeaponBoneAcceleration::BoneName' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndWeaponBoneAcceleration, MaxVelocity) == 0x000038, "Member 'UAnimNotify_EndWeaponBoneAcceleration::MaxVelocity' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndWeaponBoneAcceleration, BeginAcceleration) == 0x000044, "Member 'UAnimNotify_EndWeaponBoneAcceleration::BeginAcceleration' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EndWeaponBoneAcceleration, EndAcceleration) == 0x000050, "Member 'UAnimNotify_EndWeaponBoneAcceleration::EndAcceleration' has a wrong offset!");

// Class EndGame.End3DAudioSimpleCylinderVisualizerComponent
// 0x0000 (0x00F8 - 0x00F8)
class UEnd3DAudioSimpleCylinderVisualizerComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"End3DAudioSimpleCylinderVisualizerComponent">();
	}
	static class UEnd3DAudioSimpleCylinderVisualizerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnd3DAudioSimpleCylinderVisualizerComponent>();
	}
};
static_assert(alignof(UEnd3DAudioSimpleCylinderVisualizerComponent) == 0x000008, "Wrong alignment on UEnd3DAudioSimpleCylinderVisualizerComponent");
static_assert(sizeof(UEnd3DAudioSimpleCylinderVisualizerComponent) == 0x0000F8, "Wrong size on UEnd3DAudioSimpleCylinderVisualizerComponent");

// Class EndGame.EndEmissiveControlActor
// 0x0008 (0x0380 - 0x0378)
class AEndEmissiveControlActor final : public AActor
{
public:
	class UEndEmissiveControlComponent*           ControllerComponent;                               // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void UpdateControllerComponent();

	class UEndEmissiveControlComponent* GetControllerComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEmissiveControlActor">();
	}
	static class AEndEmissiveControlActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndEmissiveControlActor>();
	}
};
static_assert(alignof(AEndEmissiveControlActor) == 0x000008, "Wrong alignment on AEndEmissiveControlActor");
static_assert(sizeof(AEndEmissiveControlActor) == 0x000380, "Wrong size on AEndEmissiveControlActor");
static_assert(offsetof(AEndEmissiveControlActor, ControllerComponent) == 0x000378, "Member 'AEndEmissiveControlActor::ControllerComponent' has a wrong offset!");

// Class EndGame.End3DAudioActor
// 0x00F0 (0x0468 - 0x0378)
class AEnd3DAudioActor final : public AActor
{
public:
	struct FEnd3DAudioSimpleCylinder              _rangeForUI;                                       // 0x0378(0x0038)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FEnd3DAudioSimpleCylinder              _rangeForReset;                                    // 0x03B0(0x0038)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class FName                                   _jbId;                                             // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _autoPlayDist;                                     // 0x03F0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEnd3DAudioActorUseType                       _useType;                                          // 0x03F4(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F5[0x3];                                      // 0x03F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _stateChangeObjectId;                              // 0x03F8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _playStopStateId;                                  // 0x0400(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _zerooneStateChangeObjectId;                       // 0x0408(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _setZerooneEnableStateId;                          // 0x0410(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAttenuation*                      _overwriteAttenuationSetting;                      // 0x0418(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_420[0x48];                                     // 0x0420(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"End3DAudioActor">();
	}
	static class AEnd3DAudioActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnd3DAudioActor>();
	}
};
static_assert(alignof(AEnd3DAudioActor) == 0x000008, "Wrong alignment on AEnd3DAudioActor");
static_assert(sizeof(AEnd3DAudioActor) == 0x000468, "Wrong size on AEnd3DAudioActor");
static_assert(offsetof(AEnd3DAudioActor, _rangeForUI) == 0x000378, "Member 'AEnd3DAudioActor::_rangeForUI' has a wrong offset!");
static_assert(offsetof(AEnd3DAudioActor, _rangeForReset) == 0x0003B0, "Member 'AEnd3DAudioActor::_rangeForReset' has a wrong offset!");
static_assert(offsetof(AEnd3DAudioActor, _jbId) == 0x0003E8, "Member 'AEnd3DAudioActor::_jbId' has a wrong offset!");
static_assert(offsetof(AEnd3DAudioActor, _autoPlayDist) == 0x0003F0, "Member 'AEnd3DAudioActor::_autoPlayDist' has a wrong offset!");
static_assert(offsetof(AEnd3DAudioActor, _useType) == 0x0003F4, "Member 'AEnd3DAudioActor::_useType' has a wrong offset!");
static_assert(offsetof(AEnd3DAudioActor, _stateChangeObjectId) == 0x0003F8, "Member 'AEnd3DAudioActor::_stateChangeObjectId' has a wrong offset!");
static_assert(offsetof(AEnd3DAudioActor, _playStopStateId) == 0x000400, "Member 'AEnd3DAudioActor::_playStopStateId' has a wrong offset!");
static_assert(offsetof(AEnd3DAudioActor, _zerooneStateChangeObjectId) == 0x000408, "Member 'AEnd3DAudioActor::_zerooneStateChangeObjectId' has a wrong offset!");
static_assert(offsetof(AEnd3DAudioActor, _setZerooneEnableStateId) == 0x000410, "Member 'AEnd3DAudioActor::_setZerooneEnableStateId' has a wrong offset!");
static_assert(offsetof(AEnd3DAudioActor, _overwriteAttenuationSetting) == 0x000418, "Member 'AEnd3DAudioActor::_overwriteAttenuationSetting' has a wrong offset!");

// Class EndGame.EndActionBreakBoxMiniGameBoxActor
// 0x0428 (0x07D0 - 0x03A8)
class AEndActionBreakBoxMiniGameBoxActor final : public AStaticMeshActor
{
public:
	struct FEndBreakBoxMiniGameBoxPhysicsSe       m_SeSetting_Normal;                                // 0x03A8(0x00B8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FEndBreakBoxMiniGameBoxPhysicsSe       m_SeSetting_HighGread;                             // 0x0460(0x00B8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FEndBreakBoxMiniGameBoxPhysicsSe       m_SeSetting_Ability;                               // 0x0518(0x00B8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EEndBreakBoxMiniGameBoxType                   m_BoxType;                                         // 0x05D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          m_bHighGreadL;                                     // 0x05D1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D2[0x2];                                      // 0x05D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         m_GroupIndex;                                      // 0x05D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         m_Radius;                                          // 0x05D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5DC[0x4];                                      // 0x05DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        m_Effect[0x4];                                     // 0x05E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_600[0x30];                                     // 0x0600(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   m_StaticMeshComponent[0xB];                        // 0x0630(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        m_EffectDummyPoint[0x4];                           // 0x0688(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6A8[0x70];                                     // 0x06A8(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class USQEXSEADSound*                         HitSoundAsset;                                     // 0x0718(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_720[0xB0];                                     // 0x0720(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EEndBreakBoxMiniGameBoxType ApplyBoxType();
	void Deactive_TimerFunc();
	EEndBreakBoxMiniGameBoxType GetBoxType();
	void Hit_TimerFunc();
	void OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnEndImpulseInterval();
	void PlayHitSe_TimerFunc();
	void SetEffectDummyPoint(EEndBreakBoxMiniGameEffect Type, class USceneComponent* Component);
	void SetImpulseRadius(float InRadius);
	void SetReferenceStaticMesh(EEndBreakBoxMiniGameBoxType Type, class UStaticMeshComponent* StaticMeshComp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndActionBreakBoxMiniGameBoxActor">();
	}
	static class AEndActionBreakBoxMiniGameBoxActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndActionBreakBoxMiniGameBoxActor>();
	}
};
static_assert(alignof(AEndActionBreakBoxMiniGameBoxActor) == 0x000008, "Wrong alignment on AEndActionBreakBoxMiniGameBoxActor");
static_assert(sizeof(AEndActionBreakBoxMiniGameBoxActor) == 0x0007D0, "Wrong size on AEndActionBreakBoxMiniGameBoxActor");
static_assert(offsetof(AEndActionBreakBoxMiniGameBoxActor, m_SeSetting_Normal) == 0x0003A8, "Member 'AEndActionBreakBoxMiniGameBoxActor::m_SeSetting_Normal' has a wrong offset!");
static_assert(offsetof(AEndActionBreakBoxMiniGameBoxActor, m_SeSetting_HighGread) == 0x000460, "Member 'AEndActionBreakBoxMiniGameBoxActor::m_SeSetting_HighGread' has a wrong offset!");
static_assert(offsetof(AEndActionBreakBoxMiniGameBoxActor, m_SeSetting_Ability) == 0x000518, "Member 'AEndActionBreakBoxMiniGameBoxActor::m_SeSetting_Ability' has a wrong offset!");
static_assert(offsetof(AEndActionBreakBoxMiniGameBoxActor, m_BoxType) == 0x0005D0, "Member 'AEndActionBreakBoxMiniGameBoxActor::m_BoxType' has a wrong offset!");
static_assert(offsetof(AEndActionBreakBoxMiniGameBoxActor, m_bHighGreadL) == 0x0005D1, "Member 'AEndActionBreakBoxMiniGameBoxActor::m_bHighGreadL' has a wrong offset!");
static_assert(offsetof(AEndActionBreakBoxMiniGameBoxActor, m_GroupIndex) == 0x0005D4, "Member 'AEndActionBreakBoxMiniGameBoxActor::m_GroupIndex' has a wrong offset!");
static_assert(offsetof(AEndActionBreakBoxMiniGameBoxActor, m_Radius) == 0x0005D8, "Member 'AEndActionBreakBoxMiniGameBoxActor::m_Radius' has a wrong offset!");
static_assert(offsetof(AEndActionBreakBoxMiniGameBoxActor, m_Effect) == 0x0005E0, "Member 'AEndActionBreakBoxMiniGameBoxActor::m_Effect' has a wrong offset!");
static_assert(offsetof(AEndActionBreakBoxMiniGameBoxActor, m_StaticMeshComponent) == 0x000630, "Member 'AEndActionBreakBoxMiniGameBoxActor::m_StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AEndActionBreakBoxMiniGameBoxActor, m_EffectDummyPoint) == 0x000688, "Member 'AEndActionBreakBoxMiniGameBoxActor::m_EffectDummyPoint' has a wrong offset!");
static_assert(offsetof(AEndActionBreakBoxMiniGameBoxActor, HitSoundAsset) == 0x000718, "Member 'AEndActionBreakBoxMiniGameBoxActor::HitSoundAsset' has a wrong offset!");

// Class EndGame.EndEnemyDetailWindow
// 0x0410 (0x0770 - 0x0360)
class UEndEnemyDetailWindow : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x410];                                    // 0x0360(0x0410)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAcquisionSetup(class UWidget* ItemWidget, int32 ItemIndex);
	void OnBattleAbilitySetup(class UWidget* ItemWidget, int32 ItemIndex);
	void OnBattleLogSetup(class UWidget* ItemWidget, int32 ItemIndex);
	void OnBufferSetup(class UWidget* ItemWidget, int32 ItemIndex);
	void OnBuffIconSetup(class UWidget* ItemWidget, int32 CellIndex);
	void OnDebuffIconSetup(class UWidget* ItemWidget, int32 CellIndex);
	void OnDropItemListSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnRareDropItemListSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnResistanceIconListSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnResistanceListSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnStealListSetupItem(class UWidget* ItemWidget, int32 CellIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnemyDetailWindow">();
	}
	static class UEndEnemyDetailWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnemyDetailWindow>();
	}
};
static_assert(alignof(UEndEnemyDetailWindow) == 0x000008, "Wrong alignment on UEndEnemyDetailWindow");
static_assert(sizeof(UEndEnemyDetailWindow) == 0x000770, "Wrong size on UEndEnemyDetailWindow");

// Class EndGame.EndActionMako5TimingInputArrowWidget
// 0x0010 (0x0370 - 0x0360)
class UEndActionMako5TimingInputArrowWidget final : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x10];                                     // 0x0360(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInAnimationFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndActionMako5TimingInputArrowWidget">();
	}
	static class UEndActionMako5TimingInputArrowWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndActionMako5TimingInputArrowWidget>();
	}
};
static_assert(alignof(UEndActionMako5TimingInputArrowWidget) == 0x000008, "Wrong alignment on UEndActionMako5TimingInputArrowWidget");
static_assert(sizeof(UEndActionMako5TimingInputArrowWidget) == 0x000370, "Wrong size on UEndActionMako5TimingInputArrowWidget");

// Class EndGame.EndFieldActionActorHeavyDoor
// 0x0088 (0x06A0 - 0x0618)
class AEndFieldActionActorHeavyDoor final : public AEndFieldActionActorBase
{
public:
	class FName                                   AnimationActorName;                                // 0x0618(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LongPushTime;                                      // 0x0620(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableForceAutoClose;                             // 0x0624(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_625[0x3];                                      // 0x0625(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndFieldActionTriggerComponent*        PressVolume;                                       // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        PullVolume;                                        // 0x0630(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndSwitchAreaBoxComponent*             DividedVersatileVolume;                            // 0x0638(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndSwitchAreaBoxComponent*             DividedImpassableVolume;                           // 0x0640(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndSwitchAreaBoxComponent*             OpendDoorVolumeLeft;                               // 0x0648(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndSwitchAreaBoxComponent*             OpendDoorVolumeRight;                              // 0x0650(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndSwitchAreaBoxComponent*             OpendDoorVolumeLeft2;                              // 0x0658(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndSwitchAreaBoxComponent*             OpendDoorVolumeRight2;                             // 0x0660(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0668(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_670[0x30];                                     // 0x0670(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorHeavyDoor">();
	}
	static class AEndFieldActionActorHeavyDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorHeavyDoor>();
	}
};
static_assert(alignof(AEndFieldActionActorHeavyDoor) == 0x000008, "Wrong alignment on AEndFieldActionActorHeavyDoor");
static_assert(sizeof(AEndFieldActionActorHeavyDoor) == 0x0006A0, "Wrong size on AEndFieldActionActorHeavyDoor");
static_assert(offsetof(AEndFieldActionActorHeavyDoor, AnimationActorName) == 0x000618, "Member 'AEndFieldActionActorHeavyDoor::AnimationActorName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorHeavyDoor, LongPushTime) == 0x000620, "Member 'AEndFieldActionActorHeavyDoor::LongPushTime' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorHeavyDoor, DisableForceAutoClose) == 0x000624, "Member 'AEndFieldActionActorHeavyDoor::DisableForceAutoClose' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorHeavyDoor, PressVolume) == 0x000628, "Member 'AEndFieldActionActorHeavyDoor::PressVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorHeavyDoor, PullVolume) == 0x000630, "Member 'AEndFieldActionActorHeavyDoor::PullVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorHeavyDoor, DividedVersatileVolume) == 0x000638, "Member 'AEndFieldActionActorHeavyDoor::DividedVersatileVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorHeavyDoor, DividedImpassableVolume) == 0x000640, "Member 'AEndFieldActionActorHeavyDoor::DividedImpassableVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorHeavyDoor, OpendDoorVolumeLeft) == 0x000648, "Member 'AEndFieldActionActorHeavyDoor::OpendDoorVolumeLeft' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorHeavyDoor, OpendDoorVolumeRight) == 0x000650, "Member 'AEndFieldActionActorHeavyDoor::OpendDoorVolumeRight' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorHeavyDoor, OpendDoorVolumeLeft2) == 0x000658, "Member 'AEndFieldActionActorHeavyDoor::OpendDoorVolumeLeft2' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorHeavyDoor, OpendDoorVolumeRight2) == 0x000660, "Member 'AEndFieldActionActorHeavyDoor::OpendDoorVolumeRight2' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorHeavyDoor, ModifierVolume) == 0x000668, "Member 'AEndFieldActionActorHeavyDoor::ModifierVolume' has a wrong offset!");

// Class EndGame.EndBikeAILoccheController
// 0x01B0 (0x1130 - 0x0F80)
class AEndBikeAILoccheController final : public AEndBikeAIControllerEnemyBase
{
public:
	uint8                                         Pad_F80[0x10];                                     // 0x0F80(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StateTriggerName_Sirius;                           // 0x0F90(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PlannerEventID_Sirius;                             // 0x0F98(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   StateTriggerName_1stStamp;                         // 0x0FA0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PlannerEventID_1stStamp;                           // 0x0FA8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   StateTriggerName_1stHitThunder;                    // 0x0FB0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PlannerEventID_1stHitThunder;                      // 0x0FB8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerSpeed_ChangeToProvoke;                       // 0x0FC0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerSpeed_ReturnToMelee;                         // 0x0FC4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Distance_ReturnToMelee;                            // 0x0FC8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FCC[0x4];                                      // 0x0FCC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBikeLoccheStateTriggerCondition> ProvokeStateTriggerConditions;                     // 0x0FD0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	EBikeLoccheAttackType                         InitialAttackType;                                 // 0x0FE0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FE1[0x3];                                      // 0x0FE1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AbilitySetID_Melee;                                // 0x0FE4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AbilitySetID_Smash;                                // 0x0FEC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AbilitySetID_Shot;                                 // 0x0FF4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Num_Melee_Min;                                     // 0x0FFC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Num_Melee_Max;                                     // 0x0FFD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Num_Smash;                                         // 0x0FFE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Num_ShortRangeAttack_ToSideChange;                 // 0x0FFF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Distance_SideChangeOffset;                         // 0x1000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Time_ChangeToLongRange;                            // 0x1004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Distance_LongRange_Max;                            // 0x1008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RunSpeed_LongRange;                                // 0x100C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RunSpeed_LongRange_Damaged;                        // 0x1010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Distance_ChangeToShortRange;                       // 0x1014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Time_ChangeToShortRange;                           // 0x1018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Rate_ChangeToPhase2;                               // 0x101C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PlannerEventID_Opening;                            // 0x1020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageRatio_DelayingPhase2;                        // 0x1028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AbilitySetID_Melee2;                               // 0x102C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AbilitySetID_Smash2;                               // 0x1034(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AbilitySetID_Provoke;                              // 0x103C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Num_Melee_Min_P2;                                  // 0x1044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Num_Melee_Max_P2;                                  // 0x1045(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Num_Smash_P2;                                      // 0x1046(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Num_ShortRangeAttack_ToSideChange_P2;              // 0x1047(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RunSpeed_Phase2;                                   // 0x1048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Distance_Phase2_Max;                               // 0x104C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Time_ChangeToStamp;                                // 0x1050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Distance_BeforeStamp;                              // 0x1054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RelativeSpeed_BeforeStamp;                         // 0x1058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InterpSpeed_RollBeforeStamp;                       // 0x105C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAngle_RollBeforeStamp;                          // 0x1060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1064[0x4];                                     // 0x1064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class FName>                DamageSourceReplaceSettings;                       // 0x1068(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FEndBikeAILoccheBreakBridge>    BreakBridgeParams;                                 // 0x10B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_10C8[0x68];                                    // 0x10C8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikeAILoccheController">();
	}
	static class AEndBikeAILoccheController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBikeAILoccheController>();
	}
};
static_assert(alignof(AEndBikeAILoccheController) == 0x000008, "Wrong alignment on AEndBikeAILoccheController");
static_assert(sizeof(AEndBikeAILoccheController) == 0x001130, "Wrong size on AEndBikeAILoccheController");
static_assert(offsetof(AEndBikeAILoccheController, StateTriggerName_Sirius) == 0x000F90, "Member 'AEndBikeAILoccheController::StateTriggerName_Sirius' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, PlannerEventID_Sirius) == 0x000F98, "Member 'AEndBikeAILoccheController::PlannerEventID_Sirius' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, StateTriggerName_1stStamp) == 0x000FA0, "Member 'AEndBikeAILoccheController::StateTriggerName_1stStamp' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, PlannerEventID_1stStamp) == 0x000FA8, "Member 'AEndBikeAILoccheController::PlannerEventID_1stStamp' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, StateTriggerName_1stHitThunder) == 0x000FB0, "Member 'AEndBikeAILoccheController::StateTriggerName_1stHitThunder' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, PlannerEventID_1stHitThunder) == 0x000FB8, "Member 'AEndBikeAILoccheController::PlannerEventID_1stHitThunder' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, PlayerSpeed_ChangeToProvoke) == 0x000FC0, "Member 'AEndBikeAILoccheController::PlayerSpeed_ChangeToProvoke' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, PlayerSpeed_ReturnToMelee) == 0x000FC4, "Member 'AEndBikeAILoccheController::PlayerSpeed_ReturnToMelee' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, Distance_ReturnToMelee) == 0x000FC8, "Member 'AEndBikeAILoccheController::Distance_ReturnToMelee' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, ProvokeStateTriggerConditions) == 0x000FD0, "Member 'AEndBikeAILoccheController::ProvokeStateTriggerConditions' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, InitialAttackType) == 0x000FE0, "Member 'AEndBikeAILoccheController::InitialAttackType' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, AbilitySetID_Melee) == 0x000FE4, "Member 'AEndBikeAILoccheController::AbilitySetID_Melee' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, AbilitySetID_Smash) == 0x000FEC, "Member 'AEndBikeAILoccheController::AbilitySetID_Smash' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, AbilitySetID_Shot) == 0x000FF4, "Member 'AEndBikeAILoccheController::AbilitySetID_Shot' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, Num_Melee_Min) == 0x000FFC, "Member 'AEndBikeAILoccheController::Num_Melee_Min' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, Num_Melee_Max) == 0x000FFD, "Member 'AEndBikeAILoccheController::Num_Melee_Max' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, Num_Smash) == 0x000FFE, "Member 'AEndBikeAILoccheController::Num_Smash' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, Num_ShortRangeAttack_ToSideChange) == 0x000FFF, "Member 'AEndBikeAILoccheController::Num_ShortRangeAttack_ToSideChange' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, Distance_SideChangeOffset) == 0x001000, "Member 'AEndBikeAILoccheController::Distance_SideChangeOffset' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, Time_ChangeToLongRange) == 0x001004, "Member 'AEndBikeAILoccheController::Time_ChangeToLongRange' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, Distance_LongRange_Max) == 0x001008, "Member 'AEndBikeAILoccheController::Distance_LongRange_Max' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, RunSpeed_LongRange) == 0x00100C, "Member 'AEndBikeAILoccheController::RunSpeed_LongRange' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, RunSpeed_LongRange_Damaged) == 0x001010, "Member 'AEndBikeAILoccheController::RunSpeed_LongRange_Damaged' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, Distance_ChangeToShortRange) == 0x001014, "Member 'AEndBikeAILoccheController::Distance_ChangeToShortRange' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, Time_ChangeToShortRange) == 0x001018, "Member 'AEndBikeAILoccheController::Time_ChangeToShortRange' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, Rate_ChangeToPhase2) == 0x00101C, "Member 'AEndBikeAILoccheController::Rate_ChangeToPhase2' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, PlannerEventID_Opening) == 0x001020, "Member 'AEndBikeAILoccheController::PlannerEventID_Opening' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, DamageRatio_DelayingPhase2) == 0x001028, "Member 'AEndBikeAILoccheController::DamageRatio_DelayingPhase2' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, AbilitySetID_Melee2) == 0x00102C, "Member 'AEndBikeAILoccheController::AbilitySetID_Melee2' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, AbilitySetID_Smash2) == 0x001034, "Member 'AEndBikeAILoccheController::AbilitySetID_Smash2' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, AbilitySetID_Provoke) == 0x00103C, "Member 'AEndBikeAILoccheController::AbilitySetID_Provoke' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, Num_Melee_Min_P2) == 0x001044, "Member 'AEndBikeAILoccheController::Num_Melee_Min_P2' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, Num_Melee_Max_P2) == 0x001045, "Member 'AEndBikeAILoccheController::Num_Melee_Max_P2' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, Num_Smash_P2) == 0x001046, "Member 'AEndBikeAILoccheController::Num_Smash_P2' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, Num_ShortRangeAttack_ToSideChange_P2) == 0x001047, "Member 'AEndBikeAILoccheController::Num_ShortRangeAttack_ToSideChange_P2' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, RunSpeed_Phase2) == 0x001048, "Member 'AEndBikeAILoccheController::RunSpeed_Phase2' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, Distance_Phase2_Max) == 0x00104C, "Member 'AEndBikeAILoccheController::Distance_Phase2_Max' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, Time_ChangeToStamp) == 0x001050, "Member 'AEndBikeAILoccheController::Time_ChangeToStamp' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, Distance_BeforeStamp) == 0x001054, "Member 'AEndBikeAILoccheController::Distance_BeforeStamp' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, RelativeSpeed_BeforeStamp) == 0x001058, "Member 'AEndBikeAILoccheController::RelativeSpeed_BeforeStamp' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, InterpSpeed_RollBeforeStamp) == 0x00105C, "Member 'AEndBikeAILoccheController::InterpSpeed_RollBeforeStamp' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, MaxAngle_RollBeforeStamp) == 0x001060, "Member 'AEndBikeAILoccheController::MaxAngle_RollBeforeStamp' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, DamageSourceReplaceSettings) == 0x001068, "Member 'AEndBikeAILoccheController::DamageSourceReplaceSettings' has a wrong offset!");
static_assert(offsetof(AEndBikeAILoccheController, BreakBridgeParams) == 0x0010B8, "Member 'AEndBikeAILoccheController::BreakBridgeParams' has a wrong offset!");

// Class EndGame.UEndBTTask_FindRelocationPoint
// 0x0008 (0x0078 - 0x0070)
class UUEndBTTask_FindRelocationPoint final : public UBTTaskNode
{
public:
	class FName                                   RelocationPointBlackBoardName;                     // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UEndBTTask_FindRelocationPoint">();
	}
	static class UUEndBTTask_FindRelocationPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUEndBTTask_FindRelocationPoint>();
	}
};
static_assert(alignof(UUEndBTTask_FindRelocationPoint) == 0x000008, "Wrong alignment on UUEndBTTask_FindRelocationPoint");
static_assert(sizeof(UUEndBTTask_FindRelocationPoint) == 0x000078, "Wrong size on UUEndBTTask_FindRelocationPoint");
static_assert(offsetof(UUEndBTTask_FindRelocationPoint, RelocationPointBlackBoardName) == 0x000070, "Member 'UUEndBTTask_FindRelocationPoint::RelocationPointBlackBoardName' has a wrong offset!");

// Class EndGame.EndActionMako5TimingInputWidget
// 0x0058 (0x03B8 - 0x0360)
class UEndActionMako5TimingInputWidget final : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x58];                                     // 0x0360(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMainGuideAnimationFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndActionMako5TimingInputWidget">();
	}
	static class UEndActionMako5TimingInputWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndActionMako5TimingInputWidget>();
	}
};
static_assert(alignof(UEndActionMako5TimingInputWidget) == 0x000008, "Wrong alignment on UEndActionMako5TimingInputWidget");
static_assert(sizeof(UEndActionMako5TimingInputWidget) == 0x0003B8, "Wrong size on UEndActionMako5TimingInputWidget");

// Class EndGame.EndActionSlum7DartsRankWindowWidget
// 0x0048 (0x03A8 - 0x0360)
class UEndActionSlum7DartsRankWindowWidget final : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x28];                                     // 0x0360(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 InMiniGame;                                        // 0x0388(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InAction;                                          // 0x0398(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnSetupItems(class UWidget* ItemWidget, int32 Index_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndActionSlum7DartsRankWindowWidget">();
	}
	static class UEndActionSlum7DartsRankWindowWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndActionSlum7DartsRankWindowWidget>();
	}
};
static_assert(alignof(UEndActionSlum7DartsRankWindowWidget) == 0x000008, "Wrong alignment on UEndActionSlum7DartsRankWindowWidget");
static_assert(sizeof(UEndActionSlum7DartsRankWindowWidget) == 0x0003A8, "Wrong size on UEndActionSlum7DartsRankWindowWidget");
static_assert(offsetof(UEndActionSlum7DartsRankWindowWidget, InMiniGame) == 0x000388, "Member 'UEndActionSlum7DartsRankWindowWidget::InMiniGame' has a wrong offset!");
static_assert(offsetof(UEndActionSlum7DartsRankWindowWidget, InAction) == 0x000398, "Member 'UEndActionSlum7DartsRankWindowWidget::InAction' has a wrong offset!");

// Class EndGame.EndEnvironmentStaticMeshActor
// 0x0038 (0x03E0 - 0x03A8)
class AEndEnvironmentStaticMeshActor : public AStaticMeshActor
{
public:
	uint8                                         Pad_3A8[0x10];                                     // 0x03A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableSeeThroughSkillCamera;                      // 0x03B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B9[0x27];                                     // 0x03B9(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvironmentStaticMeshActor">();
	}
	static class AEndEnvironmentStaticMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndEnvironmentStaticMeshActor>();
	}
};
static_assert(alignof(AEndEnvironmentStaticMeshActor) == 0x000008, "Wrong alignment on AEndEnvironmentStaticMeshActor");
static_assert(sizeof(AEndEnvironmentStaticMeshActor) == 0x0003E0, "Wrong size on AEndEnvironmentStaticMeshActor");
static_assert(offsetof(AEndEnvironmentStaticMeshActor, bEnableSeeThroughSkillCamera) == 0x0003B8, "Member 'AEndEnvironmentStaticMeshActor::bEnableSeeThroughSkillCamera' has a wrong offset!");

// Class EndGame.EndFieldActionActorHookShotChild
// 0x0030 (0x0648 - 0x0618)
class AEndFieldActionActorHookShotChild final : public AEndFieldActionActorBase
{
public:
	class UEndFieldActionTriggerComponent*        PressVolume;                                       // 0x0618(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndHoocShotTriggerComponent*           TargetVolume;                                      // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        ArrivalVolume;                                     // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0630(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_638[0x10];                                     // 0x0638(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorHookShotChild">();
	}
	static class AEndFieldActionActorHookShotChild* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorHookShotChild>();
	}
};
static_assert(alignof(AEndFieldActionActorHookShotChild) == 0x000008, "Wrong alignment on AEndFieldActionActorHookShotChild");
static_assert(sizeof(AEndFieldActionActorHookShotChild) == 0x000648, "Wrong size on AEndFieldActionActorHookShotChild");
static_assert(offsetof(AEndFieldActionActorHookShotChild, PressVolume) == 0x000618, "Member 'AEndFieldActionActorHookShotChild::PressVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorHookShotChild, TargetVolume) == 0x000620, "Member 'AEndFieldActionActorHookShotChild::TargetVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorHookShotChild, ArrivalVolume) == 0x000628, "Member 'AEndFieldActionActorHookShotChild::ArrivalVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorHookShotChild, ModifierVolume) == 0x000630, "Member 'AEndFieldActionActorHookShotChild::ModifierVolume' has a wrong offset!");

// Class EndGame.EndBattleDamageSourceComponentBubble
// 0x0070 (0x04D0 - 0x0460)
class UEndBattleDamageSourceComponentBubble final : public UEndBattleDamageSourceComponent
{
public:
	uint8                                         Pad_460[0x70];                                     // 0x0460(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleDamageSourceComponentBubble">();
	}
	static class UEndBattleDamageSourceComponentBubble* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleDamageSourceComponentBubble>();
	}
};
static_assert(alignof(UEndBattleDamageSourceComponentBubble) == 0x000008, "Wrong alignment on UEndBattleDamageSourceComponentBubble");
static_assert(sizeof(UEndBattleDamageSourceComponentBubble) == 0x0004D0, "Wrong size on UEndBattleDamageSourceComponentBubble");

// Class EndGame.EndWeaponUpgradeCircleGauge
// 0x00D0 (0x0430 - 0x0360)
class UEndWeaponUpgradeCircleGauge : public UEndUserWidget
{
public:
	class UEndCanvasPanel*                        SpLv2;                                             // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        SpLv3;                                             // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        SpLv4;                                             // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        SpLv5;                                             // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        SpLv6;                                             // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        SpInfoBox;                                         // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndUserWidget*                         Gauge1;                                            // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_TotalSp;                                       // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndUserWidget*                         Gauge2;                                            // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_NextLv_2;                                      // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_LvSp_2;                                        // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndUserWidget*                         Gauge3;                                            // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_NextLv_3;                                      // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_LvSp_3;                                        // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndUserWidget*                         Gauge4;                                            // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_NextLv_4;                                      // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_LvSp_4;                                        // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndUserWidget*                         Gauge5;                                            // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_NextLv_5;                                      // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_LvSp_5;                                        // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndUserWidget*                         Gauge6;                                            // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_NextLv_6;                                      // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_LvSp_6;                                        // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_LvMax;                                         // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndImage*                              Img_Slash_6;                                       // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Level;                                         // 0x0428(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndWeaponUpgradeCircleGauge">();
	}
	static class UEndWeaponUpgradeCircleGauge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndWeaponUpgradeCircleGauge>();
	}
};
static_assert(alignof(UEndWeaponUpgradeCircleGauge) == 0x000008, "Wrong alignment on UEndWeaponUpgradeCircleGauge");
static_assert(sizeof(UEndWeaponUpgradeCircleGauge) == 0x000430, "Wrong size on UEndWeaponUpgradeCircleGauge");
static_assert(offsetof(UEndWeaponUpgradeCircleGauge, SpLv2) == 0x000360, "Member 'UEndWeaponUpgradeCircleGauge::SpLv2' has a wrong offset!");
static_assert(offsetof(UEndWeaponUpgradeCircleGauge, SpLv3) == 0x000368, "Member 'UEndWeaponUpgradeCircleGauge::SpLv3' has a wrong offset!");
static_assert(offsetof(UEndWeaponUpgradeCircleGauge, SpLv4) == 0x000370, "Member 'UEndWeaponUpgradeCircleGauge::SpLv4' has a wrong offset!");
static_assert(offsetof(UEndWeaponUpgradeCircleGauge, SpLv5) == 0x000378, "Member 'UEndWeaponUpgradeCircleGauge::SpLv5' has a wrong offset!");
static_assert(offsetof(UEndWeaponUpgradeCircleGauge, SpLv6) == 0x000380, "Member 'UEndWeaponUpgradeCircleGauge::SpLv6' has a wrong offset!");
static_assert(offsetof(UEndWeaponUpgradeCircleGauge, SpInfoBox) == 0x000388, "Member 'UEndWeaponUpgradeCircleGauge::SpInfoBox' has a wrong offset!");
static_assert(offsetof(UEndWeaponUpgradeCircleGauge, Gauge1) == 0x000390, "Member 'UEndWeaponUpgradeCircleGauge::Gauge1' has a wrong offset!");
static_assert(offsetof(UEndWeaponUpgradeCircleGauge, Txt_TotalSp) == 0x000398, "Member 'UEndWeaponUpgradeCircleGauge::Txt_TotalSp' has a wrong offset!");
static_assert(offsetof(UEndWeaponUpgradeCircleGauge, Gauge2) == 0x0003A0, "Member 'UEndWeaponUpgradeCircleGauge::Gauge2' has a wrong offset!");
static_assert(offsetof(UEndWeaponUpgradeCircleGauge, Txt_NextLv_2) == 0x0003A8, "Member 'UEndWeaponUpgradeCircleGauge::Txt_NextLv_2' has a wrong offset!");
static_assert(offsetof(UEndWeaponUpgradeCircleGauge, Txt_LvSp_2) == 0x0003B0, "Member 'UEndWeaponUpgradeCircleGauge::Txt_LvSp_2' has a wrong offset!");
static_assert(offsetof(UEndWeaponUpgradeCircleGauge, Gauge3) == 0x0003B8, "Member 'UEndWeaponUpgradeCircleGauge::Gauge3' has a wrong offset!");
static_assert(offsetof(UEndWeaponUpgradeCircleGauge, Txt_NextLv_3) == 0x0003C0, "Member 'UEndWeaponUpgradeCircleGauge::Txt_NextLv_3' has a wrong offset!");
static_assert(offsetof(UEndWeaponUpgradeCircleGauge, Txt_LvSp_3) == 0x0003C8, "Member 'UEndWeaponUpgradeCircleGauge::Txt_LvSp_3' has a wrong offset!");
static_assert(offsetof(UEndWeaponUpgradeCircleGauge, Gauge4) == 0x0003D0, "Member 'UEndWeaponUpgradeCircleGauge::Gauge4' has a wrong offset!");
static_assert(offsetof(UEndWeaponUpgradeCircleGauge, Txt_NextLv_4) == 0x0003D8, "Member 'UEndWeaponUpgradeCircleGauge::Txt_NextLv_4' has a wrong offset!");
static_assert(offsetof(UEndWeaponUpgradeCircleGauge, Txt_LvSp_4) == 0x0003E0, "Member 'UEndWeaponUpgradeCircleGauge::Txt_LvSp_4' has a wrong offset!");
static_assert(offsetof(UEndWeaponUpgradeCircleGauge, Gauge5) == 0x0003E8, "Member 'UEndWeaponUpgradeCircleGauge::Gauge5' has a wrong offset!");
static_assert(offsetof(UEndWeaponUpgradeCircleGauge, Txt_NextLv_5) == 0x0003F0, "Member 'UEndWeaponUpgradeCircleGauge::Txt_NextLv_5' has a wrong offset!");
static_assert(offsetof(UEndWeaponUpgradeCircleGauge, Txt_LvSp_5) == 0x0003F8, "Member 'UEndWeaponUpgradeCircleGauge::Txt_LvSp_5' has a wrong offset!");
static_assert(offsetof(UEndWeaponUpgradeCircleGauge, Gauge6) == 0x000400, "Member 'UEndWeaponUpgradeCircleGauge::Gauge6' has a wrong offset!");
static_assert(offsetof(UEndWeaponUpgradeCircleGauge, Txt_NextLv_6) == 0x000408, "Member 'UEndWeaponUpgradeCircleGauge::Txt_NextLv_6' has a wrong offset!");
static_assert(offsetof(UEndWeaponUpgradeCircleGauge, Txt_LvSp_6) == 0x000410, "Member 'UEndWeaponUpgradeCircleGauge::Txt_LvSp_6' has a wrong offset!");
static_assert(offsetof(UEndWeaponUpgradeCircleGauge, Txt_LvMax) == 0x000418, "Member 'UEndWeaponUpgradeCircleGauge::Txt_LvMax' has a wrong offset!");
static_assert(offsetof(UEndWeaponUpgradeCircleGauge, Img_Slash_6) == 0x000420, "Member 'UEndWeaponUpgradeCircleGauge::Img_Slash_6' has a wrong offset!");
static_assert(offsetof(UEndWeaponUpgradeCircleGauge, Txt_Level) == 0x000428, "Member 'UEndWeaponUpgradeCircleGauge::Txt_Level' has a wrong offset!");

// Class EndGame.EndActiveTimeGaugeIcon
// 0x0058 (0x03B8 - 0x0360)
class UEndActiveTimeGaugeIcon : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x58];                                     // 0x0360(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndActiveTimeGaugeIcon">();
	}
	static class UEndActiveTimeGaugeIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndActiveTimeGaugeIcon>();
	}
};
static_assert(alignof(UEndActiveTimeGaugeIcon) == 0x000008, "Wrong alignment on UEndActiveTimeGaugeIcon");
static_assert(sizeof(UEndActiveTimeGaugeIcon) == 0x0003B8, "Wrong size on UEndActiveTimeGaugeIcon");

// Class EndGame.EndBikeTriggerBox
// 0x0048 (0x03C8 - 0x0380)
class AEndBikeTriggerBox final : public ATriggerBox
{
public:
	EEndBikeTriggerBoxType                        Type;                                              // 0x0380(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_381[0x7];                                      // 0x0381(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Keys;                                              // 0x0388(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           TargetIds;                                         // 0x0398(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A8[0x20];                                     // 0x03A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikeTriggerBox">();
	}
	static class AEndBikeTriggerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBikeTriggerBox>();
	}
};
static_assert(alignof(AEndBikeTriggerBox) == 0x000008, "Wrong alignment on AEndBikeTriggerBox");
static_assert(sizeof(AEndBikeTriggerBox) == 0x0003C8, "Wrong size on AEndBikeTriggerBox");
static_assert(offsetof(AEndBikeTriggerBox, Type) == 0x000380, "Member 'AEndBikeTriggerBox::Type' has a wrong offset!");
static_assert(offsetof(AEndBikeTriggerBox, Keys) == 0x000388, "Member 'AEndBikeTriggerBox::Keys' has a wrong offset!");
static_assert(offsetof(AEndBikeTriggerBox, TargetIds) == 0x000398, "Member 'AEndBikeTriggerBox::TargetIds' has a wrong offset!");

// Class EndGame.EndActivityAPI
// 0x0000 (0x0028 - 0x0028)
class UEndActivityAPI final : public UBlueprintFunctionLibrary
{
public:
	static void ActivityInit(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	static EEndActivityInitResult GetActivityInitResult();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndActivityAPI">();
	}
	static class UEndActivityAPI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndActivityAPI>();
	}
};
static_assert(alignof(UEndActivityAPI) == 0x000008, "Wrong alignment on UEndActivityAPI");
static_assert(sizeof(UEndActivityAPI) == 0x000028, "Wrong size on UEndActivityAPI");

// Class EndGame.EndFootAttributeComponent
// 0x00B8 (0x01B0 - 0x00F8)
class UEndFootAttributeComponent final : public UActorComponent
{
public:
	class USQEXSEADSound*                         SoundBank;                                         // 0x00F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USQEXSEADAutoSeComponentSetting*        SettingData;                                       // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USQEXSEADAutoSeDetectionSetting*        DetectionSetting;                                  // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndAutoSeComponentSoundIndexTable*     SoundIndexTable;                                   // 0x0110(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USQEXSEADAutoSeComponent*               AutoSeComponent;                                   // 0x0118(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndAutoSeCallback*                     AutoSeCallback;                                    // 0x0120(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabledFootAttribute;                             // 0x0128(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x87];                                     // 0x0129(0x0087)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFootAttributeComponent">();
	}
	static class UEndFootAttributeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndFootAttributeComponent>();
	}
};
static_assert(alignof(UEndFootAttributeComponent) == 0x000008, "Wrong alignment on UEndFootAttributeComponent");
static_assert(sizeof(UEndFootAttributeComponent) == 0x0001B0, "Wrong size on UEndFootAttributeComponent");
static_assert(offsetof(UEndFootAttributeComponent, SoundBank) == 0x0000F8, "Member 'UEndFootAttributeComponent::SoundBank' has a wrong offset!");
static_assert(offsetof(UEndFootAttributeComponent, SettingData) == 0x000100, "Member 'UEndFootAttributeComponent::SettingData' has a wrong offset!");
static_assert(offsetof(UEndFootAttributeComponent, DetectionSetting) == 0x000108, "Member 'UEndFootAttributeComponent::DetectionSetting' has a wrong offset!");
static_assert(offsetof(UEndFootAttributeComponent, SoundIndexTable) == 0x000110, "Member 'UEndFootAttributeComponent::SoundIndexTable' has a wrong offset!");
static_assert(offsetof(UEndFootAttributeComponent, AutoSeComponent) == 0x000118, "Member 'UEndFootAttributeComponent::AutoSeComponent' has a wrong offset!");
static_assert(offsetof(UEndFootAttributeComponent, AutoSeCallback) == 0x000120, "Member 'UEndFootAttributeComponent::AutoSeCallback' has a wrong offset!");
static_assert(offsetof(UEndFootAttributeComponent, bEnabledFootAttribute) == 0x000128, "Member 'UEndFootAttributeComponent::bEnabledFootAttribute' has a wrong offset!");

// Class EndGame.EndBikePlayerController
// 0x04D0 (0x04F8 - 0x0028)
class UEndBikePlayerController final : public UObject
{
public:
	uint8                                         Pad_28[0x4D0];                                     // 0x0028(0x04D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikePlayerController">();
	}
	static class UEndBikePlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBikePlayerController>();
	}
};
static_assert(alignof(UEndBikePlayerController) == 0x000008, "Wrong alignment on UEndBikePlayerController");
static_assert(sizeof(UEndBikePlayerController) == 0x0004F8, "Wrong size on UEndBikePlayerController");

// Class EndGame.EndActorBaseInterface
// 0x0000 (0x0028 - 0x0028)
class IEndActorBaseInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndActorBaseInterface">();
	}
	static class IEndActorBaseInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEndActorBaseInterface>();
	}
};
static_assert(alignof(IEndActorBaseInterface) == 0x000008, "Wrong alignment on IEndActorBaseInterface");
static_assert(sizeof(IEndActorBaseInterface) == 0x000028, "Wrong size on IEndActorBaseInterface");

// Class EndGame.EndActorInterface
// 0x0000 (0x0028 - 0x0028)
class IEndActorInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndActorInterface">();
	}
	static class IEndActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEndActorInterface>();
	}
};
static_assert(alignof(IEndActorInterface) == 0x000008, "Wrong alignment on IEndActorInterface");
static_assert(sizeof(IEndActorInterface) == 0x000028, "Wrong size on IEndActorInterface");

// Class EndGame.EndBikeScoreComponent
// 0x0068 (0x0160 - 0x00F8)
class UEndBikeScoreComponent final : public UActorComponent
{
public:
	uint8                                         Pad_F8[0x68];                                      // 0x00F8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikeScoreComponent">();
	}
	static class UEndBikeScoreComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBikeScoreComponent>();
	}
};
static_assert(alignof(UEndBikeScoreComponent) == 0x000008, "Wrong alignment on UEndBikeScoreComponent");
static_assert(sizeof(UEndBikeScoreComponent) == 0x000160, "Wrong size on UEndBikeScoreComponent");

// Class EndGame.EndAerialNavAreaVolume
// 0x0238 (0x05B0 - 0x0378)
class AEndAerialNavAreaVolume final : public AActor
{
public:
	TArray<class FName>                           BattleSceneID;                                     // 0x0378(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	int32                                         X_POINT_MAX;                                       // 0x0388(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Y_POINT_MAX;                                       // 0x038C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Z_POINT_MAX;                                       // 0x0390(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          EnableEqualInterval;                               // 0x0394(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          CanEverAffectNavigation;                           // 0x0395(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsAffectedBattleArea;                              // 0x0396(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          NotCheckCollision;                                 // 0x0397(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          NotCheckGameCameraCollision;                       // 0x0398(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_399[0x3];                                      // 0x0399(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         X_CM_SPACE_MAX;                                    // 0x039C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Y_CM_SPACE_MAX;                                    // 0x03A0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Z_CM_SPACE_MAX;                                    // 0x03A4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndAerialNavBoxComponent*              EndArealNavBox;                                    // 0x03A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBox                                   AABB;                                              // 0x03B0(0x001C)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3CC[0x4];                                      // 0x03CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAerialPointData>               PointDataList;                                     // 0x03D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         XPointNum;                                         // 0x03E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         YPointNum;                                         // 0x03E1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         ZPointNum;                                         // 0x03E2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E3[0x1];                                      // 0x03E3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        PointMaxNum;                                       // 0x03E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E8[0x1C8];                                    // 0x03E8(0x01C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAerialNavAreaVolume">();
	}
	static class AEndAerialNavAreaVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndAerialNavAreaVolume>();
	}
};
static_assert(alignof(AEndAerialNavAreaVolume) == 0x000008, "Wrong alignment on AEndAerialNavAreaVolume");
static_assert(sizeof(AEndAerialNavAreaVolume) == 0x0005B0, "Wrong size on AEndAerialNavAreaVolume");
static_assert(offsetof(AEndAerialNavAreaVolume, BattleSceneID) == 0x000378, "Member 'AEndAerialNavAreaVolume::BattleSceneID' has a wrong offset!");
static_assert(offsetof(AEndAerialNavAreaVolume, X_POINT_MAX) == 0x000388, "Member 'AEndAerialNavAreaVolume::X_POINT_MAX' has a wrong offset!");
static_assert(offsetof(AEndAerialNavAreaVolume, Y_POINT_MAX) == 0x00038C, "Member 'AEndAerialNavAreaVolume::Y_POINT_MAX' has a wrong offset!");
static_assert(offsetof(AEndAerialNavAreaVolume, Z_POINT_MAX) == 0x000390, "Member 'AEndAerialNavAreaVolume::Z_POINT_MAX' has a wrong offset!");
static_assert(offsetof(AEndAerialNavAreaVolume, EnableEqualInterval) == 0x000394, "Member 'AEndAerialNavAreaVolume::EnableEqualInterval' has a wrong offset!");
static_assert(offsetof(AEndAerialNavAreaVolume, CanEverAffectNavigation) == 0x000395, "Member 'AEndAerialNavAreaVolume::CanEverAffectNavigation' has a wrong offset!");
static_assert(offsetof(AEndAerialNavAreaVolume, IsAffectedBattleArea) == 0x000396, "Member 'AEndAerialNavAreaVolume::IsAffectedBattleArea' has a wrong offset!");
static_assert(offsetof(AEndAerialNavAreaVolume, NotCheckCollision) == 0x000397, "Member 'AEndAerialNavAreaVolume::NotCheckCollision' has a wrong offset!");
static_assert(offsetof(AEndAerialNavAreaVolume, NotCheckGameCameraCollision) == 0x000398, "Member 'AEndAerialNavAreaVolume::NotCheckGameCameraCollision' has a wrong offset!");
static_assert(offsetof(AEndAerialNavAreaVolume, X_CM_SPACE_MAX) == 0x00039C, "Member 'AEndAerialNavAreaVolume::X_CM_SPACE_MAX' has a wrong offset!");
static_assert(offsetof(AEndAerialNavAreaVolume, Y_CM_SPACE_MAX) == 0x0003A0, "Member 'AEndAerialNavAreaVolume::Y_CM_SPACE_MAX' has a wrong offset!");
static_assert(offsetof(AEndAerialNavAreaVolume, Z_CM_SPACE_MAX) == 0x0003A4, "Member 'AEndAerialNavAreaVolume::Z_CM_SPACE_MAX' has a wrong offset!");
static_assert(offsetof(AEndAerialNavAreaVolume, EndArealNavBox) == 0x0003A8, "Member 'AEndAerialNavAreaVolume::EndArealNavBox' has a wrong offset!");
static_assert(offsetof(AEndAerialNavAreaVolume, AABB) == 0x0003B0, "Member 'AEndAerialNavAreaVolume::AABB' has a wrong offset!");
static_assert(offsetof(AEndAerialNavAreaVolume, PointDataList) == 0x0003D0, "Member 'AEndAerialNavAreaVolume::PointDataList' has a wrong offset!");
static_assert(offsetof(AEndAerialNavAreaVolume, XPointNum) == 0x0003E0, "Member 'AEndAerialNavAreaVolume::XPointNum' has a wrong offset!");
static_assert(offsetof(AEndAerialNavAreaVolume, YPointNum) == 0x0003E1, "Member 'AEndAerialNavAreaVolume::YPointNum' has a wrong offset!");
static_assert(offsetof(AEndAerialNavAreaVolume, ZPointNum) == 0x0003E2, "Member 'AEndAerialNavAreaVolume::ZPointNum' has a wrong offset!");
static_assert(offsetof(AEndAerialNavAreaVolume, PointMaxNum) == 0x0003E4, "Member 'AEndAerialNavAreaVolume::PointMaxNum' has a wrong offset!");

// Class EndGame.EndParticleModuleFootStep
// 0x0008 (0x0040 - 0x0038)
class UEndParticleModuleFootStep final : public UEndParticleModuleBase
{
public:
	uint32                                        m_BurstCount;                                      // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndParticleModuleFootStep">();
	}
	static class UEndParticleModuleFootStep* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndParticleModuleFootStep>();
	}
};
static_assert(alignof(UEndParticleModuleFootStep) == 0x000008, "Wrong alignment on UEndParticleModuleFootStep");
static_assert(sizeof(UEndParticleModuleFootStep) == 0x000040, "Wrong size on UEndParticleModuleFootStep");
static_assert(offsetof(UEndParticleModuleFootStep, m_BurstCount) == 0x000038, "Member 'UEndParticleModuleFootStep::m_BurstCount' has a wrong offset!");

// Class EndGame.EndAIIntentionCuriositySetting
// 0x0010 (0x0040 - 0x0030)
class UEndAIIntentionCuriositySetting final : public UDataAsset
{
public:
	float                                         InterestThreshold;                                 // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceThreshold;                                 // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterestActorDuringTimeMin;                        // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAIIntentionCuriositySetting">();
	}
	static class UEndAIIntentionCuriositySetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAIIntentionCuriositySetting>();
	}
};
static_assert(alignof(UEndAIIntentionCuriositySetting) == 0x000008, "Wrong alignment on UEndAIIntentionCuriositySetting");
static_assert(sizeof(UEndAIIntentionCuriositySetting) == 0x000040, "Wrong size on UEndAIIntentionCuriositySetting");
static_assert(offsetof(UEndAIIntentionCuriositySetting, InterestThreshold) == 0x000030, "Member 'UEndAIIntentionCuriositySetting::InterestThreshold' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionCuriositySetting, DistanceThreshold) == 0x000034, "Member 'UEndAIIntentionCuriositySetting::DistanceThreshold' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionCuriositySetting, InterestActorDuringTimeMin) == 0x000038, "Member 'UEndAIIntentionCuriositySetting::InterestActorDuringTimeMin' has a wrong offset!");

// Class EndGame.EndEnvQueryContext_FleeActors
// 0x0000 (0x0028 - 0x0028)
class UEndEnvQueryContext_FleeActors final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryContext_FleeActors">();
	}
	static class UEndEnvQueryContext_FleeActors* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryContext_FleeActors>();
	}
};
static_assert(alignof(UEndEnvQueryContext_FleeActors) == 0x000008, "Wrong alignment on UEndEnvQueryContext_FleeActors");
static_assert(sizeof(UEndEnvQueryContext_FleeActors) == 0x000028, "Wrong size on UEndEnvQueryContext_FleeActors");

// Class EndGame.EndAIIntentionIdleBaseSetting
// 0x0050 (0x0080 - 0x0030)
class UEndAIIntentionIdleBaseSetting : public UDataAsset
{
public:
	struct FVector2D                              LookAtWaitTimeRange;                               // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LookAtRandomRotationMin;                           // 0x0038(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               LookAtRandomRotationMax;                           // 0x0044(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LookAtWeight;                                      // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SaccadeWaitTimeRange;                              // 0x0054(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SaccadeWaitTimeAfterLookAt;                        // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SaccadeUpdateCycle;                                // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SaccadeRandomRotationMin;                          // 0x0064(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               SaccadeRandomRotationMax;                          // 0x0070(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SaccadeUpRate;                                     // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAIIntentionIdleBaseSetting">();
	}
	static class UEndAIIntentionIdleBaseSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAIIntentionIdleBaseSetting>();
	}
};
static_assert(alignof(UEndAIIntentionIdleBaseSetting) == 0x000008, "Wrong alignment on UEndAIIntentionIdleBaseSetting");
static_assert(sizeof(UEndAIIntentionIdleBaseSetting) == 0x000080, "Wrong size on UEndAIIntentionIdleBaseSetting");
static_assert(offsetof(UEndAIIntentionIdleBaseSetting, LookAtWaitTimeRange) == 0x000030, "Member 'UEndAIIntentionIdleBaseSetting::LookAtWaitTimeRange' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionIdleBaseSetting, LookAtRandomRotationMin) == 0x000038, "Member 'UEndAIIntentionIdleBaseSetting::LookAtRandomRotationMin' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionIdleBaseSetting, LookAtRandomRotationMax) == 0x000044, "Member 'UEndAIIntentionIdleBaseSetting::LookAtRandomRotationMax' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionIdleBaseSetting, LookAtWeight) == 0x000050, "Member 'UEndAIIntentionIdleBaseSetting::LookAtWeight' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionIdleBaseSetting, SaccadeWaitTimeRange) == 0x000054, "Member 'UEndAIIntentionIdleBaseSetting::SaccadeWaitTimeRange' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionIdleBaseSetting, SaccadeWaitTimeAfterLookAt) == 0x00005C, "Member 'UEndAIIntentionIdleBaseSetting::SaccadeWaitTimeAfterLookAt' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionIdleBaseSetting, SaccadeUpdateCycle) == 0x000060, "Member 'UEndAIIntentionIdleBaseSetting::SaccadeUpdateCycle' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionIdleBaseSetting, SaccadeRandomRotationMin) == 0x000064, "Member 'UEndAIIntentionIdleBaseSetting::SaccadeRandomRotationMin' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionIdleBaseSetting, SaccadeRandomRotationMax) == 0x000070, "Member 'UEndAIIntentionIdleBaseSetting::SaccadeRandomRotationMax' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionIdleBaseSetting, SaccadeUpRate) == 0x00007C, "Member 'UEndAIIntentionIdleBaseSetting::SaccadeUpRate' has a wrong offset!");

// Class EndGame.EndAIIntentionIdleSetting
// 0x0028 (0x00A8 - 0x0080)
class UEndAIIntentionIdleSetting final : public UEndAIIntentionIdleBaseSetting
{
public:
	struct FVector2D                              AnimationWaitTimeRange;                            // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtCancelTimeMin;                               // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LookAtBlendTimeRange;                              // 0x008C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtWaitTimeBiasInCaution;                       // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtBlendTimeBiasInCaution;                      // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtTargetRotationMinClampAngleInCaution;        // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtTargetAdditiveRotationBiasInCaution;         // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SaccadeTargetRotationBiasInCaution;                // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAIIntentionIdleSetting">();
	}
	static class UEndAIIntentionIdleSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAIIntentionIdleSetting>();
	}
};
static_assert(alignof(UEndAIIntentionIdleSetting) == 0x000008, "Wrong alignment on UEndAIIntentionIdleSetting");
static_assert(sizeof(UEndAIIntentionIdleSetting) == 0x0000A8, "Wrong size on UEndAIIntentionIdleSetting");
static_assert(offsetof(UEndAIIntentionIdleSetting, AnimationWaitTimeRange) == 0x000080, "Member 'UEndAIIntentionIdleSetting::AnimationWaitTimeRange' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionIdleSetting, LookAtCancelTimeMin) == 0x000088, "Member 'UEndAIIntentionIdleSetting::LookAtCancelTimeMin' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionIdleSetting, LookAtBlendTimeRange) == 0x00008C, "Member 'UEndAIIntentionIdleSetting::LookAtBlendTimeRange' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionIdleSetting, LookAtWaitTimeBiasInCaution) == 0x000094, "Member 'UEndAIIntentionIdleSetting::LookAtWaitTimeBiasInCaution' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionIdleSetting, LookAtBlendTimeBiasInCaution) == 0x000098, "Member 'UEndAIIntentionIdleSetting::LookAtBlendTimeBiasInCaution' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionIdleSetting, LookAtTargetRotationMinClampAngleInCaution) == 0x00009C, "Member 'UEndAIIntentionIdleSetting::LookAtTargetRotationMinClampAngleInCaution' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionIdleSetting, LookAtTargetAdditiveRotationBiasInCaution) == 0x0000A0, "Member 'UEndAIIntentionIdleSetting::LookAtTargetAdditiveRotationBiasInCaution' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionIdleSetting, SaccadeTargetRotationBiasInCaution) == 0x0000A4, "Member 'UEndAIIntentionIdleSetting::SaccadeTargetRotationBiasInCaution' has a wrong offset!");

// Class EndGame.EndFieldActionActorVendingMachine
// 0x0120 (0x0738 - 0x0618)
class AEndFieldActionActorVendingMachine final : public AEndFieldActionActorBase
{
public:
	uint8                                         Pad_618[0x8];                                      // 0x0618(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EnvActorName;                                      // 0x0620(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ShopActionID;                                      // 0x0628(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        PressVolume;                                       // 0x0630(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0638(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_640[0xF8];                                     // 0x0640(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorVendingMachine">();
	}
	static class AEndFieldActionActorVendingMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorVendingMachine>();
	}
};
static_assert(alignof(AEndFieldActionActorVendingMachine) == 0x000008, "Wrong alignment on AEndFieldActionActorVendingMachine");
static_assert(sizeof(AEndFieldActionActorVendingMachine) == 0x000738, "Wrong size on AEndFieldActionActorVendingMachine");
static_assert(offsetof(AEndFieldActionActorVendingMachine, EnvActorName) == 0x000620, "Member 'AEndFieldActionActorVendingMachine::EnvActorName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorVendingMachine, ShopActionID) == 0x000628, "Member 'AEndFieldActionActorVendingMachine::ShopActionID' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorVendingMachine, PressVolume) == 0x000630, "Member 'AEndFieldActionActorVendingMachine::PressVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorVendingMachine, ModifierVolume) == 0x000638, "Member 'AEndFieldActionActorVendingMachine::ModifierVolume' has a wrong offset!");

// Class EndGame.EndBonamikGlobalWindActor
// 0x0020 (0x0398 - 0x0378)
class AEndBonamikGlobalWindActor final : public AActor
{
public:
	class UEndBonamikWindData*                    WindData;                                          // 0x0378(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0380(0x000C)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38C[0x4];                                      // 0x038C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USQEX_BonamikWind*                      BonamikWind;                                       // 0x0390(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetDirection(const struct FVector& InDirection);
	void SetWindData(class UEndBonamikWindData* InWindData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBonamikGlobalWindActor">();
	}
	static class AEndBonamikGlobalWindActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBonamikGlobalWindActor>();
	}
};
static_assert(alignof(AEndBonamikGlobalWindActor) == 0x000008, "Wrong alignment on AEndBonamikGlobalWindActor");
static_assert(sizeof(AEndBonamikGlobalWindActor) == 0x000398, "Wrong size on AEndBonamikGlobalWindActor");
static_assert(offsetof(AEndBonamikGlobalWindActor, WindData) == 0x000378, "Member 'AEndBonamikGlobalWindActor::WindData' has a wrong offset!");
static_assert(offsetof(AEndBonamikGlobalWindActor, Direction) == 0x000380, "Member 'AEndBonamikGlobalWindActor::Direction' has a wrong offset!");
static_assert(offsetof(AEndBonamikGlobalWindActor, BonamikWind) == 0x000390, "Member 'AEndBonamikGlobalWindActor::BonamikWind' has a wrong offset!");

// Class EndGame.EndAIIntentionTalkControlSetting
// 0x0090 (0x0110 - 0x0080)
class UEndAIIntentionTalkControlSetting final : public UEndAIIntentionIdleBaseSetting
{
public:
	float                                         CoolDownRate;                                      // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtWaitTimeBiasListener;                        // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtWaitTimeBiasOther;                           // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LookAtActiveBlendTimeRange;                        // 0x008C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LookAtDeactiveBlendTimeRange;                      // 0x0094(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtUpperFollowTargetHeadRate;                   // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtLowerFollowTargetHeadRate;                   // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtToSaccadeTargetRate;                         // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtTurnAngleThreshold;                          // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtTurnBlendTime;                               // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtTurnUpperBodyBlendTime;                      // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LookAtTurnWaitTimeRange;                           // 0x00B4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LookAtOffsetHeightRange;                           // 0x00BC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtOffsetHeightInterpSpeed;                     // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtOffsetHeightApplyDistance;                   // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtDeactiveDistance;                            // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SaccadeTargetOffsetHeight;                         // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEndAIIntentionTalkControlStateContext> StateContexts;                                     // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         PlayAnimationRate;                                 // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StateChangeBeginWaitTimeRange;                     // 0x00EC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StateChangeContinuationWaitTimeRange;              // 0x00F4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TalkInMovementWalkLoopCountRange;                  // 0x00FC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TalkFinishDelayTimeRange;                          // 0x0104(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAIIntentionTalkControlSetting">();
	}
	static class UEndAIIntentionTalkControlSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAIIntentionTalkControlSetting>();
	}
};
static_assert(alignof(UEndAIIntentionTalkControlSetting) == 0x000008, "Wrong alignment on UEndAIIntentionTalkControlSetting");
static_assert(sizeof(UEndAIIntentionTalkControlSetting) == 0x000110, "Wrong size on UEndAIIntentionTalkControlSetting");
static_assert(offsetof(UEndAIIntentionTalkControlSetting, CoolDownRate) == 0x000080, "Member 'UEndAIIntentionTalkControlSetting::CoolDownRate' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionTalkControlSetting, LookAtWaitTimeBiasListener) == 0x000084, "Member 'UEndAIIntentionTalkControlSetting::LookAtWaitTimeBiasListener' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionTalkControlSetting, LookAtWaitTimeBiasOther) == 0x000088, "Member 'UEndAIIntentionTalkControlSetting::LookAtWaitTimeBiasOther' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionTalkControlSetting, LookAtActiveBlendTimeRange) == 0x00008C, "Member 'UEndAIIntentionTalkControlSetting::LookAtActiveBlendTimeRange' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionTalkControlSetting, LookAtDeactiveBlendTimeRange) == 0x000094, "Member 'UEndAIIntentionTalkControlSetting::LookAtDeactiveBlendTimeRange' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionTalkControlSetting, LookAtUpperFollowTargetHeadRate) == 0x00009C, "Member 'UEndAIIntentionTalkControlSetting::LookAtUpperFollowTargetHeadRate' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionTalkControlSetting, LookAtLowerFollowTargetHeadRate) == 0x0000A0, "Member 'UEndAIIntentionTalkControlSetting::LookAtLowerFollowTargetHeadRate' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionTalkControlSetting, LookAtToSaccadeTargetRate) == 0x0000A4, "Member 'UEndAIIntentionTalkControlSetting::LookAtToSaccadeTargetRate' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionTalkControlSetting, LookAtTurnAngleThreshold) == 0x0000A8, "Member 'UEndAIIntentionTalkControlSetting::LookAtTurnAngleThreshold' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionTalkControlSetting, LookAtTurnBlendTime) == 0x0000AC, "Member 'UEndAIIntentionTalkControlSetting::LookAtTurnBlendTime' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionTalkControlSetting, LookAtTurnUpperBodyBlendTime) == 0x0000B0, "Member 'UEndAIIntentionTalkControlSetting::LookAtTurnUpperBodyBlendTime' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionTalkControlSetting, LookAtTurnWaitTimeRange) == 0x0000B4, "Member 'UEndAIIntentionTalkControlSetting::LookAtTurnWaitTimeRange' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionTalkControlSetting, LookAtOffsetHeightRange) == 0x0000BC, "Member 'UEndAIIntentionTalkControlSetting::LookAtOffsetHeightRange' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionTalkControlSetting, LookAtOffsetHeightInterpSpeed) == 0x0000C4, "Member 'UEndAIIntentionTalkControlSetting::LookAtOffsetHeightInterpSpeed' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionTalkControlSetting, LookAtOffsetHeightApplyDistance) == 0x0000C8, "Member 'UEndAIIntentionTalkControlSetting::LookAtOffsetHeightApplyDistance' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionTalkControlSetting, LookAtDeactiveDistance) == 0x0000CC, "Member 'UEndAIIntentionTalkControlSetting::LookAtDeactiveDistance' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionTalkControlSetting, SaccadeTargetOffsetHeight) == 0x0000D0, "Member 'UEndAIIntentionTalkControlSetting::SaccadeTargetOffsetHeight' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionTalkControlSetting, StateContexts) == 0x0000D8, "Member 'UEndAIIntentionTalkControlSetting::StateContexts' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionTalkControlSetting, PlayAnimationRate) == 0x0000E8, "Member 'UEndAIIntentionTalkControlSetting::PlayAnimationRate' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionTalkControlSetting, StateChangeBeginWaitTimeRange) == 0x0000EC, "Member 'UEndAIIntentionTalkControlSetting::StateChangeBeginWaitTimeRange' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionTalkControlSetting, StateChangeContinuationWaitTimeRange) == 0x0000F4, "Member 'UEndAIIntentionTalkControlSetting::StateChangeContinuationWaitTimeRange' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionTalkControlSetting, TalkInMovementWalkLoopCountRange) == 0x0000FC, "Member 'UEndAIIntentionTalkControlSetting::TalkInMovementWalkLoopCountRange' has a wrong offset!");
static_assert(offsetof(UEndAIIntentionTalkControlSetting, TalkFinishDelayTimeRange) == 0x000104, "Member 'UEndAIIntentionTalkControlSetting::TalkFinishDelayTimeRange' has a wrong offset!");

// Class EndGame.EndDataObjectLimitBreak
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectLimitBreak final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectLimitBreak">();
	}
	static class UEndDataObjectLimitBreak* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectLimitBreak>();
	}
};
static_assert(alignof(UEndDataObjectLimitBreak) == 0x000008, "Wrong alignment on UEndDataObjectLimitBreak");
static_assert(sizeof(UEndDataObjectLimitBreak) == 0x000088, "Wrong size on UEndDataObjectLimitBreak");

// Class EndGame.EndAIModelControllerInterface
// 0x0000 (0x0028 - 0x0028)
class IEndAIModelControllerInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAIModelControllerInterface">();
	}
	static class IEndAIModelControllerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEndAIModelControllerInterface>();
	}
};
static_assert(alignof(IEndAIModelControllerInterface) == 0x000008, "Wrong alignment on IEndAIModelControllerInterface");
static_assert(sizeof(IEndAIModelControllerInterface) == 0x000028, "Wrong size on IEndAIModelControllerInterface");

// Class EndGame.EndEnvQueryContext_QuerierFeetLocation
// 0x0000 (0x0028 - 0x0028)
class UEndEnvQueryContext_QuerierFeetLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryContext_QuerierFeetLocation">();
	}
	static class UEndEnvQueryContext_QuerierFeetLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryContext_QuerierFeetLocation>();
	}
};
static_assert(alignof(UEndEnvQueryContext_QuerierFeetLocation) == 0x000008, "Wrong alignment on UEndEnvQueryContext_QuerierFeetLocation");
static_assert(sizeof(UEndEnvQueryContext_QuerierFeetLocation) == 0x000028, "Wrong size on UEndEnvQueryContext_QuerierFeetLocation");

// Class EndGame.EndAIModelPersonalityData
// 0x0020 (0x0050 - 0x0030)
class UEndAIModelPersonalityData final : public UDataAsset
{
public:
	EEndAIUpdatePriority                          InitialUpdatePriority;                             // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndAIPersonalType                            PersonalType;                                      // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExperienceSpeed;                                   // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ExperienceSpeedRandomBias;                         // 0x0038(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CautionCalmSpeed;                                  // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CautionCalmSpeedRandomBias;                        // 0x0044(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemoveRecognitionTime;                             // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAIModelPersonalityData">();
	}
	static class UEndAIModelPersonalityData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAIModelPersonalityData>();
	}
};
static_assert(alignof(UEndAIModelPersonalityData) == 0x000008, "Wrong alignment on UEndAIModelPersonalityData");
static_assert(sizeof(UEndAIModelPersonalityData) == 0x000050, "Wrong size on UEndAIModelPersonalityData");
static_assert(offsetof(UEndAIModelPersonalityData, InitialUpdatePriority) == 0x000030, "Member 'UEndAIModelPersonalityData::InitialUpdatePriority' has a wrong offset!");
static_assert(offsetof(UEndAIModelPersonalityData, PersonalType) == 0x000031, "Member 'UEndAIModelPersonalityData::PersonalType' has a wrong offset!");
static_assert(offsetof(UEndAIModelPersonalityData, ExperienceSpeed) == 0x000034, "Member 'UEndAIModelPersonalityData::ExperienceSpeed' has a wrong offset!");
static_assert(offsetof(UEndAIModelPersonalityData, ExperienceSpeedRandomBias) == 0x000038, "Member 'UEndAIModelPersonalityData::ExperienceSpeedRandomBias' has a wrong offset!");
static_assert(offsetof(UEndAIModelPersonalityData, CautionCalmSpeed) == 0x000040, "Member 'UEndAIModelPersonalityData::CautionCalmSpeed' has a wrong offset!");
static_assert(offsetof(UEndAIModelPersonalityData, CautionCalmSpeedRandomBias) == 0x000044, "Member 'UEndAIModelPersonalityData::CautionCalmSpeedRandomBias' has a wrong offset!");
static_assert(offsetof(UEndAIModelPersonalityData, RemoveRecognitionTime) == 0x00004C, "Member 'UEndAIModelPersonalityData::RemoveRecognitionTime' has a wrong offset!");

// Class EndGame.EndParticleModuleEventSpawnEffect
// 0x0040 (0x0078 - 0x0038)
class UEndParticleModuleEventSpawnEffect final : public UEndParticleModuleBase
{
public:
	struct FSoftObjectPath                        m_CreateEffectPath;                                // 0x0038(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndEffectEventKind                           m_EventKind;                                       // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   m_RefPointName;                                    // 0x0054(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         m_bAttachment : 1;                                 // 0x005C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEndEffectAttachInfo                   m_AttachInfo;                                      // 0x0060(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	EEndEffectLocationKind                        m_AttachActorKind;                                 // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEndEffectSocketName                   m_AttachSocketName;                                // 0x006C(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndParticleModuleEventSpawnEffect">();
	}
	static class UEndParticleModuleEventSpawnEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndParticleModuleEventSpawnEffect>();
	}
};
static_assert(alignof(UEndParticleModuleEventSpawnEffect) == 0x000008, "Wrong alignment on UEndParticleModuleEventSpawnEffect");
static_assert(sizeof(UEndParticleModuleEventSpawnEffect) == 0x000078, "Wrong size on UEndParticleModuleEventSpawnEffect");
static_assert(offsetof(UEndParticleModuleEventSpawnEffect, m_CreateEffectPath) == 0x000038, "Member 'UEndParticleModuleEventSpawnEffect::m_CreateEffectPath' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleEventSpawnEffect, m_EventKind) == 0x000050, "Member 'UEndParticleModuleEventSpawnEffect::m_EventKind' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleEventSpawnEffect, m_RefPointName) == 0x000054, "Member 'UEndParticleModuleEventSpawnEffect::m_RefPointName' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleEventSpawnEffect, m_AttachInfo) == 0x000060, "Member 'UEndParticleModuleEventSpawnEffect::m_AttachInfo' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleEventSpawnEffect, m_AttachActorKind) == 0x000068, "Member 'UEndParticleModuleEventSpawnEffect::m_AttachActorKind' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleEventSpawnEffect, m_AttachSocketName) == 0x00006C, "Member 'UEndParticleModuleEventSpawnEffect::m_AttachSocketName' has a wrong offset!");

// Class EndGame.EndAIModelPersonality
// 0x0010 (0x0038 - 0x0028)
class UEndAIModelPersonality final : public UObject
{
public:
	float                                         ExperienceSpeed;                                   // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ExperienceSpeedRandomBias;                         // 0x002C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemoveRecognitionTime;                             // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAIModelPersonality">();
	}
	static class UEndAIModelPersonality* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAIModelPersonality>();
	}
};
static_assert(alignof(UEndAIModelPersonality) == 0x000008, "Wrong alignment on UEndAIModelPersonality");
static_assert(sizeof(UEndAIModelPersonality) == 0x000038, "Wrong size on UEndAIModelPersonality");
static_assert(offsetof(UEndAIModelPersonality, ExperienceSpeed) == 0x000028, "Member 'UEndAIModelPersonality::ExperienceSpeed' has a wrong offset!");
static_assert(offsetof(UEndAIModelPersonality, ExperienceSpeedRandomBias) == 0x00002C, "Member 'UEndAIModelPersonality::ExperienceSpeedRandomBias' has a wrong offset!");
static_assert(offsetof(UEndAIModelPersonality, RemoveRecognitionTime) == 0x000034, "Member 'UEndAIModelPersonality::RemoveRecognitionTime' has a wrong offset!");

// Class EndGame.EndInvalidationBox
// 0x0018 (0x0128 - 0x0110)
class UEndInvalidationBox final : public UContentWidget
{
public:
	bool                                          bCanCache;                                         // 0x0110(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CacheRelativeTransforms;                           // 0x0111(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_112[0x16];                                     // 0x0112(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InvalidateCache();
	void SetCanCache(bool CanCache);

	bool GetCanCache() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndInvalidationBox">();
	}
	static class UEndInvalidationBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndInvalidationBox>();
	}
};
static_assert(alignof(UEndInvalidationBox) == 0x000008, "Wrong alignment on UEndInvalidationBox");
static_assert(sizeof(UEndInvalidationBox) == 0x000128, "Wrong size on UEndInvalidationBox");
static_assert(offsetof(UEndInvalidationBox, bCanCache) == 0x000110, "Member 'UEndInvalidationBox::bCanCache' has a wrong offset!");
static_assert(offsetof(UEndInvalidationBox, CacheRelativeTransforms) == 0x000111, "Member 'UEndInvalidationBox::CacheRelativeTransforms' has a wrong offset!");

// Class EndGame.EndBTD_SummonRequestAbility
// 0x0058 (0x00C0 - 0x0068)
class UEndBTD_SummonRequestAbility final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 FromBlackboardKey_AbilityID;                       // 0x0068(0x0028)(Edit, NativeAccessSpecifierPublic)
	bool                                          bIgnoreAbilityRange;                               // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AbilityRange;                                      // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDefaultAbilityRange;                           // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RequestAbilityIDBlackBoardName;                    // 0x009C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AbilityRangeBlackBoardName;                        // 0x00A4(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IgnoreAbilityRangeBlackBoardName;                  // 0x00AC(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AbilityLockBlackBoardName;                         // 0x00B4(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTD_SummonRequestAbility">();
	}
	static class UEndBTD_SummonRequestAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTD_SummonRequestAbility>();
	}
};
static_assert(alignof(UEndBTD_SummonRequestAbility) == 0x000008, "Wrong alignment on UEndBTD_SummonRequestAbility");
static_assert(sizeof(UEndBTD_SummonRequestAbility) == 0x0000C0, "Wrong size on UEndBTD_SummonRequestAbility");
static_assert(offsetof(UEndBTD_SummonRequestAbility, FromBlackboardKey_AbilityID) == 0x000068, "Member 'UEndBTD_SummonRequestAbility::FromBlackboardKey_AbilityID' has a wrong offset!");
static_assert(offsetof(UEndBTD_SummonRequestAbility, bIgnoreAbilityRange) == 0x000090, "Member 'UEndBTD_SummonRequestAbility::bIgnoreAbilityRange' has a wrong offset!");
static_assert(offsetof(UEndBTD_SummonRequestAbility, AbilityRange) == 0x000094, "Member 'UEndBTD_SummonRequestAbility::AbilityRange' has a wrong offset!");
static_assert(offsetof(UEndBTD_SummonRequestAbility, bUseDefaultAbilityRange) == 0x000098, "Member 'UEndBTD_SummonRequestAbility::bUseDefaultAbilityRange' has a wrong offset!");
static_assert(offsetof(UEndBTD_SummonRequestAbility, RequestAbilityIDBlackBoardName) == 0x00009C, "Member 'UEndBTD_SummonRequestAbility::RequestAbilityIDBlackBoardName' has a wrong offset!");
static_assert(offsetof(UEndBTD_SummonRequestAbility, AbilityRangeBlackBoardName) == 0x0000A4, "Member 'UEndBTD_SummonRequestAbility::AbilityRangeBlackBoardName' has a wrong offset!");
static_assert(offsetof(UEndBTD_SummonRequestAbility, IgnoreAbilityRangeBlackBoardName) == 0x0000AC, "Member 'UEndBTD_SummonRequestAbility::IgnoreAbilityRangeBlackBoardName' has a wrong offset!");
static_assert(offsetof(UEndBTD_SummonRequestAbility, AbilityLockBlackBoardName) == 0x0000B4, "Member 'UEndBTD_SummonRequestAbility::AbilityLockBlackBoardName' has a wrong offset!");

// Class EndGame.EndAIModelTemplateData
// 0x0AD0 (0x0B00 - 0x0030)
class UEndAIModelTemplateData final : public UDataAsset
{
public:
	struct FEndAISensorVision                     Vision;                                            // 0x0030(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FEndAISensorHearing                    Hearing;                                           // 0x00B0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FEndAISensorTactileSense               TactileSense;                                      // 0x00C8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FEndAIIntentionManualControl           ManualControl;                                     // 0x00E0(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FEndAIIntentionInterestActionControl   InterestActionControl;                             // 0x0120(0x06D8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FEndAIIntentionTalkControl             TalkControl;                                       // 0x07F8(0x0120)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FEndAIIntentionContact                 Contact;                                           // 0x0918(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FEndAIIntentionWallContact             WallContact;                                       // 0x09A8(0x0060)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FEndAIIntentionCognition               Cognition;                                         // 0x0A08(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FEndAIIntentionCuriosity               Curiosity;                                         // 0x0A18(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FEndAIIntentionIdle                    Idle;                                              // 0x0A60(0x00A0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAIModelTemplateData">();
	}
	static class UEndAIModelTemplateData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAIModelTemplateData>();
	}
};
static_assert(alignof(UEndAIModelTemplateData) == 0x000008, "Wrong alignment on UEndAIModelTemplateData");
static_assert(sizeof(UEndAIModelTemplateData) == 0x000B00, "Wrong size on UEndAIModelTemplateData");
static_assert(offsetof(UEndAIModelTemplateData, Vision) == 0x000030, "Member 'UEndAIModelTemplateData::Vision' has a wrong offset!");
static_assert(offsetof(UEndAIModelTemplateData, Hearing) == 0x0000B0, "Member 'UEndAIModelTemplateData::Hearing' has a wrong offset!");
static_assert(offsetof(UEndAIModelTemplateData, TactileSense) == 0x0000C8, "Member 'UEndAIModelTemplateData::TactileSense' has a wrong offset!");
static_assert(offsetof(UEndAIModelTemplateData, ManualControl) == 0x0000E0, "Member 'UEndAIModelTemplateData::ManualControl' has a wrong offset!");
static_assert(offsetof(UEndAIModelTemplateData, InterestActionControl) == 0x000120, "Member 'UEndAIModelTemplateData::InterestActionControl' has a wrong offset!");
static_assert(offsetof(UEndAIModelTemplateData, TalkControl) == 0x0007F8, "Member 'UEndAIModelTemplateData::TalkControl' has a wrong offset!");
static_assert(offsetof(UEndAIModelTemplateData, Contact) == 0x000918, "Member 'UEndAIModelTemplateData::Contact' has a wrong offset!");
static_assert(offsetof(UEndAIModelTemplateData, WallContact) == 0x0009A8, "Member 'UEndAIModelTemplateData::WallContact' has a wrong offset!");
static_assert(offsetof(UEndAIModelTemplateData, Cognition) == 0x000A08, "Member 'UEndAIModelTemplateData::Cognition' has a wrong offset!");
static_assert(offsetof(UEndAIModelTemplateData, Curiosity) == 0x000A18, "Member 'UEndAIModelTemplateData::Curiosity' has a wrong offset!");
static_assert(offsetof(UEndAIModelTemplateData, Idle) == 0x000A60, "Member 'UEndAIModelTemplateData::Idle' has a wrong offset!");

// Class EndGame.EndAIModelTemplate
// 0x0000 (0x0028 - 0x0028)
class UEndAIModelTemplate final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAIModelTemplate">();
	}
	static class UEndAIModelTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAIModelTemplate>();
	}
};
static_assert(alignof(UEndAIModelTemplate) == 0x000008, "Wrong alignment on UEndAIModelTemplate");
static_assert(sizeof(UEndAIModelTemplate) == 0x000028, "Wrong size on UEndAIModelTemplate");

// Class EndGame.EndEffectAPI
// 0x0000 (0x0028 - 0x0028)
class UEndEffectAPI final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEffectAPI">();
	}
	static class UEndEffectAPI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEffectAPI>();
	}
};
static_assert(alignof(UEndEffectAPI) == 0x000008, "Wrong alignment on UEndEffectAPI");
static_assert(sizeof(UEndEffectAPI) == 0x000028, "Wrong size on UEndEffectAPI");

// Class EndGame.EndMainMenuListBase
// 0x0000 (0x0360 - 0x0360)
class UEndMainMenuListBase : public UEndUserWidget
{
public:
	void OnCellPressed(int32 CellIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainMenuListBase">();
	}
	static class UEndMainMenuListBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainMenuListBase>();
	}
};
static_assert(alignof(UEndMainMenuListBase) == 0x000008, "Wrong alignment on UEndMainMenuListBase");
static_assert(sizeof(UEndMainMenuListBase) == 0x000360, "Wrong size on UEndMainMenuListBase");

// Class EndGame.EndBTDecorator_CheckConditionBase
// 0x0000 (0x0068 - 0x0068)
class UEndBTDecorator_CheckConditionBase : public UBTDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_CheckConditionBase">();
	}
	static class UEndBTDecorator_CheckConditionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_CheckConditionBase>();
	}
};
static_assert(alignof(UEndBTDecorator_CheckConditionBase) == 0x000008, "Wrong alignment on UEndBTDecorator_CheckConditionBase");
static_assert(sizeof(UEndBTDecorator_CheckConditionBase) == 0x000068, "Wrong size on UEndBTDecorator_CheckConditionBase");

// Class EndGame.EndCameraRail
// 0x0100 (0x0478 - 0x0378)
class AEndCameraRail : public AActor
{
public:
	class USplineComponent*                       CameraRailComponent;                               // 0x0378(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USplineComponent*                       PlayerRailComponent;                               // 0x0380(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USplineComponent*>               GuideSplinesInterface;                             // 0x0388(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class ULevelSequence*                         RailCameraSequencerData;                           // 0x0398(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelSequence*                         ReverseRailCameraSequencerData;                    // 0x03A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RCSMinDist;                                        // 0x03A8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RCSMaxDist;                                        // 0x03AC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UpdateControlRotation;                             // 0x03B0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UpdateControlRotOnWeightDecrease;                  // 0x03B1(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopInputBlend;                                    // 0x03B2(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B3[0x1];                                      // 0x03B3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FollowTarget;                                      // 0x03B4(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseHorizontalFollow;                               // 0x03BC(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERCSCutConnect                                CutConnectType;                                    // 0x03BD(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseDOFActor;                                       // 0x03BE(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3BF[0x1];                                      // 0x03BF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugTime;                                         // 0x03C0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowCamera;                                        // 0x03C4(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugPreview;                                      // 0x03C5(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowNumber;                                        // 0x03C6(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCameraCut;                                      // 0x03C7(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _PrevWeight;                                       // 0x03C8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayTime;                                          // 0x03CC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistThreshold;                                     // 0x03D0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartBlend;                                        // 0x03D4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndBlend;                                          // 0x03D8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 FOVs;                                              // 0x03E0(0x0010)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<float>                                 Rolls;                                             // 0x03F0(0x0010)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          CanSkip;                                           // 0x0400(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_401[0x3];                                      // 0x0401(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 CameraRailColor;                                   // 0x0404(0x0004)(Edit, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 PlayerRailColor;                                   // 0x0408(0x0004)(Edit, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40C[0x6C];                                     // 0x040C(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCameraRail">();
	}
	static class AEndCameraRail* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndCameraRail>();
	}
};
static_assert(alignof(AEndCameraRail) == 0x000008, "Wrong alignment on AEndCameraRail");
static_assert(sizeof(AEndCameraRail) == 0x000478, "Wrong size on AEndCameraRail");
static_assert(offsetof(AEndCameraRail, CameraRailComponent) == 0x000378, "Member 'AEndCameraRail::CameraRailComponent' has a wrong offset!");
static_assert(offsetof(AEndCameraRail, PlayerRailComponent) == 0x000380, "Member 'AEndCameraRail::PlayerRailComponent' has a wrong offset!");
static_assert(offsetof(AEndCameraRail, GuideSplinesInterface) == 0x000388, "Member 'AEndCameraRail::GuideSplinesInterface' has a wrong offset!");
static_assert(offsetof(AEndCameraRail, RailCameraSequencerData) == 0x000398, "Member 'AEndCameraRail::RailCameraSequencerData' has a wrong offset!");
static_assert(offsetof(AEndCameraRail, ReverseRailCameraSequencerData) == 0x0003A0, "Member 'AEndCameraRail::ReverseRailCameraSequencerData' has a wrong offset!");
static_assert(offsetof(AEndCameraRail, RCSMinDist) == 0x0003A8, "Member 'AEndCameraRail::RCSMinDist' has a wrong offset!");
static_assert(offsetof(AEndCameraRail, RCSMaxDist) == 0x0003AC, "Member 'AEndCameraRail::RCSMaxDist' has a wrong offset!");
static_assert(offsetof(AEndCameraRail, UpdateControlRotation) == 0x0003B0, "Member 'AEndCameraRail::UpdateControlRotation' has a wrong offset!");
static_assert(offsetof(AEndCameraRail, UpdateControlRotOnWeightDecrease) == 0x0003B1, "Member 'AEndCameraRail::UpdateControlRotOnWeightDecrease' has a wrong offset!");
static_assert(offsetof(AEndCameraRail, StopInputBlend) == 0x0003B2, "Member 'AEndCameraRail::StopInputBlend' has a wrong offset!");
static_assert(offsetof(AEndCameraRail, FollowTarget) == 0x0003B4, "Member 'AEndCameraRail::FollowTarget' has a wrong offset!");
static_assert(offsetof(AEndCameraRail, UseHorizontalFollow) == 0x0003BC, "Member 'AEndCameraRail::UseHorizontalFollow' has a wrong offset!");
static_assert(offsetof(AEndCameraRail, CutConnectType) == 0x0003BD, "Member 'AEndCameraRail::CutConnectType' has a wrong offset!");
static_assert(offsetof(AEndCameraRail, UseDOFActor) == 0x0003BE, "Member 'AEndCameraRail::UseDOFActor' has a wrong offset!");
static_assert(offsetof(AEndCameraRail, DebugTime) == 0x0003C0, "Member 'AEndCameraRail::DebugTime' has a wrong offset!");
static_assert(offsetof(AEndCameraRail, ShowCamera) == 0x0003C4, "Member 'AEndCameraRail::ShowCamera' has a wrong offset!");
static_assert(offsetof(AEndCameraRail, DebugPreview) == 0x0003C5, "Member 'AEndCameraRail::DebugPreview' has a wrong offset!");
static_assert(offsetof(AEndCameraRail, ShowNumber) == 0x0003C6, "Member 'AEndCameraRail::ShowNumber' has a wrong offset!");
static_assert(offsetof(AEndCameraRail, UseCameraCut) == 0x0003C7, "Member 'AEndCameraRail::UseCameraCut' has a wrong offset!");
static_assert(offsetof(AEndCameraRail, _PrevWeight) == 0x0003C8, "Member 'AEndCameraRail::_PrevWeight' has a wrong offset!");
static_assert(offsetof(AEndCameraRail, PlayTime) == 0x0003CC, "Member 'AEndCameraRail::PlayTime' has a wrong offset!");
static_assert(offsetof(AEndCameraRail, DistThreshold) == 0x0003D0, "Member 'AEndCameraRail::DistThreshold' has a wrong offset!");
static_assert(offsetof(AEndCameraRail, StartBlend) == 0x0003D4, "Member 'AEndCameraRail::StartBlend' has a wrong offset!");
static_assert(offsetof(AEndCameraRail, EndBlend) == 0x0003D8, "Member 'AEndCameraRail::EndBlend' has a wrong offset!");
static_assert(offsetof(AEndCameraRail, FOVs) == 0x0003E0, "Member 'AEndCameraRail::FOVs' has a wrong offset!");
static_assert(offsetof(AEndCameraRail, Rolls) == 0x0003F0, "Member 'AEndCameraRail::Rolls' has a wrong offset!");
static_assert(offsetof(AEndCameraRail, CanSkip) == 0x000400, "Member 'AEndCameraRail::CanSkip' has a wrong offset!");
static_assert(offsetof(AEndCameraRail, CameraRailColor) == 0x000404, "Member 'AEndCameraRail::CameraRailColor' has a wrong offset!");
static_assert(offsetof(AEndCameraRail, PlayerRailColor) == 0x000408, "Member 'AEndCameraRail::PlayerRailColor' has a wrong offset!");

// Class EndGame.EndAimOnlyRail
// 0x0050 (0x04C8 - 0x0478)
class AEndAimOnlyRail final : public AEndCameraRail
{
public:
	float                                         StartBlendTime;                                    // 0x0478(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndBlendTime;                                      // 0x047C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControllLimit;                                     // 0x0480(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCollisionCheck;                                 // 0x0484(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopControl;                                       // 0x0485(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseForceConnect;                                   // 0x0486(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_487[0x41];                                     // 0x0487(0x0041)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAimOnlyRail">();
	}
	static class AEndAimOnlyRail* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndAimOnlyRail>();
	}
};
static_assert(alignof(AEndAimOnlyRail) == 0x000008, "Wrong alignment on AEndAimOnlyRail");
static_assert(sizeof(AEndAimOnlyRail) == 0x0004C8, "Wrong size on AEndAimOnlyRail");
static_assert(offsetof(AEndAimOnlyRail, StartBlendTime) == 0x000478, "Member 'AEndAimOnlyRail::StartBlendTime' has a wrong offset!");
static_assert(offsetof(AEndAimOnlyRail, EndBlendTime) == 0x00047C, "Member 'AEndAimOnlyRail::EndBlendTime' has a wrong offset!");
static_assert(offsetof(AEndAimOnlyRail, ControllLimit) == 0x000480, "Member 'AEndAimOnlyRail::ControllLimit' has a wrong offset!");
static_assert(offsetof(AEndAimOnlyRail, UseCollisionCheck) == 0x000484, "Member 'AEndAimOnlyRail::UseCollisionCheck' has a wrong offset!");
static_assert(offsetof(AEndAimOnlyRail, StopControl) == 0x000485, "Member 'AEndAimOnlyRail::StopControl' has a wrong offset!");
static_assert(offsetof(AEndAimOnlyRail, UseForceConnect) == 0x000486, "Member 'AEndAimOnlyRail::UseForceConnect' has a wrong offset!");

// Class EndGame.EndBorderSlot
// 0x0028 (0x0060 - 0x0038)
class UEndBorderSlot final : public UPanelSlot
{
public:
	struct FMargin                                Padding;                                           // 0x0038(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A[0x16];                                      // 0x004A(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment);
	void SetPadding(const struct FMargin& InPadding);
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBorderSlot">();
	}
	static class UEndBorderSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBorderSlot>();
	}
};
static_assert(alignof(UEndBorderSlot) == 0x000008, "Wrong alignment on UEndBorderSlot");
static_assert(sizeof(UEndBorderSlot) == 0x000060, "Wrong size on UEndBorderSlot");
static_assert(offsetof(UEndBorderSlot, Padding) == 0x000038, "Member 'UEndBorderSlot::Padding' has a wrong offset!");
static_assert(offsetof(UEndBorderSlot, HorizontalAlignment) == 0x000048, "Member 'UEndBorderSlot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UEndBorderSlot, VerticalAlignment) == 0x000049, "Member 'UEndBorderSlot::VerticalAlignment' has a wrong offset!");

// Class EndGame.EndSimpleMenu
// 0x0008 (0x0368 - 0x0360)
class UEndSimpleMenu : public UEndUserWidget
{
public:
	bool                                          bResident;                                         // 0x0360(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_361[0x7];                                      // 0x0361(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndSimpleMenu">();
	}
	static class UEndSimpleMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndSimpleMenu>();
	}
};
static_assert(alignof(UEndSimpleMenu) == 0x000008, "Wrong alignment on UEndSimpleMenu");
static_assert(sizeof(UEndSimpleMenu) == 0x000368, "Wrong size on UEndSimpleMenu");
static_assert(offsetof(UEndSimpleMenu, bResident) == 0x000360, "Member 'UEndSimpleMenu::bResident' has a wrong offset!");

// Class EndGame.EndTestPlayTitleMenu
// 0x0058 (0x03C0 - 0x0368)
class UEndTestPlayTitleMenu final : public UEndSimpleMenu
{
public:
	struct FSlateSound                            DecideSound;                                       // 0x0368(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UEndUserWidget>             OrderWindowWidgetClass;                            // 0x0380(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                FocusedWidget;                                     // 0x0388(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndTrialOrderWindow*                   OrderWindow;                                       // 0x0390(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_398[0x28];                                     // 0x0398(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStartButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndTestPlayTitleMenu">();
	}
	static class UEndTestPlayTitleMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndTestPlayTitleMenu>();
	}
};
static_assert(alignof(UEndTestPlayTitleMenu) == 0x000008, "Wrong alignment on UEndTestPlayTitleMenu");
static_assert(sizeof(UEndTestPlayTitleMenu) == 0x0003C0, "Wrong size on UEndTestPlayTitleMenu");
static_assert(offsetof(UEndTestPlayTitleMenu, DecideSound) == 0x000368, "Member 'UEndTestPlayTitleMenu::DecideSound' has a wrong offset!");
static_assert(offsetof(UEndTestPlayTitleMenu, OrderWindowWidgetClass) == 0x000380, "Member 'UEndTestPlayTitleMenu::OrderWindowWidgetClass' has a wrong offset!");
static_assert(offsetof(UEndTestPlayTitleMenu, FocusedWidget) == 0x000388, "Member 'UEndTestPlayTitleMenu::FocusedWidget' has a wrong offset!");
static_assert(offsetof(UEndTestPlayTitleMenu, OrderWindow) == 0x000390, "Member 'UEndTestPlayTitleMenu::OrderWindow' has a wrong offset!");

// Class EndGame.EndAimSolver
// 0x0058 (0x0080 - 0x0028)
class UEndAimSolver final : public UObject
{
public:
	TMap<class FName, struct FEndAimSolveEffector> Effectors;                                         // 0x0028(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ClampHorizontalDistanceMin;                        // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAimSolver">();
	}
	static class UEndAimSolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAimSolver>();
	}
};
static_assert(alignof(UEndAimSolver) == 0x000008, "Wrong alignment on UEndAimSolver");
static_assert(sizeof(UEndAimSolver) == 0x000080, "Wrong size on UEndAimSolver");
static_assert(offsetof(UEndAimSolver, Effectors) == 0x000028, "Member 'UEndAimSolver::Effectors' has a wrong offset!");
static_assert(offsetof(UEndAimSolver, ClampHorizontalDistanceMin) == 0x000078, "Member 'UEndAimSolver::ClampHorizontalDistanceMin' has a wrong offset!");

// Class EndGame.EndAITimerComponent
// 0x0070 (0x0168 - 0x00F8)
class UEndAITimerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_F8[0x50];                                      // 0x00F8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnRunningDispacher;                                // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFinishDispacher;                                 // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AddTimer(float InTime, class FName InName);
	bool IsRunning();
	bool IsRunningFromName(class FName InName);
	bool NotRunning();
	bool NotRunningFromName(class FName InName);
	void START(float InTime, class FName InName);
	void Suspend(class FName InName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAITimerComponent">();
	}
	static class UEndAITimerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAITimerComponent>();
	}
};
static_assert(alignof(UEndAITimerComponent) == 0x000008, "Wrong alignment on UEndAITimerComponent");
static_assert(sizeof(UEndAITimerComponent) == 0x000168, "Wrong size on UEndAITimerComponent");
static_assert(offsetof(UEndAITimerComponent, OnRunningDispacher) == 0x000148, "Member 'UEndAITimerComponent::OnRunningDispacher' has a wrong offset!");
static_assert(offsetof(UEndAITimerComponent, OnFinishDispacher) == 0x000158, "Member 'UEndAITimerComponent::OnFinishDispacher' has a wrong offset!");

// Class EndGame.EndBalanceMoveDrawComponent
// 0x0000 (0x00F8 - 0x00F8)
class UEndBalanceMoveDrawComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBalanceMoveDrawComponent">();
	}
	static class UEndBalanceMoveDrawComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBalanceMoveDrawComponent>();
	}
};
static_assert(alignof(UEndBalanceMoveDrawComponent) == 0x000008, "Wrong alignment on UEndBalanceMoveDrawComponent");
static_assert(sizeof(UEndBalanceMoveDrawComponent) == 0x0000F8, "Wrong size on UEndBalanceMoveDrawComponent");

// Class EndGame.EndBTD_SummonCheckDistance
// 0x0058 (0x00C0 - 0x0068)
class UEndBTD_SummonCheckDistance final : public UEndBTDecorator_CheckConditionBase
{
public:
	struct FBlackboardKeySelector                 ToBlackboardKey;                                   // 0x0068(0x0028)(Edit, NativeAccessSpecifierPublic)
	EEndAiMathCmp                                 Operator;                                          // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 CheckDistanceBlackboardKey;                        // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTD_SummonCheckDistance">();
	}
	static class UEndBTD_SummonCheckDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTD_SummonCheckDistance>();
	}
};
static_assert(alignof(UEndBTD_SummonCheckDistance) == 0x000008, "Wrong alignment on UEndBTD_SummonCheckDistance");
static_assert(sizeof(UEndBTD_SummonCheckDistance) == 0x0000C0, "Wrong size on UEndBTD_SummonCheckDistance");
static_assert(offsetof(UEndBTD_SummonCheckDistance, ToBlackboardKey) == 0x000068, "Member 'UEndBTD_SummonCheckDistance::ToBlackboardKey' has a wrong offset!");
static_assert(offsetof(UEndBTD_SummonCheckDistance, Operator) == 0x000090, "Member 'UEndBTD_SummonCheckDistance::Operator' has a wrong offset!");
static_assert(offsetof(UEndBTD_SummonCheckDistance, CheckDistanceBlackboardKey) == 0x000098, "Member 'UEndBTD_SummonCheckDistance::CheckDistanceBlackboardKey' has a wrong offset!");

// Class EndGame.EndTargetPoint
// 0x0038 (0x03B0 - 0x0378)
class AEndTargetPoint final : public ATargetPoint
{
public:
	uint8                                         Pad_378[0x30];                                     // 0x0378(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndTextRenderComponent*                TextRenderComponent;                               // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndTargetPoint">();
	}
	static class AEndTargetPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndTargetPoint>();
	}
};
static_assert(alignof(AEndTargetPoint) == 0x000008, "Wrong alignment on AEndTargetPoint");
static_assert(sizeof(AEndTargetPoint) == 0x0003B0, "Wrong size on AEndTargetPoint");
static_assert(offsetof(AEndTargetPoint, TextRenderComponent) == 0x0003A8, "Member 'AEndTargetPoint::TextRenderComponent' has a wrong offset!");

// Class EndGame.EndAnimActorInterface
// 0x0000 (0x0028 - 0x0028)
class IEndAnimActorInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimActorInterface">();
	}
	static class IEndAnimActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEndAnimActorInterface>();
	}
};
static_assert(alignof(IEndAnimActorInterface) == 0x000008, "Wrong alignment on IEndAnimActorInterface");
static_assert(sizeof(IEndAnimActorInterface) == 0x000028, "Wrong size on IEndAnimActorInterface");

// Class EndGame.EndAnimationSettings
// 0x0208 (0x0230 - 0x0028)
class UEndAnimationSettings final : public UObject
{
public:
	TArray<EObjectTypeQuery>                      IKTerrainTraceObjectTypes;                         // 0x0028(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      IKEffectTraceObjectTypes;                          // 0x0038(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	float                                         LocomotionQuickTurnAngularVelocity;                // 0x0048(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnTimer;                                         // 0x004C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkRunStartInterruptionRatioThresholdNeutral;     // 0x0050(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkRunStartInterruptionRatioThresholdBattle;      // 0x0054(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkRunStartIgnoreRotationRateThreshold;           // 0x0058(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkRunStartAdditiveRootRotationScaleMax;          // 0x005C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationRateInterpSpeed;                           // 0x0060(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackJumpFallGravityScale;                        // 0x0064(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunEndTimer;                                       // 0x0068(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunToDashBlendInputThreshold;                      // 0x006C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWalkNoise;                                      // 0x0070(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkNoiseSpeedMultiplier;                          // 0x0074(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashWallContactMaxDot;                             // 0x0078(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendSpaceWalkRunStartMoveSpeedInterpSpeed;        // 0x007C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendSpaceWalkRunLoopMoveSpeedInterpSpeed;         // 0x0080(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendSpaceWalkRunMoveSlopeInterpSpeed;             // 0x0084(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendSpaceStrafingWalkDirectionInterpSpeed;        // 0x0088(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkInputPoolTime;                                 // 0x008C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleSwitchBehaviorDashInputBlockTime;              // 0x0090(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunSwitchBehaviorDashInputBlockTime;               // 0x0094(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Direction90_MaxThreshold_0;                        // 0x0098(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Direction90_MaxThreshold_90;                       // 0x009C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Direction45_MaxThreshold_0;                        // 0x00A0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Direction45_MaxThreshold_45;                       // 0x00A4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Direction45_MaxThreshold_90;                       // 0x00A8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Direction45_MaxThreshold_135;                      // 0x00AC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RequestMoveToOverrideRotationRate;                 // 0x00B0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleLoopTurnAngleTolerance;                        // 0x00B4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZeroTurnRotationRate;                              // 0x00B8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ContinuationTurnRemainingTime;                     // 0x00BC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandAnimTimer;                                     // 0x00C0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchWakeUpMinTime;                               // 0x00C4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchMinRagdollAirTime;                           // 0x00C8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchWakeUpCrashLandingIKTime;                    // 0x00CC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PowerPerRagdollPenetrationDepth;                   // 0x00D0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RagdollCollisionShapeInflation;                    // 0x00D4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxOverlapDuration;                                // 0x00D8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRagdollPushMagnitude;                           // 0x00DC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRagdollPushMagnitude;                           // 0x00E0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseBodyVolume;                                    // 0x00E4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceRampUpTime;                                   // 0x00E8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowRagdollDebugInfo;                             // 0x00EC(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FieldLookAtSlomoRateMin;                           // 0x00F0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FieldLookAtSlomoActiveTime;                        // 0x00F4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FieldLookAtSlomoWaitTimeRange;                     // 0x00F8(0x0008)(Edit, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FieldLookAtSlomoInterpSpeed;                       // 0x0100(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FieldLookAtSlomoReverseInterpSpeed;                // 0x0104(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTimeMinWhenWaitMode;                          // 0x0108(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnAngularSpeed;                                  // 0x010C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnAngularSpeedOnPlayerInput;                     // 0x0110(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BikeYawRotationSpeed;                              // 0x0114(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTurnAngleToRollAngleFactor;                     // 0x0118(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BikeGravityScale;                                  // 0x011C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DitchRoughness;                                    // 0x0120(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DitchRoughnessInterpSpeed;                         // 0x0124(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideRateInterpSpeed;                              // 0x0128(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BikeBlendSpaceMultiplier;                          // 0x012C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowBikeDebugScreenInfo;                          // 0x0130(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x3];                                      // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BikeWindStrengthMultiplier;                        // 0x0134(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BikeWindFrequency;                                 // 0x0138(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BikeWindAmplitude;                                 // 0x013C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BikeRagdollSmallHitStrength;                       // 0x0140(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BikeRagdollLargeHitStrength;                       // 0x0144(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BikeMaxBankAngle;                                  // 0x0148(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BikeBankAngleInterpIncreaseSpeed;                  // 0x014C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BikeBankAngleInterpDecreaseSpeed;                  // 0x0150(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BikePlayerAdditiveBlendspaceSpeedMultiplier;       // 0x0154(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             BikeRiderBlendSpaceCurve;                          // 0x0158(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x3];                                      // 0x0159(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RiderRagdollKnockbackForce;                        // 0x015C(0x000C)(Edit, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HookShotSpeed;                                     // 0x0168(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HookShotMinPitchAngle;                             // 0x016C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HookShotLandingAdjustRotationTime;                 // 0x0170(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HookSplineBeginTangentScale;                       // 0x0174(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HookSplineEndTangentScale;                         // 0x0178(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HookLaunchRootAdjustDistance;                      // 0x017C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HookAdjustRotationLerpDistance;                    // 0x0180(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HookPreLandingAdjustRotationLerpDistance;          // 0x0184(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TreasureBoxDistance;                               // 0x0188(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TreasureBoxDistanceLR;                             // 0x018C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TreasureBoxPickUpDistance;                         // 0x0190(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TreasureBoxLocationSmoothingSpeed;                 // 0x0194(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TreasureBoxRotationSmoothingSpeed;                 // 0x0198(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TreasureBoxTurnTolerance;                          // 0x019C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TreasureBoxWalkRunEndWaitTime;                     // 0x01A0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PushButtonLocationSmoothingSpeed;                  // 0x01A4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PushButtonRotationSmoothingSpeed;                  // 0x01A8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PushButtonTurnTolerance;                           // 0x01AC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PushButtonWalkRunEndWaitTime;                      // 0x01B0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FaceGuardLoopTimeMin;                              // 0x01B4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AnimationCoolDownTimeRange;                        // 0x01B8(0x0008)(Edit, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationContactWalkTime;                          // 0x01C0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWallSlideDot;                                   // 0x01C4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinWallSlideAngle;                                 // 0x01C8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CC[0x4];                                      // 0x01CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      PhysicalConstraintTraceObjectTypes;                // 0x01D0(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	float                                         LadderPhysicalConstraintBlendInTime;               // 0x01E0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LadderPhysicalConstraintBlendOutTime;              // 0x01E4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AutoSaccadeEyeRotationRangeX;                      // 0x01E8(0x0008)(Edit, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AutoSaccadeEyeRotationRangeY;                      // 0x01F0(0x0008)(Edit, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoSaccadeAdditiveEyeRotationBySpineX;            // 0x01F8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoSaccadeAdditiveEyeRotationBySpineY;            // 0x01FC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoSaccadeFocusChangeAngle;                       // 0x0200(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoSaccadeFocusClusteringAngle;                   // 0x0204(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AutoSaccadeRandomMoveFrame;                        // 0x0208(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AutoSaccadeRandomMoveRotationRangeX;               // 0x020C(0x0008)(Edit, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AutoSaccadeRandomMoveRotationRangeY;               // 0x0214(0x0008)(Edit, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisableLandingLOD;                                 // 0x021C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisableFacialSolverLOD;                            // 0x0220(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisableFacialEyeMoveSolverLOD;                     // 0x0224(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisableFacialEyeMoveSolverLODLight;                // 0x0228(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimationSettings">();
	}
	static class UEndAnimationSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimationSettings>();
	}
};
static_assert(alignof(UEndAnimationSettings) == 0x000008, "Wrong alignment on UEndAnimationSettings");
static_assert(sizeof(UEndAnimationSettings) == 0x000230, "Wrong size on UEndAnimationSettings");
static_assert(offsetof(UEndAnimationSettings, IKTerrainTraceObjectTypes) == 0x000028, "Member 'UEndAnimationSettings::IKTerrainTraceObjectTypes' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, IKEffectTraceObjectTypes) == 0x000038, "Member 'UEndAnimationSettings::IKEffectTraceObjectTypes' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, LocomotionQuickTurnAngularVelocity) == 0x000048, "Member 'UEndAnimationSettings::LocomotionQuickTurnAngularVelocity' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, TurnTimer) == 0x00004C, "Member 'UEndAnimationSettings::TurnTimer' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, WalkRunStartInterruptionRatioThresholdNeutral) == 0x000050, "Member 'UEndAnimationSettings::WalkRunStartInterruptionRatioThresholdNeutral' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, WalkRunStartInterruptionRatioThresholdBattle) == 0x000054, "Member 'UEndAnimationSettings::WalkRunStartInterruptionRatioThresholdBattle' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, WalkRunStartIgnoreRotationRateThreshold) == 0x000058, "Member 'UEndAnimationSettings::WalkRunStartIgnoreRotationRateThreshold' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, WalkRunStartAdditiveRootRotationScaleMax) == 0x00005C, "Member 'UEndAnimationSettings::WalkRunStartAdditiveRootRotationScaleMax' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, RotationRateInterpSpeed) == 0x000060, "Member 'UEndAnimationSettings::RotationRateInterpSpeed' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, AttackJumpFallGravityScale) == 0x000064, "Member 'UEndAnimationSettings::AttackJumpFallGravityScale' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, RunEndTimer) == 0x000068, "Member 'UEndAnimationSettings::RunEndTimer' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, RunToDashBlendInputThreshold) == 0x00006C, "Member 'UEndAnimationSettings::RunToDashBlendInputThreshold' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, MaxWalkNoise) == 0x000070, "Member 'UEndAnimationSettings::MaxWalkNoise' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, WalkNoiseSpeedMultiplier) == 0x000074, "Member 'UEndAnimationSettings::WalkNoiseSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, DashWallContactMaxDot) == 0x000078, "Member 'UEndAnimationSettings::DashWallContactMaxDot' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, BlendSpaceWalkRunStartMoveSpeedInterpSpeed) == 0x00007C, "Member 'UEndAnimationSettings::BlendSpaceWalkRunStartMoveSpeedInterpSpeed' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, BlendSpaceWalkRunLoopMoveSpeedInterpSpeed) == 0x000080, "Member 'UEndAnimationSettings::BlendSpaceWalkRunLoopMoveSpeedInterpSpeed' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, BlendSpaceWalkRunMoveSlopeInterpSpeed) == 0x000084, "Member 'UEndAnimationSettings::BlendSpaceWalkRunMoveSlopeInterpSpeed' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, BlendSpaceStrafingWalkDirectionInterpSpeed) == 0x000088, "Member 'UEndAnimationSettings::BlendSpaceStrafingWalkDirectionInterpSpeed' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, WalkInputPoolTime) == 0x00008C, "Member 'UEndAnimationSettings::WalkInputPoolTime' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, IdleSwitchBehaviorDashInputBlockTime) == 0x000090, "Member 'UEndAnimationSettings::IdleSwitchBehaviorDashInputBlockTime' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, RunSwitchBehaviorDashInputBlockTime) == 0x000094, "Member 'UEndAnimationSettings::RunSwitchBehaviorDashInputBlockTime' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, Direction90_MaxThreshold_0) == 0x000098, "Member 'UEndAnimationSettings::Direction90_MaxThreshold_0' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, Direction90_MaxThreshold_90) == 0x00009C, "Member 'UEndAnimationSettings::Direction90_MaxThreshold_90' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, Direction45_MaxThreshold_0) == 0x0000A0, "Member 'UEndAnimationSettings::Direction45_MaxThreshold_0' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, Direction45_MaxThreshold_45) == 0x0000A4, "Member 'UEndAnimationSettings::Direction45_MaxThreshold_45' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, Direction45_MaxThreshold_90) == 0x0000A8, "Member 'UEndAnimationSettings::Direction45_MaxThreshold_90' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, Direction45_MaxThreshold_135) == 0x0000AC, "Member 'UEndAnimationSettings::Direction45_MaxThreshold_135' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, RequestMoveToOverrideRotationRate) == 0x0000B0, "Member 'UEndAnimationSettings::RequestMoveToOverrideRotationRate' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, IdleLoopTurnAngleTolerance) == 0x0000B4, "Member 'UEndAnimationSettings::IdleLoopTurnAngleTolerance' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, ZeroTurnRotationRate) == 0x0000B8, "Member 'UEndAnimationSettings::ZeroTurnRotationRate' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, ContinuationTurnRemainingTime) == 0x0000BC, "Member 'UEndAnimationSettings::ContinuationTurnRemainingTime' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, LandAnimTimer) == 0x0000C0, "Member 'UEndAnimationSettings::LandAnimTimer' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, LaunchWakeUpMinTime) == 0x0000C4, "Member 'UEndAnimationSettings::LaunchWakeUpMinTime' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, LaunchMinRagdollAirTime) == 0x0000C8, "Member 'UEndAnimationSettings::LaunchMinRagdollAirTime' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, LaunchWakeUpCrashLandingIKTime) == 0x0000CC, "Member 'UEndAnimationSettings::LaunchWakeUpCrashLandingIKTime' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, PowerPerRagdollPenetrationDepth) == 0x0000D0, "Member 'UEndAnimationSettings::PowerPerRagdollPenetrationDepth' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, RagdollCollisionShapeInflation) == 0x0000D4, "Member 'UEndAnimationSettings::RagdollCollisionShapeInflation' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, MaxOverlapDuration) == 0x0000D8, "Member 'UEndAnimationSettings::MaxOverlapDuration' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, MinRagdollPushMagnitude) == 0x0000DC, "Member 'UEndAnimationSettings::MinRagdollPushMagnitude' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, MaxRagdollPushMagnitude) == 0x0000E0, "Member 'UEndAnimationSettings::MaxRagdollPushMagnitude' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, BaseBodyVolume) == 0x0000E4, "Member 'UEndAnimationSettings::BaseBodyVolume' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, ForceRampUpTime) == 0x0000E8, "Member 'UEndAnimationSettings::ForceRampUpTime' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, bShowRagdollDebugInfo) == 0x0000EC, "Member 'UEndAnimationSettings::bShowRagdollDebugInfo' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, FieldLookAtSlomoRateMin) == 0x0000F0, "Member 'UEndAnimationSettings::FieldLookAtSlomoRateMin' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, FieldLookAtSlomoActiveTime) == 0x0000F4, "Member 'UEndAnimationSettings::FieldLookAtSlomoActiveTime' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, FieldLookAtSlomoWaitTimeRange) == 0x0000F8, "Member 'UEndAnimationSettings::FieldLookAtSlomoWaitTimeRange' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, FieldLookAtSlomoInterpSpeed) == 0x000100, "Member 'UEndAnimationSettings::FieldLookAtSlomoInterpSpeed' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, FieldLookAtSlomoReverseInterpSpeed) == 0x000104, "Member 'UEndAnimationSettings::FieldLookAtSlomoReverseInterpSpeed' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, BlendTimeMinWhenWaitMode) == 0x000108, "Member 'UEndAnimationSettings::BlendTimeMinWhenWaitMode' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, TurnAngularSpeed) == 0x00010C, "Member 'UEndAnimationSettings::TurnAngularSpeed' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, TurnAngularSpeedOnPlayerInput) == 0x000110, "Member 'UEndAnimationSettings::TurnAngularSpeedOnPlayerInput' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, BikeYawRotationSpeed) == 0x000114, "Member 'UEndAnimationSettings::BikeYawRotationSpeed' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, MaxTurnAngleToRollAngleFactor) == 0x000118, "Member 'UEndAnimationSettings::MaxTurnAngleToRollAngleFactor' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, BikeGravityScale) == 0x00011C, "Member 'UEndAnimationSettings::BikeGravityScale' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, DitchRoughness) == 0x000120, "Member 'UEndAnimationSettings::DitchRoughness' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, DitchRoughnessInterpSpeed) == 0x000124, "Member 'UEndAnimationSettings::DitchRoughnessInterpSpeed' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, SlideRateInterpSpeed) == 0x000128, "Member 'UEndAnimationSettings::SlideRateInterpSpeed' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, BikeBlendSpaceMultiplier) == 0x00012C, "Member 'UEndAnimationSettings::BikeBlendSpaceMultiplier' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, bShowBikeDebugScreenInfo) == 0x000130, "Member 'UEndAnimationSettings::bShowBikeDebugScreenInfo' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, BikeWindStrengthMultiplier) == 0x000134, "Member 'UEndAnimationSettings::BikeWindStrengthMultiplier' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, BikeWindFrequency) == 0x000138, "Member 'UEndAnimationSettings::BikeWindFrequency' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, BikeWindAmplitude) == 0x00013C, "Member 'UEndAnimationSettings::BikeWindAmplitude' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, BikeRagdollSmallHitStrength) == 0x000140, "Member 'UEndAnimationSettings::BikeRagdollSmallHitStrength' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, BikeRagdollLargeHitStrength) == 0x000144, "Member 'UEndAnimationSettings::BikeRagdollLargeHitStrength' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, BikeMaxBankAngle) == 0x000148, "Member 'UEndAnimationSettings::BikeMaxBankAngle' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, BikeBankAngleInterpIncreaseSpeed) == 0x00014C, "Member 'UEndAnimationSettings::BikeBankAngleInterpIncreaseSpeed' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, BikeBankAngleInterpDecreaseSpeed) == 0x000150, "Member 'UEndAnimationSettings::BikeBankAngleInterpDecreaseSpeed' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, BikePlayerAdditiveBlendspaceSpeedMultiplier) == 0x000154, "Member 'UEndAnimationSettings::BikePlayerAdditiveBlendspaceSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, BikeRiderBlendSpaceCurve) == 0x000158, "Member 'UEndAnimationSettings::BikeRiderBlendSpaceCurve' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, RiderRagdollKnockbackForce) == 0x00015C, "Member 'UEndAnimationSettings::RiderRagdollKnockbackForce' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, HookShotSpeed) == 0x000168, "Member 'UEndAnimationSettings::HookShotSpeed' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, HookShotMinPitchAngle) == 0x00016C, "Member 'UEndAnimationSettings::HookShotMinPitchAngle' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, HookShotLandingAdjustRotationTime) == 0x000170, "Member 'UEndAnimationSettings::HookShotLandingAdjustRotationTime' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, HookSplineBeginTangentScale) == 0x000174, "Member 'UEndAnimationSettings::HookSplineBeginTangentScale' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, HookSplineEndTangentScale) == 0x000178, "Member 'UEndAnimationSettings::HookSplineEndTangentScale' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, HookLaunchRootAdjustDistance) == 0x00017C, "Member 'UEndAnimationSettings::HookLaunchRootAdjustDistance' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, HookAdjustRotationLerpDistance) == 0x000180, "Member 'UEndAnimationSettings::HookAdjustRotationLerpDistance' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, HookPreLandingAdjustRotationLerpDistance) == 0x000184, "Member 'UEndAnimationSettings::HookPreLandingAdjustRotationLerpDistance' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, TreasureBoxDistance) == 0x000188, "Member 'UEndAnimationSettings::TreasureBoxDistance' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, TreasureBoxDistanceLR) == 0x00018C, "Member 'UEndAnimationSettings::TreasureBoxDistanceLR' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, TreasureBoxPickUpDistance) == 0x000190, "Member 'UEndAnimationSettings::TreasureBoxPickUpDistance' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, TreasureBoxLocationSmoothingSpeed) == 0x000194, "Member 'UEndAnimationSettings::TreasureBoxLocationSmoothingSpeed' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, TreasureBoxRotationSmoothingSpeed) == 0x000198, "Member 'UEndAnimationSettings::TreasureBoxRotationSmoothingSpeed' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, TreasureBoxTurnTolerance) == 0x00019C, "Member 'UEndAnimationSettings::TreasureBoxTurnTolerance' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, TreasureBoxWalkRunEndWaitTime) == 0x0001A0, "Member 'UEndAnimationSettings::TreasureBoxWalkRunEndWaitTime' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, PushButtonLocationSmoothingSpeed) == 0x0001A4, "Member 'UEndAnimationSettings::PushButtonLocationSmoothingSpeed' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, PushButtonRotationSmoothingSpeed) == 0x0001A8, "Member 'UEndAnimationSettings::PushButtonRotationSmoothingSpeed' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, PushButtonTurnTolerance) == 0x0001AC, "Member 'UEndAnimationSettings::PushButtonTurnTolerance' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, PushButtonWalkRunEndWaitTime) == 0x0001B0, "Member 'UEndAnimationSettings::PushButtonWalkRunEndWaitTime' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, FaceGuardLoopTimeMin) == 0x0001B4, "Member 'UEndAnimationSettings::FaceGuardLoopTimeMin' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, AnimationCoolDownTimeRange) == 0x0001B8, "Member 'UEndAnimationSettings::AnimationCoolDownTimeRange' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, AnimationContactWalkTime) == 0x0001C0, "Member 'UEndAnimationSettings::AnimationContactWalkTime' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, MaxWallSlideDot) == 0x0001C4, "Member 'UEndAnimationSettings::MaxWallSlideDot' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, MinWallSlideAngle) == 0x0001C8, "Member 'UEndAnimationSettings::MinWallSlideAngle' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, PhysicalConstraintTraceObjectTypes) == 0x0001D0, "Member 'UEndAnimationSettings::PhysicalConstraintTraceObjectTypes' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, LadderPhysicalConstraintBlendInTime) == 0x0001E0, "Member 'UEndAnimationSettings::LadderPhysicalConstraintBlendInTime' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, LadderPhysicalConstraintBlendOutTime) == 0x0001E4, "Member 'UEndAnimationSettings::LadderPhysicalConstraintBlendOutTime' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, AutoSaccadeEyeRotationRangeX) == 0x0001E8, "Member 'UEndAnimationSettings::AutoSaccadeEyeRotationRangeX' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, AutoSaccadeEyeRotationRangeY) == 0x0001F0, "Member 'UEndAnimationSettings::AutoSaccadeEyeRotationRangeY' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, AutoSaccadeAdditiveEyeRotationBySpineX) == 0x0001F8, "Member 'UEndAnimationSettings::AutoSaccadeAdditiveEyeRotationBySpineX' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, AutoSaccadeAdditiveEyeRotationBySpineY) == 0x0001FC, "Member 'UEndAnimationSettings::AutoSaccadeAdditiveEyeRotationBySpineY' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, AutoSaccadeFocusChangeAngle) == 0x000200, "Member 'UEndAnimationSettings::AutoSaccadeFocusChangeAngle' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, AutoSaccadeFocusClusteringAngle) == 0x000204, "Member 'UEndAnimationSettings::AutoSaccadeFocusClusteringAngle' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, AutoSaccadeRandomMoveFrame) == 0x000208, "Member 'UEndAnimationSettings::AutoSaccadeRandomMoveFrame' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, AutoSaccadeRandomMoveRotationRangeX) == 0x00020C, "Member 'UEndAnimationSettings::AutoSaccadeRandomMoveRotationRangeX' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, AutoSaccadeRandomMoveRotationRangeY) == 0x000214, "Member 'UEndAnimationSettings::AutoSaccadeRandomMoveRotationRangeY' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, DisableLandingLOD) == 0x00021C, "Member 'UEndAnimationSettings::DisableLandingLOD' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, DisableFacialSolverLOD) == 0x000220, "Member 'UEndAnimationSettings::DisableFacialSolverLOD' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, DisableFacialEyeMoveSolverLOD) == 0x000224, "Member 'UEndAnimationSettings::DisableFacialEyeMoveSolverLOD' has a wrong offset!");
static_assert(offsetof(UEndAnimationSettings, DisableFacialEyeMoveSolverLODLight) == 0x000228, "Member 'UEndAnimationSettings::DisableFacialEyeMoveSolverLODLight' has a wrong offset!");

// Class EndGame.EndBTD_IsSummonMinRangeAbility
// 0x0050 (0x00B8 - 0x0068)
class UEndBTD_IsSummonMinRangeAbility final : public UEndBTDecorator_CheckConditionBase
{
public:
	struct FBlackboardKeySelector                 FromBlackboardKey_AbilityID;                       // 0x0068(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 FromBlackboardKey_ComboCount;                      // 0x0090(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTD_IsSummonMinRangeAbility">();
	}
	static class UEndBTD_IsSummonMinRangeAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTD_IsSummonMinRangeAbility>();
	}
};
static_assert(alignof(UEndBTD_IsSummonMinRangeAbility) == 0x000008, "Wrong alignment on UEndBTD_IsSummonMinRangeAbility");
static_assert(sizeof(UEndBTD_IsSummonMinRangeAbility) == 0x0000B8, "Wrong size on UEndBTD_IsSummonMinRangeAbility");
static_assert(offsetof(UEndBTD_IsSummonMinRangeAbility, FromBlackboardKey_AbilityID) == 0x000068, "Member 'UEndBTD_IsSummonMinRangeAbility::FromBlackboardKey_AbilityID' has a wrong offset!");
static_assert(offsetof(UEndBTD_IsSummonMinRangeAbility, FromBlackboardKey_ComboCount) == 0x000090, "Member 'UEndBTD_IsSummonMinRangeAbility::FromBlackboardKey_ComboCount' has a wrong offset!");

// Class EndGame.EndTitleDlcWindow
// 0x0050 (0x03B0 - 0x0360)
class UEndTitleDlcWindow : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x50];                                     // 0x0360(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndTitleDlcWindow">();
	}
	static class UEndTitleDlcWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndTitleDlcWindow>();
	}
};
static_assert(alignof(UEndTitleDlcWindow) == 0x000008, "Wrong alignment on UEndTitleDlcWindow");
static_assert(sizeof(UEndTitleDlcWindow) == 0x0003B0, "Wrong size on UEndTitleDlcWindow");

// Class EndGame.EndAnimInstance
// 0x1358 (0x1780 - 0x0428)
class UEndAnimInstance : public UAnimInstance
{
public:
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CenterBoneIndex;                                   // 0x0430(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_434[0x4];                                      // 0x0434(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndLocomotionData*                     NeutralLocomotionData;                             // 0x0438(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndLocomotionData*                     BattleLocomotionData;                              // 0x0440(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EEndLocomotionAnim, struct FEndLocomotionAnimSetting> LocomotionAnimSetting;                             // 0x0448(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, struct FEndAnimResidentBlend> ResidentBlends;                                    // 0x0498(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EEndAnimBehaviorMatchingType                  LocomotionMatchingType;                            // 0x04E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E9[0x7];                                      // 0x04E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           LocomotionMatchingBoneNames;                       // 0x04F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVector2D                              MoveRotationInputRange;                            // 0x0500(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MoveRotationOutputSpeedMaxRange;                   // 0x0508(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EEndLocomotionState, float>              LocomotionRotationRates;                           // 0x0510(0x0050)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	TArray<class FName>                           OverrideIdleActionNames;                           // 0x0560(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      OverrideIdleActionTable;                           // 0x0570(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         OverrideIdleActionIntervalMin;                     // 0x05C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideIdleActionIntervalMax;                     // 0x05C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayRunEndOnRunToWalk;                            // 0x05C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C9[0x3];                                      // 0x05C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideRunEndInputBlockOnRunToWalk;               // 0x05CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdjustRotationInDamageActions;                    // 0x05D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D1[0x3];                                      // 0x05D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CinemaCorrectionHeightInterpSpeed;                 // 0x05D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysInterpCinemaCorrectionHeight;               // 0x05D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreOnEndCutSceneCorrectionHeight;              // 0x05D9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSwitchBehaviorBlendLookAt;                     // 0x05DA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5DB[0x1];                                      // 0x05DB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SwitchBehaviorCustomBoneFilter;                    // 0x05DC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSwitchBehaviorWalkCancelBlend;              // 0x05E4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipBeginGuardDuringRunning;                      // 0x05E5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E6[0x2];                                      // 0x05E6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FaceGuardCustomBoneFilter;                         // 0x05E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabledLaunchRagdoll;                             // 0x05F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F1[0x3];                                      // 0x05F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HipOffsetHeightWhenBattleUpperBodyAction;          // 0x05F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FaceGuardRunEndBlendOutTime;                       // 0x05F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DeadActionConstraintBoneName;                      // 0x05FC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSyncWeapon;                                       // 0x0604(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseIdleMotionOnSyncWeaponMotionMissing;           // 0x0605(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHiddenWeaponInField;                              // 0x0606(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_607[0x1];                                      // 0x0607(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           FieldActionRunInputCancelOverrideLocomotionNames;  // 0x0608(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         FieldActionRunInputCancelOverrideLocomotionRate;   // 0x0618(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61C[0x1164];                                   // 0x061C(0x1164)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimInstance">();
	}
	static class UEndAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimInstance>();
	}
};
static_assert(alignof(UEndAnimInstance) == 0x000008, "Wrong alignment on UEndAnimInstance");
static_assert(sizeof(UEndAnimInstance) == 0x001780, "Wrong size on UEndAnimInstance");
static_assert(offsetof(UEndAnimInstance, CenterBoneIndex) == 0x000430, "Member 'UEndAnimInstance::CenterBoneIndex' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, NeutralLocomotionData) == 0x000438, "Member 'UEndAnimInstance::NeutralLocomotionData' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, BattleLocomotionData) == 0x000440, "Member 'UEndAnimInstance::BattleLocomotionData' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, LocomotionAnimSetting) == 0x000448, "Member 'UEndAnimInstance::LocomotionAnimSetting' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, ResidentBlends) == 0x000498, "Member 'UEndAnimInstance::ResidentBlends' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, LocomotionMatchingType) == 0x0004E8, "Member 'UEndAnimInstance::LocomotionMatchingType' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, LocomotionMatchingBoneNames) == 0x0004F0, "Member 'UEndAnimInstance::LocomotionMatchingBoneNames' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, MoveRotationInputRange) == 0x000500, "Member 'UEndAnimInstance::MoveRotationInputRange' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, MoveRotationOutputSpeedMaxRange) == 0x000508, "Member 'UEndAnimInstance::MoveRotationOutputSpeedMaxRange' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, LocomotionRotationRates) == 0x000510, "Member 'UEndAnimInstance::LocomotionRotationRates' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, OverrideIdleActionNames) == 0x000560, "Member 'UEndAnimInstance::OverrideIdleActionNames' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, OverrideIdleActionTable) == 0x000570, "Member 'UEndAnimInstance::OverrideIdleActionTable' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, OverrideIdleActionIntervalMin) == 0x0005C0, "Member 'UEndAnimInstance::OverrideIdleActionIntervalMin' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, OverrideIdleActionIntervalMax) == 0x0005C4, "Member 'UEndAnimInstance::OverrideIdleActionIntervalMax' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, bPlayRunEndOnRunToWalk) == 0x0005C8, "Member 'UEndAnimInstance::bPlayRunEndOnRunToWalk' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, OverrideRunEndInputBlockOnRunToWalk) == 0x0005CC, "Member 'UEndAnimInstance::OverrideRunEndInputBlockOnRunToWalk' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, bAdjustRotationInDamageActions) == 0x0005D0, "Member 'UEndAnimInstance::bAdjustRotationInDamageActions' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, CinemaCorrectionHeightInterpSpeed) == 0x0005D4, "Member 'UEndAnimInstance::CinemaCorrectionHeightInterpSpeed' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, bAlwaysInterpCinemaCorrectionHeight) == 0x0005D8, "Member 'UEndAnimInstance::bAlwaysInterpCinemaCorrectionHeight' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, bIgnoreOnEndCutSceneCorrectionHeight) == 0x0005D9, "Member 'UEndAnimInstance::bIgnoreOnEndCutSceneCorrectionHeight' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, bUseSwitchBehaviorBlendLookAt) == 0x0005DA, "Member 'UEndAnimInstance::bUseSwitchBehaviorBlendLookAt' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, SwitchBehaviorCustomBoneFilter) == 0x0005DC, "Member 'UEndAnimInstance::SwitchBehaviorCustomBoneFilter' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, bEnableSwitchBehaviorWalkCancelBlend) == 0x0005E4, "Member 'UEndAnimInstance::bEnableSwitchBehaviorWalkCancelBlend' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, bSkipBeginGuardDuringRunning) == 0x0005E5, "Member 'UEndAnimInstance::bSkipBeginGuardDuringRunning' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, FaceGuardCustomBoneFilter) == 0x0005E8, "Member 'UEndAnimInstance::FaceGuardCustomBoneFilter' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, bEnabledLaunchRagdoll) == 0x0005F0, "Member 'UEndAnimInstance::bEnabledLaunchRagdoll' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, HipOffsetHeightWhenBattleUpperBodyAction) == 0x0005F4, "Member 'UEndAnimInstance::HipOffsetHeightWhenBattleUpperBodyAction' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, FaceGuardRunEndBlendOutTime) == 0x0005F8, "Member 'UEndAnimInstance::FaceGuardRunEndBlendOutTime' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, DeadActionConstraintBoneName) == 0x0005FC, "Member 'UEndAnimInstance::DeadActionConstraintBoneName' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, bSyncWeapon) == 0x000604, "Member 'UEndAnimInstance::bSyncWeapon' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, bUseIdleMotionOnSyncWeaponMotionMissing) == 0x000605, "Member 'UEndAnimInstance::bUseIdleMotionOnSyncWeaponMotionMissing' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, bHiddenWeaponInField) == 0x000606, "Member 'UEndAnimInstance::bHiddenWeaponInField' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, FieldActionRunInputCancelOverrideLocomotionNames) == 0x000608, "Member 'UEndAnimInstance::FieldActionRunInputCancelOverrideLocomotionNames' has a wrong offset!");
static_assert(offsetof(UEndAnimInstance, FieldActionRunInputCancelOverrideLocomotionRate) == 0x000618, "Member 'UEndAnimInstance::FieldActionRunInputCancelOverrideLocomotionRate' has a wrong offset!");

// Class EndGame.EndAnimInstanceInterface
// 0x0000 (0x0028 - 0x0028)
class IEndAnimInstanceInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimInstanceInterface">();
	}
	static class IEndAnimInstanceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEndAnimInstanceInterface>();
	}
};
static_assert(alignof(IEndAnimInstanceInterface) == 0x000008, "Wrong alignment on IEndAnimInstanceInterface");
static_assert(sizeof(IEndAnimInstanceInterface) == 0x000028, "Wrong size on IEndAnimInstanceInterface");

// Class EndGame.EndEffectSinCosVector
// 0x0040 (0x00A0 - 0x0060)
class UEndEffectSinCosVector final : public UDistributionVectorConstantCurve
{
public:
	struct FInterpCurveVector                     m_ValueScale;                                      // 0x0060(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                m_CycleTime;                                       // 0x0078(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         m_UseCosX : 1;                                     // 0x0084(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         m_UseCosY : 1;                                     // 0x0084(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         m_UseCosZ : 1;                                     // 0x0084(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         m_AbsoluteX : 1;                                   // 0x0084(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         m_AbsoluteY : 1;                                   // 0x0084(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         m_AbsoluteZ : 1;                                   // 0x0084(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_85[0x1B];                                      // 0x0085(0x001B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEffectSinCosVector">();
	}
	static class UEndEffectSinCosVector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEffectSinCosVector>();
	}
};
static_assert(alignof(UEndEffectSinCosVector) == 0x000008, "Wrong alignment on UEndEffectSinCosVector");
static_assert(sizeof(UEndEffectSinCosVector) == 0x0000A0, "Wrong size on UEndEffectSinCosVector");
static_assert(offsetof(UEndEffectSinCosVector, m_ValueScale) == 0x000060, "Member 'UEndEffectSinCosVector::m_ValueScale' has a wrong offset!");
static_assert(offsetof(UEndEffectSinCosVector, m_CycleTime) == 0x000078, "Member 'UEndEffectSinCosVector::m_CycleTime' has a wrong offset!");

// Class EndGame.EndFieldActionActorBenchBreak
// 0x0018 (0x0630 - 0x0618)
class AEndFieldActionActorBenchBreak final : public AEndFieldActionActorBase
{
public:
	class UEndFieldActionTriggerComponent*        PressVolume;                                       // 0x0618(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0620(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndBenchType                                 BenchType;                                         // 0x0628(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_629[0x7];                                      // 0x0629(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorBenchBreak">();
	}
	static class AEndFieldActionActorBenchBreak* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorBenchBreak>();
	}
};
static_assert(alignof(AEndFieldActionActorBenchBreak) == 0x000008, "Wrong alignment on AEndFieldActionActorBenchBreak");
static_assert(sizeof(AEndFieldActionActorBenchBreak) == 0x000630, "Wrong size on AEndFieldActionActorBenchBreak");
static_assert(offsetof(AEndFieldActionActorBenchBreak, PressVolume) == 0x000618, "Member 'AEndFieldActionActorBenchBreak::PressVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBenchBreak, ModifierVolume) == 0x000620, "Member 'AEndFieldActionActorBenchBreak::ModifierVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBenchBreak, BenchType) == 0x000628, "Member 'AEndFieldActionActorBenchBreak::BenchType' has a wrong offset!");

// Class EndGame.EndBTDecorator_AIPCDurationRequestGuard
// 0x0008 (0x0070 - 0x0068)
class UEndBTDecorator_AIPCDurationRequestGuard final : public UBTDecorator
{
public:
	bool                                          Inverse;                                           // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreRedXIII;                                     // 0x0069(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_AIPCDurationRequestGuard">();
	}
	static class UEndBTDecorator_AIPCDurationRequestGuard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_AIPCDurationRequestGuard>();
	}
};
static_assert(alignof(UEndBTDecorator_AIPCDurationRequestGuard) == 0x000008, "Wrong alignment on UEndBTDecorator_AIPCDurationRequestGuard");
static_assert(sizeof(UEndBTDecorator_AIPCDurationRequestGuard) == 0x000070, "Wrong size on UEndBTDecorator_AIPCDurationRequestGuard");
static_assert(offsetof(UEndBTDecorator_AIPCDurationRequestGuard, Inverse) == 0x000068, "Member 'UEndBTDecorator_AIPCDurationRequestGuard::Inverse' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_AIPCDurationRequestGuard, IgnoreRedXIII) == 0x000069, "Member 'UEndBTDecorator_AIPCDurationRequestGuard::IgnoreRedXIII' has a wrong offset!");

// Class EndGame.EndLocomotionData
// 0x0FA0 (0x0FD0 - 0x0030)
class UEndLocomotionData final : public UDataAsset
{
public:
	struct FEndLocomotionSetting                  Idle;                                              // 0x0030(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FEndLocomotionSetting                  WalkStart;                                         // 0x00F8(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FEndLocomotionSetting                  Walk;                                              // 0x01C0(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FEndLocomotionSetting                  WalkEnd;                                           // 0x0288(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FEndLocomotionSetting                  RunStart;                                          // 0x0350(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FEndLocomotionSetting                  Run;                                               // 0x0418(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FEndLocomotionSetting                  RunEnd;                                            // 0x04E0(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FEndLocomotionSetting                  DashStart;                                         // 0x05A8(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FEndLocomotionSetting                  Dash;                                              // 0x0670(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FEndLocomotionSetting                  DashEnd;                                           // 0x0738(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FEndLocomotionSetting                  DashToWalk;                                        // 0x0800(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FEndLocomotionSetting                  IdleTurn;                                          // 0x08C8(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FEndLocomotionSetting                  WalkTurn;                                          // 0x0990(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FEndLocomotionSetting                  RunTurn;                                           // 0x0A58(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FEndLocomotionSetting                  StrafingWalkStart;                                 // 0x0B20(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FEndLocomotionSetting                  StrafingWalk;                                      // 0x0BE8(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FEndLocomotionSetting                  StrafingWalkEnd;                                   // 0x0CB0(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FEndLocomotionSetting                  SwitchBehavior;                                    // 0x0D78(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FEndLocomotionSetting                  Fall;                                              // 0x0E40(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FEndLocomotionSetting                  FallEnd;                                           // 0x0F08(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndLocomotionData">();
	}
	static class UEndLocomotionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndLocomotionData>();
	}
};
static_assert(alignof(UEndLocomotionData) == 0x000008, "Wrong alignment on UEndLocomotionData");
static_assert(sizeof(UEndLocomotionData) == 0x000FD0, "Wrong size on UEndLocomotionData");
static_assert(offsetof(UEndLocomotionData, Idle) == 0x000030, "Member 'UEndLocomotionData::Idle' has a wrong offset!");
static_assert(offsetof(UEndLocomotionData, WalkStart) == 0x0000F8, "Member 'UEndLocomotionData::WalkStart' has a wrong offset!");
static_assert(offsetof(UEndLocomotionData, Walk) == 0x0001C0, "Member 'UEndLocomotionData::Walk' has a wrong offset!");
static_assert(offsetof(UEndLocomotionData, WalkEnd) == 0x000288, "Member 'UEndLocomotionData::WalkEnd' has a wrong offset!");
static_assert(offsetof(UEndLocomotionData, RunStart) == 0x000350, "Member 'UEndLocomotionData::RunStart' has a wrong offset!");
static_assert(offsetof(UEndLocomotionData, Run) == 0x000418, "Member 'UEndLocomotionData::Run' has a wrong offset!");
static_assert(offsetof(UEndLocomotionData, RunEnd) == 0x0004E0, "Member 'UEndLocomotionData::RunEnd' has a wrong offset!");
static_assert(offsetof(UEndLocomotionData, DashStart) == 0x0005A8, "Member 'UEndLocomotionData::DashStart' has a wrong offset!");
static_assert(offsetof(UEndLocomotionData, Dash) == 0x000670, "Member 'UEndLocomotionData::Dash' has a wrong offset!");
static_assert(offsetof(UEndLocomotionData, DashEnd) == 0x000738, "Member 'UEndLocomotionData::DashEnd' has a wrong offset!");
static_assert(offsetof(UEndLocomotionData, DashToWalk) == 0x000800, "Member 'UEndLocomotionData::DashToWalk' has a wrong offset!");
static_assert(offsetof(UEndLocomotionData, IdleTurn) == 0x0008C8, "Member 'UEndLocomotionData::IdleTurn' has a wrong offset!");
static_assert(offsetof(UEndLocomotionData, WalkTurn) == 0x000990, "Member 'UEndLocomotionData::WalkTurn' has a wrong offset!");
static_assert(offsetof(UEndLocomotionData, RunTurn) == 0x000A58, "Member 'UEndLocomotionData::RunTurn' has a wrong offset!");
static_assert(offsetof(UEndLocomotionData, StrafingWalkStart) == 0x000B20, "Member 'UEndLocomotionData::StrafingWalkStart' has a wrong offset!");
static_assert(offsetof(UEndLocomotionData, StrafingWalk) == 0x000BE8, "Member 'UEndLocomotionData::StrafingWalk' has a wrong offset!");
static_assert(offsetof(UEndLocomotionData, StrafingWalkEnd) == 0x000CB0, "Member 'UEndLocomotionData::StrafingWalkEnd' has a wrong offset!");
static_assert(offsetof(UEndLocomotionData, SwitchBehavior) == 0x000D78, "Member 'UEndLocomotionData::SwitchBehavior' has a wrong offset!");
static_assert(offsetof(UEndLocomotionData, Fall) == 0x000E40, "Member 'UEndLocomotionData::Fall' has a wrong offset!");
static_assert(offsetof(UEndLocomotionData, FallEnd) == 0x000F08, "Member 'UEndLocomotionData::FallEnd' has a wrong offset!");

// Class EndGame.EndAnimNotifyAudioVolumeEventTrigger
// 0x0010 (0x0048 - 0x0038)
class UEndAnimNotifyAudioVolumeEventTrigger final : public UAnimNotify
{
public:
	class FName                                   AudioVolumeEventID;                                // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUsePrefixOwnerID : 1;                             // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyAudioVolumeEventTrigger">();
	}
	static class UEndAnimNotifyAudioVolumeEventTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyAudioVolumeEventTrigger>();
	}
};
static_assert(alignof(UEndAnimNotifyAudioVolumeEventTrigger) == 0x000008, "Wrong alignment on UEndAnimNotifyAudioVolumeEventTrigger");
static_assert(sizeof(UEndAnimNotifyAudioVolumeEventTrigger) == 0x000048, "Wrong size on UEndAnimNotifyAudioVolumeEventTrigger");
static_assert(offsetof(UEndAnimNotifyAudioVolumeEventTrigger, AudioVolumeEventID) == 0x000038, "Member 'UEndAnimNotifyAudioVolumeEventTrigger::AudioVolumeEventID' has a wrong offset!");

// Class EndGame.EndBTDecorator_DurationDisableWalkRunTurn
// 0x0000 (0x0068 - 0x0068)
class UEndBTDecorator_DurationDisableWalkRunTurn final : public UBTDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_DurationDisableWalkRunTurn">();
	}
	static class UEndBTDecorator_DurationDisableWalkRunTurn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_DurationDisableWalkRunTurn>();
	}
};
static_assert(alignof(UEndBTDecorator_DurationDisableWalkRunTurn) == 0x000008, "Wrong alignment on UEndBTDecorator_DurationDisableWalkRunTurn");
static_assert(sizeof(UEndBTDecorator_DurationDisableWalkRunTurn) == 0x000068, "Wrong size on UEndBTDecorator_DurationDisableWalkRunTurn");

// Class EndGame.EndFieldAIController
// 0x49C0 (0x5750 - 0x0D90)
class AEndFieldAIController : public AEndAIController
{
public:
	uint8                                         Pad_D90[0x49C0];                                   // 0x0D90(0x49C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldAIController">();
	}
	static class AEndFieldAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldAIController>();
	}
};
static_assert(alignof(AEndFieldAIController) == 0x000008, "Wrong alignment on AEndFieldAIController");
static_assert(sizeof(AEndFieldAIController) == 0x005750, "Wrong size on AEndFieldAIController");

// Class EndGame.EndFieldAILowerCityChildController
// 0x0000 (0x5750 - 0x5750)
class AEndFieldAILowerCityChildController final : public AEndFieldAIController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldAILowerCityChildController">();
	}
	static class AEndFieldAILowerCityChildController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldAILowerCityChildController>();
	}
};
static_assert(alignof(AEndFieldAILowerCityChildController) == 0x000008, "Wrong alignment on AEndFieldAILowerCityChildController");
static_assert(sizeof(AEndFieldAILowerCityChildController) == 0x005750, "Wrong size on AEndFieldAILowerCityChildController");

// Class EndGame.EndAnimNotifyStateAudioVolumeEventTrigger
// 0x0018 (0x0048 - 0x0030)
class UEndAnimNotifyStateAudioVolumeEventTrigger final : public UAnimNotifyState
{
public:
	class FName                                   OnBeginAudioVolumeEventID;                         // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OnEndAudioVolumeEventID;                           // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUsePrefixOwnerID : 1;                             // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateAudioVolumeEventTrigger">();
	}
	static class UEndAnimNotifyStateAudioVolumeEventTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateAudioVolumeEventTrigger>();
	}
};
static_assert(alignof(UEndAnimNotifyStateAudioVolumeEventTrigger) == 0x000008, "Wrong alignment on UEndAnimNotifyStateAudioVolumeEventTrigger");
static_assert(sizeof(UEndAnimNotifyStateAudioVolumeEventTrigger) == 0x000048, "Wrong size on UEndAnimNotifyStateAudioVolumeEventTrigger");
static_assert(offsetof(UEndAnimNotifyStateAudioVolumeEventTrigger, OnBeginAudioVolumeEventID) == 0x000030, "Member 'UEndAnimNotifyStateAudioVolumeEventTrigger::OnBeginAudioVolumeEventID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateAudioVolumeEventTrigger, OnEndAudioVolumeEventID) == 0x000038, "Member 'UEndAnimNotifyStateAudioVolumeEventTrigger::OnEndAudioVolumeEventID' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattle
// 0x0008 (0x0040 - 0x0038)
class UEndAnimNotifyBattle final : public UAnimNotify
{
public:
	EEndAnimNotifyBattleType                      Type;                                              // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattle">();
	}
	static class UEndAnimNotifyBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattle>();
	}
};
static_assert(alignof(UEndAnimNotifyBattle) == 0x000008, "Wrong alignment on UEndAnimNotifyBattle");
static_assert(sizeof(UEndAnimNotifyBattle) == 0x000040, "Wrong size on UEndAnimNotifyBattle");
static_assert(offsetof(UEndAnimNotifyBattle, Type) == 0x000038, "Member 'UEndAnimNotifyBattle::Type' has a wrong offset!");

// Class EndGame.EndEnvQueryTest_CheckLowerCityChildCronyIndex
// 0x0008 (0x01C8 - 0x01C0)
class UEndEnvQueryTest_CheckLowerCityChildCronyIndex final : public UEnvQueryTest
{
public:
	int32                                         m_Index;                                           // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndAiMathCmp                                 m_ArithmeticOperation;                             // 0x01C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C5[0x3];                                      // 0x01C5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryTest_CheckLowerCityChildCronyIndex">();
	}
	static class UEndEnvQueryTest_CheckLowerCityChildCronyIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryTest_CheckLowerCityChildCronyIndex>();
	}
};
static_assert(alignof(UEndEnvQueryTest_CheckLowerCityChildCronyIndex) == 0x000008, "Wrong alignment on UEndEnvQueryTest_CheckLowerCityChildCronyIndex");
static_assert(sizeof(UEndEnvQueryTest_CheckLowerCityChildCronyIndex) == 0x0001C8, "Wrong size on UEndEnvQueryTest_CheckLowerCityChildCronyIndex");
static_assert(offsetof(UEndEnvQueryTest_CheckLowerCityChildCronyIndex, m_Index) == 0x0001C0, "Member 'UEndEnvQueryTest_CheckLowerCityChildCronyIndex::m_Index' has a wrong offset!");
static_assert(offsetof(UEndEnvQueryTest_CheckLowerCityChildCronyIndex, m_ArithmeticOperation) == 0x0001C4, "Member 'UEndEnvQueryTest_CheckLowerCityChildCronyIndex::m_ArithmeticOperation' has a wrong offset!");

// Class EndGame.EndBTDecorator_AIPCIsWeaponNormalAttackReach
// 0x0000 (0x0068 - 0x0068)
class UEndBTDecorator_AIPCIsWeaponNormalAttackReach final : public UEndBTDecorator_CheckConditionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_AIPCIsWeaponNormalAttackReach">();
	}
	static class UEndBTDecorator_AIPCIsWeaponNormalAttackReach* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_AIPCIsWeaponNormalAttackReach>();
	}
};
static_assert(alignof(UEndBTDecorator_AIPCIsWeaponNormalAttackReach) == 0x000008, "Wrong alignment on UEndBTDecorator_AIPCIsWeaponNormalAttackReach");
static_assert(sizeof(UEndBTDecorator_AIPCIsWeaponNormalAttackReach) == 0x000068, "Wrong size on UEndBTDecorator_AIPCIsWeaponNormalAttackReach");

// Class EndGame.EndFieldAPI
// 0x0000 (0x0028 - 0x0028)
class UEndFieldAPI final : public UObject
{
public:
	static void ActivateCameraFlavorReset(float Pitch, float Yaw);
	static void CallbackCreatePlayerActor(const class FName& partyActorName, class AActor* Actor);
	static bool CheckExclusion(EndFieldExclusion enumValue);
	static void ClearDebugFlag(EEndDebugFlag Flag);
	static void DeactivateCameraFlavorReset();
	static void DelayFinishBattleScene(class FName baseBattleSceneId, float DelayTime);
	static void EntryLocation(const class FName& LocationName);
	static void ExitLoation();
	static bool FieldAiLookAtTarget(class FName TargetActorName, class FName LookAtTargetActorName, const struct FVector& LookAtTargetLocation, float ReactionDistance, bool InIgnoreLookAtDeactiveAngle, bool InIsLookAwayFromActor);
	static struct FTransform FindEndTargetPoint(class FName NodeName);
	static void FinishBattleScene(class FName baseBattleSceneId);
	static struct FVector GetEndTargetPointLocation(class FName NodeName);
	static struct FTransform GetEndTargetPointTransform(class FName NodeName);
	static bool IsEnableFieldControler(bool bEncount);
	static bool IsEnableFieldFullScreenMainMenu();
	static bool IsEnableSkipPauseMenu();
	static bool IsEnableUpdateBattleParameter();
	static bool IsEncountWaveBattleScene(class FName BattleSceneID);
	static bool IsEscaping();
	static bool IsShowEscaping();
	static bool IsStable();
	static bool IsWaveBattleScene(class FName baseBattleSceneId, int32 waveIndex);
	static bool IsWaveCharacter(class AEndCharacter* chara);
	static void PlayBGM(EndFieldBGMLayer Layer, class FName BGM, float fadeStartTime, float fadeEndTime, bool crossFade);
	static void RefreshCacheBGM(const class FString& cacheBGM);
	static bool ResetFieldAiLookAtTarget(class FName TargetActorName);
	static void ResetOverrideTargetLengthCameraFlavorByBP(class FName CharaSpecID);
	static void SendPlannerEventTrigger(const class FName& PlannerEventID, const class FString& TriggerId);
	static void SendStateTrigger(const class FString& StateTriggerName);
	static void SendStateTriggerDirect(const class FString& StateTriggerName);
	static void SetDebugFlag(EEndDebugFlag Flag);
	static void SetExecSlotIndex(int32 SlotIndex);
	static void SetOverrideTargetLengthCameraFlavorByBP(class FName CharaSpecID, class FName dataTableCameraFlavorID);
	static void SetTruthLocationName(class FName truthLocationName);
	static TArray<class FName> StartWaveBattleScene(class FName baseBattleSceneId, EndWaveBattleSceneType Type, int32 IntegerArgument00, int32 IntegerArgument01, int32 IntegerArgument02, int32 IntegerArgument03, const TArray<struct FTransform>& enemyPopTransforms);
	static class FName StartWaveBattleSceneReturnWaveBattleSceneId(class FName baseBattleSceneId, EndWaveBattleSceneType Type, int32 IntegerArgument00, int32 IntegerArgument01, int32 IntegerArgument02, int32 IntegerArgument03, const TArray<struct FTransform>& enemyPopTransforms);
	static void WaitStable(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldAPI">();
	}
	static class UEndFieldAPI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndFieldAPI>();
	}
};
static_assert(alignof(UEndFieldAPI) == 0x000008, "Wrong alignment on UEndFieldAPI");
static_assert(sizeof(UEndFieldAPI) == 0x000028, "Wrong size on UEndFieldAPI");

// Class EndGame.EndAnimNotifyBattleAbilityAimEnd
// 0x0010 (0x0048 - 0x0038)
class UEndAnimNotifyBattleAbilityAimEnd final : public UAnimNotify
{
public:
	TArray<class FName>                           EffectorSettingNames;                              // 0x0038(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleAbilityAimEnd">();
	}
	static class UEndAnimNotifyBattleAbilityAimEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleAbilityAimEnd>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleAbilityAimEnd) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleAbilityAimEnd");
static_assert(sizeof(UEndAnimNotifyBattleAbilityAimEnd) == 0x000048, "Wrong size on UEndAnimNotifyBattleAbilityAimEnd");
static_assert(offsetof(UEndAnimNotifyBattleAbilityAimEnd, EffectorSettingNames) == 0x000038, "Member 'UEndAnimNotifyBattleAbilityAimEnd::EffectorSettingNames' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattleAbilityAimStart
// 0x0010 (0x0048 - 0x0038)
class UEndAnimNotifyBattleAbilityAimStart final : public UAnimNotify
{
public:
	TArray<class FName>                           EffectorSettingNames;                              // 0x0038(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleAbilityAimStart">();
	}
	static class UEndAnimNotifyBattleAbilityAimStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleAbilityAimStart>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleAbilityAimStart) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleAbilityAimStart");
static_assert(sizeof(UEndAnimNotifyBattleAbilityAimStart) == 0x000048, "Wrong size on UEndAnimNotifyBattleAbilityAimStart");
static_assert(offsetof(UEndAnimNotifyBattleAbilityAimStart, EffectorSettingNames) == 0x000038, "Member 'UEndAnimNotifyBattleAbilityAimStart::EffectorSettingNames' has a wrong offset!");

// Class EndGame.EndFieldActionActorCurtain
// 0x0080 (0x0698 - 0x0618)
class AEndFieldActionActorCurtain final : public AEndFieldActionActorBase
{
public:
	class FName                                   EnvActorName;                                      // 0x0618(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableForceAutoClose;                             // 0x0620(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECurtainActiveEffectType                      CurtainActiveEffectType;                           // 0x0621(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_622[0x6];                                      // 0x0622(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndFieldActionTriggerComponent*        PressVolume;                                       // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        PullVolume;                                        // 0x0630(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndSwitchAreaBoxComponent*             DividedVersatileVolume;                            // 0x0638(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndSwitchAreaBoxComponent*             DividedImpassableVolume;                           // 0x0640(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0648(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_650[0x48];                                     // 0x0650(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorCurtain">();
	}
	static class AEndFieldActionActorCurtain* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorCurtain>();
	}
};
static_assert(alignof(AEndFieldActionActorCurtain) == 0x000008, "Wrong alignment on AEndFieldActionActorCurtain");
static_assert(sizeof(AEndFieldActionActorCurtain) == 0x000698, "Wrong size on AEndFieldActionActorCurtain");
static_assert(offsetof(AEndFieldActionActorCurtain, EnvActorName) == 0x000618, "Member 'AEndFieldActionActorCurtain::EnvActorName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCurtain, DisableForceAutoClose) == 0x000620, "Member 'AEndFieldActionActorCurtain::DisableForceAutoClose' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCurtain, CurtainActiveEffectType) == 0x000621, "Member 'AEndFieldActionActorCurtain::CurtainActiveEffectType' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCurtain, PressVolume) == 0x000628, "Member 'AEndFieldActionActorCurtain::PressVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCurtain, PullVolume) == 0x000630, "Member 'AEndFieldActionActorCurtain::PullVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCurtain, DividedVersatileVolume) == 0x000638, "Member 'AEndFieldActionActorCurtain::DividedVersatileVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCurtain, DividedImpassableVolume) == 0x000640, "Member 'AEndFieldActionActorCurtain::DividedImpassableVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCurtain, ModifierVolume) == 0x000648, "Member 'AEndFieldActionActorCurtain::ModifierVolume' has a wrong offset!");

// Class EndGame.EndBTDecorator_AIPCCheckTargetAngle
// 0x0008 (0x0070 - 0x0068)
class UEndBTDecorator_AIPCCheckTargetAngle final : public UEndBTDecorator_CheckConditionBase
{
public:
	ETargetType                                   targetType;                                        // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpecifiedAngle;                                    // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_AIPCCheckTargetAngle">();
	}
	static class UEndBTDecorator_AIPCCheckTargetAngle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_AIPCCheckTargetAngle>();
	}
};
static_assert(alignof(UEndBTDecorator_AIPCCheckTargetAngle) == 0x000008, "Wrong alignment on UEndBTDecorator_AIPCCheckTargetAngle");
static_assert(sizeof(UEndBTDecorator_AIPCCheckTargetAngle) == 0x000070, "Wrong size on UEndBTDecorator_AIPCCheckTargetAngle");
static_assert(offsetof(UEndBTDecorator_AIPCCheckTargetAngle, targetType) == 0x000068, "Member 'UEndBTDecorator_AIPCCheckTargetAngle::targetType' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_AIPCCheckTargetAngle, SpecifiedAngle) == 0x00006C, "Member 'UEndBTDecorator_AIPCCheckTargetAngle::SpecifiedAngle' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattleAbilityCancel
// 0x0010 (0x0048 - 0x0038)
class UEndAnimNotifyBattleAbilityCancel final : public UAnimNotify
{
public:
	TArray<int32>                                 CancelNumbers;                                     // 0x0038(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleAbilityCancel">();
	}
	static class UEndAnimNotifyBattleAbilityCancel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleAbilityCancel>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleAbilityCancel) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleAbilityCancel");
static_assert(sizeof(UEndAnimNotifyBattleAbilityCancel) == 0x000048, "Wrong size on UEndAnimNotifyBattleAbilityCancel");
static_assert(offsetof(UEndAnimNotifyBattleAbilityCancel, CancelNumbers) == 0x000038, "Member 'UEndAnimNotifyBattleAbilityCancel::CancelNumbers' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattleAbilityCancelStart
// 0x0010 (0x0048 - 0x0038)
class UEndAnimNotifyBattleAbilityCancelStart final : public UAnimNotify
{
public:
	TArray<int32>                                 CancelNumbers;                                     // 0x0038(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleAbilityCancelStart">();
	}
	static class UEndAnimNotifyBattleAbilityCancelStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleAbilityCancelStart>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleAbilityCancelStart) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleAbilityCancelStart");
static_assert(sizeof(UEndAnimNotifyBattleAbilityCancelStart) == 0x000048, "Wrong size on UEndAnimNotifyBattleAbilityCancelStart");
static_assert(offsetof(UEndAnimNotifyBattleAbilityCancelStart, CancelNumbers) == 0x000038, "Member 'UEndAnimNotifyBattleAbilityCancelStart::CancelNumbers' has a wrong offset!");

// Class EndGame.EndEnvQueryTest_DangerArea
// 0x0000 (0x01C0 - 0x01C0)
class UEndEnvQueryTest_DangerArea final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryTest_DangerArea">();
	}
	static class UEndEnvQueryTest_DangerArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryTest_DangerArea>();
	}
};
static_assert(alignof(UEndEnvQueryTest_DangerArea) == 0x000008, "Wrong alignment on UEndEnvQueryTest_DangerArea");
static_assert(sizeof(UEndEnvQueryTest_DangerArea) == 0x0001C0, "Wrong size on UEndEnvQueryTest_DangerArea");

// Class EndGame.EndDuctMoveDebugTextComponent
// 0x00D0 (0x07C0 - 0x06F0)
class UEndDuctMoveDebugTextComponent final : public UPrimitiveComponent
{
public:
	uint8                                         Pad_6F0[0xD0];                                     // 0x06F0(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDuctMoveDebugTextComponent">();
	}
	static class UEndDuctMoveDebugTextComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDuctMoveDebugTextComponent>();
	}
};
static_assert(alignof(UEndDuctMoveDebugTextComponent) == 0x000010, "Wrong alignment on UEndDuctMoveDebugTextComponent");
static_assert(sizeof(UEndDuctMoveDebugTextComponent) == 0x0007C0, "Wrong size on UEndDuctMoveDebugTextComponent");

// Class EndGame.EndBTDecorator_ClearBlackboard
// 0x0028 (0x0090 - 0x0068)
class UEndBTDecorator_ClearBlackboard final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 BlackboardKey;                                     // 0x0068(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_ClearBlackboard">();
	}
	static class UEndBTDecorator_ClearBlackboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_ClearBlackboard>();
	}
};
static_assert(alignof(UEndBTDecorator_ClearBlackboard) == 0x000008, "Wrong alignment on UEndBTDecorator_ClearBlackboard");
static_assert(sizeof(UEndBTDecorator_ClearBlackboard) == 0x000090, "Wrong size on UEndBTDecorator_ClearBlackboard");
static_assert(offsetof(UEndBTDecorator_ClearBlackboard, BlackboardKey) == 0x000068, "Member 'UEndBTDecorator_ClearBlackboard::BlackboardKey' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattleAbilityCatchWeapon
// 0x0000 (0x0038 - 0x0038)
class UEndAnimNotifyBattleAbilityCatchWeapon final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleAbilityCatchWeapon">();
	}
	static class UEndAnimNotifyBattleAbilityCatchWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleAbilityCatchWeapon>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleAbilityCatchWeapon) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleAbilityCatchWeapon");
static_assert(sizeof(UEndAnimNotifyBattleAbilityCatchWeapon) == 0x000038, "Wrong size on UEndAnimNotifyBattleAbilityCatchWeapon");

// Class EndGame.EndAnimNotifyBattleAbilityChargeRelease
// 0x0000 (0x0038 - 0x0038)
class UEndAnimNotifyBattleAbilityChargeRelease final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleAbilityChargeRelease">();
	}
	static class UEndAnimNotifyBattleAbilityChargeRelease* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleAbilityChargeRelease>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleAbilityChargeRelease) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleAbilityChargeRelease");
static_assert(sizeof(UEndAnimNotifyBattleAbilityChargeRelease) == 0x000038, "Wrong size on UEndAnimNotifyBattleAbilityChargeRelease");

// Class EndGame.EndBikeManagerActor
// 0x0170 (0x04E8 - 0x0378)
class AEndBikeManagerActor final : public AActor
{
public:
	class UEndBikeNormalPopupComponent*           pNormalPopupComponent;                             // 0x0378(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, TWeakObjectPtr<class UEndBikeEndlessPopupComponent>> pEndlessPopupComponents;                           // 0x0380(0x0050)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	class UEndBikeCutSceneComponent*              pCutSceneComponent;                                // 0x03D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndBikeScoreComponent*                 pScoreComponent;                                   // 0x03D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndBikePlayerController*               pPlayerController;                                 // 0x03E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E8[0x100];                                    // 0x03E8(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikeManagerActor">();
	}
	static class AEndBikeManagerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBikeManagerActor>();
	}
};
static_assert(alignof(AEndBikeManagerActor) == 0x000008, "Wrong alignment on AEndBikeManagerActor");
static_assert(sizeof(AEndBikeManagerActor) == 0x0004E8, "Wrong size on AEndBikeManagerActor");
static_assert(offsetof(AEndBikeManagerActor, pNormalPopupComponent) == 0x000378, "Member 'AEndBikeManagerActor::pNormalPopupComponent' has a wrong offset!");
static_assert(offsetof(AEndBikeManagerActor, pEndlessPopupComponents) == 0x000380, "Member 'AEndBikeManagerActor::pEndlessPopupComponents' has a wrong offset!");
static_assert(offsetof(AEndBikeManagerActor, pCutSceneComponent) == 0x0003D0, "Member 'AEndBikeManagerActor::pCutSceneComponent' has a wrong offset!");
static_assert(offsetof(AEndBikeManagerActor, pScoreComponent) == 0x0003D8, "Member 'AEndBikeManagerActor::pScoreComponent' has a wrong offset!");
static_assert(offsetof(AEndBikeManagerActor, pPlayerController) == 0x0003E0, "Member 'AEndBikeManagerActor::pPlayerController' has a wrong offset!");

// Class EndGame.EndFieldKeyGuideList
// 0x0000 (0x0360 - 0x0360)
class UEndFieldKeyGuideList : public UEndUserWidget
{
public:
	void OnCommandCellSetupField(class UWidget* ItemWidget, int32 ItemIndex);
	void OnCommandCellSetupGBike(class UWidget* ItemWidget, int32 ItemIndex);
	void OnCommandCellSetupPlayFeel(class UWidget* ItemWidget, int32 ItemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldKeyGuideList">();
	}
	static class UEndFieldKeyGuideList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndFieldKeyGuideList>();
	}
};
static_assert(alignof(UEndFieldKeyGuideList) == 0x000008, "Wrong alignment on UEndFieldKeyGuideList");
static_assert(sizeof(UEndFieldKeyGuideList) == 0x000360, "Wrong size on UEndFieldKeyGuideList");

// Class EndGame.EndAnimNotifyBattleAbilityCorrection
// 0x0008 (0x0040 - 0x0038)
class UEndAnimNotifyBattleAbilityCorrection final : public UAnimNotify
{
public:
	bool                                          DistanceEnd;                                       // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DirectionEnd;                                      // 0x0039(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleAbilityCorrection">();
	}
	static class UEndAnimNotifyBattleAbilityCorrection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleAbilityCorrection>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleAbilityCorrection) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleAbilityCorrection");
static_assert(sizeof(UEndAnimNotifyBattleAbilityCorrection) == 0x000040, "Wrong size on UEndAnimNotifyBattleAbilityCorrection");
static_assert(offsetof(UEndAnimNotifyBattleAbilityCorrection, DistanceEnd) == 0x000038, "Member 'UEndAnimNotifyBattleAbilityCorrection::DistanceEnd' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityCorrection, DirectionEnd) == 0x000039, "Member 'UEndAnimNotifyBattleAbilityCorrection::DirectionEnd' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattleAbilityEnergy
// 0x0008 (0x0040 - 0x0038)
class UEndAnimNotifyBattleAbilityEnergy final : public UAnimNotify
{
public:
	EEndAnimNotifyBattleAbilityEnergyType         Type;                                              // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleAbilityEnergy">();
	}
	static class UEndAnimNotifyBattleAbilityEnergy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleAbilityEnergy>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleAbilityEnergy) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleAbilityEnergy");
static_assert(sizeof(UEndAnimNotifyBattleAbilityEnergy) == 0x000040, "Wrong size on UEndAnimNotifyBattleAbilityEnergy");
static_assert(offsetof(UEndAnimNotifyBattleAbilityEnergy, Type) == 0x000038, "Member 'UEndAnimNotifyBattleAbilityEnergy::Type' has a wrong offset!");

// Class EndGame.EndEnvQueryTest_Field_CheckFollowPosition
// 0x0008 (0x01C8 - 0x01C0)
class UEndEnvQueryTest_Field_CheckFollowPosition final : public UEnvQueryTest
{
public:
	EEndFieldAIFollowPosition                     m_FollowPositionType;                              // 0x01C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryTest_Field_CheckFollowPosition">();
	}
	static class UEndEnvQueryTest_Field_CheckFollowPosition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryTest_Field_CheckFollowPosition>();
	}
};
static_assert(alignof(UEndEnvQueryTest_Field_CheckFollowPosition) == 0x000008, "Wrong alignment on UEndEnvQueryTest_Field_CheckFollowPosition");
static_assert(sizeof(UEndEnvQueryTest_Field_CheckFollowPosition) == 0x0001C8, "Wrong size on UEndEnvQueryTest_Field_CheckFollowPosition");
static_assert(offsetof(UEndEnvQueryTest_Field_CheckFollowPosition, m_FollowPositionType) == 0x0001C0, "Member 'UEndEnvQueryTest_Field_CheckFollowPosition::m_FollowPositionType' has a wrong offset!");

// Class EndGame.EndFieldReturnFastTravelIcon
// 0x0018 (0x0378 - 0x0360)
class UEndFieldReturnFastTravelIcon : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x18];                                     // 0x0360(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldReturnFastTravelIcon">();
	}
	static class UEndFieldReturnFastTravelIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndFieldReturnFastTravelIcon>();
	}
};
static_assert(alignof(UEndFieldReturnFastTravelIcon) == 0x000008, "Wrong alignment on UEndFieldReturnFastTravelIcon");
static_assert(sizeof(UEndFieldReturnFastTravelIcon) == 0x000378, "Wrong size on UEndFieldReturnFastTravelIcon");

// Class EndGame.EndBikeAIStunRayController
// 0x0098 (0x1018 - 0x0F80)
#pragma pack(push, 0x1)
class alignas(0x08) AEndBikeAIStunRayController : public AEndBikeAIControllerEnemyBase
{
public:
	float                                         AvoidJumpPointDistance;                            // 0x0F80(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F84[0x94];                                     // 0x0F84(0x0094)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikeAIStunRayController">();
	}
	static class AEndBikeAIStunRayController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBikeAIStunRayController>();
	}
};
#pragma pack(pop)
static_assert(alignof(AEndBikeAIStunRayController) == 0x000008, "Wrong alignment on AEndBikeAIStunRayController");
static_assert(sizeof(AEndBikeAIStunRayController) == 0x001018, "Wrong size on AEndBikeAIStunRayController");
static_assert(offsetof(AEndBikeAIStunRayController, AvoidJumpPointDistance) == 0x000F80, "Member 'AEndBikeAIStunRayController::AvoidJumpPointDistance' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattleAbilityKeepEnd
// 0x0000 (0x0038 - 0x0038)
class UEndAnimNotifyBattleAbilityKeepEnd final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleAbilityKeepEnd">();
	}
	static class UEndAnimNotifyBattleAbilityKeepEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleAbilityKeepEnd>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleAbilityKeepEnd) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleAbilityKeepEnd");
static_assert(sizeof(UEndAnimNotifyBattleAbilityKeepEnd) == 0x000038, "Wrong size on UEndAnimNotifyBattleAbilityKeepEnd");

// Class EndGame.EndAnimNotifyBattleAbilityRushWeapon
// 0x00A0 (0x00D8 - 0x0038)
class UEndAnimNotifyBattleAbilityRushWeapon final : public UAnimNotify
{
public:
	class FName                                   ThrowDamageSourceID;                               // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ThrowAirDamageSourceID;                            // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RushGroundDamageSourceID;                          // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RushGroundWeaponOffsetZ;                           // 0x0050(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RushAirDamageSourceID;                             // 0x0054(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RushTime;                                          // 0x005C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RushCalcDamageCoefficient;                         // 0x0060(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RushCactuarWeaponCharaID;                          // 0x0064(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RushCactuarWeaponPitch;                            // 0x006C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnDamageSourceID;                              // 0x0070(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CatchDamageSourceID;                               // 0x0078(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RotateBoneName;                                    // 0x0080(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ThrowRotateMaxVelocity;                            // 0x0088(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ThrowRotateAcceleration;                           // 0x0094(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnRotateMaxVelocity;                           // 0x00A0(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnRotateAcceleration;                          // 0x00AC(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   BindEffectID;                                      // 0x00B8(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ColorPaletteId;                                    // 0x00C0(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndEmissiveModifierType                      Modifier;                                          // 0x00C8(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndEmissiveCurveType                         Curve;                                             // 0x00C9(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA[0x2];                                       // 0x00CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x00CC(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x00D0(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x00D4(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleAbilityRushWeapon">();
	}
	static class UEndAnimNotifyBattleAbilityRushWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleAbilityRushWeapon>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleAbilityRushWeapon) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleAbilityRushWeapon");
static_assert(sizeof(UEndAnimNotifyBattleAbilityRushWeapon) == 0x0000D8, "Wrong size on UEndAnimNotifyBattleAbilityRushWeapon");
static_assert(offsetof(UEndAnimNotifyBattleAbilityRushWeapon, ThrowDamageSourceID) == 0x000038, "Member 'UEndAnimNotifyBattleAbilityRushWeapon::ThrowDamageSourceID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityRushWeapon, ThrowAirDamageSourceID) == 0x000040, "Member 'UEndAnimNotifyBattleAbilityRushWeapon::ThrowAirDamageSourceID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityRushWeapon, RushGroundDamageSourceID) == 0x000048, "Member 'UEndAnimNotifyBattleAbilityRushWeapon::RushGroundDamageSourceID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityRushWeapon, RushGroundWeaponOffsetZ) == 0x000050, "Member 'UEndAnimNotifyBattleAbilityRushWeapon::RushGroundWeaponOffsetZ' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityRushWeapon, RushAirDamageSourceID) == 0x000054, "Member 'UEndAnimNotifyBattleAbilityRushWeapon::RushAirDamageSourceID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityRushWeapon, RushTime) == 0x00005C, "Member 'UEndAnimNotifyBattleAbilityRushWeapon::RushTime' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityRushWeapon, RushCalcDamageCoefficient) == 0x000060, "Member 'UEndAnimNotifyBattleAbilityRushWeapon::RushCalcDamageCoefficient' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityRushWeapon, RushCactuarWeaponCharaID) == 0x000064, "Member 'UEndAnimNotifyBattleAbilityRushWeapon::RushCactuarWeaponCharaID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityRushWeapon, RushCactuarWeaponPitch) == 0x00006C, "Member 'UEndAnimNotifyBattleAbilityRushWeapon::RushCactuarWeaponPitch' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityRushWeapon, ReturnDamageSourceID) == 0x000070, "Member 'UEndAnimNotifyBattleAbilityRushWeapon::ReturnDamageSourceID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityRushWeapon, CatchDamageSourceID) == 0x000078, "Member 'UEndAnimNotifyBattleAbilityRushWeapon::CatchDamageSourceID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityRushWeapon, RotateBoneName) == 0x000080, "Member 'UEndAnimNotifyBattleAbilityRushWeapon::RotateBoneName' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityRushWeapon, ThrowRotateMaxVelocity) == 0x000088, "Member 'UEndAnimNotifyBattleAbilityRushWeapon::ThrowRotateMaxVelocity' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityRushWeapon, ThrowRotateAcceleration) == 0x000094, "Member 'UEndAnimNotifyBattleAbilityRushWeapon::ThrowRotateAcceleration' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityRushWeapon, ReturnRotateMaxVelocity) == 0x0000A0, "Member 'UEndAnimNotifyBattleAbilityRushWeapon::ReturnRotateMaxVelocity' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityRushWeapon, ReturnRotateAcceleration) == 0x0000AC, "Member 'UEndAnimNotifyBattleAbilityRushWeapon::ReturnRotateAcceleration' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityRushWeapon, BindEffectID) == 0x0000B8, "Member 'UEndAnimNotifyBattleAbilityRushWeapon::BindEffectID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityRushWeapon, ColorPaletteId) == 0x0000C0, "Member 'UEndAnimNotifyBattleAbilityRushWeapon::ColorPaletteId' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityRushWeapon, Modifier) == 0x0000C8, "Member 'UEndAnimNotifyBattleAbilityRushWeapon::Modifier' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityRushWeapon, Curve) == 0x0000C9, "Member 'UEndAnimNotifyBattleAbilityRushWeapon::Curve' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityRushWeapon, Duration) == 0x0000CC, "Member 'UEndAnimNotifyBattleAbilityRushWeapon::Duration' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityRushWeapon, BlendInTime) == 0x0000D0, "Member 'UEndAnimNotifyBattleAbilityRushWeapon::BlendInTime' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityRushWeapon, BlendOutTime) == 0x0000D4, "Member 'UEndAnimNotifyBattleAbilityRushWeapon::BlendOutTime' has a wrong offset!");

// Class EndGame.EndBTDecorator_CheckDistance
// 0x0060 (0x00C8 - 0x0068)
class UEndBTDecorator_CheckDistance : public UEndBTDecorator_CheckConditionBase
{
public:
	struct FBlackboardKeySelector                 FromBlackboardKey;                                 // 0x0068(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 ToBlackboardKey;                                   // 0x0090(0x0028)(Edit, NativeAccessSpecifierPublic)
	EEndAiMathCmp                                 Operator;                                          // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CheckDistance;                                     // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDistanceType                                 DistanceType;                                      // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_CheckDistance">();
	}
	static class UEndBTDecorator_CheckDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_CheckDistance>();
	}
};
static_assert(alignof(UEndBTDecorator_CheckDistance) == 0x000008, "Wrong alignment on UEndBTDecorator_CheckDistance");
static_assert(sizeof(UEndBTDecorator_CheckDistance) == 0x0000C8, "Wrong size on UEndBTDecorator_CheckDistance");
static_assert(offsetof(UEndBTDecorator_CheckDistance, FromBlackboardKey) == 0x000068, "Member 'UEndBTDecorator_CheckDistance::FromBlackboardKey' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_CheckDistance, ToBlackboardKey) == 0x000090, "Member 'UEndBTDecorator_CheckDistance::ToBlackboardKey' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_CheckDistance, Operator) == 0x0000B8, "Member 'UEndBTDecorator_CheckDistance::Operator' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_CheckDistance, CheckDistance) == 0x0000BC, "Member 'UEndBTDecorator_CheckDistance::CheckDistance' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_CheckDistance, DistanceType) == 0x0000C0, "Member 'UEndBTDecorator_CheckDistance::DistanceType' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattleAbilityThrowWeapon
// 0x0070 (0x00A8 - 0x0038)
class UEndAnimNotifyBattleAbilityThrowWeapon final : public UAnimNotify
{
public:
	class FName                                   ThrowDamageSourceID;                               // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnDamageSourceID;                              // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CatchDamageSourceID;                               // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RotateBoneName;                                    // 0x0050(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ThrowRotateMaxVelocity;                            // 0x0058(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ThrowRotateAcceleration;                           // 0x0064(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnRotateMaxVelocity;                           // 0x0070(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnRotateAcceleration;                          // 0x007C(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   BindEffectID;                                      // 0x0088(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ColorPaletteId;                                    // 0x0090(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndEmissiveModifierType                      Modifier;                                          // 0x0098(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndEmissiveCurveType                         Curve;                                             // 0x0099(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x2];                                       // 0x009A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x009C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x00A0(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x00A4(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleAbilityThrowWeapon">();
	}
	static class UEndAnimNotifyBattleAbilityThrowWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleAbilityThrowWeapon>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleAbilityThrowWeapon) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleAbilityThrowWeapon");
static_assert(sizeof(UEndAnimNotifyBattleAbilityThrowWeapon) == 0x0000A8, "Wrong size on UEndAnimNotifyBattleAbilityThrowWeapon");
static_assert(offsetof(UEndAnimNotifyBattleAbilityThrowWeapon, ThrowDamageSourceID) == 0x000038, "Member 'UEndAnimNotifyBattleAbilityThrowWeapon::ThrowDamageSourceID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityThrowWeapon, ReturnDamageSourceID) == 0x000040, "Member 'UEndAnimNotifyBattleAbilityThrowWeapon::ReturnDamageSourceID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityThrowWeapon, CatchDamageSourceID) == 0x000048, "Member 'UEndAnimNotifyBattleAbilityThrowWeapon::CatchDamageSourceID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityThrowWeapon, RotateBoneName) == 0x000050, "Member 'UEndAnimNotifyBattleAbilityThrowWeapon::RotateBoneName' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityThrowWeapon, ThrowRotateMaxVelocity) == 0x000058, "Member 'UEndAnimNotifyBattleAbilityThrowWeapon::ThrowRotateMaxVelocity' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityThrowWeapon, ThrowRotateAcceleration) == 0x000064, "Member 'UEndAnimNotifyBattleAbilityThrowWeapon::ThrowRotateAcceleration' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityThrowWeapon, ReturnRotateMaxVelocity) == 0x000070, "Member 'UEndAnimNotifyBattleAbilityThrowWeapon::ReturnRotateMaxVelocity' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityThrowWeapon, ReturnRotateAcceleration) == 0x00007C, "Member 'UEndAnimNotifyBattleAbilityThrowWeapon::ReturnRotateAcceleration' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityThrowWeapon, BindEffectID) == 0x000088, "Member 'UEndAnimNotifyBattleAbilityThrowWeapon::BindEffectID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityThrowWeapon, ColorPaletteId) == 0x000090, "Member 'UEndAnimNotifyBattleAbilityThrowWeapon::ColorPaletteId' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityThrowWeapon, Modifier) == 0x000098, "Member 'UEndAnimNotifyBattleAbilityThrowWeapon::Modifier' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityThrowWeapon, Curve) == 0x000099, "Member 'UEndAnimNotifyBattleAbilityThrowWeapon::Curve' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityThrowWeapon, Duration) == 0x00009C, "Member 'UEndAnimNotifyBattleAbilityThrowWeapon::Duration' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityThrowWeapon, BlendInTime) == 0x0000A0, "Member 'UEndAnimNotifyBattleAbilityThrowWeapon::BlendInTime' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleAbilityThrowWeapon, BlendOutTime) == 0x0000A4, "Member 'UEndAnimNotifyBattleAbilityThrowWeapon::BlendOutTime' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattleActionRelatedBreakable
// 0x0008 (0x0040 - 0x0038)
class UEndAnimNotifyBattleActionRelatedBreakable final : public UAnimNotify
{
public:
	EEndBattleBreakableRelationActionType         actionType_;                                       // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleActionRelatedBreakable">();
	}
	static class UEndAnimNotifyBattleActionRelatedBreakable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleActionRelatedBreakable>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleActionRelatedBreakable) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleActionRelatedBreakable");
static_assert(sizeof(UEndAnimNotifyBattleActionRelatedBreakable) == 0x000040, "Wrong size on UEndAnimNotifyBattleActionRelatedBreakable");
static_assert(offsetof(UEndAnimNotifyBattleActionRelatedBreakable, actionType_) == 0x000038, "Member 'UEndAnimNotifyBattleActionRelatedBreakable::actionType_' has a wrong offset!");

// Class EndGame.EndEnvQueryTest_Field_ViewLineEscape
// 0x0000 (0x01C0 - 0x01C0)
class UEndEnvQueryTest_Field_ViewLineEscape final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryTest_Field_ViewLineEscape">();
	}
	static class UEndEnvQueryTest_Field_ViewLineEscape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryTest_Field_ViewLineEscape>();
	}
};
static_assert(alignof(UEndEnvQueryTest_Field_ViewLineEscape) == 0x000008, "Wrong alignment on UEndEnvQueryTest_Field_ViewLineEscape");
static_assert(sizeof(UEndEnvQueryTest_Field_ViewLineEscape) == 0x0001C0, "Wrong size on UEndEnvQueryTest_Field_ViewLineEscape");

// Class EndGame.EndBikeCutSceneComponent
// 0x00F8 (0x01F0 - 0x00F8)
class UEndBikeCutSceneComponent final : public UActorComponent
{
public:
	uint8                                         Pad_F8[0xF8];                                      // 0x00F8(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikeCutSceneComponent">();
	}
	static class UEndBikeCutSceneComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBikeCutSceneComponent>();
	}
};
static_assert(alignof(UEndBikeCutSceneComponent) == 0x000008, "Wrong alignment on UEndBikeCutSceneComponent");
static_assert(sizeof(UEndBikeCutSceneComponent) == 0x0001F0, "Wrong size on UEndBikeCutSceneComponent");

// Class EndGame.EndAnimNotifyBattleAnimationSkipEnd
// 0x0008 (0x0040 - 0x0038)
class UEndAnimNotifyBattleAnimationSkipEnd final : public UAnimNotify
{
public:
	int32                                         CancelNumber;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleAnimationSkipEnd">();
	}
	static class UEndAnimNotifyBattleAnimationSkipEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleAnimationSkipEnd>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleAnimationSkipEnd) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleAnimationSkipEnd");
static_assert(sizeof(UEndAnimNotifyBattleAnimationSkipEnd) == 0x000040, "Wrong size on UEndAnimNotifyBattleAnimationSkipEnd");
static_assert(offsetof(UEndAnimNotifyBattleAnimationSkipEnd, CancelNumber) == 0x000038, "Member 'UEndAnimNotifyBattleAnimationSkipEnd::CancelNumber' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattleAnimationSkipStart
// 0x0008 (0x0040 - 0x0038)
class UEndAnimNotifyBattleAnimationSkipStart final : public UAnimNotify
{
public:
	int32                                         CancelNumber;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleAnimationSkipStart">();
	}
	static class UEndAnimNotifyBattleAnimationSkipStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleAnimationSkipStart>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleAnimationSkipStart) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleAnimationSkipStart");
static_assert(sizeof(UEndAnimNotifyBattleAnimationSkipStart) == 0x000040, "Wrong size on UEndAnimNotifyBattleAnimationSkipStart");
static_assert(offsetof(UEndAnimNotifyBattleAnimationSkipStart, CancelNumber) == 0x000038, "Member 'UEndAnimNotifyBattleAnimationSkipStart::CancelNumber' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattleCameraChangeTiming
// 0x0008 (0x0040 - 0x0038)
class UEndAnimNotifyBattleCameraChangeTiming final : public UAnimNotify
{
public:
	EEndNotifyBattleCameraChangeTimingType        ChangeTimingType;                                  // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleCameraChangeTiming">();
	}
	static class UEndAnimNotifyBattleCameraChangeTiming* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleCameraChangeTiming>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleCameraChangeTiming) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleCameraChangeTiming");
static_assert(sizeof(UEndAnimNotifyBattleCameraChangeTiming) == 0x000040, "Wrong size on UEndAnimNotifyBattleCameraChangeTiming");
static_assert(offsetof(UEndAnimNotifyBattleCameraChangeTiming, ChangeTimingType) == 0x000038, "Member 'UEndAnimNotifyBattleCameraChangeTiming::ChangeTimingType' has a wrong offset!");

// Class EndGame.EndDataObjectEnemyParameter
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectEnemyParameter final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectEnemyParameter">();
	}
	static class UEndDataObjectEnemyParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectEnemyParameter>();
	}
};
static_assert(alignof(UEndDataObjectEnemyParameter) == 0x000008, "Wrong alignment on UEndDataObjectEnemyParameter");
static_assert(sizeof(UEndDataObjectEnemyParameter) == 0x000088, "Wrong size on UEndDataObjectEnemyParameter");

// Class EndGame.EndBattleAIController
// 0x14F8 (0x2288 - 0x0D90)
#pragma pack(push, 0x1)
class alignas(0x08) AEndBattleAIController : public AEndAIController
{
public:
	uint8                                         Pad_D90[0x300];                                    // 0x0D90(0x0300)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         RelatedBattleCharaSpec;                            // 0x1090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         PositionAngleQuantity;                             // 0x10A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10A4[0xC];                                     // 0x10A4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRunAround;                                        // 0x10B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAroundWalkMode;                                   // 0x10B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAroundStrafeMode;                                 // 0x10B2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAroundDirection                        AroundDirection;                                   // 0x10B3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AroundAddDistance;                                 // 0x10B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunAroundThreshold;                                // 0x10B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWandering;                                        // 0x10BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10BD[0x3];                                     // 0x10BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WanderingRange;                                    // 0x10C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WanderingInterval;                                 // 0x10C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WanderingIntervalRand;                             // 0x10C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWanderingStrafe;                                  // 0x10CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockMoveMode;                                     // 0x10CD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAcceptMoveAbility;                                // 0x10CE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10CF[0x1];                                     // 0x10CF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SearchMoveTime;                                    // 0x10D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SearchMovePathCheck;                               // 0x10D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10D5[0x7];                                     // 0x10D5(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bForceEscapeMove;                                  // 0x10DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceEscapeTurn;                                  // 0x10DD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10DE[0x1B];                                    // 0x10DE(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bNormalEnemyShrink;                                // 0x10F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUcpcDifHeightAuto;                                // 0x10FA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10FB[0x1];                                     // 0x10FB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UcpcDifHeightAutoRange;                            // 0x10FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActorChaseEndDistance;                             // 0x1100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActorChaseEndDifHeight;                            // 0x1104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  ActorChaseTarget;                                  // 0x1108(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ActorChaseOffset;                                  // 0x1110(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTurnIgnoreMove;                                // 0x111C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111D[0x3];                                     // 0x111D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SearchDistance;                                    // 0x1120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceFar;                                       // 0x1124(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceConfront;                                  // 0x1128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_112C[0x4];                                     // 0x112C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceNear;                                      // 0x1130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDistanceSearchUseConfront;                        // 0x1134(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAerialDistanceSearchTarget;                       // 0x1135(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1136[0x2];                                     // 0x1136(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CharaDistance;                                     // 0x1138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharaDistanceQuantity;                             // 0x113C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanRequestActionAtSync;                           // 0x1140(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1141[0x7];                                     // 0x1141(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AEndCharacter>           ActionTarget;                                      // 0x1148(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForcePositionAngle;                               // 0x1150(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1151[0x3];                                     // 0x1151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForcePositionAngleRange;                           // 0x1154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WhiteListGroup;                                    // 0x1158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlackListGroup;                                    // 0x115C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefenceAreaGroup;                                  // 0x1160(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AirPointGroup;                                     // 0x1164(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChaseGroup;                                        // 0x1168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FearThreshold;                                     // 0x116C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageSourceEntryThreshold;                        // 0x1170(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CanReachRange;                                     // 0x1174(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRescueSizeMove;                                   // 0x1178(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAcceptActionOutArea;                              // 0x1179(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseResetPathAtAbility;                            // 0x117A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAroundDirection                        AerialAroundDirection;                             // 0x117B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AerialAroundStrafe;                                // 0x117C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_117D[0x3];                                     // 0x117D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  AerialFunnelTarget;                                // 0x1180(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AerialFunnelOffset;                                // 0x1188(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAerialFunnelParentRotate;                         // 0x1194(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAerialFunnelParentTarget;                         // 0x1195(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAerialFunnelFixFlag;                              // 0x1196(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1197[0x1];                                     // 0x1197(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AerialFunnelFixTime;                               // 0x1198(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAeriaDecoyMode;                                   // 0x119C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119D[0x3];                                     // 0x119D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AerialGoalRadius;                                  // 0x11A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AerialUsePath;                                     // 0x11A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11A5[0x3];                                     // 0x11A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AerialSplineActor;                                 // 0x11A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AerialSplineRotateMargin;                          // 0x11B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AerialSplineRotateSpeed;                           // 0x11B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AerialSplineAccSpeed;                              // 0x11B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAerialSplineRotatePitch;                          // 0x11BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAerialSplineRotateRoll;                           // 0x11BD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAerialSplineRun;                                  // 0x11BE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11BF[0x1];                                     // 0x11BF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         bAerialSplineThreshold;                            // 0x11C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAerialSplineActive;                               // 0x11C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAerialSplineApproachFront;                        // 0x11C5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C6[0x2];                                     // 0x11C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         bAerialSplineApproachDistanceQuantity;             // 0x11C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         bAerialSplineApproachQuantity;                     // 0x11CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11D0[0x8];                                     // 0x11D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAerialSplineUnloopAutoStop;                       // 0x11D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAerialSplineMotionForwardOnly;                    // 0x11D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAerialSplineStartStopRootMotion;                  // 0x11DA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAerialSplineStrafe;                               // 0x11DB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAerialSplineOverrideYaw;                          // 0x11DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11DD[0x3];                                     // 0x11DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AerialSplineOverrideYawAngle;                      // 0x11E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAerialSplineOverridePitch;                        // 0x11E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11E5[0x3];                                     // 0x11E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AerialSplineOverridePitchAngle;                    // 0x11E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AerialSplineTurn;                                  // 0x11EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAerialSplineAutoAdjust;                           // 0x11ED(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11EE[0x2];                                     // 0x11EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AerialRotateSpeed;                                 // 0x11F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AerialHoveringRange;                               // 0x11F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AerialHoveringInterval;                            // 0x11F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AerialHoveringIntervalRand;                        // 0x11FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1200[0xC];                                     // 0x1200(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAerialHelicopter;                                 // 0x120C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAerialLandingAnywhere;                            // 0x120D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAerialLandingAnywhereAndTargetEqs;                // 0x120E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAerialSplineSpeedMax;                             // 0x120F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AerialSplineSpeed;                                 // 0x1210(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AerialSplineLaunch;                                // 0x1214(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1215[0x3];                                     // 0x1215(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GroundSplineActor;                                 // 0x1218(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanUseFastCalcMove;                                // 0x1220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1221[0xF];                                     // 0x1221(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       SplineComponent;                                   // 0x1230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1238[0x3C];                                    // 0x1238(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          DebugRequestActionLog;                             // 0x1274(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseBoids;                                         // 0x1275(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseBoidsAvoid;                                    // 0x1276(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1277[0x1];                                     // 0x1277(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           UseBoidsAvoidSpec;                                 // 0x1278(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FEndBoidsParam                         Boids;                                             // 0x1288(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_12A8[0x10];                                    // 0x12A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEndAerialBoidsParam                   AerialBoids;                                       // 0x12B8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FEndBattleAIQuantityParam              MoveRangeFactor;                                   // 0x1308(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndBattleAIQuantityParam              TargetDistanceFactor;                              // 0x1310(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndBattleAIQuantityParam              LatestDistanceFactor;                              // 0x1318(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndBattleAIQuantityParam              BoidsFactor;                                       // 0x1320(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndBattleAIQuantityParam              PersonalFactor;                                    // 0x1328(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndBattleAIQuantityParam              CanBlockSeeFactor;                                 // 0x1330(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndBattleAIQuantityParam              RepalsiveFactor;                                   // 0x1338(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndBattleAIQuantityParam              BlackListFactor;                                   // 0x1340(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndBattleAIQuantityParam              AerialBoidsFactor;                                 // 0x1348(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndBattleAIQuantityParam              AerialRepalsiveFactor;                             // 0x1350(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndBattleAIRoleSetting                RoleSetting;                                       // 0x1358(0x01A0)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bTakeDamageDelayMove;                              // 0x14F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHate;                                          // 0x14F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPrepareProcOnce;                                  // 0x14FA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFirstUpdateOnce;                                  // 0x14FB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAcceptInterceptAtStopStatus;                      // 0x14FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14FD[0x87B];                                   // 0x14FD(0x087B)(Fixing Size After Last Property [ Dumper-7 ])
	class AEndCharacter*                          LatestLeader;                                      // 0x1D78(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D80[0x248];                                   // 0x1D80(0x0248)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       TransformSpline;                                   // 0x1FC8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FD0[0x14];                                    // 0x1FD0(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         secondsIntervalATBAttack_;                         // 0x1FE4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FE8[0x4];                                     // 0x1FE8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NextWarpPosition;                                  // 0x1FEC(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        WarpPositions;                                     // 0x1FF8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2008[0x69];                                    // 0x2008(0x0069)(Fixing Size After Last Property [ Dumper-7 ])
	ETriggerBoxCondition                          TriggerBoxCondition;                               // 0x2071(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2072[0x2];                                     // 0x2072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TriggerBoxInSideName;                              // 0x2074(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_207C[0x1C];                                    // 0x207C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, bool>                       workBool_;                                         // 0x2098(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, int32>                      workInt32_;                                        // 0x20E8(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, float>                      workFloat_;                                        // 0x2138(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FVector>             workVector_;                                       // 0x2188(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FRotator>            workRotator_;                                      // 0x21D8(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class FName>                workName_;                                         // 0x2228(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   drawThinkPoint;                                    // 0x2278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowDodgeAngleInfo;                                // 0x2280(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowSensorRange;                                   // 0x2281(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowBattleAreaDistance;                            // 0x2282(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowPushCollisionController;                       // 0x2283(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2284[0x4];                                     // 0x2284(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void BranchAnd2(EEndAIBranchBit* OutSignal, bool A, bool B);

	void AddAirPointArea(const struct FVector& InLocation, float InRadius, int32 InGroup);
	void AddAreaFromModify(EModifierVolumeType InType, int32 InGroup);
	void AddAttachEffect(const struct FEndCharacterAttachEffectArguments& args);
	bool AddBindAction(class FName InName);
	void AddBlackListArea(const struct FVector& InLocation, float InRadius, int32 InGroup);
	void AddChaseArea(const struct FVector& InLocation, float InRadius, int32 InGroup);
	void AddDefenseArea(const struct FVector& InLocation, float InRadius, int32 InGroup);
	int32 AddDestructionPartsName(class FName keyword, class FName meshName, class FName destructionPartsLabelName, class FName restorePartsLabelName);
	int32 AddEasySpawnCharacter(class FName keyword, class FName CharaSpecName, bool spawnedInvisible, bool spawnedDisableCollision, EEndBattleEasySpawnEnableRagdollType enableRagdollType, float destroyTimer, bool recycle, bool enableStartupDestroyTimer);
	void AddIgnoreNavArea(class FName InName);
	void AddPathArea(const struct FVector& InLocation, float InRadius, int32 InGroup);
	void AddSpecialStateEffect(class FName specialStateEffectID);
	void AddSpecialStateEffectWithBeamTarget(class FName specialStateEffectID, const TArray<class AEndCharacter*>& beamTargetCharaList);
	void AddSpecialStatus(EEndBattleSpecialStatusChangeType Type);
	void AddSpecialStatusByID(class FName ID);
	int32 AddSubStep();
	void AddWhiteListArea(const struct FVector& InLocation, float InRadius, int32 InGroup);
	void AIDelay(class UObject* WorldContextObject, float Duration, const struct FLatentActionInfo& LatentInfo);
	void ApplyHate();
	void BranchAnd(bool Flag1, bool Flag2, EEndAIBranchBit* OutSignal);
	void BranchOR(bool Flag1, bool Flag2, EEndAIBranchBit* OutSignal);
	void BranchXOR(bool Flag1, bool Flag2, EEndAIBranchBit* OutSignal);
	void CalcATBChangeValue(float IntervalTime, bool resetComparetiveATB, bool defaultIntervalSeconds);
	void CalcATBCompareValue();
	void CancelActorChase();
	void CancelGroundSpline();
	bool CanSeeBlockCharacter(class AEndCharacter* InChara);
	bool CanSeeBlockTarget();
	bool CanSeeCharacter(class AEndCharacter* InChara);
	bool CanSeeTarget();
	void ChangeBattleScenePhase(int32 Phase);
	void ClearAction();
	void ClearBPDamageCoefficient();
	void ClearDisableRemainAttributeEffect();
	void ClearHPMinLimit();
	void ClearHPMinLimitAIPCAttack();
	void ClearHPMinLimitPassiveDamage();
	void CreateDamageSource(class FName DamageSourceID, class AEndCharacter* targetChara, class FName AbilityID, bool bOverrideDamage, int32 OverrideDamage);
	void CreateDamageSourceByCurrentTargetBase(class FName DamageSourceID);
	void CreateOtherPath();
	void CreateSyncAction(class FName syncActionID, class AEndCharacter* targetChara, bool bOverwrite);
	void DestroyDamageSource(class FName DamageSourceID, bool bDestroyEffect);
	void DisableProcessDead();
	void DoOnceWithThen(const EEndDoOnceCode Code, const struct FLatentActionInfo& LatentInfo, EEndDoOnceOutCode* Result);
	void EnableDamageReactionOwnerSyncAction();
	void EnableProcessDead();
	void EndBurstInstant();
	void EndDisableLatestContactWall();
	void EndFsmAddMotion();
	void FinishBattle();
	void FinishEscape();
	void FloatCmpBranch(float ValueA, float ValueB, EEndAiMathCmp cmp, EEndAIBranchBit* OutSignal);
	void ForceDisableAimEffectorSetting(class FName EffectorSettingName);
	void ForceEnableAimEffectorSetting(class FName EffectorSettingName);
	bool ForceRequestAction(class FName InName);
	int32 GetActionAbilityLocalCountFromID(class FName InAbilityID);
	TArray<class AEndCharacter*> GetActionCharacter(EEndAiBattleTargetType InTarget, class FName InActionName);
	int32 GetActionCount(class FName InName);
	float GetActionInTime(class FName InName);
	int32 GetActionLocalCount(class FName InName);
	int32 GetActionRequestCount(class FName InName);
	float GetActionTime(class FName InName);
	class AEndCharacter* GetAerialBoidsLeader();
	float GetAerialHeliVelocity();
	EBattleAirMoveType GetAerialMoveType();
	float GetAirMoveGoalDistance();
	float GetAirMoveGoalDistance2D();
	int32 GetATB();
	int32 GetATBMax();
	bool GetBattleAIFlag(EBattleAIInfoFlag InType);
	float GetBattleAIParam(EBattleAIInfoParam InType);
	EBattleAIProgress GetBattleAIProgress();
	EBattleInSituationType GetBattleInSituation();
	EBattleMoveType GetBattleMoveType();
	class AEndBattleSceneBlueprint* GetBattleSceneBlueprint();
	int32 GetBattleScenePhase();
	float GetBattleScenePhaseTime();
	float GetBP();
	float GetBPPercent();
	int32 GetCharaBattleID();
	class AEndCharacter* GetCharacter();
	int32 GetCharaRoleID();
	class FName GetCharaSpec();
	class FName GetCurrentAction();
	class FName GetCurrentBindAction();
	float GetDistance(class AEndCharacter* Target, bool Path);
	float GetEnemyABSAngle();
	float GetEnemyAngle();
	float GetEnemyDistance();
	float GetEnemyDistance2D();
	float GetEnemyHeightDistance();
	float GetEnemyHeightDistanceAbs();
	struct FVector GetEnemyLocation();
	void GetEnemyMember(TArray<class AEndCharacter*>* OutMember, bool bAlive);
	TArray<class AEndCharacter*> GetEnemyMembersIgnoreSelf();
	float GetEnemyPitchAngle();
	struct FRotator GetEnemyRotation();
	float GetEnemysDistance();
	float GetEnemyToPathDistance(const struct FVector& Location);
	struct FVector GetEnemyVector();
	EBattleEntryType GetEntryType();
	EEndAiEscapeState GetEscapeState();
	int32 GetHP();
	int32 GetHPMax();
	int32 GetHPPercent();
	class AEndCharacter* GetLeader();
	int32 GetNearestSplinePoint();
	float GetNearestSplinePointFloat();
	struct FVector GetNextWarpPosition();
	int32 GetPartsHPPercent(class FName partsID);
	void GetPartyMember(TArray<class AEndCharacter*>* OutMember, bool bIgnoreSelf);
	float GetPathDistance(const struct FVector& Location);
	int32 GetRaceAndRoleCount(class FName InRace, EEndAiBattleRole InRole);
	int32 GetRaceCount(class FName InRace);
	int32 GetRatioSwitch(const TArray<int32>& inArray);
	int32 GetRatioSwitch2(int32 Switch0, int32 Switch1);
	int32 GetRatioSwitch3(int32 Switch0, int32 Switch1, int32 Switch2);
	int32 GetRemainingHardAttackATB();
	int32 GetRemainingLightAttackATB();
	EEndAiBattleRole GetReserveRole();
	int32 GetReserveStep();
	int32 GetReserveSubStep();
	EEndAiBattleRole GetRole();
	int32 GetRoleCount(EEndAiBattleRole InRole);
	int32 GetSceneEnemyCount();
	TArray<class AEndCharacter*> GetSpecialStatusChangeCharacter(EEndAiBattleTargetType InTarget, EEndBattleSpecialStatusChangeType Type);
	int32 GetSplinePoint();
	float GetSplinePointFloat();
	TArray<class AEndCharacter*> GetStatusChangeCharacter(EEndAiBattleTargetType InTarget, EEndBattleStatusChangeType Type);
	int32 GetStep();
	int32 GetSubStep();
	class AEndCharacter* GetSummonMaster();
	TArray<class AEndCharacter*> GetSyncActionCharacter(EEndAiBattleTargetType InTarget, EEndBattleSyncActionType Type);
	class AEndCharacter* GetTarget();
	class AEndCharacter* GetTargetBase();
	ETriggerBoxCondition GetTriggerBoxCondition();
	struct FVector GetWarpPosition(int32 warpPointId);
	bool GetWorkBool(class FName Name_0);
	float GetWorkFloat(class FName Name_0);
	int32 GetWorkInt32(class FName Name_0);
	class FName GetWorkName(class FName Name_0);
	struct FRotator GetWorkRotator(class FName Name_0);
	struct FVector GetWorkVector(class FName Name_0);
	void HaltAction();
	bool HasAbilityCancelNumber();
	bool HasDamageSource(class FName DamageSourceID);
	bool HasSpecialStatus(EEndBattleSpecialStatusChangeType Type);
	bool HasSpecialStatusByID(class FName ID);
	bool HasStatusChange(EEndAiBattleTargetType InTarget, EEndBattleStatusChangeType Type);
	bool HasStatusChangeDeSpell(EEndAiBattleTargetType InTarget);
	bool HasStatusChangeEsuna(EEndAiBattleTargetType InTarget);
	bool HasStatusDeBarrier(EEndAiBattleTargetType InTarget);
	bool ImmediateAction(class FName InName);
	bool ImmediateBindAction(class FName InName, int32 InCancelID);
	bool ImmediateMotion(class FName InName, float Inter);
	bool ImmediateRegisterMove(class FName InName);
	void ImmediateRegisterMoveWeak(class FName InName);
	void IntCmpBranch(int32 ValueA, int32 ValueB, EEndAiMathCmp cmp, EEndAIBranchBit* OutSignal);
	bool IsAbility(class FName InName);
	bool IsAbilityState();
	bool IsActionCount(class FName InName, int32 InCount, EEndAiMathCmp InCmp);
	bool IsActionLocalCount(class FName InName, int32 InCount, EEndAiMathCmp InCmp);
	bool IsActionTimeOver(class FName InName);
	bool IsAggressive();
	bool IsATB(int32 InATB);
	bool IsATBLightAttack();
	bool IsBadState();
	bool IsBattleAIEnableTick();
	bool IsBattleScenePhase(int32 InPhase);
	void IsBoolBranch(class FName Name_0, EEndAIBranchBit* OutSignal);
	bool IsBPAttackChance();
	bool IsBrokenParts(class FName partsID);
	bool IsBurst();
	bool IsCombo(class FName InName);
	bool IsDelayProcessing();
	bool IsDestruction(class FName keyword);
	bool IsDisableProcessDead();
	bool IsEnemyAngleFront(float InAngle, bool InReverse);
	void IsEnemyAngleFrontBranch(float InAngle, EEndAIBranchBit* OutSignal, bool InReverse);
	void IsEnemyDistanceBranch(float InDistance, EEndAiMathCmp cmp, EEndAIBranchBit* OutSignal);
	bool IsEnemyDistanceHigh(float InDistance);
	bool IsEnemyDistanceLow(float InDistance);
	bool IsEnemyRange(float InMin, float InMax);
	void IsEnemyRangeBranch(float InMin, float InMax, EEndAiMathBinCmp cmp, EEndAIBranchBit* OutSignal);
	bool IsEscaping();
	bool IsFly();
	bool IsHPPercent(int32 Percent, EEndAiMathCmp cmp);
	bool IsIdle();
	bool IsMotion(class FName InName);
	bool IsMotionState();
	bool IsOverrideUpperAnim();
	bool IsRangeArea(class AEndCharacter* InChara, const struct FVector& InLocation, float InRadius);
	bool IsRole(EEndAiBattleRole InRole);
	bool IsRunningAITimer();
	bool IsSceneSense();
	bool IsStep(int32 InStep);
	bool IsStepAndSubStep(int32 InStep, int32 InSubStep);
	bool IsSubStep(int32 InSubStep);
	bool IsToad(EPlayerType PlayerType);
	bool IsTriggerBoxCondition(const ETriggerBoxCondition Condition);
	bool IsValidAerialCharaPoint(const struct FVector& InOffset, bool InRotateYaw);
	bool IsValidPath();
	bool IsValidPathPoint(struct FVector* OutLocation, float InQuantity);
	bool IsWeakCondition();
	bool IsWithinTargetEQS(const struct FVector& inP);
	bool IsWorkFloat(class FName Name_0, float Value, EEndAiMathCmp cmp);
	void IsWorkFloatBranch(class FName Name_0, float Value, EEndAiMathCmp cmp, EEndAIBranchBit* OutSignal);
	bool IsWorkInt32(class FName Name_0, int32 Value, EEndAiMathCmp cmp);
	void IsWorkInt32Branch(class FName Name_0, int32 Value, EEndAiMathCmp cmp, EEndAIBranchBit* OutSignal);
	void LockTargetCharaBase(EEndBattleTargetCharaBaseLockType Type, bool bLock);
	int32 NextSubStep();
	void NotBoolBranch(class FName Name_0, EEndAIBranchBit* OutSignal);
	void NotifyAbilityReaction(float Param0);
	void OnAbilityReactionCondition(EEndBattleAbilityReactionConditionType abilityReactionConditionType);
	void OnAbilityReactionConditionTargetDodge(const class FName& AbilityID, class AEndCharacter* targetChara);
	void OnAbilityReactionConditionTargetDodgeAngle(const class FName& AbilityID, class AEndCharacter* targetChara);
	void OnAbilityReactionConditionTargetDodgeDirection(const class FName& AbilityID, class AEndCharacter* targetChara);
	void OnAddStatusChange(EEndBattleStatusChangeType Type);
	void OnAerialSplineBegin();
	void OnAerialSplineEnd();
	void OnArrivalRegisterMove(class FName InName);
	void OnATBHardAttackEvent();
	void OnATBLightAttackEvent();
	void OnBeginAbility(class AEndCharacter* InChara, class FName InAbilityName);
	void OnBeginCutScene(const class FName& CutsceneID);
	void OnBeginOtherMove();
	void OnBPAttackChanceFinish();
	void OnBPAttackChanceStart();
	void OnBurstBegin();
	void OnBurstEnd(bool instant);
	void OnChangeAggressive();
	void OnChangeLeader(class AEndCharacter* InLeader);
	void OnChangeMotionState(int32 Before, int32 After);
	void OnChangeMoveMode();
	void OnChangePhase(int32 InNew, int32 InOld);
	void OnChangeRole(EEndAiBattleRole InRole);
	void OnChangeStep(int32 InStep);
	void OnCheckBindAction(class FName ActionName, int32 CheckID, int32 ComboIndex);
	void OnClearAction(class FName InName);
	void OnCompleteAbility(class FName InName);
	void OnCompletedAbilityExtraActionEvent(EPlayerType PlayerType, class FName AbilityFName);
	void OnCompleteRegisterMove(class FName InName);
	void OnContactObject(float Angle);
	void OnContactWall(float Angle);
	void OnConvocation(class AEndCharacter* InLeader, class FName InFormationName);
	void OnCreateDamageSource(class AEndCharacter* InOwner, const class FName& DamageSourceID, class UEndBattleDamageSourceComponent* InDamageSource);
	void OnCutSceneMessage(const class FName& Message);
	void OnDamageSourceEntry(class AEndCharacter* InChara, class FName InAbilityName, const struct FVector& InLocation, class UEndBattleDamageSourceComponent* InDamageSourceComponent);
	void OnDead(bool AtBurst);
	void OnDestroyDamageSource(const class FName& DamageSourceID, const struct FVector& Location);
	void OnEndCutScene(const class FName& CutsceneID);
	void OnEndOtherMove();
	void OnEndSetPlay();
	void OnEntryBattleScene();
	void OnEntryCharaRange(class AEndCharacter* InChara);
	void OnEscape();
	void OnEscapeBegin();
	void OnEscapeCancel();
	void OnEscapeSuccess();
	void OnEventAddWeakCondition(EEndBattleWeakConditionType ConditionType);
	void OnEventCompletedWeakCondition(EEndBattleWeakConditionType ConditionType);
	void OnEventDamageOverWeakCondition(EEndBattleWeakConditionType ConditionType);
	void OnEventDamageSource(class FName DamageSourceID);
	void OnEventRemoveWeakCondition(EEndBattleWeakConditionType ConditionType);
	void OnFear(class AEndCharacter* InChara, class FName InAbilityName, const struct FVector& InLocation, class UEndBattleDamageSourceComponent* InDamageSourceComponent);
	void OnFirstUpdate(EEndAiBattleRole InRole, int32 InStep);
	bool OnGetCreateFieldPosition(struct FVector* outPosition, class FName InBattleAbilityID, class FName InDamageSourceID, class FName InAnimationName);
	bool OnGetTargetFieldPosition(struct FVector* outPosition, class FName InBattleAbilityID, class FName InDamageSourceID, class FName InAnimationName);
	void OnGiveDamage(int32 Damage, class AEndCharacter* InTarget, class FName InName, bool InBind, bool InGuard, bool InJustGuard, bool KeepOver, bool InDodge, bool InCounter, class FName InBoneName, bool InAttributeWeak, class FName InDamageSourceID, bool InSteal, bool heal);
	void OnInAreaSensorEvent(EPlayerType PlayerType);
	void OnIncrementBattleCountPerID(class FName TargetCharaName, EEndBattleCountLogType Type, class FName ID, int32 Count);
	void OnInitializeProc();
	void OnInterceptAbility(class FName InName);
	bool OnIsHitDamage(class AEndCharacter* causerChara, class FName AbilityID, int32 abilityUniqueID, class FName DamageSourceID);
	void OnItemStolen();
	void OnKilled(int32 Damage, class AEndCharacter* InTarget, class FName InName, bool InBind);
	void OnMetaEventNotifyEnemyAbility(class AEndCharacter* InSender, class AEndCharacter* InReceiver, class FName InName, bool InNormal);
	void OnMetaEventTakeDamage(int32 Damage, class AEndCharacter* InSender, class AEndCharacter* InReceiver, class FName InName, bool InBind, bool InGuard, bool InDodge, class FName InBoneName, bool InAttributeWeak, bool InHeal);
	void OnMetaMessage(const class FString& InMessage);
	void OnMetaMessageAboutCharacter(class AEndCharacter* InChara, const class FString& InMessage);
	void OnMotionMessage(class FName InMotionName, class FName InName, int32 InIntValue, float InFloatValue);
	void OnMotionStateMessageBegin(class FName InMotionName, class FName InName, int32 InIntValue, float InFloatValue, float InTotalDuration);
	void OnMotionStateMessageEnd(class FName InMotionName, class FName InName, int32 InIntValue, float InFloatValue);
	void OnMotionStateMessageUpdate(class FName InMotionName, class FName InName, int32 InIntValue, float InFloatValue, float InProgress, bool LatestContactWall, bool LatestContact);
	void OnNotifyEnemyAbility(class AEndCharacter* InEnemy, class FName InName, bool InNormal);
	void OnOrder(class AEndCharacter* InChara, class FName InMessage);
	void OnOutAreaSensorEvent(EPlayerType PlayerType);
	void OnOverlapTriggerBox(class FName ObjectName);
	void OnPartsBreak(class FName partsID);
	void OnPassiveUpdate(EEndAiBattleRole InRole, int32 InStep, float DeltaTime);
	void OnPinchCondition(EPlayerType playerTyoe);
	void OnPreBurstBegin();
	void OnPreCalcDamage(class AEndCharacter* causerCharacter, class FName abilityName, class FName DamageSourceID);
	void OnPrepareAbility(class FName InName);
	void OnPrepareProc();
	void OnPreparingAbility(class FName InName);
	void OnPressedDodgeButtonFromSyncAction(float totalPower, float MaxPower);
	void OnPreTakeDamage(float justHitRotYaw, class AEndCharacter* OwnerCharacter, class FName InName, class FName hitBoneName, class FName DamageSourceID, const struct FVector& hitPosition, int32 Damage, bool InGuard);
	void OnReactionSensing(class AEndCharacter* causerChara, EEndBattleReactionInfluenceType ReactionInfluenceType, EEndBattleAttackDirectionType AttackDirectionType, EEndBattleAbilityCommandType CommandType, EEndBattleAttributeType DmgSrcAttributeType, int32 CutValue);
	void OnReactionSensingAbilityInvoke(class AEndCharacter* causerChara, EEndBattleReactionInfluenceType ReactionInfluenceType, EEndBattleAttackDirectionType AttackDirectionType, EEndBattleAbilityCommandType CommandType);
	void OnReactionSensingAbilitySequenceInvoke(class AEndCharacter* causerChara, EEndBattleReactionInfluenceType ReactionInfluenceType, EEndBattleAttackDirectionType AttackDirectionType, EEndBattleAbilityCommandType CommandType, const class UAnimSequence* AnimSequence, float StartTime);
	void OnRemoveStatusChange(EEndBattleStatusChangeType Type);
	void OnRunningRegisterMove(class FName InName);
	void OnShowedWaveBattleScene();
	void OnSpecialStateEffectEvent(class FName EventName);
	void OnSpecialStatusChange(const class FName& SpecialStatusChangeID, EEndBattleSpecialStatusChangeType Type, const class FName& ChangeID, const TArray<float>& Params_0, const TArray<class FName>& ParamIDs, const TArray<class AActor*>& ParamActors);
	void OnSplineModeBegin();
	void OnSplineModeEnd();
	void OnStartSetPlay();
	void OnStolen();
	void OnSummonCutSceneDamaged();
	void OnSummonCutSceneEnd();
	void OnSummonCutSceneRequested();
	void OnSummonEndOfChanting();
	void OnSummonStartChanting();
	void OnSuspendAbility(class FName InName, EEndAiAbilitySuspendFactor InFactor, EEndAiAbilitySuspendTiming InTiming);
	void OnSuspendRegisterTurn(class FName InName);
	void OnSyncActionChange(const class FName& syncActionID, const class FName& ChangeID, const class FName& DetachDamageSourceID);
	void OnSystemMessage(const class FString& InMessage);
	void OnTakeAbilityInvoke(class AEndCharacter* causerChara, const class FName& abilityName, EEndBattleAbilityCommandType AbilityCommandType, const TArray<class FName>& AnimationNameList);
	void OnTakeAbilitySequenceInvoke(class AEndCharacter* causerChara, const class FName& abilityName, const class FName& AnimName, const class UAnimSequence* AnimSequence, float StartTime);
	void OnTakeDamage(int32 Damage, class AEndCharacter* InChara, class FName InName, EEndBattleAbilityCommandType InCommandType, bool InBind, bool InGuard, bool InDodge, class FName InBoneName, bool InAttributeWeak, class FName InDmgSrcID, EEndBattleAttributeType InDmgSrcAttribute, float justHitRotYaw, const struct FVector& hitPosition, bool InHeal, bool InCounter, const struct FEndDataTableBattleDamageSource& dataTableBattleDamageSource, bool useAbilityUCPC);
	void OnTakeDamageOnce(class AEndCharacter* InCauserChara, class FName InAbilityID, bool InAttributeWeak, EEndBattleAbilityCommandType AbilityCommandType);
	void OnUpdate(EEndAiBattleRole InRole, int32 InStep, float DeltaTime);
	void OverrideDamageHitReactionID(class FName AbilityID, const struct FEndDataTableBattleAbility& dataTableBattleAbility, class FName DamageSourceID, bool abilityFirstHit, class FName* damageHitReactionID);
	void PlayAddMotion(class FName motionName, EEndExtraActionLayer Layer, bool bInfiniteLoop);
	int32 PlayBattleCameraSequence(class FName SequenceID);
	void PlayFsmAddMotion(class FName motionBegin, class FName motionLoop, class FName motionEnd);
	void PlayMotion(class FName motionName);
	void PlayPartLoopMotion(class FName motionName, class FName InBone, EEndExtraActionLayer Layer);
	void PlayPartMotion(class FName motionName, class FName InBone, EEndExtraActionLayer Layer, float overrideBlendIn, float overrideBlendOut);
	bool RegisterAbility(class FName InName, class FName InID, float InTime, float InTimeout, int32 InATB, int32 InRandomATB, float InMinRange, float InMaxRange, float InActionMin, float InActionMax, float InHeightMin, float InHeightMax, float InViewRange, bool ViewReverse, float InDelayMove, float InDelayAbility, float InDelayRandAbility, bool InNeedMove, bool InNeedBetterMove, bool InAerialNeedMove, bool InCancelLostTarget, class FName InOverrideLeftAbility, class FName InOverrideRightAbility, bool InNeedSee);
	bool RegisterAbilityListener(class FName InAbility);
	bool RegisterCharaRangeListener(class AEndCharacter* InChara, float InRange);
	bool RegisterCombo(class FName InName, float InTime, int32 InATB, int32 InRandomATB, class FName InAction1, class FName InAction2, class FName InAction3, class FName InAction4, class FName InAction5, class FName InAction6, class FName InAction7, class FName InAction8, bool InLock, bool InTimeout);
	bool RegisterConfront(class FName InName, float InMin, float InMax);
	bool RegisterMotion(class FName InName, float InTime, int32 InOverrideKeep);
	bool RegisterMove(class FName InName, const struct FVector& InLocation, const struct FVector& InLookAt, float InRadius, float InTimeout, bool InPathFind, float InWalkRadius, bool InWaitIdle, float SmoothingDistance, bool InImmediate, float InInterval);
	bool RegisterOrder(class FName InName, class FName InOrder, int32 InCount, class FName InRace, EBattleOrderRule InRule, float InInterest);
	void RegisterOverlapTriggerBox();
	bool RegisterTurn(class FName InName, float InYaw, float InMargin, bool InTarget, float InTimeout);
	void RemakeWeakCondition(ETriggerWeakRemakeType remakeType, bool resetProtectionTime);
	void RemoveAllWeakCondiiton();
	void RemoveAttachEffect(const class FName AttachSocketName, const class FName ResourceName, bool bDestroy);
	void RemoveIgnoreNavArea(class FName InName);
	void RemoveSpecialStateEffect(class FName specialStateEffectID);
	void RemoveSpecialStatus(EEndBattleSpecialStatusChangeType Type);
	void RemoveSpecialStatusByID(class FName ID);
	bool RemoveStatusChange(EEndBattleStatusChangeType Type);
	bool RequestAction(class FName InName);
	bool RequestActionStep(class FName InName, int32 InStep);
	bool RequestActionSubStep(class FName InName, int32 InSubStep);
	void RequestActorChase(class AActor* InActor, const struct FVector& InOffset);
	void RequestAerialCrash(bool InBurst);
	void RequestAttachSyncAction();
	bool RequestBindAction(class FName InName);
	void RequestBurstLaunch();
	void RequestDodge(const struct FVector& Location, bool InEnemy);
	void RequestEscapeWait();
	void RequestGroundCrash(bool InBurst);
	void RequestGroundSpline(class FName InName);
	void RequestGuard(float InTime, bool InMovable);
	void RequestHeliMove(const struct FEndBattleHelicopterSpec& InSpec, int32 InGoal, bool InSkip);
	void RequestHeliOverridePoint(class AEndNavModifierVolume* InNav, const struct FEndBattleHelicopterSpec& InSpec);
	void RequestNextSpline(class FName InName);
	void RequestOtherLaunch();
	void RequestOtherMove();
	bool RequestPathFind(bool IgnoreCanMove);
	bool RequestPathFindLocation(const struct FVector& InLocation, const struct FVector& InLookAt, float InRadius, float SmoothingDistance);
	bool RequestReserveAction(class FName InName, int32 iValue, float fValue, const class FString& sValue);
	bool RequestReserveAction2Arg(class FName InName, int32 iValue, int32 iValue2, float fValue, float fValue2, const class FString& sValue, const class FString& sValue2);
	void RequestShowAbilityName(class FName InName, float InTime, bool bNonGuardableIcon);
	void RequestWandering(const struct FVector& InLocation);
	bool ReserveAbility(class FName InName, bool InImmediate);
	void ResetActionAbilityLocalCountFromID(class FName InAbilityID);
	void ResetActionLocalCount(class FName InName);
	void ResetActionRequestCount(class FName InName);
	void ResetAerial();
	void ResetAirPointArea();
	void ResetAllWork();
	void ResetAngleRangeTargetPoint(class FName SocketName);
	void ResetATB();
	void ResetBlackListArea();
	void ResetBP();
	void ResetChaseArea();
	void ResetDefenseArea();
	void ResetIgnoreNavArea();
	void ResetLatestContactWall();
	void ResetMovementMode();
	void ResetOverrideActiveAimAngle();
	void ResetOverrideAnim(EEndLocomotionAnim InType, const class FName InInter);
	void ResetOverrideBattleCharaPartsSpec(class FName BaseID);
	void ResetOverrideBattleCharaSpec();
	void ResetOverrideKeep();
	void ResetOverrideUpperAnim(bool InPlayEndAnim);
	void ResetPathArea();
	void ResetWhiteListArea();
	void ResetWorkBool(class FName Name_0);
	void ResetWorkFloat(class FName Name_0);
	void ResetWorkInt32(class FName Name_0);
	void ResetWorkName(class FName Name_0);
	void ResetWorkRotator(class FName Name_0);
	void ResetWorkVector(class FName Name_0);
	void SelfDisappear(bool drawPause);
	void SetActionTime(class FName InName, float InTime);
	void SetAerialBoidsLeader(class AEndCharacter* InLeader);
	void SetAerialMoveType(EBattleAirMoveType InType);
	void SetAISpec(class FName InName);
	void SetAngleRangeTargetPoint(class FName SocketName, float baseAngle, float angleRange);
	void SetBattleAbilityRotateStateLocation(const struct FVector& Location);
	void SetBattleAbilityRotateStatePointName(class FName modifierVolumeName);
	void SetBattleAIFlag(EBattleAIInfoFlag InType, bool InFlag);
	void SetBattleAIParam(EBattleAIInfoParam InType, float InParam);
	void SetBattleSafeTransform(bool bEnable);
	void SetBattleSensorShapeType(EBattleSensorShapeType InSensorShapeType, float InAngleRange, float InRadiusMin, float InRadiusMax, class FName InSocketName);
	void SetBodyDummyParts(class FName PartsSpecID);
	void SetBP(float Value);
	void SetBPAttackChance(bool Enable);
	void SetBPDamageCoefficient(float coefficient);
	void SetBPPercent(float Value);
	void SetBurstForceAerial(bool Flag);
	void SetCapturableBySummon(bool Flag);
	void SetCommandLinkageTimeScale(float Scale);
	void SetConfront(float InNear, float InConfront, float InFar);
	void SetCountDownTimer(class FName InName, float InParam);
	void SetDisableBPDamage(bool disable);
	void SetDisableBurst(bool disable);
	void SetDisableParts(class FName partsID, bool bDisableTarget, bool bDisableDamage, bool bDisableDamageCollision);
	void SetDisableReaction(bool disable);
	void SetDisableRemainAttributeEffect(EEndBattleAttributeType attribute);
	void SetDisableSuspendAction(bool disable);
	void SetDisableTargetPoint(class FName SocketName, bool bDisable);
	void SetEnableCompletedAbilityExtraActionEvent(bool InEnable);
	void SetEnableContactWallReturnAngle(bool Enable);
	void SetEnabledUpdateAimLocation(bool bEnabled);
	void SetEnablePauseUpdateDamageSource(bool Enable);
	void SetEnableWeakCondition(EEndWeakConditionEnable Condition, EEndWeakConditionEnableOption Option);
	void SetEyeTraceFlag(bool InTarget, bool InParty, bool InEnemy);
	void SetFly(float InHeight, float InUpSpeed, float InDownSpeed);
	void SetForceDefaultCollisionSetting();
	void SetForceDefaultSetting();
	void SetForceEnableTargetSpecialStatusChange(EEndBattleSpecialStatusChangeType Type, bool Enable);
	void SetForceMoveType(EEndAiMoveMode InType);
	void SetHateUpdateFlag();
	void SetHPMinLimit(int32 Value);
	void SetHPMinLimitAIPCAttackPercent(int32 InPercent);
	void SetHPMinLimitPassiveDamagePercent(int32 InPercent);
	void SetHPMinLimitPercent(int32 InPercent);
	void SetHPPercent(int32 Percent);
	void SetIgnore(float InTime);
	void SetMeshDisp(bool InDisp);
	void SetMovementMode(bool bMovable, bool bHitWall, bool bHitObject, bool bFitFloor, bool bMaxWeight);
	void SetMoveModeParam(EBattleMoveType InType, bool InStrafe, float InRunDistance, float InArrivalRadius);
	void SetNextAbilityTarget(class AEndCharacter* InChara);
	void SetNextWarpPosition(const struct FVector& warpPosition);
	void SetOtherMoveAnim(class FName InStart, class FName InLoop, class FName InEnd);
	void SetOverrideAbilityKeep(int32 Value);
	void SetOverrideAbilityRange(float InPrepareMin, float InPrepareMax, float InMin, float InMax);
	void SetOverrideActiveAimAngle(const struct FVector2D& ActiveYawRange, const struct FVector2D& ActivePitchRange);
	void SetOverrideAerialAroundPoint(bool InOverride, const struct FVector& InPoint);
	void SetOverrideAnim(EEndLocomotionAnim InType, const class FName InName, const class FName InInter, const EEndAnimWalkType InAfterType);
	void SetOverrideAroundPoint(bool InOverride, const struct FVector& InPoint);
	void SetOverrideAroundPointReserveUpdate(bool InOverride, EAroundPointType InType);
	void SetOverrideBattleCharaPartsSpec(class FName BaseID, class FName OverrideId, bool bChangeHP);
	void SetOverrideBattleCharaSpec(class FName BattleCharaSpecID);
	void SetOverrideConfrontCharacter(class AEndCharacter* InChara);
	void SetOverrideKeep(int32 InKeep);
	void SetOverrideKeepFromAbility(class FName InAbilityName);
	void SetOverrideLocomotionAnim(class FName InID);
	void SetOverrideParamTargetCorrectionNotify(class FName motionName, class FName abilityName, bool bOverrideDirectionAngle, float OverrideDirectionAngle, bool bOverrideDistance, float OverrideDistance, bool bOverrideNotDistanceMoveStop, EEndBattleAbilityTargetCloseMoveType OverrideNotDistanceMoveStopType);
	void SetOverrideUpperAnim(const class FName InName, const class FName InInterIn, const class FName InInterOut);
	void SetPauseUpdateDamageSource(bool Pause);
	void SetPreAsyncTick(bool bUse);
	void SetPushCollisionEnable(class FName partId, bool Enable);
	void SetRole(EEndAiBattleRole InRole);
	void SetSecondRoleTerm(EEndAiBattleSecondRole InTerm);
	void SetSpecialStatusStateChangeID(EEndBattleSpecialStatusChangeType Type, class FName StateChangeID, class FName paramID);
	void SetSplinePointFloat(float InPoint);
	void SetStep(int32 InStep, bool InClearSubStep);
	void SetSubStep(int32 InSubStep);
	void SetTarget(class AEndCharacter* InChara);
	void SetTargetAbility(class AEndCharacter* InChara);
	void SetTargetByType(EBattleAISetTargetType InType);
	bool SetTargetPlayer(EPlayerType Type);
	void SetTargetTurn(bool InTurn);
	void SetTriggerBoxCondition(const ETriggerBoxCondition Condition);
	void SetTurn(EBattleMoveType InType, bool InTurn);
	void SetUncheckEnvStaticMeshContactWall(bool uncheck);
	bool SetupCeilJump(float MinQt, float MaxQt, float KickDistQt, float InLimitAngle);
	void SetupDroppingAbility(float Speed, float Acc, float Rotate, float RotateUp, float RotateDown);
	bool SetupWallJump(float MinQt, float MaxQt, float KickDistQt, bool InCeil);
	bool SetupWallJumpDetailed(float MinQt, float MaxQt, float KickDistQt, bool InCeil);
	void SetupWarpInformation(const TArray<class FName>& warpPointNames);
	class FName SetupWaterJump(float InRangeMin, float InRangeMax);
	void SetVisibilityWeapon(bool bVisible, EWeaponSlot weaponSlotType);
	void SetWeakConditionDamageOnlyMode(bool enableDamageOnlyMode, bool enableDamageOverEvent);
	bool SetWorkBool(class FName Name_0, bool Value);
	float SetWorkFloat(class FName Name_0, float Value);
	int32 SetWorkInt32(class FName Name_0, int32 Value);
	class FName SetWorkName(class FName Name_0, class FName Value);
	struct FRotator SetWorkRotator(class FName Name_0, const struct FRotator& Value);
	struct FVector SetWorkVector(class FName Name_0, const struct FVector& Value);
	bool StartBurst(bool Force);
	void StartDisableLatestContactWall();
	void StopAddMotion();
	void StopPartLoopMotion();
	void SuspendAction(bool Ability, bool Motion);
	void SuspendAll();
	void SuspendDamage();
	void SwitchAroundMove();
	void SwitchingTriggerBoxCondition();
	void ToAerial();
	void ToBreak(class FName charaPartsSpecName, bool bEnableBreakMessage);
	bool ToChangeParts(class FName meshName, class FName meshLabel);
	int32 ToDestructionParts(class FName keyword);
	bool ToKillEasySpawnCharacter(class FName keyword, bool forceDestroy);
	void ToLanding();
	bool ToMoveToSocketEasySpawnCharacter(class FName keyword, class FName SocketName);
	int32 ToRepair(class FName charaPartsSpecName, class FName meshLabelName, EEndPartsRepairConditionType Condition);
	void ToRepairWithHPPercent(class FName charaPartsSpecName, class FName meshLabelName, float HPPercent);
	int32 ToRestoreParts(class FName keyword);
	bool ToSpawnEasySpawnCharacter(class FName keyword, const struct FVector& hidePosition, const struct FRotator& Rotation);
	void TransformCharacter(class FName BattleCharaSpecID);
	bool TryPossibleEasySpawnCharacter(class FName keyword);
	void UnregisterOverlapTriggerBox();

	class AEndCharacter* GetEasySpawnCharacter(const class FName& keyword) const;
	bool GetFirstDamageTime(float* FirstDamageTime, const class UAnimSequence* AnimSequecne, float StartTime) const;
	float GetSpecialStatusParamFloat(EEndBattleSpecialStatusChangeType Type, class FName paramID) const;
	void GetSpecialStatusType(TArray<EEndBattleSpecialStatusChangeType>* typeList) const;
	bool IsInDummyBattle() const;
	bool IsInSyncAction() const;
	bool IsLockTargetCharaBase() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIController">();
	}
	static class AEndBattleAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIController>();
	}
};
#pragma pack(pop)
static_assert(alignof(AEndBattleAIController) == 0x000008, "Wrong alignment on AEndBattleAIController");
static_assert(sizeof(AEndBattleAIController) == 0x002288, "Wrong size on AEndBattleAIController");
static_assert(offsetof(AEndBattleAIController, RelatedBattleCharaSpec) == 0x001090, "Member 'AEndBattleAIController::RelatedBattleCharaSpec' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, PositionAngleQuantity) == 0x0010A0, "Member 'AEndBattleAIController::PositionAngleQuantity' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bRunAround) == 0x0010B0, "Member 'AEndBattleAIController::bRunAround' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bAroundWalkMode) == 0x0010B1, "Member 'AEndBattleAIController::bAroundWalkMode' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bAroundStrafeMode) == 0x0010B2, "Member 'AEndBattleAIController::bAroundStrafeMode' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, AroundDirection) == 0x0010B3, "Member 'AEndBattleAIController::AroundDirection' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, AroundAddDistance) == 0x0010B4, "Member 'AEndBattleAIController::AroundAddDistance' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, RunAroundThreshold) == 0x0010B8, "Member 'AEndBattleAIController::RunAroundThreshold' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bWandering) == 0x0010BC, "Member 'AEndBattleAIController::bWandering' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, WanderingRange) == 0x0010C0, "Member 'AEndBattleAIController::WanderingRange' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, WanderingInterval) == 0x0010C4, "Member 'AEndBattleAIController::WanderingInterval' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, WanderingIntervalRand) == 0x0010C8, "Member 'AEndBattleAIController::WanderingIntervalRand' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bWanderingStrafe) == 0x0010CC, "Member 'AEndBattleAIController::bWanderingStrafe' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bLockMoveMode) == 0x0010CD, "Member 'AEndBattleAIController::bLockMoveMode' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bAcceptMoveAbility) == 0x0010CE, "Member 'AEndBattleAIController::bAcceptMoveAbility' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, SearchMoveTime) == 0x0010D0, "Member 'AEndBattleAIController::SearchMoveTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, SearchMovePathCheck) == 0x0010D4, "Member 'AEndBattleAIController::SearchMovePathCheck' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bForceEscapeMove) == 0x0010DC, "Member 'AEndBattleAIController::bForceEscapeMove' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bForceEscapeTurn) == 0x0010DD, "Member 'AEndBattleAIController::bForceEscapeTurn' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bNormalEnemyShrink) == 0x0010F9, "Member 'AEndBattleAIController::bNormalEnemyShrink' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bUcpcDifHeightAuto) == 0x0010FA, "Member 'AEndBattleAIController::bUcpcDifHeightAuto' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, UcpcDifHeightAutoRange) == 0x0010FC, "Member 'AEndBattleAIController::UcpcDifHeightAutoRange' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, ActorChaseEndDistance) == 0x001100, "Member 'AEndBattleAIController::ActorChaseEndDistance' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, ActorChaseEndDifHeight) == 0x001104, "Member 'AEndBattleAIController::ActorChaseEndDifHeight' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, ActorChaseTarget) == 0x001108, "Member 'AEndBattleAIController::ActorChaseTarget' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, ActorChaseOffset) == 0x001110, "Member 'AEndBattleAIController::ActorChaseOffset' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bCanTurnIgnoreMove) == 0x00111C, "Member 'AEndBattleAIController::bCanTurnIgnoreMove' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, SearchDistance) == 0x001120, "Member 'AEndBattleAIController::SearchDistance' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, DistanceFar) == 0x001124, "Member 'AEndBattleAIController::DistanceFar' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, DistanceConfront) == 0x001128, "Member 'AEndBattleAIController::DistanceConfront' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, DistanceNear) == 0x001130, "Member 'AEndBattleAIController::DistanceNear' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bDistanceSearchUseConfront) == 0x001134, "Member 'AEndBattleAIController::bDistanceSearchUseConfront' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bAerialDistanceSearchTarget) == 0x001135, "Member 'AEndBattleAIController::bAerialDistanceSearchTarget' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, CharaDistance) == 0x001138, "Member 'AEndBattleAIController::CharaDistance' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, CharaDistanceQuantity) == 0x00113C, "Member 'AEndBattleAIController::CharaDistanceQuantity' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bCanRequestActionAtSync) == 0x001140, "Member 'AEndBattleAIController::bCanRequestActionAtSync' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, ActionTarget) == 0x001148, "Member 'AEndBattleAIController::ActionTarget' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bForcePositionAngle) == 0x001150, "Member 'AEndBattleAIController::bForcePositionAngle' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, ForcePositionAngleRange) == 0x001154, "Member 'AEndBattleAIController::ForcePositionAngleRange' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, WhiteListGroup) == 0x001158, "Member 'AEndBattleAIController::WhiteListGroup' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, BlackListGroup) == 0x00115C, "Member 'AEndBattleAIController::BlackListGroup' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, DefenceAreaGroup) == 0x001160, "Member 'AEndBattleAIController::DefenceAreaGroup' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, AirPointGroup) == 0x001164, "Member 'AEndBattleAIController::AirPointGroup' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, ChaseGroup) == 0x001168, "Member 'AEndBattleAIController::ChaseGroup' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, FearThreshold) == 0x00116C, "Member 'AEndBattleAIController::FearThreshold' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, DamageSourceEntryThreshold) == 0x001170, "Member 'AEndBattleAIController::DamageSourceEntryThreshold' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, CanReachRange) == 0x001174, "Member 'AEndBattleAIController::CanReachRange' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bRescueSizeMove) == 0x001178, "Member 'AEndBattleAIController::bRescueSizeMove' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bAcceptActionOutArea) == 0x001179, "Member 'AEndBattleAIController::bAcceptActionOutArea' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bUseResetPathAtAbility) == 0x00117A, "Member 'AEndBattleAIController::bUseResetPathAtAbility' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, AerialAroundDirection) == 0x00117B, "Member 'AEndBattleAIController::AerialAroundDirection' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, AerialAroundStrafe) == 0x00117C, "Member 'AEndBattleAIController::AerialAroundStrafe' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, AerialFunnelTarget) == 0x001180, "Member 'AEndBattleAIController::AerialFunnelTarget' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, AerialFunnelOffset) == 0x001188, "Member 'AEndBattleAIController::AerialFunnelOffset' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bAerialFunnelParentRotate) == 0x001194, "Member 'AEndBattleAIController::bAerialFunnelParentRotate' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bAerialFunnelParentTarget) == 0x001195, "Member 'AEndBattleAIController::bAerialFunnelParentTarget' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bAerialFunnelFixFlag) == 0x001196, "Member 'AEndBattleAIController::bAerialFunnelFixFlag' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, AerialFunnelFixTime) == 0x001198, "Member 'AEndBattleAIController::AerialFunnelFixTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bAeriaDecoyMode) == 0x00119C, "Member 'AEndBattleAIController::bAeriaDecoyMode' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, AerialGoalRadius) == 0x0011A0, "Member 'AEndBattleAIController::AerialGoalRadius' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, AerialUsePath) == 0x0011A4, "Member 'AEndBattleAIController::AerialUsePath' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, AerialSplineActor) == 0x0011A8, "Member 'AEndBattleAIController::AerialSplineActor' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, AerialSplineRotateMargin) == 0x0011B0, "Member 'AEndBattleAIController::AerialSplineRotateMargin' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, AerialSplineRotateSpeed) == 0x0011B4, "Member 'AEndBattleAIController::AerialSplineRotateSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, AerialSplineAccSpeed) == 0x0011B8, "Member 'AEndBattleAIController::AerialSplineAccSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bAerialSplineRotatePitch) == 0x0011BC, "Member 'AEndBattleAIController::bAerialSplineRotatePitch' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bAerialSplineRotateRoll) == 0x0011BD, "Member 'AEndBattleAIController::bAerialSplineRotateRoll' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bAerialSplineRun) == 0x0011BE, "Member 'AEndBattleAIController::bAerialSplineRun' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bAerialSplineThreshold) == 0x0011C0, "Member 'AEndBattleAIController::bAerialSplineThreshold' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bAerialSplineActive) == 0x0011C4, "Member 'AEndBattleAIController::bAerialSplineActive' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bAerialSplineApproachFront) == 0x0011C5, "Member 'AEndBattleAIController::bAerialSplineApproachFront' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bAerialSplineApproachDistanceQuantity) == 0x0011C8, "Member 'AEndBattleAIController::bAerialSplineApproachDistanceQuantity' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bAerialSplineApproachQuantity) == 0x0011CC, "Member 'AEndBattleAIController::bAerialSplineApproachQuantity' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bAerialSplineUnloopAutoStop) == 0x0011D8, "Member 'AEndBattleAIController::bAerialSplineUnloopAutoStop' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bAerialSplineMotionForwardOnly) == 0x0011D9, "Member 'AEndBattleAIController::bAerialSplineMotionForwardOnly' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bAerialSplineStartStopRootMotion) == 0x0011DA, "Member 'AEndBattleAIController::bAerialSplineStartStopRootMotion' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bAerialSplineStrafe) == 0x0011DB, "Member 'AEndBattleAIController::bAerialSplineStrafe' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bAerialSplineOverrideYaw) == 0x0011DC, "Member 'AEndBattleAIController::bAerialSplineOverrideYaw' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, AerialSplineOverrideYawAngle) == 0x0011E0, "Member 'AEndBattleAIController::AerialSplineOverrideYawAngle' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bAerialSplineOverridePitch) == 0x0011E4, "Member 'AEndBattleAIController::bAerialSplineOverridePitch' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, AerialSplineOverridePitchAngle) == 0x0011E8, "Member 'AEndBattleAIController::AerialSplineOverridePitchAngle' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, AerialSplineTurn) == 0x0011EC, "Member 'AEndBattleAIController::AerialSplineTurn' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bAerialSplineAutoAdjust) == 0x0011ED, "Member 'AEndBattleAIController::bAerialSplineAutoAdjust' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, AerialRotateSpeed) == 0x0011F0, "Member 'AEndBattleAIController::AerialRotateSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, AerialHoveringRange) == 0x0011F4, "Member 'AEndBattleAIController::AerialHoveringRange' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, AerialHoveringInterval) == 0x0011F8, "Member 'AEndBattleAIController::AerialHoveringInterval' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, AerialHoveringIntervalRand) == 0x0011FC, "Member 'AEndBattleAIController::AerialHoveringIntervalRand' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bAerialHelicopter) == 0x00120C, "Member 'AEndBattleAIController::bAerialHelicopter' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bAerialLandingAnywhere) == 0x00120D, "Member 'AEndBattleAIController::bAerialLandingAnywhere' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bAerialLandingAnywhereAndTargetEqs) == 0x00120E, "Member 'AEndBattleAIController::bAerialLandingAnywhereAndTargetEqs' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bAerialSplineSpeedMax) == 0x00120F, "Member 'AEndBattleAIController::bAerialSplineSpeedMax' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, AerialSplineSpeed) == 0x001210, "Member 'AEndBattleAIController::AerialSplineSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, AerialSplineLaunch) == 0x001214, "Member 'AEndBattleAIController::AerialSplineLaunch' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, GroundSplineActor) == 0x001218, "Member 'AEndBattleAIController::GroundSplineActor' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, CanUseFastCalcMove) == 0x001220, "Member 'AEndBattleAIController::CanUseFastCalcMove' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, SplineComponent) == 0x001230, "Member 'AEndBattleAIController::SplineComponent' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, DebugRequestActionLog) == 0x001274, "Member 'AEndBattleAIController::DebugRequestActionLog' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bUseBoids) == 0x001275, "Member 'AEndBattleAIController::bUseBoids' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bUseBoidsAvoid) == 0x001276, "Member 'AEndBattleAIController::bUseBoidsAvoid' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, UseBoidsAvoidSpec) == 0x001278, "Member 'AEndBattleAIController::UseBoidsAvoidSpec' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, Boids) == 0x001288, "Member 'AEndBattleAIController::Boids' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, AerialBoids) == 0x0012B8, "Member 'AEndBattleAIController::AerialBoids' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, MoveRangeFactor) == 0x001308, "Member 'AEndBattleAIController::MoveRangeFactor' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, TargetDistanceFactor) == 0x001310, "Member 'AEndBattleAIController::TargetDistanceFactor' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, LatestDistanceFactor) == 0x001318, "Member 'AEndBattleAIController::LatestDistanceFactor' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, BoidsFactor) == 0x001320, "Member 'AEndBattleAIController::BoidsFactor' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, PersonalFactor) == 0x001328, "Member 'AEndBattleAIController::PersonalFactor' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, CanBlockSeeFactor) == 0x001330, "Member 'AEndBattleAIController::CanBlockSeeFactor' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, RepalsiveFactor) == 0x001338, "Member 'AEndBattleAIController::RepalsiveFactor' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, BlackListFactor) == 0x001340, "Member 'AEndBattleAIController::BlackListFactor' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, AerialBoidsFactor) == 0x001348, "Member 'AEndBattleAIController::AerialBoidsFactor' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, AerialRepalsiveFactor) == 0x001350, "Member 'AEndBattleAIController::AerialRepalsiveFactor' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, RoleSetting) == 0x001358, "Member 'AEndBattleAIController::RoleSetting' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bTakeDamageDelayMove) == 0x0014F8, "Member 'AEndBattleAIController::bTakeDamageDelayMove' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bUseHate) == 0x0014F9, "Member 'AEndBattleAIController::bUseHate' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bPrepareProcOnce) == 0x0014FA, "Member 'AEndBattleAIController::bPrepareProcOnce' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bFirstUpdateOnce) == 0x0014FB, "Member 'AEndBattleAIController::bFirstUpdateOnce' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, bAcceptInterceptAtStopStatus) == 0x0014FC, "Member 'AEndBattleAIController::bAcceptInterceptAtStopStatus' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, LatestLeader) == 0x001D78, "Member 'AEndBattleAIController::LatestLeader' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, TransformSpline) == 0x001FC8, "Member 'AEndBattleAIController::TransformSpline' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, secondsIntervalATBAttack_) == 0x001FE4, "Member 'AEndBattleAIController::secondsIntervalATBAttack_' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, NextWarpPosition) == 0x001FEC, "Member 'AEndBattleAIController::NextWarpPosition' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, WarpPositions) == 0x001FF8, "Member 'AEndBattleAIController::WarpPositions' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, TriggerBoxCondition) == 0x002071, "Member 'AEndBattleAIController::TriggerBoxCondition' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, TriggerBoxInSideName) == 0x002074, "Member 'AEndBattleAIController::TriggerBoxInSideName' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, workBool_) == 0x002098, "Member 'AEndBattleAIController::workBool_' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, workInt32_) == 0x0020E8, "Member 'AEndBattleAIController::workInt32_' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, workFloat_) == 0x002138, "Member 'AEndBattleAIController::workFloat_' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, workVector_) == 0x002188, "Member 'AEndBattleAIController::workVector_' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, workRotator_) == 0x0021D8, "Member 'AEndBattleAIController::workRotator_' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, workName_) == 0x002228, "Member 'AEndBattleAIController::workName_' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, drawThinkPoint) == 0x002278, "Member 'AEndBattleAIController::drawThinkPoint' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, ShowDodgeAngleInfo) == 0x002280, "Member 'AEndBattleAIController::ShowDodgeAngleInfo' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, ShowSensorRange) == 0x002281, "Member 'AEndBattleAIController::ShowSensorRange' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, ShowBattleAreaDistance) == 0x002282, "Member 'AEndBattleAIController::ShowBattleAreaDistance' has a wrong offset!");
static_assert(offsetof(AEndBattleAIController, ShowPushCollisionController) == 0x002283, "Member 'AEndBattleAIController::ShowPushCollisionController' has a wrong offset!");

// Class EndGame.EndBattleAIEB0021Controller
// 0x0088 (0x2310 - 0x2288)
class AEndBattleAIEB0021Controller final : public AEndBattleAIController
{
public:
	uint8                                         Pad_2288[0x6C];                                    // 0x2288(0x006C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          DrawInBlowArea;                                    // 0x22F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22F5[0x3];                                     // 0x22F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEndBattleAIEB0021Counter>      CounterParams;                                     // 0x22F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2308[0x8];                                     // 0x2308(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableCounter();
	void OnCounterCheck(class FName InTakeAbilityID, class FName InTakeMotionID, class FName InPlanAction, int32 InCount);
	void OnHitTerrainEvent();
	bool RequestBlownAway(class AEndCharacter* causerCharacter, class FName* OutTargetName, struct FVector* OutTargetLocation);
	void SetHitTerrainAbilityName(class FName abilitiName);
	void SetHitTerrainDamageSourceName(class FName damageSourceName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEB0021Controller">();
	}
	static class AEndBattleAIEB0021Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEB0021Controller>();
	}
};
static_assert(alignof(AEndBattleAIEB0021Controller) == 0x000008, "Wrong alignment on AEndBattleAIEB0021Controller");
static_assert(sizeof(AEndBattleAIEB0021Controller) == 0x002310, "Wrong size on AEndBattleAIEB0021Controller");
static_assert(offsetof(AEndBattleAIEB0021Controller, DrawInBlowArea) == 0x0022F4, "Member 'AEndBattleAIEB0021Controller::DrawInBlowArea' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0021Controller, CounterParams) == 0x0022F8, "Member 'AEndBattleAIEB0021Controller::CounterParams' has a wrong offset!");

// Class EndGame.EndNavModifierParamActor
// 0x00A0 (0x0418 - 0x0378)
class AEndNavModifierParamActor final : public AActor
{
public:
	TMap<uint32, struct FEndNavModifierInfo>      ModifierInfoTable;                                 // 0x0378(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<class FName, uint32>                     ModifierIdTable;                                   // 0x03C8(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavModifierParamActor">();
	}
	static class AEndNavModifierParamActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndNavModifierParamActor>();
	}
};
static_assert(alignof(AEndNavModifierParamActor) == 0x000008, "Wrong alignment on AEndNavModifierParamActor");
static_assert(sizeof(AEndNavModifierParamActor) == 0x000418, "Wrong size on AEndNavModifierParamActor");
static_assert(offsetof(AEndNavModifierParamActor, ModifierInfoTable) == 0x000378, "Member 'AEndNavModifierParamActor::ModifierInfoTable' has a wrong offset!");
static_assert(offsetof(AEndNavModifierParamActor, ModifierIdTable) == 0x0003C8, "Member 'AEndNavModifierParamActor::ModifierIdTable' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattleCancelCounter
// 0x0000 (0x0038 - 0x0038)
class UEndAnimNotifyBattleCancelCounter final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleCancelCounter">();
	}
	static class UEndAnimNotifyBattleCancelCounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleCancelCounter>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleCancelCounter) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleCancelCounter");
static_assert(sizeof(UEndAnimNotifyBattleCancelCounter) == 0x000038, "Wrong size on UEndAnimNotifyBattleCancelCounter");

// Class EndGame.EndAnimNotifyBattleCancelDodge
// 0x0000 (0x0038 - 0x0038)
class UEndAnimNotifyBattleCancelDodge final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleCancelDodge">();
	}
	static class UEndAnimNotifyBattleCancelDodge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleCancelDodge>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleCancelDodge) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleCancelDodge");
static_assert(sizeof(UEndAnimNotifyBattleCancelDodge) == 0x000038, "Wrong size on UEndAnimNotifyBattleCancelDodge");

// Class EndGame.EndAnimNotifyBattleCancelGuard
// 0x0000 (0x0038 - 0x0038)
class UEndAnimNotifyBattleCancelGuard final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleCancelGuard">();
	}
	static class UEndAnimNotifyBattleCancelGuard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleCancelGuard>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleCancelGuard) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleCancelGuard");
static_assert(sizeof(UEndAnimNotifyBattleCancelGuard) == 0x000038, "Wrong size on UEndAnimNotifyBattleCancelGuard");

// Class EndGame.EndAnimNotifyBattleCancelGuardOverride
// 0x0000 (0x0038 - 0x0038)
class UEndAnimNotifyBattleCancelGuardOverride final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleCancelGuardOverride">();
	}
	static class UEndAnimNotifyBattleCancelGuardOverride* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleCancelGuardOverride>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleCancelGuardOverride) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleCancelGuardOverride");
static_assert(sizeof(UEndAnimNotifyBattleCancelGuardOverride) == 0x000038, "Wrong size on UEndAnimNotifyBattleCancelGuardOverride");

// Class EndGame.EndDataObjectEnvironmentSpec
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectEnvironmentSpec final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectEnvironmentSpec">();
	}
	static class UEndDataObjectEnvironmentSpec* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectEnvironmentSpec>();
	}
};
static_assert(alignof(UEndDataObjectEnvironmentSpec) == 0x000008, "Wrong alignment on UEndDataObjectEnvironmentSpec");
static_assert(sizeof(UEndDataObjectEnvironmentSpec) == 0x000088, "Wrong size on UEndDataObjectEnvironmentSpec");

// Class EndGame.EndMainSystemMenu
// 0x00D0 (0x0500 - 0x0430)
class UEndMainSystemMenu : public UEndMainMenuWindow
{
public:
	TSubclassOf<class UEndUserWidget>             OptionsMenuWidgetClass;                            // 0x0430(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEndUserWidget>             ChapterSelectWidgetClass;                          // 0x0438(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_440[0xA0];                                     // 0x0440(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSoftObjectPath>                _BillboardImagePaths;                              // 0x04E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class UEndUserWidget*                         PlaylogList;                                       // 0x04F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndNewOptionsMenu*                     OptionsMenu;                                       // 0x04F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnLeftMenuPressedItem(int32 ItemIndex);
	void OnLeftMenuSetupItem(class UWidget* ItemWidget, int32 ItemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainSystemMenu">();
	}
	static class UEndMainSystemMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainSystemMenu>();
	}
};
static_assert(alignof(UEndMainSystemMenu) == 0x000008, "Wrong alignment on UEndMainSystemMenu");
static_assert(sizeof(UEndMainSystemMenu) == 0x000500, "Wrong size on UEndMainSystemMenu");
static_assert(offsetof(UEndMainSystemMenu, OptionsMenuWidgetClass) == 0x000430, "Member 'UEndMainSystemMenu::OptionsMenuWidgetClass' has a wrong offset!");
static_assert(offsetof(UEndMainSystemMenu, ChapterSelectWidgetClass) == 0x000438, "Member 'UEndMainSystemMenu::ChapterSelectWidgetClass' has a wrong offset!");
static_assert(offsetof(UEndMainSystemMenu, _BillboardImagePaths) == 0x0004E0, "Member 'UEndMainSystemMenu::_BillboardImagePaths' has a wrong offset!");
static_assert(offsetof(UEndMainSystemMenu, PlaylogList) == 0x0004F0, "Member 'UEndMainSystemMenu::PlaylogList' has a wrong offset!");
static_assert(offsetof(UEndMainSystemMenu, OptionsMenu) == 0x0004F8, "Member 'UEndMainSystemMenu::OptionsMenu' has a wrong offset!");

// Class EndGame.EndBattleAIFitSplineController
// 0x00B0 (0x2338 - 0x2288)
#pragma pack(push, 0x1)
class alignas(0x08) AEndBattleAIFitSplineController : public AEndBattleAIController
{
public:
	float                                         FitSplineMinVelocity;                              // 0x2288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FitSplineMaxVelocity;                              // 0x228C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FitSplineAcceleration;                             // 0x2290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FitSplineDeceleration;                             // 0x2294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FitSplineAccelerationAngularVelocityThreshold;     // 0x2298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FitSplineTurningRollRate;                          // 0x229C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FitSplineTurningRollInterpSpeed;                   // 0x22A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FitSplineConnectMargin;                            // 0x22A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FitSplineConnectUseInterpolation;                  // 0x22A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FitSplineUseSplineAnimInterpolation;               // 0x22A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FitSplineConnectUseSplineAnimInterpolation;        // 0x22AA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FitSplineUseSplineRotation;                        // 0x22AB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FitSplineBeginMotionName;                          // 0x22AC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22B4[0x74];                                    // 0x22B4(0x0074)(Fixing Size After Last Property [ Dumper-7 ])
	class AEndBattleAISpline*                     ConnectSpline;                                     // 0x2328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShowFindSplineFan;                                 // 0x2330(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2331[0x7];                                     // 0x2331(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AEndBattleAISpline* FindNearestSplineNodeActor(float InFanAngle, float InFanRadiusMin, float InFanRadiusMax, class FName InSocketName, float* NextPointDistance, class FName InGroupName);
	bool FindNearestSplineNodeLocation(class FName* OutSplineNodeName, struct FVector* OutPointLocation, float* OutNextPointDistance, float InFanAngle, float InFanRadiusMin, float InFanRadiusMax, class FName InSocketName, class FName InGroupName);
	class FName FindNearestSplineNodeName(float InFanAngle, float InFanRadiusMin, float InFanRadiusMax, class FName InSocketName, float* NextPointDistance, class FName InGroupName);
	class FName GetConnectGoal();
	class FName GetCurrentSprine();
	float GetCurrentVelocity();
	class FName GetPrevSprine();
	struct FVector GetSplineLocation(class FName InName);
	struct FVector GetSplineVector(class FName InName);
	void OnBeginSplineMove(class FName InName);
	void OnCompleteSplineMove(class FName InName);
	void OnSuspendSplineMove(class FName InName);
	void OnUpdateSplineMove(class FName InName, float InProgress);
	void RequestChangeMotion(class FName InMotionName);
	void RequestConnectSpline(class FName InName);
	void RequestOneShotMotion(class FName InMotionName);
	void RequestSplineMove(class FName InName, class FName InMotionName, float InNextPointDistance);
	void ReserveNextSpline(class FName InName);
	void SetFitSplineAcceleration(float InAcceleration, float InDeceleration);
	void SetFitSplineRoll(float InThreashold, float InRate, float InSpeed);
	void SetFitSplineVelocity(float InMax, float InMin);
	void SuspendSpline();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIFitSplineController">();
	}
	static class AEndBattleAIFitSplineController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIFitSplineController>();
	}
};
#pragma pack(pop)
static_assert(alignof(AEndBattleAIFitSplineController) == 0x000008, "Wrong alignment on AEndBattleAIFitSplineController");
static_assert(sizeof(AEndBattleAIFitSplineController) == 0x002338, "Wrong size on AEndBattleAIFitSplineController");
static_assert(offsetof(AEndBattleAIFitSplineController, FitSplineMinVelocity) == 0x002288, "Member 'AEndBattleAIFitSplineController::FitSplineMinVelocity' has a wrong offset!");
static_assert(offsetof(AEndBattleAIFitSplineController, FitSplineMaxVelocity) == 0x00228C, "Member 'AEndBattleAIFitSplineController::FitSplineMaxVelocity' has a wrong offset!");
static_assert(offsetof(AEndBattleAIFitSplineController, FitSplineAcceleration) == 0x002290, "Member 'AEndBattleAIFitSplineController::FitSplineAcceleration' has a wrong offset!");
static_assert(offsetof(AEndBattleAIFitSplineController, FitSplineDeceleration) == 0x002294, "Member 'AEndBattleAIFitSplineController::FitSplineDeceleration' has a wrong offset!");
static_assert(offsetof(AEndBattleAIFitSplineController, FitSplineAccelerationAngularVelocityThreshold) == 0x002298, "Member 'AEndBattleAIFitSplineController::FitSplineAccelerationAngularVelocityThreshold' has a wrong offset!");
static_assert(offsetof(AEndBattleAIFitSplineController, FitSplineTurningRollRate) == 0x00229C, "Member 'AEndBattleAIFitSplineController::FitSplineTurningRollRate' has a wrong offset!");
static_assert(offsetof(AEndBattleAIFitSplineController, FitSplineTurningRollInterpSpeed) == 0x0022A0, "Member 'AEndBattleAIFitSplineController::FitSplineTurningRollInterpSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleAIFitSplineController, FitSplineConnectMargin) == 0x0022A4, "Member 'AEndBattleAIFitSplineController::FitSplineConnectMargin' has a wrong offset!");
static_assert(offsetof(AEndBattleAIFitSplineController, FitSplineConnectUseInterpolation) == 0x0022A8, "Member 'AEndBattleAIFitSplineController::FitSplineConnectUseInterpolation' has a wrong offset!");
static_assert(offsetof(AEndBattleAIFitSplineController, FitSplineUseSplineAnimInterpolation) == 0x0022A9, "Member 'AEndBattleAIFitSplineController::FitSplineUseSplineAnimInterpolation' has a wrong offset!");
static_assert(offsetof(AEndBattleAIFitSplineController, FitSplineConnectUseSplineAnimInterpolation) == 0x0022AA, "Member 'AEndBattleAIFitSplineController::FitSplineConnectUseSplineAnimInterpolation' has a wrong offset!");
static_assert(offsetof(AEndBattleAIFitSplineController, FitSplineUseSplineRotation) == 0x0022AB, "Member 'AEndBattleAIFitSplineController::FitSplineUseSplineRotation' has a wrong offset!");
static_assert(offsetof(AEndBattleAIFitSplineController, FitSplineBeginMotionName) == 0x0022AC, "Member 'AEndBattleAIFitSplineController::FitSplineBeginMotionName' has a wrong offset!");
static_assert(offsetof(AEndBattleAIFitSplineController, ConnectSpline) == 0x002328, "Member 'AEndBattleAIFitSplineController::ConnectSpline' has a wrong offset!");
static_assert(offsetof(AEndBattleAIFitSplineController, ShowFindSplineFan) == 0x002330, "Member 'AEndBattleAIFitSplineController::ShowFindSplineFan' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattleCancelGuardPressed
// 0x0000 (0x0038 - 0x0038)
class UEndAnimNotifyBattleCancelGuardPressed final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleCancelGuardPressed">();
	}
	static class UEndAnimNotifyBattleCancelGuardPressed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleCancelGuardPressed>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleCancelGuardPressed) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleCancelGuardPressed");
static_assert(sizeof(UEndAnimNotifyBattleCancelGuardPressed) == 0x000038, "Wrong size on UEndAnimNotifyBattleCancelGuardPressed");

// Class EndGame.EndAnimNotifyBattleCancelQuickTurn
// 0x0000 (0x0038 - 0x0038)
class UEndAnimNotifyBattleCancelQuickTurn final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleCancelQuickTurn">();
	}
	static class UEndAnimNotifyBattleCancelQuickTurn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleCancelQuickTurn>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleCancelQuickTurn) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleCancelQuickTurn");
static_assert(sizeof(UEndAnimNotifyBattleCancelQuickTurn) == 0x000038, "Wrong size on UEndAnimNotifyBattleCancelQuickTurn");

// Class EndGame.EndBattleAIEB0017Controller
// 0x0008 (0x2290 - 0x2288)
class AEndBattleAIEB0017Controller final : public AEndBattleAIController
{
public:
	EDarknationLinkMode                           linkMode_;                                         // 0x2288(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          debugDrawLinkMode;                                 // 0x2289(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_228A[0x6];                                     // 0x228A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckLinkMode(EDarknationLinkMode linkMode);
	void SetLinkMode(EDarknationLinkMode linkMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEB0017Controller">();
	}
	static class AEndBattleAIEB0017Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEB0017Controller>();
	}
};
static_assert(alignof(AEndBattleAIEB0017Controller) == 0x000008, "Wrong alignment on AEndBattleAIEB0017Controller");
static_assert(sizeof(AEndBattleAIEB0017Controller) == 0x002290, "Wrong size on AEndBattleAIEB0017Controller");
static_assert(offsetof(AEndBattleAIEB0017Controller, linkMode_) == 0x002288, "Member 'AEndBattleAIEB0017Controller::linkMode_' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0017Controller, debugDrawLinkMode) == 0x002289, "Member 'AEndBattleAIEB0017Controller::debugDrawLinkMode' has a wrong offset!");

// Class EndGame.EndNavModifierInDoorVolume
// 0x0010 (0x0438 - 0x0428)
class AEndNavModifierInDoorVolume final : public AEndNavModifierVolumeBase
{
public:
	EEndFieldCameraInDoorType                     CameraType;                                        // 0x0428(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_429[0x3];                                      // 0x0429(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OverrideCameraSettingID;                           // 0x042C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndFieldCameraInDoorPriorityType             OverridePriorityType;                              // 0x0434(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndSpecificMoveType                          SpecificMoveType;                                  // 0x0435(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndDashType                                  DashType;                                          // 0x0436(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_437[0x1];                                      // 0x0437(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavModifierInDoorVolume">();
	}
	static class AEndNavModifierInDoorVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndNavModifierInDoorVolume>();
	}
};
static_assert(alignof(AEndNavModifierInDoorVolume) == 0x000008, "Wrong alignment on AEndNavModifierInDoorVolume");
static_assert(sizeof(AEndNavModifierInDoorVolume) == 0x000438, "Wrong size on AEndNavModifierInDoorVolume");
static_assert(offsetof(AEndNavModifierInDoorVolume, CameraType) == 0x000428, "Member 'AEndNavModifierInDoorVolume::CameraType' has a wrong offset!");
static_assert(offsetof(AEndNavModifierInDoorVolume, OverrideCameraSettingID) == 0x00042C, "Member 'AEndNavModifierInDoorVolume::OverrideCameraSettingID' has a wrong offset!");
static_assert(offsetof(AEndNavModifierInDoorVolume, OverridePriorityType) == 0x000434, "Member 'AEndNavModifierInDoorVolume::OverridePriorityType' has a wrong offset!");
static_assert(offsetof(AEndNavModifierInDoorVolume, SpecificMoveType) == 0x000435, "Member 'AEndNavModifierInDoorVolume::SpecificMoveType' has a wrong offset!");
static_assert(offsetof(AEndNavModifierInDoorVolume, DashType) == 0x000436, "Member 'AEndNavModifierInDoorVolume::DashType' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattleChangeAerialNormalAttackFall
// 0x0000 (0x0038 - 0x0038)
class UEndAnimNotifyBattleChangeAerialNormalAttackFall final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleChangeAerialNormalAttackFall">();
	}
	static class UEndAnimNotifyBattleChangeAerialNormalAttackFall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleChangeAerialNormalAttackFall>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleChangeAerialNormalAttackFall) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleChangeAerialNormalAttackFall");
static_assert(sizeof(UEndAnimNotifyBattleChangeAerialNormalAttackFall) == 0x000038, "Wrong size on UEndAnimNotifyBattleChangeAerialNormalAttackFall");

// Class EndGame.EndAnimNotifyBattleDamage
// 0x0028 (0x0060 - 0x0038)
class UEndAnimNotifyBattleDamage : public UAnimNotify
{
public:
	class FString                                 DamageSourceID;                                    // 0x0038(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndBattleDamageSourcePositionBaseType        CreatePositionBase;                                // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CreatePositionName;                                // 0x004C(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReplaceOwnerCharaName;                             // 0x0054(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndAnimNotifyBattleDamageOwnerFilterType     OwnerFilterType;                                   // 0x005C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleDamage">();
	}
	static class UEndAnimNotifyBattleDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleDamage>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleDamage) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleDamage");
static_assert(sizeof(UEndAnimNotifyBattleDamage) == 0x000060, "Wrong size on UEndAnimNotifyBattleDamage");
static_assert(offsetof(UEndAnimNotifyBattleDamage, DamageSourceID) == 0x000038, "Member 'UEndAnimNotifyBattleDamage::DamageSourceID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleDamage, CreatePositionBase) == 0x000048, "Member 'UEndAnimNotifyBattleDamage::CreatePositionBase' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleDamage, CreatePositionName) == 0x00004C, "Member 'UEndAnimNotifyBattleDamage::CreatePositionName' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleDamage, ReplaceOwnerCharaName) == 0x000054, "Member 'UEndAnimNotifyBattleDamage::ReplaceOwnerCharaName' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleDamage, OwnerFilterType) == 0x00005C, "Member 'UEndAnimNotifyBattleDamage::OwnerFilterType' has a wrong offset!");

// Class EndGame.EndDataObjectEventPriority
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectEventPriority final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectEventPriority">();
	}
	static class UEndDataObjectEventPriority* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectEventPriority>();
	}
};
static_assert(alignof(UEndDataObjectEventPriority) == 0x000008, "Wrong alignment on UEndDataObjectEventPriority");
static_assert(sizeof(UEndDataObjectEventPriority) == 0x000088, "Wrong size on UEndDataObjectEventPriority");

// Class EndGame.EndNavSimpleWallVolume
// 0x0000 (0x0450 - 0x0450)
class AEndNavSimpleWallVolume final : public AEndNavBlockingModifierVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavSimpleWallVolume">();
	}
	static class AEndNavSimpleWallVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndNavSimpleWallVolume>();
	}
};
static_assert(alignof(AEndNavSimpleWallVolume) == 0x000008, "Wrong alignment on AEndNavSimpleWallVolume");
static_assert(sizeof(AEndNavSimpleWallVolume) == 0x000450, "Wrong size on AEndNavSimpleWallVolume");

// Class EndGame.EndAnimNotifyBattleDamageAssist
// 0x0010 (0x0048 - 0x0038)
class UEndAnimNotifyBattleDamageAssist final : public UAnimNotify
{
public:
	class FString                                 DamageSourceID;                                    // 0x0038(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleDamageAssist">();
	}
	static class UEndAnimNotifyBattleDamageAssist* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleDamageAssist>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleDamageAssist) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleDamageAssist");
static_assert(sizeof(UEndAnimNotifyBattleDamageAssist) == 0x000048, "Wrong size on UEndAnimNotifyBattleDamageAssist");
static_assert(offsetof(UEndAnimNotifyBattleDamageAssist, DamageSourceID) == 0x000038, "Member 'UEndAnimNotifyBattleDamageAssist::DamageSourceID' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattleDamageDisplay
// 0x0028 (0x0060 - 0x0038)
class UEndAnimNotifyBattleDamageDisplay final : public UAnimNotify
{
public:
	class FString                                 DamageSourceID;                                    // 0x0038(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndBattleDamageSourcePositionBaseType        CreatePositionBase;                                // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CreatePositionName;                                // 0x004C(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReplaceOwnerCharaName;                             // 0x0054(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndAnimNotifyBattleDamageOwnerFilterType     OwnerFilterType;                                   // 0x005C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleDamageDisplay">();
	}
	static class UEndAnimNotifyBattleDamageDisplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleDamageDisplay>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleDamageDisplay) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleDamageDisplay");
static_assert(sizeof(UEndAnimNotifyBattleDamageDisplay) == 0x000060, "Wrong size on UEndAnimNotifyBattleDamageDisplay");
static_assert(offsetof(UEndAnimNotifyBattleDamageDisplay, DamageSourceID) == 0x000038, "Member 'UEndAnimNotifyBattleDamageDisplay::DamageSourceID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleDamageDisplay, CreatePositionBase) == 0x000048, "Member 'UEndAnimNotifyBattleDamageDisplay::CreatePositionBase' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleDamageDisplay, CreatePositionName) == 0x00004C, "Member 'UEndAnimNotifyBattleDamageDisplay::CreatePositionName' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleDamageDisplay, ReplaceOwnerCharaName) == 0x000054, "Member 'UEndAnimNotifyBattleDamageDisplay::ReplaceOwnerCharaName' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleDamageDisplay, OwnerFilterType) == 0x00005C, "Member 'UEndAnimNotifyBattleDamageDisplay::OwnerFilterType' has a wrong offset!");

// Class EndGame.EndMenuResidentResource
// 0x0020 (0x0220 - 0x0200)
class UEndMenuResidentResource final : public UUserWidget
{
public:
	TArray<class UEndFont*>                       SystemFonts;                                       // 0x0200(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UEndFont*>                       DigitFonts;                                        // 0x0210(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMenuResidentResource">();
	}
	static class UEndMenuResidentResource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMenuResidentResource>();
	}
};
static_assert(alignof(UEndMenuResidentResource) == 0x000008, "Wrong alignment on UEndMenuResidentResource");
static_assert(sizeof(UEndMenuResidentResource) == 0x000220, "Wrong size on UEndMenuResidentResource");
static_assert(offsetof(UEndMenuResidentResource, SystemFonts) == 0x000200, "Member 'UEndMenuResidentResource::SystemFonts' has a wrong offset!");
static_assert(offsetof(UEndMenuResidentResource, DigitFonts) == 0x000210, "Member 'UEndMenuResidentResource::DigitFonts' has a wrong offset!");

// Class EndGame.EndAnimVehicleUserData
// 0x0008 (0x0030 - 0x0028)
class UEndAnimVehicleUserData final : public UAssetUserData
{
public:
	float                                         Mass;                                              // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimVehicleUserData">();
	}
	static class UEndAnimVehicleUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimVehicleUserData>();
	}
};
static_assert(alignof(UEndAnimVehicleUserData) == 0x000008, "Wrong alignment on UEndAnimVehicleUserData");
static_assert(sizeof(UEndAnimVehicleUserData) == 0x000030, "Wrong size on UEndAnimVehicleUserData");
static_assert(offsetof(UEndAnimVehicleUserData, Mass) == 0x000028, "Member 'UEndAnimVehicleUserData::Mass' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattleDamageRandom
// 0x0020 (0x0080 - 0x0060)
class UEndAnimNotifyBattleDamageRandom final : public UEndAnimNotifyBattleDamage
{
public:
	uint8                                         Probability;                                       // 0x0060(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TextLabel;                                         // 0x0068(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0078(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleDamageRandom">();
	}
	static class UEndAnimNotifyBattleDamageRandom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleDamageRandom>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleDamageRandom) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleDamageRandom");
static_assert(sizeof(UEndAnimNotifyBattleDamageRandom) == 0x000080, "Wrong size on UEndAnimNotifyBattleDamageRandom");
static_assert(offsetof(UEndAnimNotifyBattleDamageRandom, Probability) == 0x000060, "Member 'UEndAnimNotifyBattleDamageRandom::Probability' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleDamageRandom, TextLabel) == 0x000068, "Member 'UEndAnimNotifyBattleDamageRandom::TextLabel' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleDamageRandom, Time) == 0x000078, "Member 'UEndAnimNotifyBattleDamageRandom::Time' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattleDestroyDamageSource
// 0x0008 (0x0040 - 0x0038)
class UEndAnimNotifyBattleDestroyDamageSource final : public UAnimNotify
{
public:
	class FName                                   DamageSourceID;                                    // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleDestroyDamageSource">();
	}
	static class UEndAnimNotifyBattleDestroyDamageSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleDestroyDamageSource>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleDestroyDamageSource) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleDestroyDamageSource");
static_assert(sizeof(UEndAnimNotifyBattleDestroyDamageSource) == 0x000040, "Wrong size on UEndAnimNotifyBattleDestroyDamageSource");
static_assert(offsetof(UEndAnimNotifyBattleDestroyDamageSource, DamageSourceID) == 0x000038, "Member 'UEndAnimNotifyBattleDestroyDamageSource::DamageSourceID' has a wrong offset!");

// Class EndGame.EndDataObjectExclusion
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectExclusion final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectExclusion">();
	}
	static class UEndDataObjectExclusion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectExclusion>();
	}
};
static_assert(alignof(UEndDataObjectExclusion) == 0x000008, "Wrong alignment on UEndDataObjectExclusion");
static_assert(sizeof(UEndDataObjectExclusion) == 0x000088, "Wrong size on UEndDataObjectExclusion");

// Class EndGame.EndMenuAPI
// 0x0000 (0x0028 - 0x0028)
class UEndMenuAPI final : public UObject
{
public:
	static void AddFadeFilter(class UObject* WorldContextObject, class FName Name_0, int32 ZOrder, const struct FLinearColor& FromColor, const struct FLinearColor& ToColor, float FadeTime, bool bAutoDestroy, bool bPauseable);
	static void AddMessageLog_AnyThread(EEndMenuIconKind Icon, const class FString& Message, EEndMenuLogEffectKind Effect);
	static void AddTalkLogByTextId(const class FString& TextID, float WaitSeconds);
	static bool AreaNameExists(const class FString& TextID);
	static void BPHideBattleEscape(bool aInBattle);
	static void BPHideBattleTutorialWindow(class FName aKey);
	static void BPHideBossStatus();
	static void BPHideCaution(bool aInBattle);
	static void BPHideCharacterJoin();
	static void BPHideCharacterReJoin();
	static void BPHideCountdown(bool aHideFailed);
	static void BPHideDataAccessIcon();
	static void BPHideEventProgress(bool aAnimation);
	static void BPHideFieldInputGuidelineWindow();
	static void BPHideFieldStaminaIcon();
	static void BPHideGameOver();
	static void BPHideNavimap();
	static void BPHideTalkSelect();
	static void BPHideUIFilterWindow(EEndMenuUIFilterType aFilterType);
	static void BPHideVisionIcon();
	static void BPSetBossDamageLidHP(float aHP);
	static void BPSetBossHPGauge(float aHP);
	static void BPSetCautionQuantity(float aQT);
	static void BPSetCountdownTime(float SetTime);
	static void BPSetFieldStaminaGauge(float aGaugeQt);
	static void BPSetFieldStaminaSpeed(float aSpeedQt);
	static void BPShowBattleEscape(class UObject* WorldContextObject);
	static class UUserWidget* BPShowBattleLockonMarkerIcon(class UObject* WorldContextObject, const struct FVector& WorldPosition, EEndMenuLockonMarkerType aType);
	static void BPShowBattleTutorialWindow(class UObject* WorldContextObject, class FName aKey);
	static void BPShowBossStatus(class UObject* WorldContextObject);
	static void BPShowCaution(class UObject* WorldContextObject);
	static void BPShowCharacterJoin(class UObject* WorldContextObject, EPlayerType PlayerType, bool bIsIn);
	static void BPShowCharacterReJoin(class UObject* WorldContextObject, bool bIsLeftOut);
	static void BPShowCountdown(class UObject* WorldContextObject, float SetTime);
	static void BPShowDataAccessIcon(class UObject* WorldContextObject);
	static void BPShowEventProgress(class UObject* WorldContextObject, const class FString& aShowText);
	static void BPShowFieldAction(const class FString& aActionTextId);
	static void BPShowFieldInputGuidelineWindow(class UObject* WorldContextObject, EEndMenuInputGuidelineType aType);
	static void BPShowFieldStaminaIcon(class UObject* WorldContextObject);
	static void BPShowGameOver(class UObject* WorldContextObject);
	static void BPShowNavimap(class UObject* WorldContextObject);
	static void BPShowTalkSelect(class UObject* WorldContextObject, EEndMenuTalkSelectWindowType aWindowType);
	static void BPShowUIFilterWindow(class UObject* WorldContextObject, EEndMenuUIFilterType aFilterType);
	static void BPShowVisionIcon(class UObject* WorldContextObject);
	static void ChangeBattleTargetIconState(class UUserWidget* Icon, EEndMenuBattleTargetState State);
	static void ChangeFadeFilter(class FName Name_0, const struct FLinearColor& ToColor, float FadeTime, bool bAutoDestroy, bool bPauseable);
	static void ChangeFieldTargetIconButton(class UUserWidget* Icon, EEndMenuFieldTargetIconType aButtonType);
	static void ChangeFieldTargetIconState(class UUserWidget* Icon, EEndMenuFieldTargetState State);
	static bool ChapterNameExists(const class FString& TextID);
	static void ClearFadeFilters();
	static void ClearLocationTitles();
	static void ClearMessageWindows();
	static void ClearTalkLogs();
	static class UUserWidget* CreateWidgetFromPack(class UObject* WorldContextObject, class FName LevelName, class FName ResourceName);
	static EEndMenuBattleTargetState GetBattleTargetIconState(class UUserWidget* Icon);
	static struct FLinearColor GetFadeFilterCurrentColor(class FName Name_0);
	static void GetFadeFilterNames(TArray<class FName>* outNames);
	static bool GetFadeFilterVisibility(class FName Name_0);
	static EEndMenuFieldTargetState GetFieldTargetIconState(class UUserWidget* Icon);
	static EEndMenuIconKind GetItemMessageLogIconKind(class FName ItemID);
	static int32 GetMessageWindowSelectedIndex(class UUserWidget* Widget);
	static class FString GetString(const class FString& TextID);
	static class UWidgetAnimation* GetWidgetAnimationByName(class UWidget* InWidget, class FName InName);
	static void GetWidgetAnimations(class UWidget* InWidget, TArray<class FName>* outNames);
	static bool HasFadeFilters();
	static bool HasFadeFiltersDuringAnimation();
	static void HideBattleEnemyOutsideWindow();
	static void HideBattleEnemyStatusWindow();
	static void HideBattlePlayerStatusWindow();
	static void HideBattleTargetIcon(class UUserWidget* Icon);
	static void HideFieldAction();
	static void HideFieldMenu();
	static void HideFieldPane(EEndMenuFieldPaneType Type);
	static void HideFieldTargetIcon(class UUserWidget* Icon);
	static void HideLoadingIcon();
	static void HideLoadingScreen();
	static void HideMessageLogs();
	static void HideMessageWindow(class UUserWidget* Widget);
	static void HideMovie();
	static void HidePauseMenu();
	static void HideSkippingIcon();
	static void HideSubtitle(const class FString& TextID);
	static void HideTalkLogs();
	static bool IsFadeFilter(class FName Name_0);
	static bool IsFadeFilterDuringAnimation(class FName Name_0);
	static bool IsFieldMenuShortcutActive();
	static bool IsFieldMenuStatus(EEndMenuFieldMenuStatus Status);
	static bool IsJoinLeftUpdate();
	static bool IsMessageWindowClosed(class UUserWidget* Widget);
	static bool IsPauseMenuClosed();
	static bool IsSubtitleClosed(const class FString& TextID);
	static bool Key_IsVirtualAccept(const struct FKey& Key);
	static bool Key_IsVirtualBack(const struct FKey& Key);
	static bool LocationNameExists(const class FString& TextID);
	static TSoftClassPtr<class UClass> MakeSoftClassPtr(const class FString& inString);
	static bool Need4KFont();
	static void RefreshStatusWindow();
	static void RemoveFadeFilter(class FName Name_0);
	static void SetBattleEnemyStatusWindowPosition(class UUserWidget* Icon, const struct FVector& WorldPosition);
	static void SetBattleTargetIconActor(class UUserWidget* Icon, class AActor* Actor);
	static bool SetBattleTargetIconPosition(class UUserWidget* Icon, const struct FVector& WorldPosition);
	static void SetFadeFilterVisibility(class FName Name_0, bool bVisible);
	static void SetFieldMenuInBattle(bool bInInBattle);
	static void SetFieldTargetIconHoldGauge(class UUserWidget* Icon, float aGauge);
	static void SetFieldTargetIconPosition(class UUserWidget* Icon, const struct FVector& WorldPosition);
	static void SetFocusBrushBySlateColor(const struct FSlateColor& InColor);
	static void SetFocusToWidget(class UWidget* InWidget);
	static void SetNavimapInBattle(bool bInInBattle);
	static void SetVirtualAcceptRight(bool bRight);
	static void ShowAreaName(class UObject* WorldContextObject, const class FString& TextID);
	static void ShowBattleEnemyOutsideWindow();
	static class UUserWidget* ShowBattleEnemyStatusWindow();
	static class UUserWidget* ShowBattlePlayerStatusWindow();
	static class UUserWidget* ShowBattleTargetIcon(class UObject* WorldContextObject, const struct FVector& WorldPosition, EEndMenuBattleTargetState State);
	static void ShowChapterName(class UObject* WorldContextObject, const class FString& TextID, const class FString& EnTextId);
	static void ShowDamagePopupMessage(class UObject* WorldContextObject, class AActor* Actor, const struct FVector& WorldPosition, EEndMenuPopupMessageKind Kind, const struct FEndMenuDamageInfo& Info);
	static void ShowDebugListBox(class UObject* WorldContextObject, const TArray<class FString>& InStringArray, float InWidth, float InHeight, bool InSingleNodeAutoClick, class FString* OutString, const struct FLatentActionInfo& LatentInfo);
	static void ShowFieldMenu(class UObject* WorldContextObject);
	static void ShowFieldPane(EEndMenuFieldPaneType Type);
	static class UUserWidget* ShowFieldTargetIcon(class UObject* WorldContextObject, const struct FVector& WorldPosition, EEndMenuFieldTargetState State, EEndMenuFieldTargetIconType aType);
	static void ShowFollowingPopupMessage(class UObject* WorldContextObject, class AActor* Actor, const struct FVector& WorldPosition, EEndMenuPopupMessageKind Kind, int32 Value, int32 Magnificate, EEndMenuDamageResistance Resistance, EEndMenuPopupMessageFlags Flags_0);
	static void ShowLoadingIcon(class UObject* WorldContextObject);
	static void ShowLoadingScreen(class UObject* WorldContextObject, class FName LocationID, bool ShowLocationTip);
	static void ShowLoadingScreenForChocoboFastTravel(class UObject* WorldContextObject, const class FString& ChocoboText, class FName LocationID);
	static void ShowLocationName(class UObject* WorldContextObject, const class FString& TextID, const class FString& EnTextId);
	static void ShowMessageLogs(class UObject* WorldContextObject);
	static class UUserWidget* ShowMessageWindow(class UObject* WorldContextObject, const class FString& TextID, const TArray<class FString>& OptionTextIds, EEndMenuMessageWindowFlags Flags_0);
	static void ShowMovie(class UObject* WorldContextObject, class UMaterialInterface* Material);
	static void ShowPauseMenu(class UObject* WorldContextObject, EEndMenuPauseMode Mode);
	static void ShowPopupMessage(class UObject* WorldContextObject, const struct FVector& WorldPosition, EEndMenuPopupMessageKind Kind, int32 Value, int32 Magnificate, EEndMenuDamageResistance Resistance, EEndMenuPopupMessageFlags Flags_0);
	static void ShowSkippingIcon(class UObject* WorldContextObject);
	static void ShowSubtitle(class UObject* WorldContextObject, const class FString& TextID, bool bWaitKey, bool bArrowHidden);
	static void ShowTalkLogs(class UObject* WorldContextObject);
	static void UpdateMenu(float DeltaSeconds);
	static void UpdateWidgetTest();

	bool IsBattleTargetIconActor(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMenuAPI">();
	}
	static class UEndMenuAPI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMenuAPI>();
	}
};
static_assert(alignof(UEndMenuAPI) == 0x000008, "Wrong alignment on UEndMenuAPI");
static_assert(sizeof(UEndMenuAPI) == 0x000028, "Wrong size on UEndMenuAPI");

// Class EndGame.EndAnimSet
// 0x0060 (0x0088 - 0x0028)
class UEndAnimSet final : public UObject
{
public:
	class UEndLocomotionData*                     OverrideLocomotionData;                            // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UAnimationAsset*>     AnimationAssets;                                   // 0x0030(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bCanBeInCluster;                                   // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimSet">();
	}
	static class UEndAnimSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimSet>();
	}
};
static_assert(alignof(UEndAnimSet) == 0x000008, "Wrong alignment on UEndAnimSet");
static_assert(sizeof(UEndAnimSet) == 0x000088, "Wrong size on UEndAnimSet");
static_assert(offsetof(UEndAnimSet, OverrideLocomotionData) == 0x000028, "Member 'UEndAnimSet::OverrideLocomotionData' has a wrong offset!");
static_assert(offsetof(UEndAnimSet, AnimationAssets) == 0x000030, "Member 'UEndAnimSet::AnimationAssets' has a wrong offset!");
static_assert(offsetof(UEndAnimSet, bCanBeInCluster) == 0x000080, "Member 'UEndAnimSet::bCanBeInCluster' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattleDisablePursuitAttack
// 0x0000 (0x0038 - 0x0038)
class UEndAnimNotifyBattleDisablePursuitAttack final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleDisablePursuitAttack">();
	}
	static class UEndAnimNotifyBattleDisablePursuitAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleDisablePursuitAttack>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleDisablePursuitAttack) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleDisablePursuitAttack");
static_assert(sizeof(UEndAnimNotifyBattleDisablePursuitAttack) == 0x000038, "Wrong size on UEndAnimNotifyBattleDisablePursuitAttack");

// Class EndGame.EndAnimNotifyBattleDisablePushCollision
// 0x0010 (0x0048 - 0x0038)
class UEndAnimNotifyBattleDisablePushCollision final : public UAnimNotify
{
public:
	class FName                                   name_;                                             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          disable_;                                          // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleDisablePushCollision">();
	}
	static class UEndAnimNotifyBattleDisablePushCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleDisablePushCollision>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleDisablePushCollision) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleDisablePushCollision");
static_assert(sizeof(UEndAnimNotifyBattleDisablePushCollision) == 0x000048, "Wrong size on UEndAnimNotifyBattleDisablePushCollision");
static_assert(offsetof(UEndAnimNotifyBattleDisablePushCollision, name_) == 0x000038, "Member 'UEndAnimNotifyBattleDisablePushCollision::name_' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleDisablePushCollision, disable_) == 0x000040, "Member 'UEndAnimNotifyBattleDisablePushCollision::disable_' has a wrong offset!");

// Class EndGame.EndAnimNotifySyncProtectEnd
// 0x0000 (0x0038 - 0x0038)
class UEndAnimNotifySyncProtectEnd final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifySyncProtectEnd">();
	}
	static class UEndAnimNotifySyncProtectEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifySyncProtectEnd>();
	}
};
static_assert(alignof(UEndAnimNotifySyncProtectEnd) == 0x000008, "Wrong alignment on UEndAnimNotifySyncProtectEnd");
static_assert(sizeof(UEndAnimNotifySyncProtectEnd) == 0x000038, "Wrong size on UEndAnimNotifySyncProtectEnd");

// Class EndGame.EndNavRedLaserGimmickBox
// 0x0010 (0x0460 - 0x0450)
class AEndNavRedLaserGimmickBox final : public AEndNavBlockingModifierVolume
{
public:
	uint8                                         Pad_450[0x10];                                     // 0x0450(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavRedLaserGimmickBox">();
	}
	static class AEndNavRedLaserGimmickBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndNavRedLaserGimmickBox>();
	}
};
static_assert(alignof(AEndNavRedLaserGimmickBox) == 0x000008, "Wrong alignment on AEndNavRedLaserGimmickBox");
static_assert(sizeof(AEndNavRedLaserGimmickBox) == 0x000460, "Wrong size on AEndNavRedLaserGimmickBox");

// Class EndGame.EndAnimNotifyBattleDisableTargetCorrectionForTarget
// 0x0000 (0x0038 - 0x0038)
class UEndAnimNotifyBattleDisableTargetCorrectionForTarget final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleDisableTargetCorrectionForTarget">();
	}
	static class UEndAnimNotifyBattleDisableTargetCorrectionForTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleDisableTargetCorrectionForTarget>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleDisableTargetCorrectionForTarget) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleDisableTargetCorrectionForTarget");
static_assert(sizeof(UEndAnimNotifyBattleDisableTargetCorrectionForTarget) == 0x000038, "Wrong size on UEndAnimNotifyBattleDisableTargetCorrectionForTarget");

// Class EndGame.EndAnimNotifyBattleEnableFieldDead
// 0x0008 (0x0040 - 0x0038)
class UEndAnimNotifyBattleEnableFieldDead final : public UAnimNotify
{
public:
	bool                                          Enable;                                            // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleEnableFieldDead">();
	}
	static class UEndAnimNotifyBattleEnableFieldDead* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleEnableFieldDead>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleEnableFieldDead) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleEnableFieldDead");
static_assert(sizeof(UEndAnimNotifyBattleEnableFieldDead) == 0x000040, "Wrong size on UEndAnimNotifyBattleEnableFieldDead");
static_assert(offsetof(UEndAnimNotifyBattleEnableFieldDead, Enable) == 0x000038, "Member 'UEndAnimNotifyBattleEnableFieldDead::Enable' has a wrong offset!");

// Class EndGame.EndDataObjectStateAttribute
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectStateAttribute final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectStateAttribute">();
	}
	static class UEndDataObjectStateAttribute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectStateAttribute>();
	}
};
static_assert(alignof(UEndDataObjectStateAttribute) == 0x000008, "Wrong alignment on UEndDataObjectStateAttribute");
static_assert(sizeof(UEndDataObjectStateAttribute) == 0x000088, "Wrong size on UEndDataObjectStateAttribute");

// Class EndGame.EndAnimVehicleInstance
// 0x0110 (0x1890 - 0x1780)
class UEndAnimVehicleInstance final : public UEndAnimInstance
{
public:
	struct FBoneReference                         CenterBone;                                        // 0x1780(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                CenterBoneUpAxis;                                  // 0x1794(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CenterBoneAcceleration;                            // 0x17A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCenterDistance;                                 // 0x17A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CenterConstraintStiffness;                         // 0x17A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollAngleMultiplier;                               // 0x17AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RollAxis;                                          // 0x17B0(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHandle;                                        // 0x17BC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17BD[0x3];                                     // 0x17BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneReference                         HandleBone;                                        // 0x17C0(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxTurnAngleToHandleYawFactor;                     // 0x17D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinHandleAnglePercentage;                          // 0x17D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17DC[0x4];                                     // 0x17DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEndAnimVehicleLinearSuspension> LinearSuspensionInfos;                             // 0x17E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FEndAnimVehicleAngularSuspension> AngularSuspensionInfos;                            // 0x17F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FEndAnimVehicleTurnBone>        TurnBones;                                         // 0x1800(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         IterationCount;                                    // 0x1810(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityKmPerHour;                                 // 0x1814(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationKmPerHour;                             // 0x1818(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationToTransRotationBias;                   // 0x181C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransRotationReverseSpeed;                         // 0x1820(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransRotationToSinkingAccelerationBias;            // 0x1824(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransSinkingAccelerationInterpSpeed;               // 0x1828(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RandomSinkingAcceleration;                         // 0x182C(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomSinkingAccelerationMultiplier;               // 0x1834(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RandomSinkingTime;                                 // 0x1838(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityToRandomSinkingTimeBias;                   // 0x1840(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnAngle;                                         // 0x1844(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CenterBoneAdditiveRotation;                        // 0x1848(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         GroundHeight;                                      // 0x1854(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GroundNormal;                                      // 0x1858(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundRoughness;                                   // 0x1864(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveRoll;                                      // 0x1868(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePhysicsDuringAnimation;                        // 0x186C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseWheelRotationDuringAnimation;                  // 0x186D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_186E[0x2];                                     // 0x186E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpAngle;                                         // 0x1870(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpAngleResetInterpSpeed;                         // 0x1874(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchRotationSpeed;                                // 0x1878(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_187C[0x14];                                    // 0x187C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimVehicleInstance">();
	}
	static class UEndAnimVehicleInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimVehicleInstance>();
	}
};
static_assert(alignof(UEndAnimVehicleInstance) == 0x000008, "Wrong alignment on UEndAnimVehicleInstance");
static_assert(sizeof(UEndAnimVehicleInstance) == 0x001890, "Wrong size on UEndAnimVehicleInstance");
static_assert(offsetof(UEndAnimVehicleInstance, CenterBone) == 0x001780, "Member 'UEndAnimVehicleInstance::CenterBone' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, CenterBoneUpAxis) == 0x001794, "Member 'UEndAnimVehicleInstance::CenterBoneUpAxis' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, CenterBoneAcceleration) == 0x0017A0, "Member 'UEndAnimVehicleInstance::CenterBoneAcceleration' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, MaxCenterDistance) == 0x0017A4, "Member 'UEndAnimVehicleInstance::MaxCenterDistance' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, CenterConstraintStiffness) == 0x0017A8, "Member 'UEndAnimVehicleInstance::CenterConstraintStiffness' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, RollAngleMultiplier) == 0x0017AC, "Member 'UEndAnimVehicleInstance::RollAngleMultiplier' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, RollAxis) == 0x0017B0, "Member 'UEndAnimVehicleInstance::RollAxis' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, bUseHandle) == 0x0017BC, "Member 'UEndAnimVehicleInstance::bUseHandle' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, HandleBone) == 0x0017C0, "Member 'UEndAnimVehicleInstance::HandleBone' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, MaxTurnAngleToHandleYawFactor) == 0x0017D4, "Member 'UEndAnimVehicleInstance::MaxTurnAngleToHandleYawFactor' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, MinHandleAnglePercentage) == 0x0017D8, "Member 'UEndAnimVehicleInstance::MinHandleAnglePercentage' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, LinearSuspensionInfos) == 0x0017E0, "Member 'UEndAnimVehicleInstance::LinearSuspensionInfos' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, AngularSuspensionInfos) == 0x0017F0, "Member 'UEndAnimVehicleInstance::AngularSuspensionInfos' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, TurnBones) == 0x001800, "Member 'UEndAnimVehicleInstance::TurnBones' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, IterationCount) == 0x001810, "Member 'UEndAnimVehicleInstance::IterationCount' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, VelocityKmPerHour) == 0x001814, "Member 'UEndAnimVehicleInstance::VelocityKmPerHour' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, AccelerationKmPerHour) == 0x001818, "Member 'UEndAnimVehicleInstance::AccelerationKmPerHour' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, AccelerationToTransRotationBias) == 0x00181C, "Member 'UEndAnimVehicleInstance::AccelerationToTransRotationBias' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, TransRotationReverseSpeed) == 0x001820, "Member 'UEndAnimVehicleInstance::TransRotationReverseSpeed' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, TransRotationToSinkingAccelerationBias) == 0x001824, "Member 'UEndAnimVehicleInstance::TransRotationToSinkingAccelerationBias' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, TransSinkingAccelerationInterpSpeed) == 0x001828, "Member 'UEndAnimVehicleInstance::TransSinkingAccelerationInterpSpeed' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, RandomSinkingAcceleration) == 0x00182C, "Member 'UEndAnimVehicleInstance::RandomSinkingAcceleration' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, RandomSinkingAccelerationMultiplier) == 0x001834, "Member 'UEndAnimVehicleInstance::RandomSinkingAccelerationMultiplier' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, RandomSinkingTime) == 0x001838, "Member 'UEndAnimVehicleInstance::RandomSinkingTime' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, VelocityToRandomSinkingTimeBias) == 0x001840, "Member 'UEndAnimVehicleInstance::VelocityToRandomSinkingTimeBias' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, TurnAngle) == 0x001844, "Member 'UEndAnimVehicleInstance::TurnAngle' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, CenterBoneAdditiveRotation) == 0x001848, "Member 'UEndAnimVehicleInstance::CenterBoneAdditiveRotation' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, GroundHeight) == 0x001854, "Member 'UEndAnimVehicleInstance::GroundHeight' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, GroundNormal) == 0x001858, "Member 'UEndAnimVehicleInstance::GroundNormal' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, GroundRoughness) == 0x001864, "Member 'UEndAnimVehicleInstance::GroundRoughness' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, AdditiveRoll) == 0x001868, "Member 'UEndAnimVehicleInstance::AdditiveRoll' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, bUsePhysicsDuringAnimation) == 0x00186C, "Member 'UEndAnimVehicleInstance::bUsePhysicsDuringAnimation' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, bUseWheelRotationDuringAnimation) == 0x00186D, "Member 'UEndAnimVehicleInstance::bUseWheelRotationDuringAnimation' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, JumpAngle) == 0x001870, "Member 'UEndAnimVehicleInstance::JumpAngle' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, JumpAngleResetInterpSpeed) == 0x001874, "Member 'UEndAnimVehicleInstance::JumpAngleResetInterpSpeed' has a wrong offset!");
static_assert(offsetof(UEndAnimVehicleInstance, PitchRotationSpeed) == 0x001878, "Member 'UEndAnimVehicleInstance::PitchRotationSpeed' has a wrong offset!");

// Class EndGame.EndRecastNavMesh
// 0x0038 (0x0660 - 0x0628)
class AEndRecastNavMesh final : public ARecastNavMesh
{
public:
	uint8                                         bDrawNavAreaAll : 1;                               // 0x0628(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawCover : 1;                                    // 0x0628(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawBattleArea : 1;                               // 0x0628(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawCationArea : 1;                               // 0x0628(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawExtendedBattleArea : 1;                       // 0x0628(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawFieldAction : 1;                              // 0x0628(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawHookShot : 1;                                 // 0x0628(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawRedLaser : 1;                                 // 0x0628(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawImpassable : 1;                               // 0x0629(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawImpassable2 : 1;                              // 0x0629(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawObstacle : 1;                                 // 0x0629(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawCinemaObstacle : 1;                           // 0x0629(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawAddAttribute : 1;                             // 0x0629(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawAddAttribute2 : 1;                            // 0x0629(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawAddAttribute3 : 1;                            // 0x0629(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawAddAttribute4 : 1;                            // 0x0629(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawIgnore : 1;                                   // 0x062A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawVersatile : 1;                                // 0x062A(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawVersatile2 : 1;                               // 0x062A(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawVersatile3 : 1;                               // 0x062A(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawVersatile4 : 1;                               // 0x062A(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawInDoor : 1;                                   // 0x062A(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawPathWay : 1;                                  // 0x062A(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawCentralPathWay : 1;                           // 0x062A(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawDefault : 1;                                  // 0x062B(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawFlatlands : 1;                                // 0x062B(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawWaterSurface : 1;                             // 0x062B(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawMountain : 1;                                 // 0x062B(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	class FName                                   aBattleSceneFilterName;                            // 0x062C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDrawBattleSceneFilter : 1;                        // 0x0634(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_635[0x3];                                      // 0x0635(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NavMeshVersion;                                    // 0x0638(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ObjectCount;                                       // 0x063C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_640[0x20];                                     // 0x0640(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndRecastNavMesh">();
	}
	static class AEndRecastNavMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndRecastNavMesh>();
	}
};
static_assert(alignof(AEndRecastNavMesh) == 0x000008, "Wrong alignment on AEndRecastNavMesh");
static_assert(sizeof(AEndRecastNavMesh) == 0x000660, "Wrong size on AEndRecastNavMesh");
static_assert(offsetof(AEndRecastNavMesh, aBattleSceneFilterName) == 0x00062C, "Member 'AEndRecastNavMesh::aBattleSceneFilterName' has a wrong offset!");
static_assert(offsetof(AEndRecastNavMesh, NavMeshVersion) == 0x000638, "Member 'AEndRecastNavMesh::NavMeshVersion' has a wrong offset!");
static_assert(offsetof(AEndRecastNavMesh, ObjectCount) == 0x00063C, "Member 'AEndRecastNavMesh::ObjectCount' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattleEnableForceUpdateATB
// 0x0008 (0x0040 - 0x0038)
class UEndAnimNotifyBattleEnableForceUpdateATB final : public UAnimNotify
{
public:
	bool                                          Enable;                                            // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleEnableForceUpdateATB">();
	}
	static class UEndAnimNotifyBattleEnableForceUpdateATB* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleEnableForceUpdateATB>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleEnableForceUpdateATB) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleEnableForceUpdateATB");
static_assert(sizeof(UEndAnimNotifyBattleEnableForceUpdateATB) == 0x000040, "Wrong size on UEndAnimNotifyBattleEnableForceUpdateATB");
static_assert(offsetof(UEndAnimNotifyBattleEnableForceUpdateATB, Enable) == 0x000038, "Member 'UEndAnimNotifyBattleEnableForceUpdateATB::Enable' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattleEnableLeaderChange
// 0x0000 (0x0038 - 0x0038)
class UEndAnimNotifyBattleEnableLeaderChange final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleEnableLeaderChange">();
	}
	static class UEndAnimNotifyBattleEnableLeaderChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleEnableLeaderChange>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleEnableLeaderChange) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleEnableLeaderChange");
static_assert(sizeof(UEndAnimNotifyBattleEnableLeaderChange) == 0x000038, "Wrong size on UEndAnimNotifyBattleEnableLeaderChange");

// Class EndGame.EndLoadingScreen
// 0x0060 (0x03C0 - 0x0360)
class UEndLoadingScreen : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x20];                                     // 0x0360(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndBillboard*                          Img_BG;                                            // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndVirtualScrollBox*                   StoneBox;                                          // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndTextBlock*                          Txt_TipsTitle;                                     // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndTextBlock*                          Txt_Info;                                          // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndTextBlock*                          Txt_Goto;                                          // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndTextBlock*                          Txt_Category;                                      // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndBillboard*                          Billboard_QuestThumbnail;                          // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndTextBlock*                          Txt_QuestStep;                                     // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnTipListSelectedIndexChanged(int32 CellIndex);
	void OnTipListSetupItem(class UWidget* ItemWidget, int32 CellIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndLoadingScreen">();
	}
	static class UEndLoadingScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndLoadingScreen>();
	}
};
static_assert(alignof(UEndLoadingScreen) == 0x000008, "Wrong alignment on UEndLoadingScreen");
static_assert(sizeof(UEndLoadingScreen) == 0x0003C0, "Wrong size on UEndLoadingScreen");
static_assert(offsetof(UEndLoadingScreen, Img_BG) == 0x000380, "Member 'UEndLoadingScreen::Img_BG' has a wrong offset!");
static_assert(offsetof(UEndLoadingScreen, StoneBox) == 0x000388, "Member 'UEndLoadingScreen::StoneBox' has a wrong offset!");
static_assert(offsetof(UEndLoadingScreen, Txt_TipsTitle) == 0x000390, "Member 'UEndLoadingScreen::Txt_TipsTitle' has a wrong offset!");
static_assert(offsetof(UEndLoadingScreen, Txt_Info) == 0x000398, "Member 'UEndLoadingScreen::Txt_Info' has a wrong offset!");
static_assert(offsetof(UEndLoadingScreen, Txt_Goto) == 0x0003A0, "Member 'UEndLoadingScreen::Txt_Goto' has a wrong offset!");
static_assert(offsetof(UEndLoadingScreen, Txt_Category) == 0x0003A8, "Member 'UEndLoadingScreen::Txt_Category' has a wrong offset!");
static_assert(offsetof(UEndLoadingScreen, Billboard_QuestThumbnail) == 0x0003B0, "Member 'UEndLoadingScreen::Billboard_QuestThumbnail' has a wrong offset!");
static_assert(offsetof(UEndLoadingScreen, Txt_QuestStep) == 0x0003B8, "Member 'UEndLoadingScreen::Txt_QuestStep' has a wrong offset!");

// Class EndGame.EndAssetClassPack
// 0x0018 (0x0040 - 0x0028)
class UEndAssetClassPack final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UObject>>            AssetUserData;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAssetClassPack">();
	}
	static class UEndAssetClassPack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAssetClassPack>();
	}
};
static_assert(alignof(UEndAssetClassPack) == 0x000008, "Wrong alignment on UEndAssetClassPack");
static_assert(sizeof(UEndAssetClassPack) == 0x000040, "Wrong size on UEndAssetClassPack");
static_assert(offsetof(UEndAssetClassPack, AssetUserData) == 0x000030, "Member 'UEndAssetClassPack::AssetUserData' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattleEventTriggerTouchDisable
// 0x0000 (0x0030 - 0x0030)
class UEndAnimNotifyBattleEventTriggerTouchDisable final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleEventTriggerTouchDisable">();
	}
	static class UEndAnimNotifyBattleEventTriggerTouchDisable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleEventTriggerTouchDisable>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleEventTriggerTouchDisable) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleEventTriggerTouchDisable");
static_assert(sizeof(UEndAnimNotifyBattleEventTriggerTouchDisable) == 0x000030, "Wrong size on UEndAnimNotifyBattleEventTriggerTouchDisable");

// Class EndGame.EndAnimNotifyBattleEventTriggerTouchEnable
// 0x0000 (0x0030 - 0x0030)
class UEndAnimNotifyBattleEventTriggerTouchEnable final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleEventTriggerTouchEnable">();
	}
	static class UEndAnimNotifyBattleEventTriggerTouchEnable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleEventTriggerTouchEnable>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleEventTriggerTouchEnable) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleEventTriggerTouchEnable");
static_assert(sizeof(UEndAnimNotifyBattleEventTriggerTouchEnable) == 0x000030, "Wrong size on UEndAnimNotifyBattleEventTriggerTouchEnable");

// Class EndGame.EndDataObjectStory
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectStory final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectStory">();
	}
	static class UEndDataObjectStory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectStory>();
	}
};
static_assert(alignof(UEndDataObjectStory) == 0x000008, "Wrong alignment on UEndDataObjectStory");
static_assert(sizeof(UEndDataObjectStory) == 0x000088, "Wrong size on UEndDataObjectStory");

// Class EndGame.EndMenuDPIScalingRule
// 0x0000 (0x0028 - 0x0028)
class UEndMenuDPIScalingRule final : public UDPICustomScalingRule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMenuDPIScalingRule">();
	}
	static class UEndMenuDPIScalingRule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMenuDPIScalingRule>();
	}
};
static_assert(alignof(UEndMenuDPIScalingRule) == 0x000008, "Wrong alignment on UEndMenuDPIScalingRule");
static_assert(sizeof(UEndMenuDPIScalingRule) == 0x000028, "Wrong size on UEndMenuDPIScalingRule");

// Class EndGame.EndAreaMapInfoWindow
// 0x0060 (0x03C0 - 0x0360)
class UEndAreaMapInfoWindow : public UEndUserWidget
{
public:
	class UWidgetAnimation*                       MenuInAnimation;                                   // 0x0360(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_368[0x58];                                     // 0x0368(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAreaMapInfoWindow">();
	}
	static class UEndAreaMapInfoWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAreaMapInfoWindow>();
	}
};
static_assert(alignof(UEndAreaMapInfoWindow) == 0x000008, "Wrong alignment on UEndAreaMapInfoWindow");
static_assert(sizeof(UEndAreaMapInfoWindow) == 0x0003C0, "Wrong size on UEndAreaMapInfoWindow");
static_assert(offsetof(UEndAreaMapInfoWindow, MenuInAnimation) == 0x000360, "Member 'UEndAreaMapInfoWindow::MenuInAnimation' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattleGuardMode
// 0x0008 (0x0040 - 0x0038)
class UEndAnimNotifyBattleGuardMode final : public UAnimNotify
{
public:
	bool                                          Flag;                                              // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleGuardMode">();
	}
	static class UEndAnimNotifyBattleGuardMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleGuardMode>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleGuardMode) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleGuardMode");
static_assert(sizeof(UEndAnimNotifyBattleGuardMode) == 0x000040, "Wrong size on UEndAnimNotifyBattleGuardMode");
static_assert(offsetof(UEndAnimNotifyBattleGuardMode, Flag) == 0x000038, "Member 'UEndAnimNotifyBattleGuardMode::Flag' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattleHiddenCharacter
// 0x0008 (0x0040 - 0x0038)
class UEndAnimNotifyBattleHiddenCharacter final : public UAnimNotify
{
public:
	bool                                          enableHiddenCharacter;                             // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          enableInfluenceChildren;                           // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          enableInfluenceWeapons;                            // 0x003A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleHiddenCharacter">();
	}
	static class UEndAnimNotifyBattleHiddenCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleHiddenCharacter>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleHiddenCharacter) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleHiddenCharacter");
static_assert(sizeof(UEndAnimNotifyBattleHiddenCharacter) == 0x000040, "Wrong size on UEndAnimNotifyBattleHiddenCharacter");
static_assert(offsetof(UEndAnimNotifyBattleHiddenCharacter, enableHiddenCharacter) == 0x000038, "Member 'UEndAnimNotifyBattleHiddenCharacter::enableHiddenCharacter' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleHiddenCharacter, enableInfluenceChildren) == 0x000039, "Member 'UEndAnimNotifyBattleHiddenCharacter::enableInfluenceChildren' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleHiddenCharacter, enableInfluenceWeapons) == 0x00003A, "Member 'UEndAnimNotifyBattleHiddenCharacter::enableInfluenceWeapons' has a wrong offset!");

// Class EndGame.EndAnimSingleNodeInstance
// 0x0010 (0x0450 - 0x0440)
class UEndAnimSingleNodeInstance : public UAnimSingleNodeInstance
{
public:
	uint8                                         Pad_440[0x10];                                     // 0x0440(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimSingleNodeInstance">();
	}
	static class UEndAnimSingleNodeInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimSingleNodeInstance>();
	}
};
static_assert(alignof(UEndAnimSingleNodeInstance) == 0x000008, "Wrong alignment on UEndAnimSingleNodeInstance");
static_assert(sizeof(UEndAnimSingleNodeInstance) == 0x000450, "Wrong size on UEndAnimSingleNodeInstance");

// Class EndGame.EndAnimNotifyBattleHiddenVolumeRelatedBreakable
// 0x0008 (0x0040 - 0x0038)
class UEndAnimNotifyBattleHiddenVolumeRelatedBreakable final : public UAnimNotify
{
public:
	bool                                          bHiddenVolume;                                     // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleHiddenVolumeRelatedBreakable">();
	}
	static class UEndAnimNotifyBattleHiddenVolumeRelatedBreakable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleHiddenVolumeRelatedBreakable>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleHiddenVolumeRelatedBreakable) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleHiddenVolumeRelatedBreakable");
static_assert(sizeof(UEndAnimNotifyBattleHiddenVolumeRelatedBreakable) == 0x000040, "Wrong size on UEndAnimNotifyBattleHiddenVolumeRelatedBreakable");
static_assert(offsetof(UEndAnimNotifyBattleHiddenVolumeRelatedBreakable, bHiddenVolume) == 0x000038, "Member 'UEndAnimNotifyBattleHiddenVolumeRelatedBreakable::bHiddenVolume' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattleLinkAbility
// 0x0018 (0x0050 - 0x0038)
class UEndAnimNotifyBattleLinkAbility final : public UAnimNotify
{
public:
	class FName                                   AbilityID;                                         // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupport;                                          // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAerial;                                           // 0x0041(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoWithoutTarget;                                  // 0x0042(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreLinkMode;                                   // 0x0043(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInstance;                                         // 0x0044(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SpecifiedAbilityID;                                // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleLinkAbility">();
	}
	static class UEndAnimNotifyBattleLinkAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleLinkAbility>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleLinkAbility) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleLinkAbility");
static_assert(sizeof(UEndAnimNotifyBattleLinkAbility) == 0x000050, "Wrong size on UEndAnimNotifyBattleLinkAbility");
static_assert(offsetof(UEndAnimNotifyBattleLinkAbility, AbilityID) == 0x000038, "Member 'UEndAnimNotifyBattleLinkAbility::AbilityID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleLinkAbility, bSupport) == 0x000040, "Member 'UEndAnimNotifyBattleLinkAbility::bSupport' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleLinkAbility, bAerial) == 0x000041, "Member 'UEndAnimNotifyBattleLinkAbility::bAerial' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleLinkAbility, bDoWithoutTarget) == 0x000042, "Member 'UEndAnimNotifyBattleLinkAbility::bDoWithoutTarget' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleLinkAbility, bIgnoreLinkMode) == 0x000043, "Member 'UEndAnimNotifyBattleLinkAbility::bIgnoreLinkMode' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleLinkAbility, bInstance) == 0x000044, "Member 'UEndAnimNotifyBattleLinkAbility::bInstance' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleLinkAbility, SpecifiedAbilityID) == 0x000048, "Member 'UEndAnimNotifyBattleLinkAbility::SpecifiedAbilityID' has a wrong offset!");

// Class EndGame.EndDataObjectStoryResident
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectStoryResident final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectStoryResident">();
	}
	static class UEndDataObjectStoryResident* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectStoryResident>();
	}
};
static_assert(alignof(UEndDataObjectStoryResident) == 0x000008, "Wrong alignment on UEndDataObjectStoryResident");
static_assert(sizeof(UEndDataObjectStoryResident) == 0x000088, "Wrong size on UEndDataObjectStoryResident");

// Class EndGame.EndAssetActor
// 0x0010 (0x0388 - 0x0378)
class AEndAssetActor final : public AActor
{
public:
	TArray<class UObject*>                        AssetUserData;                                     // 0x0378(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAssetActor">();
	}
	static class AEndAssetActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndAssetActor>();
	}
};
static_assert(alignof(AEndAssetActor) == 0x000008, "Wrong alignment on AEndAssetActor");
static_assert(sizeof(AEndAssetActor) == 0x000388, "Wrong size on AEndAssetActor");
static_assert(offsetof(AEndAssetActor, AssetUserData) == 0x000378, "Member 'AEndAssetActor::AssetUserData' has a wrong offset!");

// Class EndGame.EndMainEquipInfoWindowBase
// 0x0020 (0x0380 - 0x0360)
class UEndMainEquipInfoWindowBase : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x20];                                     // 0x0360(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainEquipInfoWindowBase">();
	}
	static class UEndMainEquipInfoWindowBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainEquipInfoWindowBase>();
	}
};
static_assert(alignof(UEndMainEquipInfoWindowBase) == 0x000008, "Wrong alignment on UEndMainEquipInfoWindowBase");
static_assert(sizeof(UEndMainEquipInfoWindowBase) == 0x000380, "Wrong size on UEndMainEquipInfoWindowBase");

// Class EndGame.EndShopItemInfoWindow
// 0x02D8 (0x0658 - 0x0380)
class UEndShopItemInfoWindow : public UEndMainEquipInfoWindowBase
{
public:
	uint8                                         Pad_380[0x2D8];                                    // 0x0380(0x02D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCoreListSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnMateriaInfoListSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	struct FVector2D OnMeasureInfoListSize(int32 CellIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndShopItemInfoWindow">();
	}
	static class UEndShopItemInfoWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndShopItemInfoWindow>();
	}
};
static_assert(alignof(UEndShopItemInfoWindow) == 0x000008, "Wrong alignment on UEndShopItemInfoWindow");
static_assert(sizeof(UEndShopItemInfoWindow) == 0x000658, "Wrong size on UEndShopItemInfoWindow");

// Class EndGame.EndAnimNotifyBattleOffensiveModeIdleConnection
// 0x0000 (0x0038 - 0x0038)
class UEndAnimNotifyBattleOffensiveModeIdleConnection final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleOffensiveModeIdleConnection">();
	}
	static class UEndAnimNotifyBattleOffensiveModeIdleConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleOffensiveModeIdleConnection>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleOffensiveModeIdleConnection) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleOffensiveModeIdleConnection");
static_assert(sizeof(UEndAnimNotifyBattleOffensiveModeIdleConnection) == 0x000038, "Wrong size on UEndAnimNotifyBattleOffensiveModeIdleConnection");

// Class EndGame.EndAnimNotifyBattleOffensiveModeSwitch
// 0x0000 (0x0038 - 0x0038)
class UEndAnimNotifyBattleOffensiveModeSwitch final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleOffensiveModeSwitch">();
	}
	static class UEndAnimNotifyBattleOffensiveModeSwitch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleOffensiveModeSwitch>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleOffensiveModeSwitch) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleOffensiveModeSwitch");
static_assert(sizeof(UEndAnimNotifyBattleOffensiveModeSwitch) == 0x000038, "Wrong size on UEndAnimNotifyBattleOffensiveModeSwitch");

// Class EndGame.EndMainDlcBtnMenu
// 0x0030 (0x0460 - 0x0430)
class UEndMainDlcBtnMenu : public UEndMainMenuWindow
{
public:
	class UEndButton*                             SelectBtn;                                         // 0x0430(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Category;                                      // 0x0438(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndImageSet*                           Icon_Clear;                                        // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          EndTextBlock_0;                                    // 0x0448(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_ReportTitle;                                   // 0x0450(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndImage*                              Icon_New;                                          // 0x0458(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainDlcBtnMenu">();
	}
	static class UEndMainDlcBtnMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainDlcBtnMenu>();
	}
};
static_assert(alignof(UEndMainDlcBtnMenu) == 0x000008, "Wrong alignment on UEndMainDlcBtnMenu");
static_assert(sizeof(UEndMainDlcBtnMenu) == 0x000460, "Wrong size on UEndMainDlcBtnMenu");
static_assert(offsetof(UEndMainDlcBtnMenu, SelectBtn) == 0x000430, "Member 'UEndMainDlcBtnMenu::SelectBtn' has a wrong offset!");
static_assert(offsetof(UEndMainDlcBtnMenu, Txt_Category) == 0x000438, "Member 'UEndMainDlcBtnMenu::Txt_Category' has a wrong offset!");
static_assert(offsetof(UEndMainDlcBtnMenu, Icon_Clear) == 0x000440, "Member 'UEndMainDlcBtnMenu::Icon_Clear' has a wrong offset!");
static_assert(offsetof(UEndMainDlcBtnMenu, EndTextBlock_0) == 0x000448, "Member 'UEndMainDlcBtnMenu::EndTextBlock_0' has a wrong offset!");
static_assert(offsetof(UEndMainDlcBtnMenu, Txt_ReportTitle) == 0x000450, "Member 'UEndMainDlcBtnMenu::Txt_ReportTitle' has a wrong offset!");
static_assert(offsetof(UEndMainDlcBtnMenu, Icon_New) == 0x000458, "Member 'UEndMainDlcBtnMenu::Icon_New' has a wrong offset!");

// Class EndGame.EndBattleAIPcBaseController
// 0x1618 (0x38A0 - 0x2288)
class AEndBattleAIPcBaseController : public AEndBattleAIController
{
public:
	uint8                                         Pad_2288[0x48];                                    // 0x2288(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEndBattleAITargetChoosingParam        TargetChoosingParam;                               // 0x22D0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_22F8[0x14A0];                                  // 0x22F8(0x14A0)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroundTargetReachableHeight;                       // 0x3798(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirTargetReachableHeight;                          // 0x379C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundTargetReachableHeightRangedWeapon;           // 0x37A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirTargetReachableHeightRangedWeapon;              // 0x37A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTeleportWhenCommandApproach;                   // 0x37A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37A9[0x7];                                     // 0x37A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBattleParam                           NormalBattleParam;                                 // 0x37B0(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBattleParam                           AutoPlayBattleParam;                               // 0x37E0(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBattleParam                           EnemyInBurstBattleParam;                           // 0x3810(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         StandbyTimeMax;                                    // 0x3840(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandbyTimeMin;                                    // 0x3844(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DangerDamagerSensorRadiusCoe;                      // 0x3848(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_384C[0x54];                                    // 0x384C(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool RequestUseAbility(class FName AbilityID);
	void SetDefenceActor(class AActor* TargetActor, float MaxDistance, float BestDistance);
	void SetDefenceLocaiton(const struct FVector& TargetLoaction, float MaxDistance, float BestDistance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIPcBaseController">();
	}
	static class AEndBattleAIPcBaseController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIPcBaseController>();
	}
};
static_assert(alignof(AEndBattleAIPcBaseController) == 0x000008, "Wrong alignment on AEndBattleAIPcBaseController");
static_assert(sizeof(AEndBattleAIPcBaseController) == 0x0038A0, "Wrong size on AEndBattleAIPcBaseController");
static_assert(offsetof(AEndBattleAIPcBaseController, TargetChoosingParam) == 0x0022D0, "Member 'AEndBattleAIPcBaseController::TargetChoosingParam' has a wrong offset!");
static_assert(offsetof(AEndBattleAIPcBaseController, GroundTargetReachableHeight) == 0x003798, "Member 'AEndBattleAIPcBaseController::GroundTargetReachableHeight' has a wrong offset!");
static_assert(offsetof(AEndBattleAIPcBaseController, AirTargetReachableHeight) == 0x00379C, "Member 'AEndBattleAIPcBaseController::AirTargetReachableHeight' has a wrong offset!");
static_assert(offsetof(AEndBattleAIPcBaseController, GroundTargetReachableHeightRangedWeapon) == 0x0037A0, "Member 'AEndBattleAIPcBaseController::GroundTargetReachableHeightRangedWeapon' has a wrong offset!");
static_assert(offsetof(AEndBattleAIPcBaseController, AirTargetReachableHeightRangedWeapon) == 0x0037A4, "Member 'AEndBattleAIPcBaseController::AirTargetReachableHeightRangedWeapon' has a wrong offset!");
static_assert(offsetof(AEndBattleAIPcBaseController, bCanTeleportWhenCommandApproach) == 0x0037A8, "Member 'AEndBattleAIPcBaseController::bCanTeleportWhenCommandApproach' has a wrong offset!");
static_assert(offsetof(AEndBattleAIPcBaseController, NormalBattleParam) == 0x0037B0, "Member 'AEndBattleAIPcBaseController::NormalBattleParam' has a wrong offset!");
static_assert(offsetof(AEndBattleAIPcBaseController, AutoPlayBattleParam) == 0x0037E0, "Member 'AEndBattleAIPcBaseController::AutoPlayBattleParam' has a wrong offset!");
static_assert(offsetof(AEndBattleAIPcBaseController, EnemyInBurstBattleParam) == 0x003810, "Member 'AEndBattleAIPcBaseController::EnemyInBurstBattleParam' has a wrong offset!");
static_assert(offsetof(AEndBattleAIPcBaseController, StandbyTimeMax) == 0x003840, "Member 'AEndBattleAIPcBaseController::StandbyTimeMax' has a wrong offset!");
static_assert(offsetof(AEndBattleAIPcBaseController, StandbyTimeMin) == 0x003844, "Member 'AEndBattleAIPcBaseController::StandbyTimeMin' has a wrong offset!");
static_assert(offsetof(AEndBattleAIPcBaseController, DangerDamagerSensorRadiusCoe) == 0x003848, "Member 'AEndBattleAIPcBaseController::DangerDamagerSensorRadiusCoe' has a wrong offset!");

// Class EndGame.EndBattleAIAerithController
// 0x0000 (0x38A0 - 0x38A0)
class AEndBattleAIAerithController final : public AEndBattleAIPcBaseController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIAerithController">();
	}
	static class AEndBattleAIAerithController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIAerithController>();
	}
};
static_assert(alignof(AEndBattleAIAerithController) == 0x000008, "Wrong alignment on AEndBattleAIAerithController");
static_assert(sizeof(AEndBattleAIAerithController) == 0x0038A0, "Wrong size on AEndBattleAIAerithController");

// Class EndGame.EndAnimNotifyBattlePlayBattleCameraSequence
// 0x0008 (0x0040 - 0x0038)
class UEndAnimNotifyBattlePlayBattleCameraSequence final : public UAnimNotify
{
public:
	class FName                                   BattleCameraSequenceID;                            // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattlePlayBattleCameraSequence">();
	}
	static class UEndAnimNotifyBattlePlayBattleCameraSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattlePlayBattleCameraSequence>();
	}
};
static_assert(alignof(UEndAnimNotifyBattlePlayBattleCameraSequence) == 0x000008, "Wrong alignment on UEndAnimNotifyBattlePlayBattleCameraSequence");
static_assert(sizeof(UEndAnimNotifyBattlePlayBattleCameraSequence) == 0x000040, "Wrong size on UEndAnimNotifyBattlePlayBattleCameraSequence");
static_assert(offsetof(UEndAnimNotifyBattlePlayBattleCameraSequence, BattleCameraSequenceID) == 0x000038, "Member 'UEndAnimNotifyBattlePlayBattleCameraSequence::BattleCameraSequenceID' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattlePlayBattleTalkState
// 0x0008 (0x0040 - 0x0038)
class UEndAnimNotifyBattlePlayBattleTalkState final : public UAnimNotify
{
public:
	class FName                                   TalkStateId;                                       // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattlePlayBattleTalkState">();
	}
	static class UEndAnimNotifyBattlePlayBattleTalkState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattlePlayBattleTalkState>();
	}
};
static_assert(alignof(UEndAnimNotifyBattlePlayBattleTalkState) == 0x000008, "Wrong alignment on UEndAnimNotifyBattlePlayBattleTalkState");
static_assert(sizeof(UEndAnimNotifyBattlePlayBattleTalkState) == 0x000040, "Wrong size on UEndAnimNotifyBattlePlayBattleTalkState");
static_assert(offsetof(UEndAnimNotifyBattlePlayBattleTalkState, TalkStateId) == 0x000038, "Member 'UEndAnimNotifyBattlePlayBattleTalkState::TalkStateId' has a wrong offset!");

// Class EndGame.EndDataObjectSummonParameter
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectSummonParameter final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectSummonParameter">();
	}
	static class UEndDataObjectSummonParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectSummonParameter>();
	}
};
static_assert(alignof(UEndDataObjectSummonParameter) == 0x000008, "Wrong alignment on UEndDataObjectSummonParameter");
static_assert(sizeof(UEndDataObjectSummonParameter) == 0x000088, "Wrong size on UEndDataObjectSummonParameter");

// Class EndGame.EndJukeboxMenu
// 0x0110 (0x0470 - 0x0360)
class UEndJukeboxMenu : public UEndUserWidget
{
public:
	class UEndBillboard*                          CoverBillboard;                                    // 0x0360(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       PlayingAnimation;                                  // 0x0368(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_370[0x100];                                    // 0x0370(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSoundListPressedItem(int32 ItemIndex);
	void OnSoundListSelectedIndexChanged(int32 ItemIndex);
	void OnSoundListSetupItem(class UWidget* ItemWidget, int32 ItemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndJukeboxMenu">();
	}
	static class UEndJukeboxMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndJukeboxMenu>();
	}
};
static_assert(alignof(UEndJukeboxMenu) == 0x000008, "Wrong alignment on UEndJukeboxMenu");
static_assert(sizeof(UEndJukeboxMenu) == 0x000470, "Wrong size on UEndJukeboxMenu");
static_assert(offsetof(UEndJukeboxMenu, CoverBillboard) == 0x000360, "Member 'UEndJukeboxMenu::CoverBillboard' has a wrong offset!");
static_assert(offsetof(UEndJukeboxMenu, PlayingAnimation) == 0x000368, "Member 'UEndJukeboxMenu::PlayingAnimation' has a wrong offset!");

// Class EndGame.EndAssetPack
// 0x0018 (0x0040 - 0x0028)
class UEndAssetPack final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        AssetUserData;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAssetPack">();
	}
	static class UEndAssetPack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAssetPack>();
	}
};
static_assert(alignof(UEndAssetPack) == 0x000008, "Wrong alignment on UEndAssetPack");
static_assert(sizeof(UEndAssetPack) == 0x000040, "Wrong size on UEndAssetPack");
static_assert(offsetof(UEndAssetPack, AssetUserData) == 0x000030, "Member 'UEndAssetPack::AssetUserData' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattleRemoveDamageCondition
// 0x0008 (0x0040 - 0x0038)
class UEndAnimNotifyBattleRemoveDamageCondition final : public UAnimNotify
{
public:
	bool                                          RemovePhysicsIgnore;                               // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableImmotality;                                 // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableTarget;                                      // 0x003A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleRemoveDamageCondition">();
	}
	static class UEndAnimNotifyBattleRemoveDamageCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleRemoveDamageCondition>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleRemoveDamageCondition) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleRemoveDamageCondition");
static_assert(sizeof(UEndAnimNotifyBattleRemoveDamageCondition) == 0x000040, "Wrong size on UEndAnimNotifyBattleRemoveDamageCondition");
static_assert(offsetof(UEndAnimNotifyBattleRemoveDamageCondition, RemovePhysicsIgnore) == 0x000038, "Member 'UEndAnimNotifyBattleRemoveDamageCondition::RemovePhysicsIgnore' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleRemoveDamageCondition, DisableImmotality) == 0x000039, "Member 'UEndAnimNotifyBattleRemoveDamageCondition::DisableImmotality' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleRemoveDamageCondition, EnableTarget) == 0x00003A, "Member 'UEndAnimNotifyBattleRemoveDamageCondition::EnableTarget' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattleRemoveStun
// 0x0000 (0x0038 - 0x0038)
class UEndAnimNotifyBattleRemoveStun final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleRemoveStun">();
	}
	static class UEndAnimNotifyBattleRemoveStun* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleRemoveStun>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleRemoveStun) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleRemoveStun");
static_assert(sizeof(UEndAnimNotifyBattleRemoveStun) == 0x000038, "Wrong size on UEndAnimNotifyBattleRemoveStun");

// Class EndGame.EndAreaMapMenu
// 0x0348 (0x07D0 - 0x0488)
class UEndAreaMapMenu : public UEndMapJournalMenuWindow
{
public:
	struct FBox2D                                 PlayArea;                                          // 0x0488(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_49C[0x4];                                      // 0x049C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEndUserWidget>             AreaEffectWidgetClass;                             // 0x04A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A8[0x2C0];                                    // 0x04A8(0x02C0)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndNaviMap*                            NaviMap;                                           // 0x0768(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndUserWidget*                         NaviCursor;                                        // 0x0770(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndUserWidget*                         TargetIcon;                                        // 0x0778(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndUserWidget*                         TargetButton;                                      // 0x0780(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndCanvasPanel*                        CircleCanvas;                                      // 0x0788(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndAreaMapInfoWindow*                  InfoWindow;                                        // 0x0790(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndUserWidget*                         BlockFrame;                                        // 0x0798(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndUserWidget*                         BlockCaption;                                      // 0x07A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndUserWidget*                         PlayerPosIndicator;                                // 0x07A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndUserWidget*                         TargetPosIndicator;                                // 0x07B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       CurrentAnimation;                                  // 0x07B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C0[0x10];                                     // 0x07C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLeftMenuSelectedIndexChanged(int32 ItemIndex);
	void OnLeftMenuSetupItem(class UWidget* ItemWidget, int32 ItemIndex);
	void OnStoryListBoxSetupItem(class UWidget* ItemWidget, int32 ItemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAreaMapMenu">();
	}
	static class UEndAreaMapMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAreaMapMenu>();
	}
};
static_assert(alignof(UEndAreaMapMenu) == 0x000008, "Wrong alignment on UEndAreaMapMenu");
static_assert(sizeof(UEndAreaMapMenu) == 0x0007D0, "Wrong size on UEndAreaMapMenu");
static_assert(offsetof(UEndAreaMapMenu, PlayArea) == 0x000488, "Member 'UEndAreaMapMenu::PlayArea' has a wrong offset!");
static_assert(offsetof(UEndAreaMapMenu, AreaEffectWidgetClass) == 0x0004A0, "Member 'UEndAreaMapMenu::AreaEffectWidgetClass' has a wrong offset!");
static_assert(offsetof(UEndAreaMapMenu, NaviMap) == 0x000768, "Member 'UEndAreaMapMenu::NaviMap' has a wrong offset!");
static_assert(offsetof(UEndAreaMapMenu, NaviCursor) == 0x000770, "Member 'UEndAreaMapMenu::NaviCursor' has a wrong offset!");
static_assert(offsetof(UEndAreaMapMenu, TargetIcon) == 0x000778, "Member 'UEndAreaMapMenu::TargetIcon' has a wrong offset!");
static_assert(offsetof(UEndAreaMapMenu, TargetButton) == 0x000780, "Member 'UEndAreaMapMenu::TargetButton' has a wrong offset!");
static_assert(offsetof(UEndAreaMapMenu, CircleCanvas) == 0x000788, "Member 'UEndAreaMapMenu::CircleCanvas' has a wrong offset!");
static_assert(offsetof(UEndAreaMapMenu, InfoWindow) == 0x000790, "Member 'UEndAreaMapMenu::InfoWindow' has a wrong offset!");
static_assert(offsetof(UEndAreaMapMenu, BlockFrame) == 0x000798, "Member 'UEndAreaMapMenu::BlockFrame' has a wrong offset!");
static_assert(offsetof(UEndAreaMapMenu, BlockCaption) == 0x0007A0, "Member 'UEndAreaMapMenu::BlockCaption' has a wrong offset!");
static_assert(offsetof(UEndAreaMapMenu, PlayerPosIndicator) == 0x0007A8, "Member 'UEndAreaMapMenu::PlayerPosIndicator' has a wrong offset!");
static_assert(offsetof(UEndAreaMapMenu, TargetPosIndicator) == 0x0007B0, "Member 'UEndAreaMapMenu::TargetPosIndicator' has a wrong offset!");
static_assert(offsetof(UEndAreaMapMenu, CurrentAnimation) == 0x0007B8, "Member 'UEndAreaMapMenu::CurrentAnimation' has a wrong offset!");

// Class EndGame.EndSaveGame
// 0x0000 (0x0028 - 0x0028)
class UEndSaveGame final : public USaveGame
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndSaveGame">();
	}
	static class UEndSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndSaveGame>();
	}
};
static_assert(alignof(UEndSaveGame) == 0x000008, "Wrong alignment on UEndSaveGame");
static_assert(sizeof(UEndSaveGame) == 0x000028, "Wrong size on UEndSaveGame");

// Class EndGame.EndAnimNotifyBattleSceneMessage
// 0x0000 (0x0038 - 0x0038)
class UEndAnimNotifyBattleSceneMessage final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleSceneMessage">();
	}
	static class UEndAnimNotifyBattleSceneMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleSceneMessage>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleSceneMessage) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleSceneMessage");
static_assert(sizeof(UEndAnimNotifyBattleSceneMessage) == 0x000038, "Wrong size on UEndAnimNotifyBattleSceneMessage");

// Class EndGame.EndAnimNotifyBattleSetEnableCounterAbility
// 0x0000 (0x0038 - 0x0038)
class UEndAnimNotifyBattleSetEnableCounterAbility final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleSetEnableCounterAbility">();
	}
	static class UEndAnimNotifyBattleSetEnableCounterAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleSetEnableCounterAbility>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleSetEnableCounterAbility) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleSetEnableCounterAbility");
static_assert(sizeof(UEndAnimNotifyBattleSetEnableCounterAbility) == 0x000038, "Wrong size on UEndAnimNotifyBattleSetEnableCounterAbility");

// Class EndGame.EndDataObjectLocationResident
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectLocationResident final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectLocationResident">();
	}
	static class UEndDataObjectLocationResident* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectLocationResident>();
	}
};
static_assert(alignof(UEndDataObjectLocationResident) == 0x000008, "Wrong alignment on UEndDataObjectLocationResident");
static_assert(sizeof(UEndDataObjectLocationResident) == 0x000088, "Wrong size on UEndDataObjectLocationResident");

// Class EndGame.EndParticleModuleStaticMesh
// 0x0030 (0x0068 - 0x0038)
class UEndParticleModuleStaticMesh final : public UParticleModuleLocationBase
{
public:
	class UStaticMesh*                            m_StaticMesh;                                      // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndEffectStaticMeshSelectKind                m_SelectKind;                                      // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        m_OrderOffset;                                     // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         m_OrderReverse : 1;                                // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         m_bMultiplySurfaceArea : 1;                        // 0x0048(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint16>                                m_UserSetVertexIndexArray;                         // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndParticleModuleStaticMesh">();
	}
	static class UEndParticleModuleStaticMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndParticleModuleStaticMesh>();
	}
};
static_assert(alignof(UEndParticleModuleStaticMesh) == 0x000008, "Wrong alignment on UEndParticleModuleStaticMesh");
static_assert(sizeof(UEndParticleModuleStaticMesh) == 0x000068, "Wrong size on UEndParticleModuleStaticMesh");
static_assert(offsetof(UEndParticleModuleStaticMesh, m_StaticMesh) == 0x000038, "Member 'UEndParticleModuleStaticMesh::m_StaticMesh' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleStaticMesh, m_SelectKind) == 0x000040, "Member 'UEndParticleModuleStaticMesh::m_SelectKind' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleStaticMesh, m_OrderOffset) == 0x000044, "Member 'UEndParticleModuleStaticMesh::m_OrderOffset' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleStaticMesh, m_UserSetVertexIndexArray) == 0x000050, "Member 'UEndParticleModuleStaticMesh::m_UserSetVertexIndexArray' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattleSetNormalAttackOverrideCount
// 0x0008 (0x0040 - 0x0038)
class UEndAnimNotifyBattleSetNormalAttackOverrideCount final : public UAnimNotify
{
public:
	uint8                                         Count;                                             // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EndBattleSetNormalAttackCountCondition        Condition;                                         // 0x0039(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleSetNormalAttackOverrideCount">();
	}
	static class UEndAnimNotifyBattleSetNormalAttackOverrideCount* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleSetNormalAttackOverrideCount>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleSetNormalAttackOverrideCount) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleSetNormalAttackOverrideCount");
static_assert(sizeof(UEndAnimNotifyBattleSetNormalAttackOverrideCount) == 0x000040, "Wrong size on UEndAnimNotifyBattleSetNormalAttackOverrideCount");
static_assert(offsetof(UEndAnimNotifyBattleSetNormalAttackOverrideCount, Count) == 0x000038, "Member 'UEndAnimNotifyBattleSetNormalAttackOverrideCount::Count' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleSetNormalAttackOverrideCount, Condition) == 0x000039, "Member 'UEndAnimNotifyBattleSetNormalAttackOverrideCount::Condition' has a wrong offset!");

// Class EndGame.EndEnvQueryContext_TargetFeetLocation
// 0x0000 (0x0028 - 0x0028)
class UEndEnvQueryContext_TargetFeetLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryContext_TargetFeetLocation">();
	}
	static class UEndEnvQueryContext_TargetFeetLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryContext_TargetFeetLocation>();
	}
};
static_assert(alignof(UEndEnvQueryContext_TargetFeetLocation) == 0x000008, "Wrong alignment on UEndEnvQueryContext_TargetFeetLocation");
static_assert(sizeof(UEndEnvQueryContext_TargetFeetLocation) == 0x000028, "Wrong size on UEndEnvQueryContext_TargetFeetLocation");

// Class EndGame.EndAnimNotifyBattleSetSpecialStatusChangeState
// 0x0020 (0x0058 - 0x0038)
class UEndAnimNotifyBattleSetSpecialStatusChangeState final : public UAnimNotify
{
public:
	EEndBattleSpecialStatusChangeType             Type;                                              // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StateChangeID;                                     // 0x003C(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ParamIDs;                                          // 0x0048(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleSetSpecialStatusChangeState">();
	}
	static class UEndAnimNotifyBattleSetSpecialStatusChangeState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleSetSpecialStatusChangeState>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleSetSpecialStatusChangeState) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleSetSpecialStatusChangeState");
static_assert(sizeof(UEndAnimNotifyBattleSetSpecialStatusChangeState) == 0x000058, "Wrong size on UEndAnimNotifyBattleSetSpecialStatusChangeState");
static_assert(offsetof(UEndAnimNotifyBattleSetSpecialStatusChangeState, Type) == 0x000038, "Member 'UEndAnimNotifyBattleSetSpecialStatusChangeState::Type' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleSetSpecialStatusChangeState, StateChangeID) == 0x00003C, "Member 'UEndAnimNotifyBattleSetSpecialStatusChangeState::StateChangeID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBattleSetSpecialStatusChangeState, ParamIDs) == 0x000048, "Member 'UEndAnimNotifyBattleSetSpecialStatusChangeState::ParamIDs' has a wrong offset!");

// Class EndGame.EndSplineActorBase
// 0x0010 (0x0388 - 0x0378)
class AEndSplineActorBase : public AActor
{
public:
	class USplineComponent*                       SplineMoveComponent;                               // 0x0378(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsLoop;                                            // 0x0380(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_381[0x7];                                      // 0x0381(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndSplineActorBase">();
	}
	static class AEndSplineActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndSplineActorBase>();
	}
};
static_assert(alignof(AEndSplineActorBase) == 0x000008, "Wrong alignment on AEndSplineActorBase");
static_assert(sizeof(AEndSplineActorBase) == 0x000388, "Wrong size on AEndSplineActorBase");
static_assert(offsetof(AEndSplineActorBase, SplineMoveComponent) == 0x000378, "Member 'AEndSplineActorBase::SplineMoveComponent' has a wrong offset!");
static_assert(offsetof(AEndSplineActorBase, IsLoop) == 0x000380, "Member 'AEndSplineActorBase::IsLoop' has a wrong offset!");

// Class EndGame.EndFieldSplineActor
// 0x0000 (0x0388 - 0x0388)
class AEndFieldSplineActor final : public AEndSplineActorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldSplineActor">();
	}
	static class AEndFieldSplineActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldSplineActor>();
	}
};
static_assert(alignof(AEndFieldSplineActor) == 0x000008, "Wrong alignment on AEndFieldSplineActor");
static_assert(sizeof(AEndFieldSplineActor) == 0x000388, "Wrong size on AEndFieldSplineActor");

// Class EndGame.RangeTest
// 0x0030 (0x0058 - 0x0028)
class URangeTest final : public UOnlineBlueprintCallProxyBase
{
public:
	UMulticastDelegateProperty_                   OnTrue;                                            // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFalse;                                           // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class URangeTest* IsRangeTest(float InMin, float InMax, float InDist);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RangeTest">();
	}
	static class URangeTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<URangeTest>();
	}
};
static_assert(alignof(URangeTest) == 0x000008, "Wrong alignment on URangeTest");
static_assert(sizeof(URangeTest) == 0x000058, "Wrong size on URangeTest");
static_assert(offsetof(URangeTest, OnTrue) == 0x000028, "Member 'URangeTest::OnTrue' has a wrong offset!");
static_assert(offsetof(URangeTest, OnFalse) == 0x000038, "Member 'URangeTest::OnFalse' has a wrong offset!");

// Class EndGame.EndAnimNotifyEnableInputCancel
// 0x0008 (0x0040 - 0x0038)
class UEndAnimNotifyEnableInputCancel : public UAnimNotify
{
public:
	EEndAnimWalkType                              AfterWalkType;                                     // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AfterLimitedRunningTimer;                          // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyEnableInputCancel">();
	}
	static class UEndAnimNotifyEnableInputCancel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyEnableInputCancel>();
	}
};
static_assert(alignof(UEndAnimNotifyEnableInputCancel) == 0x000008, "Wrong alignment on UEndAnimNotifyEnableInputCancel");
static_assert(sizeof(UEndAnimNotifyEnableInputCancel) == 0x000040, "Wrong size on UEndAnimNotifyEnableInputCancel");
static_assert(offsetof(UEndAnimNotifyEnableInputCancel, AfterWalkType) == 0x000038, "Member 'UEndAnimNotifyEnableInputCancel::AfterWalkType' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyEnableInputCancel, AfterLimitedRunningTimer) == 0x00003C, "Member 'UEndAnimNotifyEnableInputCancel::AfterLimitedRunningTimer' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattleStateChange
// 0x0000 (0x0040 - 0x0040)
class UEndAnimNotifyBattleStateChange final : public UEndAnimNotifyEnableInputCancel
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleStateChange">();
	}
	static class UEndAnimNotifyBattleStateChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleStateChange>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleStateChange) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleStateChange");
static_assert(sizeof(UEndAnimNotifyBattleStateChange) == 0x000040, "Wrong size on UEndAnimNotifyBattleStateChange");

// Class EndGame.EndDataObjectMapIconInfo
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectMapIconInfo final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectMapIconInfo">();
	}
	static class UEndDataObjectMapIconInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectMapIconInfo>();
	}
};
static_assert(alignof(UEndDataObjectMapIconInfo) == 0x000008, "Wrong alignment on UEndDataObjectMapIconInfo");
static_assert(sizeof(UEndDataObjectMapIconInfo) == 0x000088, "Wrong size on UEndDataObjectMapIconInfo");

// Class EndGame.EndAnimNotifyBattleSyncAbilityCreateSyncAction
// 0x0000 (0x0038 - 0x0038)
class UEndAnimNotifyBattleSyncAbilityCreateSyncAction final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleSyncAbilityCreateSyncAction">();
	}
	static class UEndAnimNotifyBattleSyncAbilityCreateSyncAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleSyncAbilityCreateSyncAction>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleSyncAbilityCreateSyncAction) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleSyncAbilityCreateSyncAction");
static_assert(sizeof(UEndAnimNotifyBattleSyncAbilityCreateSyncAction) == 0x000038, "Wrong size on UEndAnimNotifyBattleSyncAbilityCreateSyncAction");

// Class EndGame.EndEnvQueryGenerator_AIPCOnTerrainSensor
// 0x0030 (0x00B0 - 0x0080)
class UEndEnvQueryGenerator_AIPCOnTerrainSensor final : public UEnvQueryGenerator_ProjectedPoints
{
public:
	struct FAIDataProviderFloatValue              SpaceBetween;                                      // 0x0080(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryGenerator_AIPCOnTerrainSensor">();
	}
	static class UEndEnvQueryGenerator_AIPCOnTerrainSensor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryGenerator_AIPCOnTerrainSensor>();
	}
};
static_assert(alignof(UEndEnvQueryGenerator_AIPCOnTerrainSensor) == 0x000008, "Wrong alignment on UEndEnvQueryGenerator_AIPCOnTerrainSensor");
static_assert(sizeof(UEndEnvQueryGenerator_AIPCOnTerrainSensor) == 0x0000B0, "Wrong size on UEndEnvQueryGenerator_AIPCOnTerrainSensor");
static_assert(offsetof(UEndEnvQueryGenerator_AIPCOnTerrainSensor, SpaceBetween) == 0x000080, "Member 'UEndEnvQueryGenerator_AIPCOnTerrainSensor::SpaceBetween' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattleSyncAbilityRequestAttach
// 0x0000 (0x0038 - 0x0038)
class UEndAnimNotifyBattleSyncAbilityRequestAttach final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleSyncAbilityRequestAttach">();
	}
	static class UEndAnimNotifyBattleSyncAbilityRequestAttach* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleSyncAbilityRequestAttach>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleSyncAbilityRequestAttach) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleSyncAbilityRequestAttach");
static_assert(sizeof(UEndAnimNotifyBattleSyncAbilityRequestAttach) == 0x000038, "Wrong size on UEndAnimNotifyBattleSyncAbilityRequestAttach");

// Class EndGame.EndParticleModuleNoiseVelocity
// 0x0108 (0x0140 - 0x0038)
class UEndParticleModuleNoiseVelocity final : public UEndParticleModuleBase
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               m_FrequencyModulationX;                            // 0x0040(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               m_FrequencyModulationY;                            // 0x0050(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector4                               m_FrequencyModulationZ;                            // 0x0060(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 m_CycleTime;                                       // 0x0070(0x0060)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 m_Amplitude;                                       // 0x00D0(0x0060)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_130[0x10];                                     // 0x0130(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndParticleModuleNoiseVelocity">();
	}
	static class UEndParticleModuleNoiseVelocity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndParticleModuleNoiseVelocity>();
	}
};
static_assert(alignof(UEndParticleModuleNoiseVelocity) == 0x000010, "Wrong alignment on UEndParticleModuleNoiseVelocity");
static_assert(sizeof(UEndParticleModuleNoiseVelocity) == 0x000140, "Wrong size on UEndParticleModuleNoiseVelocity");
static_assert(offsetof(UEndParticleModuleNoiseVelocity, m_FrequencyModulationX) == 0x000040, "Member 'UEndParticleModuleNoiseVelocity::m_FrequencyModulationX' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleNoiseVelocity, m_FrequencyModulationY) == 0x000050, "Member 'UEndParticleModuleNoiseVelocity::m_FrequencyModulationY' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleNoiseVelocity, m_FrequencyModulationZ) == 0x000060, "Member 'UEndParticleModuleNoiseVelocity::m_FrequencyModulationZ' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleNoiseVelocity, m_CycleTime) == 0x000070, "Member 'UEndParticleModuleNoiseVelocity::m_CycleTime' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleNoiseVelocity, m_Amplitude) == 0x0000D0, "Member 'UEndParticleModuleNoiseVelocity::m_Amplitude' has a wrong offset!");

// Class EndGame.EndAnimNotifyBattleVisionStart
// 0x0000 (0x0038 - 0x0038)
class UEndAnimNotifyBattleVisionStart final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBattleVisionStart">();
	}
	static class UEndAnimNotifyBattleVisionStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBattleVisionStart>();
	}
};
static_assert(alignof(UEndAnimNotifyBattleVisionStart) == 0x000008, "Wrong alignment on UEndAnimNotifyBattleVisionStart");
static_assert(sizeof(UEndAnimNotifyBattleVisionStart) == 0x000038, "Wrong size on UEndAnimNotifyBattleVisionStart");

// Class EndGame.EndAnimNotifyBikeBreakBridge
// 0x0000 (0x0038 - 0x0038)
class UEndAnimNotifyBikeBreakBridge final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBikeBreakBridge">();
	}
	static class UEndAnimNotifyBikeBreakBridge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBikeBreakBridge>();
	}
};
static_assert(alignof(UEndAnimNotifyBikeBreakBridge) == 0x000008, "Wrong alignment on UEndAnimNotifyBikeBreakBridge");
static_assert(sizeof(UEndAnimNotifyBikeBreakBridge) == 0x000038, "Wrong size on UEndAnimNotifyBikeBreakBridge");

// Class EndGame.EndDataObjectMiniGameScoreboard
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectMiniGameScoreboard final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectMiniGameScoreboard">();
	}
	static class UEndDataObjectMiniGameScoreboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectMiniGameScoreboard>();
	}
};
static_assert(alignof(UEndDataObjectMiniGameScoreboard) == 0x000008, "Wrong alignment on UEndDataObjectMiniGameScoreboard");
static_assert(sizeof(UEndDataObjectMiniGameScoreboard) == 0x000088, "Wrong size on UEndDataObjectMiniGameScoreboard");

// Class EndGame.EndBattleAIDefine
// 0x0000 (0x0378 - 0x0378)
class AEndBattleAIDefine final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIDefine">();
	}
	static class AEndBattleAIDefine* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIDefine>();
	}
};
static_assert(alignof(AEndBattleAIDefine) == 0x000008, "Wrong alignment on AEndBattleAIDefine");
static_assert(sizeof(AEndBattleAIDefine) == 0x000378, "Wrong size on AEndBattleAIDefine");

// Class EndGame.EndAnimNotifyBikeChangeNextAction
// 0x0008 (0x0040 - 0x0038)
class UEndAnimNotifyBikeChangeNextAction final : public UAnimNotify
{
public:
	uint8                                         Pad_38[0x1];                                       // 0x0038(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAbility;                                          // 0x0039(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x1];                                       // 0x003A(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAccel;                                            // 0x003B(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBikeChangeNextAction">();
	}
	static class UEndAnimNotifyBikeChangeNextAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBikeChangeNextAction>();
	}
};
static_assert(alignof(UEndAnimNotifyBikeChangeNextAction) == 0x000008, "Wrong alignment on UEndAnimNotifyBikeChangeNextAction");
static_assert(sizeof(UEndAnimNotifyBikeChangeNextAction) == 0x000040, "Wrong size on UEndAnimNotifyBikeChangeNextAction");
static_assert(offsetof(UEndAnimNotifyBikeChangeNextAction, bAbility) == 0x000039, "Member 'UEndAnimNotifyBikeChangeNextAction::bAbility' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBikeChangeNextAction, bAccel) == 0x00003B, "Member 'UEndAnimNotifyBikeChangeNextAction::bAccel' has a wrong offset!");

// Class EndGame.EndAnimNotifyBikeDisableInput
// 0x0000 (0x0030 - 0x0030)
class UEndAnimNotifyBikeDisableInput final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBikeDisableInput">();
	}
	static class UEndAnimNotifyBikeDisableInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBikeDisableInput>();
	}
};
static_assert(alignof(UEndAnimNotifyBikeDisableInput) == 0x000008, "Wrong alignment on UEndAnimNotifyBikeDisableInput");
static_assert(sizeof(UEndAnimNotifyBikeDisableInput) == 0x000030, "Wrong size on UEndAnimNotifyBikeDisableInput");

// Class EndGame.EndFootEffectorSolver
// 0x00B8 (0x00E0 - 0x0028)
class UEndFootEffectorSolver final : public UObject
{
public:
	struct FVector                                FloorTraceBoxHalfSize;                             // 0x0028(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FootTraceBoxHalfSize;                              // 0x0034(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FloorTraceOffset;                                  // 0x0040(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloorTraceToOffsetHeight;                          // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootTraceBeginOffsetHeight;                        // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootTraceEndOffsetHeight;                          // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 FootMaxIterations;                                 // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         FootReachPrecision;                                // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetReachStepPercent;                            // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PullDistribution;                                  // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CollisionHipOffsetInterpSpeedVelocityInput;        // 0x0074(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CollisionHipOffsetInterpSpeedOutput;               // 0x007C(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RotationHipOffsetInterpSpeedVelocityInput;         // 0x0084(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RotationHipOffsetInterpSpeedOutput;                // 0x008C(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloorAdjustRotationInterpSpeed;                    // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HipAdjustFloorRate;                                // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HipAdjustFloorRotationRate;                        // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchHipOffsetFloorAngleRate;                      // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollHipOffsetFloorAngleRate;                       // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootAdjustFloorRate;                               // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchAdjustFloorAngleRate;                         // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollAdjustFloorAngleRate;                          // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootAdjustFloorOrientationRate;                    // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootAdjustFloorTranslationAngleRate;               // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionOffsetHeightMin;                          // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootAdjustTranslationHeightMax;                    // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootLandingThreshold;                              // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEffective;                                        // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowedHipOnly;                                   // 0x00C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceToeOnly;                                     // 0x00CA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreStairs;                                     // 0x00CB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEndFootEffectorSolveFoot>      Foots;                                             // 0x00D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFootEffectorSolver">();
	}
	static class UEndFootEffectorSolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndFootEffectorSolver>();
	}
};
static_assert(alignof(UEndFootEffectorSolver) == 0x000008, "Wrong alignment on UEndFootEffectorSolver");
static_assert(sizeof(UEndFootEffectorSolver) == 0x0000E0, "Wrong size on UEndFootEffectorSolver");
static_assert(offsetof(UEndFootEffectorSolver, FloorTraceBoxHalfSize) == 0x000028, "Member 'UEndFootEffectorSolver::FloorTraceBoxHalfSize' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, FootTraceBoxHalfSize) == 0x000034, "Member 'UEndFootEffectorSolver::FootTraceBoxHalfSize' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, FloorTraceOffset) == 0x000040, "Member 'UEndFootEffectorSolver::FloorTraceOffset' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, FloorTraceToOffsetHeight) == 0x00004C, "Member 'UEndFootEffectorSolver::FloorTraceToOffsetHeight' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, FootTraceBeginOffsetHeight) == 0x000050, "Member 'UEndFootEffectorSolver::FootTraceBeginOffsetHeight' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, FootTraceEndOffsetHeight) == 0x000054, "Member 'UEndFootEffectorSolver::FootTraceEndOffsetHeight' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, FootMaxIterations) == 0x000058, "Member 'UEndFootEffectorSolver::FootMaxIterations' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, FootReachPrecision) == 0x000068, "Member 'UEndFootEffectorSolver::FootReachPrecision' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, TargetReachStepPercent) == 0x00006C, "Member 'UEndFootEffectorSolver::TargetReachStepPercent' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, PullDistribution) == 0x000070, "Member 'UEndFootEffectorSolver::PullDistribution' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, CollisionHipOffsetInterpSpeedVelocityInput) == 0x000074, "Member 'UEndFootEffectorSolver::CollisionHipOffsetInterpSpeedVelocityInput' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, CollisionHipOffsetInterpSpeedOutput) == 0x00007C, "Member 'UEndFootEffectorSolver::CollisionHipOffsetInterpSpeedOutput' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, RotationHipOffsetInterpSpeedVelocityInput) == 0x000084, "Member 'UEndFootEffectorSolver::RotationHipOffsetInterpSpeedVelocityInput' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, RotationHipOffsetInterpSpeedOutput) == 0x00008C, "Member 'UEndFootEffectorSolver::RotationHipOffsetInterpSpeedOutput' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, FloorAdjustRotationInterpSpeed) == 0x000094, "Member 'UEndFootEffectorSolver::FloorAdjustRotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, HipAdjustFloorRate) == 0x000098, "Member 'UEndFootEffectorSolver::HipAdjustFloorRate' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, HipAdjustFloorRotationRate) == 0x00009C, "Member 'UEndFootEffectorSolver::HipAdjustFloorRotationRate' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, PitchHipOffsetFloorAngleRate) == 0x0000A0, "Member 'UEndFootEffectorSolver::PitchHipOffsetFloorAngleRate' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, RollHipOffsetFloorAngleRate) == 0x0000A4, "Member 'UEndFootEffectorSolver::RollHipOffsetFloorAngleRate' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, FootAdjustFloorRate) == 0x0000A8, "Member 'UEndFootEffectorSolver::FootAdjustFloorRate' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, PitchAdjustFloorAngleRate) == 0x0000AC, "Member 'UEndFootEffectorSolver::PitchAdjustFloorAngleRate' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, RollAdjustFloorAngleRate) == 0x0000B0, "Member 'UEndFootEffectorSolver::RollAdjustFloorAngleRate' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, FootAdjustFloorOrientationRate) == 0x0000B4, "Member 'UEndFootEffectorSolver::FootAdjustFloorOrientationRate' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, FootAdjustFloorTranslationAngleRate) == 0x0000B8, "Member 'UEndFootEffectorSolver::FootAdjustFloorTranslationAngleRate' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, CollisionOffsetHeightMin) == 0x0000BC, "Member 'UEndFootEffectorSolver::CollisionOffsetHeightMin' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, FootAdjustTranslationHeightMax) == 0x0000C0, "Member 'UEndFootEffectorSolver::FootAdjustTranslationHeightMax' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, FootLandingThreshold) == 0x0000C4, "Member 'UEndFootEffectorSolver::FootLandingThreshold' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, bEffective) == 0x0000C8, "Member 'UEndFootEffectorSolver::bEffective' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, bAllowedHipOnly) == 0x0000C9, "Member 'UEndFootEffectorSolver::bAllowedHipOnly' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, bTraceToeOnly) == 0x0000CA, "Member 'UEndFootEffectorSolver::bTraceToeOnly' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, bIgnoreStairs) == 0x0000CB, "Member 'UEndFootEffectorSolver::bIgnoreStairs' has a wrong offset!");
static_assert(offsetof(UEndFootEffectorSolver, Foots) == 0x0000D0, "Member 'UEndFootEffectorSolver::Foots' has a wrong offset!");

// Class EndGame.EndBattleAIEB0003Controller
// 0x00B8 (0x2340 - 0x2288)
class AEndBattleAIEB0003Controller final : public AEndBattleAIController
{
public:
	float                                         FastMoveSpeed;                                     // 0x2288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FastMoveRange;                                     // 0x228C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FastMoveLoopAngleQuantity;                         // 0x2290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FastMoveFriction;                                  // 0x2294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FastNextBlendTime;                                 // 0x2298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FastBeginToLoopBlendTime;                          // 0x229C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FastLoopToEndBlendTime;                            // 0x22A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FastMoveStartAnimRotate;                           // 0x22A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22A5[0x9B];                                    // 0x22A5(0x009B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CleanFlashDash();
	void FinishRollingAtack();
	bool IsPlayerInConfirmSpark();
	void OnReadySpark(int32 sparkID, const struct FVector& centerPos, const TArray<class AEndBattleAIEB0003MineController*>& mineAIList);
	void OnRequestFlashDash(int32 InFlashDashCount);
	void OnSuspendFlushDash();
	void PlayEffectOnce(class FName InName);
	void SetNextFastPoint(const struct FVector& Point);
	void SetNextFlashDashPoint(const struct FVector& Point);
	void StopFlashDashEffect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEB0003Controller">();
	}
	static class AEndBattleAIEB0003Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEB0003Controller>();
	}
};
static_assert(alignof(AEndBattleAIEB0003Controller) == 0x000008, "Wrong alignment on AEndBattleAIEB0003Controller");
static_assert(sizeof(AEndBattleAIEB0003Controller) == 0x002340, "Wrong size on AEndBattleAIEB0003Controller");
static_assert(offsetof(AEndBattleAIEB0003Controller, FastMoveSpeed) == 0x002288, "Member 'AEndBattleAIEB0003Controller::FastMoveSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0003Controller, FastMoveRange) == 0x00228C, "Member 'AEndBattleAIEB0003Controller::FastMoveRange' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0003Controller, FastMoveLoopAngleQuantity) == 0x002290, "Member 'AEndBattleAIEB0003Controller::FastMoveLoopAngleQuantity' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0003Controller, FastMoveFriction) == 0x002294, "Member 'AEndBattleAIEB0003Controller::FastMoveFriction' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0003Controller, FastNextBlendTime) == 0x002298, "Member 'AEndBattleAIEB0003Controller::FastNextBlendTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0003Controller, FastBeginToLoopBlendTime) == 0x00229C, "Member 'AEndBattleAIEB0003Controller::FastBeginToLoopBlendTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0003Controller, FastLoopToEndBlendTime) == 0x0022A0, "Member 'AEndBattleAIEB0003Controller::FastLoopToEndBlendTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0003Controller, FastMoveStartAnimRotate) == 0x0022A4, "Member 'AEndBattleAIEB0003Controller::FastMoveStartAnimRotate' has a wrong offset!");

// Class EndGame.EndAnimNotifyBikeEnableAccel
// 0x0000 (0x0038 - 0x0038)
class UEndAnimNotifyBikeEnableAccel final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBikeEnableAccel">();
	}
	static class UEndAnimNotifyBikeEnableAccel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBikeEnableAccel>();
	}
};
static_assert(alignof(UEndAnimNotifyBikeEnableAccel) == 0x000008, "Wrong alignment on UEndAnimNotifyBikeEnableAccel");
static_assert(sizeof(UEndAnimNotifyBikeEnableAccel) == 0x000038, "Wrong size on UEndAnimNotifyBikeEnableAccel");

// Class EndGame.EndAnimNotifyBikeEnableAccelMotion
// 0x0000 (0x0038 - 0x0038)
class UEndAnimNotifyBikeEnableAccelMotion final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBikeEnableAccelMotion">();
	}
	static class UEndAnimNotifyBikeEnableAccelMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBikeEnableAccelMotion>();
	}
};
static_assert(alignof(UEndAnimNotifyBikeEnableAccelMotion) == 0x000008, "Wrong alignment on UEndAnimNotifyBikeEnableAccelMotion");
static_assert(sizeof(UEndAnimNotifyBikeEnableAccelMotion) == 0x000038, "Wrong size on UEndAnimNotifyBikeEnableAccelMotion");

// Class EndGame.EndDataObjectObjectActor
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectObjectActor final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectObjectActor">();
	}
	static class UEndDataObjectObjectActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectObjectActor>();
	}
};
static_assert(alignof(UEndDataObjectObjectActor) == 0x000008, "Wrong alignment on UEndDataObjectObjectActor");
static_assert(sizeof(UEndDataObjectObjectActor) == 0x000088, "Wrong size on UEndDataObjectObjectActor");

// Class EndGame.RangeSwitch2
// 0x0048 (0x0070 - 0x0028)
class URangeSwitch2 final : public UOnlineBlueprintCallProxyBase
{
public:
	UMulticastDelegateProperty_                   Case1;                                             // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Case2;                                             // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Other;                                             // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x18];                                      // 0x0058(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class URangeSwitch2* RangeSwitch2(float Value, float Min1, float Max1, float Min2, float Max2, bool ContainEqual, bool FirstOnly);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RangeSwitch2">();
	}
	static class URangeSwitch2* GetDefaultObj()
	{
		return GetDefaultObjImpl<URangeSwitch2>();
	}
};
static_assert(alignof(URangeSwitch2) == 0x000008, "Wrong alignment on URangeSwitch2");
static_assert(sizeof(URangeSwitch2) == 0x000070, "Wrong size on URangeSwitch2");
static_assert(offsetof(URangeSwitch2, Case1) == 0x000028, "Member 'URangeSwitch2::Case1' has a wrong offset!");
static_assert(offsetof(URangeSwitch2, Case2) == 0x000038, "Member 'URangeSwitch2::Case2' has a wrong offset!");
static_assert(offsetof(URangeSwitch2, Other) == 0x000048, "Member 'URangeSwitch2::Other' has a wrong offset!");

// Class EndGame.EndFieldCommandMenu
// 0x0480 (0x07E0 - 0x0360)
class UEndFieldCommandMenu : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x480];                                    // 0x0360(0x0480)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCommandCellSetup(class UWidget* ItemWidget, int32 ItemIndex);
	void OnPressedItem(int32 ItemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldCommandMenu">();
	}
	static class UEndFieldCommandMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndFieldCommandMenu>();
	}
};
static_assert(alignof(UEndFieldCommandMenu) == 0x000008, "Wrong alignment on UEndFieldCommandMenu");
static_assert(sizeof(UEndFieldCommandMenu) == 0x0007E0, "Wrong size on UEndFieldCommandMenu");

// Class EndGame.EndAnimNotifyBikeHelicopterAvoidAbility
// 0x0000 (0x0038 - 0x0038)
class UEndAnimNotifyBikeHelicopterAvoidAbility final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBikeHelicopterAvoidAbility">();
	}
	static class UEndAnimNotifyBikeHelicopterAvoidAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBikeHelicopterAvoidAbility>();
	}
};
static_assert(alignof(UEndAnimNotifyBikeHelicopterAvoidAbility) == 0x000008, "Wrong alignment on UEndAnimNotifyBikeHelicopterAvoidAbility");
static_assert(sizeof(UEndAnimNotifyBikeHelicopterAvoidAbility) == 0x000038, "Wrong size on UEndAnimNotifyBikeHelicopterAvoidAbility");

// Class EndGame.EndEnvQueryTest_AIPCCombatArea
// 0x0000 (0x01C0 - 0x01C0)
class UEndEnvQueryTest_AIPCCombatArea final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryTest_AIPCCombatArea">();
	}
	static class UEndEnvQueryTest_AIPCCombatArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryTest_AIPCCombatArea>();
	}
};
static_assert(alignof(UEndEnvQueryTest_AIPCCombatArea) == 0x000008, "Wrong alignment on UEndEnvQueryTest_AIPCCombatArea");
static_assert(sizeof(UEndEnvQueryTest_AIPCCombatArea) == 0x0001C0, "Wrong size on UEndEnvQueryTest_AIPCCombatArea");

// Class EndGame.EndAnimNotifyBikeIntervalRepair
// 0x0000 (0x0038 - 0x0038)
class UEndAnimNotifyBikeIntervalRepair final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBikeIntervalRepair">();
	}
	static class UEndAnimNotifyBikeIntervalRepair* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBikeIntervalRepair>();
	}
};
static_assert(alignof(UEndAnimNotifyBikeIntervalRepair) == 0x000008, "Wrong alignment on UEndAnimNotifyBikeIntervalRepair");
static_assert(sizeof(UEndAnimNotifyBikeIntervalRepair) == 0x000038, "Wrong size on UEndAnimNotifyBikeIntervalRepair");

// Class EndGame.EndBattleAIBindActionNotify
// 0x0008 (0x0040 - 0x0038)
class UEndBattleAIBindActionNotify final : public UAnimNotify
{
public:
	int32                                         ID;                                                // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIBindActionNotify">();
	}
	static class UEndBattleAIBindActionNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleAIBindActionNotify>();
	}
};
static_assert(alignof(UEndBattleAIBindActionNotify) == 0x000008, "Wrong alignment on UEndBattleAIBindActionNotify");
static_assert(sizeof(UEndBattleAIBindActionNotify) == 0x000040, "Wrong size on UEndBattleAIBindActionNotify");
static_assert(offsetof(UEndBattleAIBindActionNotify, ID) == 0x000038, "Member 'UEndBattleAIBindActionNotify::ID' has a wrong offset!");

// Class EndGame.EndAnimNotifyBikeKeepSidePosition
// 0x0000 (0x0030 - 0x0030)
class UEndAnimNotifyBikeKeepSidePosition final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBikeKeepSidePosition">();
	}
	static class UEndAnimNotifyBikeKeepSidePosition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBikeKeepSidePosition>();
	}
};
static_assert(alignof(UEndAnimNotifyBikeKeepSidePosition) == 0x000008, "Wrong alignment on UEndAnimNotifyBikeKeepSidePosition");
static_assert(sizeof(UEndAnimNotifyBikeKeepSidePosition) == 0x000030, "Wrong size on UEndAnimNotifyBikeKeepSidePosition");

// Class EndGame.EndAnimNotifyBikeSlowDown
// 0x0000 (0x0030 - 0x0030)
class UEndAnimNotifyBikeSlowDown final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBikeSlowDown">();
	}
	static class UEndAnimNotifyBikeSlowDown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBikeSlowDown>();
	}
};
static_assert(alignof(UEndAnimNotifyBikeSlowDown) == 0x000008, "Wrong alignment on UEndAnimNotifyBikeSlowDown");
static_assert(sizeof(UEndAnimNotifyBikeSlowDown) == 0x000030, "Wrong size on UEndAnimNotifyBikeSlowDown");

// Class EndGame.EndDataObjectCutSceneList
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectCutSceneList final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectCutSceneList">();
	}
	static class UEndDataObjectCutSceneList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectCutSceneList>();
	}
};
static_assert(alignof(UEndDataObjectCutSceneList) == 0x000008, "Wrong alignment on UEndDataObjectCutSceneList");
static_assert(sizeof(UEndDataObjectCutSceneList) == 0x000088, "Wrong size on UEndDataObjectCutSceneList");

// Class EndGame.EndBattleAIEB0002ArmController
// 0x0268 (0x24F0 - 0x2288)
class AEndBattleAIEB0002ArmController final : public AEndBattleAIController
{
public:
	float                                         ArmHeightIdle;                                     // 0x2288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmHeightAroundIdle;                               // 0x228C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmHeightSideAttack1;                              // 0x2290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmHeightSideAttack2;                              // 0x2294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmHeightTargetAroundIdle;                         // 0x2298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmRotateSpeedIdle;                                // 0x229C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmDistanceIdle;                                   // 0x22A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmDistanceAroundIdle;                             // 0x22A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmDistanceSideAttack1;                            // 0x22A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmDistanceSideAttack2;                            // 0x22AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmDistanceTargetAroundIdle;                       // 0x22B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmHeightCatch;                                    // 0x22B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmDistanceCatch;                                  // 0x22B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ArmThrowLocation;                                  // 0x22BC(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmThrowHeight;                                    // 0x22C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmThrowAngle;                                     // 0x22CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmThrowRollAngle;                                 // 0x22D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmThrowRollSpeed;                                 // 0x22D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ArmPointLocation;                                  // 0x22D8(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmPointAngle;                                     // 0x22E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmPointHeight;                                    // 0x22E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmPointDistance;                                  // 0x22EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmRotateSpec;                                     // 0x22F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoArmPhase;                                     // 0x22F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22F5[0x1FB];                                   // 0x22F5(0x01FB)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EArmPhase GetArmPhase();
	bool IsLeftArm();
	void OnDetachArm(bool enableAI);
	void OnDockingFinished();
	void OnDockingStart(float MoveSpeed, float LifeTime, float targetRadius);
	void OnDockingStartLinear(float arrivalTime);
	void OnEjectFinished();
	void OnEjectStart(float MoveSpeed, float LifeTime, float targetRadius);
	void OnLeftArmDockingCompleted();
	void OnLeftArmEjectCompleted();
	void OnLeftArmRocketPunchCompleted();
	void OnRightArmDockingCompleted();
	void OnRightArmEjectCompleted();
	void OnRightArmRocketPunchCompleted();
	void OnRocketPunchFinished();
	void OnRocketPunchStart();
	void SetArmPhase(EArmPhase InPhase);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEB0002ArmController">();
	}
	static class AEndBattleAIEB0002ArmController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEB0002ArmController>();
	}
};
static_assert(alignof(AEndBattleAIEB0002ArmController) == 0x000008, "Wrong alignment on AEndBattleAIEB0002ArmController");
static_assert(sizeof(AEndBattleAIEB0002ArmController) == 0x0024F0, "Wrong size on AEndBattleAIEB0002ArmController");
static_assert(offsetof(AEndBattleAIEB0002ArmController, ArmHeightIdle) == 0x002288, "Member 'AEndBattleAIEB0002ArmController::ArmHeightIdle' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0002ArmController, ArmHeightAroundIdle) == 0x00228C, "Member 'AEndBattleAIEB0002ArmController::ArmHeightAroundIdle' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0002ArmController, ArmHeightSideAttack1) == 0x002290, "Member 'AEndBattleAIEB0002ArmController::ArmHeightSideAttack1' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0002ArmController, ArmHeightSideAttack2) == 0x002294, "Member 'AEndBattleAIEB0002ArmController::ArmHeightSideAttack2' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0002ArmController, ArmHeightTargetAroundIdle) == 0x002298, "Member 'AEndBattleAIEB0002ArmController::ArmHeightTargetAroundIdle' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0002ArmController, ArmRotateSpeedIdle) == 0x00229C, "Member 'AEndBattleAIEB0002ArmController::ArmRotateSpeedIdle' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0002ArmController, ArmDistanceIdle) == 0x0022A0, "Member 'AEndBattleAIEB0002ArmController::ArmDistanceIdle' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0002ArmController, ArmDistanceAroundIdle) == 0x0022A4, "Member 'AEndBattleAIEB0002ArmController::ArmDistanceAroundIdle' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0002ArmController, ArmDistanceSideAttack1) == 0x0022A8, "Member 'AEndBattleAIEB0002ArmController::ArmDistanceSideAttack1' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0002ArmController, ArmDistanceSideAttack2) == 0x0022AC, "Member 'AEndBattleAIEB0002ArmController::ArmDistanceSideAttack2' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0002ArmController, ArmDistanceTargetAroundIdle) == 0x0022B0, "Member 'AEndBattleAIEB0002ArmController::ArmDistanceTargetAroundIdle' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0002ArmController, ArmHeightCatch) == 0x0022B4, "Member 'AEndBattleAIEB0002ArmController::ArmHeightCatch' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0002ArmController, ArmDistanceCatch) == 0x0022B8, "Member 'AEndBattleAIEB0002ArmController::ArmDistanceCatch' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0002ArmController, ArmThrowLocation) == 0x0022BC, "Member 'AEndBattleAIEB0002ArmController::ArmThrowLocation' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0002ArmController, ArmThrowHeight) == 0x0022C8, "Member 'AEndBattleAIEB0002ArmController::ArmThrowHeight' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0002ArmController, ArmThrowAngle) == 0x0022CC, "Member 'AEndBattleAIEB0002ArmController::ArmThrowAngle' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0002ArmController, ArmThrowRollAngle) == 0x0022D0, "Member 'AEndBattleAIEB0002ArmController::ArmThrowRollAngle' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0002ArmController, ArmThrowRollSpeed) == 0x0022D4, "Member 'AEndBattleAIEB0002ArmController::ArmThrowRollSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0002ArmController, ArmPointLocation) == 0x0022D8, "Member 'AEndBattleAIEB0002ArmController::ArmPointLocation' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0002ArmController, ArmPointAngle) == 0x0022E4, "Member 'AEndBattleAIEB0002ArmController::ArmPointAngle' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0002ArmController, ArmPointHeight) == 0x0022E8, "Member 'AEndBattleAIEB0002ArmController::ArmPointHeight' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0002ArmController, ArmPointDistance) == 0x0022EC, "Member 'AEndBattleAIEB0002ArmController::ArmPointDistance' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0002ArmController, ArmRotateSpec) == 0x0022F0, "Member 'AEndBattleAIEB0002ArmController::ArmRotateSpec' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0002ArmController, bAutoArmPhase) == 0x0022F4, "Member 'AEndBattleAIEB0002ArmController::bAutoArmPhase' has a wrong offset!");

// Class EndGame.EndNaviMapStateBox
// 0x0010 (0x0388 - 0x0378)
class AEndNaviMapStateBox final : public AActor
{
public:
	EEndNaviMapLayer                              LayerNumber;                                       // 0x0378(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndNaviMapOpenGroup                          OpenGroupNumber;                                   // 0x037C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndNaviMapVisitGroup                         VisitGroupNumber;                                  // 0x0380(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndSceneNaviMapState                         TargetState;                                       // 0x0384(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNaviMapStateBox">();
	}
	static class AEndNaviMapStateBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndNaviMapStateBox>();
	}
};
static_assert(alignof(AEndNaviMapStateBox) == 0x000008, "Wrong alignment on AEndNaviMapStateBox");
static_assert(sizeof(AEndNaviMapStateBox) == 0x000388, "Wrong size on AEndNaviMapStateBox");
static_assert(offsetof(AEndNaviMapStateBox, LayerNumber) == 0x000378, "Member 'AEndNaviMapStateBox::LayerNumber' has a wrong offset!");
static_assert(offsetof(AEndNaviMapStateBox, OpenGroupNumber) == 0x00037C, "Member 'AEndNaviMapStateBox::OpenGroupNumber' has a wrong offset!");
static_assert(offsetof(AEndNaviMapStateBox, VisitGroupNumber) == 0x000380, "Member 'AEndNaviMapStateBox::VisitGroupNumber' has a wrong offset!");
static_assert(offsetof(AEndNaviMapStateBox, TargetState) == 0x000384, "Member 'AEndNaviMapStateBox::TargetState' has a wrong offset!");

// Class EndGame.EndAnimNotifyBikeWeaponVisibility
// 0x0008 (0x0040 - 0x0038)
class UEndAnimNotifyBikeWeaponVisibility final : public UAnimNotify
{
public:
	EWeaponSlot                                   Slot;                                              // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisible;                                          // 0x0039(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideAll;                                          // 0x003A(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyBikeWeaponVisibility">();
	}
	static class UEndAnimNotifyBikeWeaponVisibility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyBikeWeaponVisibility>();
	}
};
static_assert(alignof(UEndAnimNotifyBikeWeaponVisibility) == 0x000008, "Wrong alignment on UEndAnimNotifyBikeWeaponVisibility");
static_assert(sizeof(UEndAnimNotifyBikeWeaponVisibility) == 0x000040, "Wrong size on UEndAnimNotifyBikeWeaponVisibility");
static_assert(offsetof(UEndAnimNotifyBikeWeaponVisibility, Slot) == 0x000038, "Member 'UEndAnimNotifyBikeWeaponVisibility::Slot' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBikeWeaponVisibility, bVisible) == 0x000039, "Member 'UEndAnimNotifyBikeWeaponVisibility::bVisible' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyBikeWeaponVisibility, bHideAll) == 0x00003A, "Member 'UEndAnimNotifyBikeWeaponVisibility::bHideAll' has a wrong offset!");

// Class EndGame.EndAnimNotifyCondorPopSubCharacter
// 0x0028 (0x0060 - 0x0038)
class UEndAnimNotifyCondorPopSubCharacter final : public UAnimNotify
{
public:
	class FName                                   LocationSocket;                                    // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0040(0x000C)(Edit, BlueprintReadOnly, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LocationSocket_Secondary;                          // 0x004C(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset_Secondary;                          // 0x0054(0x000C)(Edit, BlueprintReadOnly, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyCondorPopSubCharacter">();
	}
	static class UEndAnimNotifyCondorPopSubCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyCondorPopSubCharacter>();
	}
};
static_assert(alignof(UEndAnimNotifyCondorPopSubCharacter) == 0x000008, "Wrong alignment on UEndAnimNotifyCondorPopSubCharacter");
static_assert(sizeof(UEndAnimNotifyCondorPopSubCharacter) == 0x000060, "Wrong size on UEndAnimNotifyCondorPopSubCharacter");
static_assert(offsetof(UEndAnimNotifyCondorPopSubCharacter, LocationSocket) == 0x000038, "Member 'UEndAnimNotifyCondorPopSubCharacter::LocationSocket' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyCondorPopSubCharacter, LocationOffset) == 0x000040, "Member 'UEndAnimNotifyCondorPopSubCharacter::LocationOffset' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyCondorPopSubCharacter, LocationSocket_Secondary) == 0x00004C, "Member 'UEndAnimNotifyCondorPopSubCharacter::LocationSocket_Secondary' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyCondorPopSubCharacter, LocationOffset_Secondary) == 0x000054, "Member 'UEndAnimNotifyCondorPopSubCharacter::LocationOffset_Secondary' has a wrong offset!");

// Class EndGame.EndMainSaveLoadTopMenu
// 0x00A0 (0x04D0 - 0x0430)
class UEndMainSaveLoadTopMenu : public UEndMainMenuWindow
{
public:
	TSubclassOf<class UEndUserWidget>             SaveLoadMenuWidgetClass;                           // 0x0430(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_438[0x88];                                     // 0x0438(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndUserWidget*                         Throbber;                                          // 0x04C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C8[0x8];                                      // 0x04C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLeftMenuPressedItem(int32 ItemIndex);
	void OnLeftMenuSetupItem(class UWidget* ItemWidget, int32 ItemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainSaveLoadTopMenu">();
	}
	static class UEndMainSaveLoadTopMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainSaveLoadTopMenu>();
	}
};
static_assert(alignof(UEndMainSaveLoadTopMenu) == 0x000008, "Wrong alignment on UEndMainSaveLoadTopMenu");
static_assert(sizeof(UEndMainSaveLoadTopMenu) == 0x0004D0, "Wrong size on UEndMainSaveLoadTopMenu");
static_assert(offsetof(UEndMainSaveLoadTopMenu, SaveLoadMenuWidgetClass) == 0x000430, "Member 'UEndMainSaveLoadTopMenu::SaveLoadMenuWidgetClass' has a wrong offset!");
static_assert(offsetof(UEndMainSaveLoadTopMenu, Throbber) == 0x0004C0, "Member 'UEndMainSaveLoadTopMenu::Throbber' has a wrong offset!");

// Class EndGame.EndBattleAIEB0012Controller
// 0x00D8 (0x2360 - 0x2288)
class AEndBattleAIEB0012Controller final : public AEndBattleAIController
{
public:
	TMap<class FName, int32>                      BehaviorNameList;                                  // 0x2288(0x0050)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            BehaviorReteList;                                  // 0x22D8(0x0050)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2328[0x38];                                    // 0x2328(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEasySpawnEvent(class FName EventName);
	bool RequestDestroyLeftArmActor();
	bool RequestKillLeftArm(bool forceDestroy);
	bool RequestRepairLeftArm(class FName charaPartsSpecName, class FName meshLabelName);
	bool RequestReplaceLeftArm(class FName SocketName);
	bool RequestSpawnLeftArm(class FName CharaSpecName, bool spawnedInvisible, bool spawnedDisableCollision, EEndBattleEasySpawnEnableRagdollType enableRagdollType, float deadEventDelayTime, const struct FVector& hidePosition, bool recycle);
	void UpdateBehaviorRateFunc(class FName Name_0, int32 addRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEB0012Controller">();
	}
	static class AEndBattleAIEB0012Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEB0012Controller>();
	}
};
static_assert(alignof(AEndBattleAIEB0012Controller) == 0x000008, "Wrong alignment on AEndBattleAIEB0012Controller");
static_assert(sizeof(AEndBattleAIEB0012Controller) == 0x002360, "Wrong size on AEndBattleAIEB0012Controller");
static_assert(offsetof(AEndBattleAIEB0012Controller, BehaviorNameList) == 0x002288, "Member 'AEndBattleAIEB0012Controller::BehaviorNameList' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0012Controller, BehaviorReteList) == 0x0022D8, "Member 'AEndBattleAIEB0012Controller::BehaviorReteList' has a wrong offset!");

// Class EndGame.EndAnimNotifyDeactiveResidentEffect
// 0x0008 (0x0038 - 0x0030)
class UEndAnimNotifyDeactiveResidentEffect final : public UAnimNotifyState
{
public:
	EEndDeactiveResidentEffectType                DeactiveType;                                      // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyDeactiveResidentEffect">();
	}
	static class UEndAnimNotifyDeactiveResidentEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyDeactiveResidentEffect>();
	}
};
static_assert(alignof(UEndAnimNotifyDeactiveResidentEffect) == 0x000008, "Wrong alignment on UEndAnimNotifyDeactiveResidentEffect");
static_assert(sizeof(UEndAnimNotifyDeactiveResidentEffect) == 0x000038, "Wrong size on UEndAnimNotifyDeactiveResidentEffect");
static_assert(offsetof(UEndAnimNotifyDeactiveResidentEffect, DeactiveType) == 0x000030, "Member 'UEndAnimNotifyDeactiveResidentEffect::DeactiveType' has a wrong offset!");

// Class EndGame.EndAnimNotifyEffectCharaProperty
// 0x0060 (0x0098 - 0x0038)
class UEndAnimNotifyEffectCharaProperty final : public UAnimNotify
{
public:
	class FString                                 ID;                                                // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EEndAnimNotifyEffectCharaPropertyReplaceType> ReplaceTypes;                                      // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EEndAnimNotifyEffectCharaPropertyAttachType   AttachType;                                        // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachSocketName;                                  // 0x005C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0064(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0070(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Attached : 1;                                      // 0x007C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEndPlayParticleActorInfo              m_CasterActorInfo;                                 // 0x0080(0x000C)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndPlayParticleActorInfo              m_TargetActorInfo;                                 // 0x008C(0x000C)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyEffectCharaProperty">();
	}
	static class UEndAnimNotifyEffectCharaProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyEffectCharaProperty>();
	}
};
static_assert(alignof(UEndAnimNotifyEffectCharaProperty) == 0x000008, "Wrong alignment on UEndAnimNotifyEffectCharaProperty");
static_assert(sizeof(UEndAnimNotifyEffectCharaProperty) == 0x000098, "Wrong size on UEndAnimNotifyEffectCharaProperty");
static_assert(offsetof(UEndAnimNotifyEffectCharaProperty, ID) == 0x000038, "Member 'UEndAnimNotifyEffectCharaProperty::ID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyEffectCharaProperty, ReplaceTypes) == 0x000048, "Member 'UEndAnimNotifyEffectCharaProperty::ReplaceTypes' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyEffectCharaProperty, AttachType) == 0x000058, "Member 'UEndAnimNotifyEffectCharaProperty::AttachType' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyEffectCharaProperty, AttachSocketName) == 0x00005C, "Member 'UEndAnimNotifyEffectCharaProperty::AttachSocketName' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyEffectCharaProperty, LocationOffset) == 0x000064, "Member 'UEndAnimNotifyEffectCharaProperty::LocationOffset' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyEffectCharaProperty, RotationOffset) == 0x000070, "Member 'UEndAnimNotifyEffectCharaProperty::RotationOffset' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyEffectCharaProperty, m_CasterActorInfo) == 0x000080, "Member 'UEndAnimNotifyEffectCharaProperty::m_CasterActorInfo' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyEffectCharaProperty, m_TargetActorInfo) == 0x00008C, "Member 'UEndAnimNotifyEffectCharaProperty::m_TargetActorInfo' has a wrong offset!");

// Class EndGame.EndDataObjectDebugPartyList
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectDebugPartyList final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectDebugPartyList">();
	}
	static class UEndDataObjectDebugPartyList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectDebugPartyList>();
	}
};
static_assert(alignof(UEndDataObjectDebugPartyList) == 0x000008, "Wrong alignment on UEndDataObjectDebugPartyList");
static_assert(sizeof(UEndDataObjectDebugPartyList) == 0x000088, "Wrong size on UEndDataObjectDebugPartyList");

// Class EndGame.EndFieldTargetIcon
// 0x0010 (0x0370 - 0x0360)
class UEndFieldTargetIcon : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x10];                                     // 0x0360(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldTargetIcon">();
	}
	static class UEndFieldTargetIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndFieldTargetIcon>();
	}
};
static_assert(alignof(UEndFieldTargetIcon) == 0x000008, "Wrong alignment on UEndFieldTargetIcon");
static_assert(sizeof(UEndFieldTargetIcon) == 0x000370, "Wrong size on UEndFieldTargetIcon");

// Class EndGame.EndBattleAIEB0005Controller
// 0x0068 (0x22F0 - 0x2288)
class AEndBattleAIEB0005Controller final : public AEndBattleAIController
{
public:
	float                                         FastMoveSpeed;                                     // 0x2288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FastMoveRange;                                     // 0x228C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FastBeginToLoopBlendTime;                          // 0x2290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FastLoopToEndBlendTime;                            // 0x2294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FastNextBlendTime;                                 // 0x2298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_229C[0x54];                                    // 0x229C(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlowSunglass(class AEndCharacter* damageCauserChara);
	void ChangeRideMode(ERideMode rideMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEB0005Controller">();
	}
	static class AEndBattleAIEB0005Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEB0005Controller>();
	}
};
static_assert(alignof(AEndBattleAIEB0005Controller) == 0x000008, "Wrong alignment on AEndBattleAIEB0005Controller");
static_assert(sizeof(AEndBattleAIEB0005Controller) == 0x0022F0, "Wrong size on AEndBattleAIEB0005Controller");
static_assert(offsetof(AEndBattleAIEB0005Controller, FastMoveSpeed) == 0x002288, "Member 'AEndBattleAIEB0005Controller::FastMoveSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0005Controller, FastMoveRange) == 0x00228C, "Member 'AEndBattleAIEB0005Controller::FastMoveRange' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0005Controller, FastBeginToLoopBlendTime) == 0x002290, "Member 'AEndBattleAIEB0005Controller::FastBeginToLoopBlendTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0005Controller, FastLoopToEndBlendTime) == 0x002294, "Member 'AEndBattleAIEB0005Controller::FastLoopToEndBlendTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0005Controller, FastNextBlendTime) == 0x002298, "Member 'AEndBattleAIEB0005Controller::FastNextBlendTime' has a wrong offset!");

// Class EndGame.EndAnimNotifyEnablePushSubCollision
// 0x0000 (0x0030 - 0x0030)
class UEndAnimNotifyEnablePushSubCollision final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyEnablePushSubCollision">();
	}
	static class UEndAnimNotifyEnablePushSubCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyEnablePushSubCollision>();
	}
};
static_assert(alignof(UEndAnimNotifyEnablePushSubCollision) == 0x000008, "Wrong alignment on UEndAnimNotifyEnablePushSubCollision");
static_assert(sizeof(UEndAnimNotifyEnablePushSubCollision) == 0x000030, "Wrong size on UEndAnimNotifyEnablePushSubCollision");

// Class EndGame.EndAnimNotifyEquipmentDrawPause
// 0x0008 (0x0040 - 0x0038)
class UEndAnimNotifyEquipmentDrawPause final : public UAnimNotify
{
public:
	EWeaponSlot                                   Slot;                                              // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPauseMask                                    Mask;                                              // 0x0039(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Pause;                                             // 0x003A(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyEquipmentDrawPause">();
	}
	static class UEndAnimNotifyEquipmentDrawPause* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyEquipmentDrawPause>();
	}
};
static_assert(alignof(UEndAnimNotifyEquipmentDrawPause) == 0x000008, "Wrong alignment on UEndAnimNotifyEquipmentDrawPause");
static_assert(sizeof(UEndAnimNotifyEquipmentDrawPause) == 0x000040, "Wrong size on UEndAnimNotifyEquipmentDrawPause");
static_assert(offsetof(UEndAnimNotifyEquipmentDrawPause, Slot) == 0x000038, "Member 'UEndAnimNotifyEquipmentDrawPause::Slot' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyEquipmentDrawPause, Mask) == 0x000039, "Member 'UEndAnimNotifyEquipmentDrawPause::Mask' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyEquipmentDrawPause, Pause) == 0x00003A, "Member 'UEndAnimNotifyEquipmentDrawPause::Pause' has a wrong offset!");

// Class EndGame.RangeSwitch4
// 0x0078 (0x00A0 - 0x0028)
class URangeSwitch4 final : public UOnlineBlueprintCallProxyBase
{
public:
	UMulticastDelegateProperty_                   Case1;                                             // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Case2;                                             // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Case3;                                             // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Case4;                                             // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Other;                                             // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x28];                                      // 0x0078(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class URangeSwitch4* RangeSwitch4(float Value, float Min1, float Max1, float Min2, float Max2, float Min3, float Max3, float Min4, float Max4, bool ContainEqual, bool FirstOnly);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RangeSwitch4">();
	}
	static class URangeSwitch4* GetDefaultObj()
	{
		return GetDefaultObjImpl<URangeSwitch4>();
	}
};
static_assert(alignof(URangeSwitch4) == 0x000008, "Wrong alignment on URangeSwitch4");
static_assert(sizeof(URangeSwitch4) == 0x0000A0, "Wrong size on URangeSwitch4");
static_assert(offsetof(URangeSwitch4, Case1) == 0x000028, "Member 'URangeSwitch4::Case1' has a wrong offset!");
static_assert(offsetof(URangeSwitch4, Case2) == 0x000038, "Member 'URangeSwitch4::Case2' has a wrong offset!");
static_assert(offsetof(URangeSwitch4, Case3) == 0x000048, "Member 'URangeSwitch4::Case3' has a wrong offset!");
static_assert(offsetof(URangeSwitch4, Case4) == 0x000058, "Member 'URangeSwitch4::Case4' has a wrong offset!");
static_assert(offsetof(URangeSwitch4, Other) == 0x000068, "Member 'URangeSwitch4::Other' has a wrong offset!");

// Class EndGame.EndNaviMapPrototypeDataV2
// 0x0050 (0x0078 - 0x0028)
class UEndNaviMapPrototypeDataV2 final : public UObject
{
public:
	TMap<class FName, struct FEndNaviMapLocationPrototypeDataV2> Locations;                                         // 0x0028(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNaviMapPrototypeDataV2">();
	}
	static class UEndNaviMapPrototypeDataV2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNaviMapPrototypeDataV2>();
	}
};
static_assert(alignof(UEndNaviMapPrototypeDataV2) == 0x000008, "Wrong alignment on UEndNaviMapPrototypeDataV2");
static_assert(sizeof(UEndNaviMapPrototypeDataV2) == 0x000078, "Wrong size on UEndNaviMapPrototypeDataV2");
static_assert(offsetof(UEndNaviMapPrototypeDataV2, Locations) == 0x000028, "Member 'UEndNaviMapPrototypeDataV2::Locations' has a wrong offset!");

// Class EndGame.EndAnimNotifyMiniGameDartsArrowThrow
// 0x0000 (0x0038 - 0x0038)
class UEndAnimNotifyMiniGameDartsArrowThrow final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyMiniGameDartsArrowThrow">();
	}
	static class UEndAnimNotifyMiniGameDartsArrowThrow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyMiniGameDartsArrowThrow>();
	}
};
static_assert(alignof(UEndAnimNotifyMiniGameDartsArrowThrow) == 0x000008, "Wrong alignment on UEndAnimNotifyMiniGameDartsArrowThrow");
static_assert(sizeof(UEndAnimNotifyMiniGameDartsArrowThrow) == 0x000038, "Wrong size on UEndAnimNotifyMiniGameDartsArrowThrow");

// Class EndGame.EndAnimNotifyModifyMovementMode
// 0x0008 (0x0038 - 0x0030)
class UEndAnimNotifyModifyMovementMode final : public UAnimNotifyState
{
public:
	bool                                          bMovable;                                          // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitWall;                                          // 0x0031(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitObject;                                        // 0x0032(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFitFloor;                                         // 0x0033(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaxWeight;                                        // 0x0034(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceUpdateLanding;                               // 0x0035(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyModifyMovementMode">();
	}
	static class UEndAnimNotifyModifyMovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyModifyMovementMode>();
	}
};
static_assert(alignof(UEndAnimNotifyModifyMovementMode) == 0x000008, "Wrong alignment on UEndAnimNotifyModifyMovementMode");
static_assert(sizeof(UEndAnimNotifyModifyMovementMode) == 0x000038, "Wrong size on UEndAnimNotifyModifyMovementMode");
static_assert(offsetof(UEndAnimNotifyModifyMovementMode, bMovable) == 0x000030, "Member 'UEndAnimNotifyModifyMovementMode::bMovable' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyModifyMovementMode, bHitWall) == 0x000031, "Member 'UEndAnimNotifyModifyMovementMode::bHitWall' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyModifyMovementMode, bHitObject) == 0x000032, "Member 'UEndAnimNotifyModifyMovementMode::bHitObject' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyModifyMovementMode, bFitFloor) == 0x000033, "Member 'UEndAnimNotifyModifyMovementMode::bFitFloor' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyModifyMovementMode, bMaxWeight) == 0x000034, "Member 'UEndAnimNotifyModifyMovementMode::bMaxWeight' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyModifyMovementMode, bForceUpdateLanding) == 0x000035, "Member 'UEndAnimNotifyModifyMovementMode::bForceUpdateLanding' has a wrong offset!");

// Class EndGame.EndDataObjectEnemyAP
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectEnemyAP final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectEnemyAP">();
	}
	static class UEndDataObjectEnemyAP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectEnemyAP>();
	}
};
static_assert(alignof(UEndDataObjectEnemyAP) == 0x000008, "Wrong alignment on UEndDataObjectEnemyAP");
static_assert(sizeof(UEndDataObjectEnemyAP) == 0x000088, "Wrong size on UEndDataObjectEnemyAP");

// Class EndGame.EndBattleAIEB0010Controller
// 0x0018 (0x22A0 - 0x2288)
class AEndBattleAIEB0010Controller final : public AEndBattleAIController
{
public:
	uint8                                         Pad_2288[0x18];                                    // 0x2288(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEventEasySpawn(class FName keyword, class FName EventName);
	void ReleaseBattleFieldByDGBoss();
	bool RequestBreakTentacle(class FName keyword);
	bool RequestSpawnTentacle(class FName keyword, class FName CharaSpecName, class FName SocketName, bool spawnedInvisible, EEndBattleEasySpawnEnableRagdollType enableRagdollType, float deadEventDelayTime, const struct FVector& hidePosition);
	void RestrictBattleFieldByDGBoss(class FName ExclusionID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEB0010Controller">();
	}
	static class AEndBattleAIEB0010Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEB0010Controller>();
	}
};
static_assert(alignof(AEndBattleAIEB0010Controller) == 0x000008, "Wrong alignment on AEndBattleAIEB0010Controller");
static_assert(sizeof(AEndBattleAIEB0010Controller) == 0x0022A0, "Wrong size on AEndBattleAIEB0010Controller");

// Class EndGame.EndAnimNotifyPlayCharacterFootSound
// 0x0058 (0x0090 - 0x0038)
class UEndAnimNotifyPlayCharacterFootSound final : public UAnimNotify
{
public:
	ESQEXSEADAutoSeMotionSoundType                AutoSeMotionType;                                  // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDirectAssign : 1;                                 // 0x003C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSQEXSEADSoundKey                      DirectAssignedSoundEntry;                          // 0x0040(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   AttachPointName;                                   // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwitchValue;                                       // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZeroOneSlotIndex;                                  // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZeroOneValue;                                      // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPlayOnlyCharecterLanded : 1;                      // 0x008C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSyncOwnerHiddenState : 1;                         // 0x008C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyPlayCharacterFootSound">();
	}
	static class UEndAnimNotifyPlayCharacterFootSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyPlayCharacterFootSound>();
	}
};
static_assert(alignof(UEndAnimNotifyPlayCharacterFootSound) == 0x000008, "Wrong alignment on UEndAnimNotifyPlayCharacterFootSound");
static_assert(sizeof(UEndAnimNotifyPlayCharacterFootSound) == 0x000090, "Wrong size on UEndAnimNotifyPlayCharacterFootSound");
static_assert(offsetof(UEndAnimNotifyPlayCharacterFootSound, AutoSeMotionType) == 0x000038, "Member 'UEndAnimNotifyPlayCharacterFootSound::AutoSeMotionType' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyPlayCharacterFootSound, DirectAssignedSoundEntry) == 0x000040, "Member 'UEndAnimNotifyPlayCharacterFootSound::DirectAssignedSoundEntry' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyPlayCharacterFootSound, AttachPointName) == 0x000078, "Member 'UEndAnimNotifyPlayCharacterFootSound::AttachPointName' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyPlayCharacterFootSound, SwitchValue) == 0x000080, "Member 'UEndAnimNotifyPlayCharacterFootSound::SwitchValue' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyPlayCharacterFootSound, ZeroOneSlotIndex) == 0x000084, "Member 'UEndAnimNotifyPlayCharacterFootSound::ZeroOneSlotIndex' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyPlayCharacterFootSound, ZeroOneValue) == 0x000088, "Member 'UEndAnimNotifyPlayCharacterFootSound::ZeroOneValue' has a wrong offset!");

// Class EndGame.EndAnimNotifyPlaySound
// 0x0058 (0x0090 - 0x0038)
class UEndAnimNotifyPlaySound : public UAnimNotify
{
public:
	TSoftObjectPtr<class USoundBase>              SoundRef;                                          // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SoundName;                                         // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bFollow : 1;                                       // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachPointName;                                   // 0x0074(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAttenuation*                      Attenuation;                                       // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSyncOwnerHiddenState : 1;                         // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bVibrationUCPCOnly : 1;                            // 0x0088(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyPlaySound">();
	}
	static class UEndAnimNotifyPlaySound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyPlaySound>();
	}
};
static_assert(alignof(UEndAnimNotifyPlaySound) == 0x000008, "Wrong alignment on UEndAnimNotifyPlaySound");
static_assert(sizeof(UEndAnimNotifyPlaySound) == 0x000090, "Wrong size on UEndAnimNotifyPlaySound");
static_assert(offsetof(UEndAnimNotifyPlaySound, SoundRef) == 0x000038, "Member 'UEndAnimNotifyPlaySound::SoundRef' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyPlaySound, SoundName) == 0x000060, "Member 'UEndAnimNotifyPlaySound::SoundName' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyPlaySound, VolumeMultiplier) == 0x000068, "Member 'UEndAnimNotifyPlaySound::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyPlaySound, PitchMultiplier) == 0x00006C, "Member 'UEndAnimNotifyPlaySound::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyPlaySound, AttachPointName) == 0x000074, "Member 'UEndAnimNotifyPlaySound::AttachPointName' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyPlaySound, Attenuation) == 0x000080, "Member 'UEndAnimNotifyPlaySound::Attenuation' has a wrong offset!");

// Class EndGame.EndMako5CardKeyMenu
// 0x0008 (0x0370 - 0x0368)
class UEndMako5CardKeyMenu : public UEndSimpleMenu
{
public:
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMako5CardKeyMenu">();
	}
	static class UEndMako5CardKeyMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMako5CardKeyMenu>();
	}
};
static_assert(alignof(UEndMako5CardKeyMenu) == 0x000008, "Wrong alignment on UEndMako5CardKeyMenu");
static_assert(sizeof(UEndMako5CardKeyMenu) == 0x000370, "Wrong size on UEndMako5CardKeyMenu");

// Class EndGame.EndBattleAIEB0026Controller
// 0x0018 (0x22A0 - 0x2288)
class AEndBattleAIEB0026Controller final : public AEndBattleAIController
{
public:
	uint8                                         Pad_2288[0x18];                                    // 0x2288(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEasySpawnEvent(class FName EventName);
	void OnEventEasySpawn(class FName keyword, class FName EventName);
	bool RequestBreakTentacle(class FName keyword);
	bool RequestKillTip(bool forceDestroy);
	bool RequestReplaceTip(class FName SocketName);
	bool RequestSpawnTentacle(class FName keyword, class FName CharaSpecName, class FName SocketName, bool spawnedInvisible, EEndBattleEasySpawnEnableRagdollType enableRagdollType, float deadEventDelayTime, const struct FVector& hidePosition);
	bool RequestSpawnTip(class FName CharaSpecName, bool spawnedInvisible, bool spawnedDisableCollision, EEndBattleEasySpawnEnableRagdollType enableRagdollType, float destroyTimer, const struct FVector& hidePosition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEB0026Controller">();
	}
	static class AEndBattleAIEB0026Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEB0026Controller>();
	}
};
static_assert(alignof(AEndBattleAIEB0026Controller) == 0x000008, "Wrong alignment on AEndBattleAIEB0026Controller");
static_assert(sizeof(AEndBattleAIEB0026Controller) == 0x0022A0, "Wrong size on AEndBattleAIEB0026Controller");

// Class EndGame.EndAnimNotifyPlayCharacterSound
// 0x0010 (0x00A0 - 0x0090)
class UEndAnimNotifyPlayCharacterSound final : public UEndAnimNotifyPlaySound
{
public:
	bool                                          bAutoSE;                                           // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDedicatedAction;                                  // 0x0091(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             DedicatedActionSound;                              // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyPlayCharacterSound">();
	}
	static class UEndAnimNotifyPlayCharacterSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyPlayCharacterSound>();
	}
};
static_assert(alignof(UEndAnimNotifyPlayCharacterSound) == 0x000008, "Wrong alignment on UEndAnimNotifyPlayCharacterSound");
static_assert(sizeof(UEndAnimNotifyPlayCharacterSound) == 0x0000A0, "Wrong size on UEndAnimNotifyPlayCharacterSound");
static_assert(offsetof(UEndAnimNotifyPlayCharacterSound, bAutoSE) == 0x000090, "Member 'UEndAnimNotifyPlayCharacterSound::bAutoSE' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyPlayCharacterSound, bDedicatedAction) == 0x000091, "Member 'UEndAnimNotifyPlayCharacterSound::bDedicatedAction' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyPlayCharacterSound, DedicatedActionSound) == 0x000098, "Member 'UEndAnimNotifyPlayCharacterSound::DedicatedActionSound' has a wrong offset!");

// Class EndGame.EndAnimNotifyPlayVoice
// 0x0008 (0x0098 - 0x0090)
class UEndAnimNotifyPlayVoice final : public UEndAnimNotifyPlaySound
{
public:
	bool                                          bForcePlay;                                        // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyPlayVoice">();
	}
	static class UEndAnimNotifyPlayVoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyPlayVoice>();
	}
};
static_assert(alignof(UEndAnimNotifyPlayVoice) == 0x000008, "Wrong alignment on UEndAnimNotifyPlayVoice");
static_assert(sizeof(UEndAnimNotifyPlayVoice) == 0x000098, "Wrong size on UEndAnimNotifyPlayVoice");
static_assert(offsetof(UEndAnimNotifyPlayVoice, bForcePlay) == 0x000090, "Member 'UEndAnimNotifyPlayVoice::bForcePlay' has a wrong offset!");

// Class EndGame.EndDataObjectEnemyBookBattleCharaSpec
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectEnemyBookBattleCharaSpec final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectEnemyBookBattleCharaSpec">();
	}
	static class UEndDataObjectEnemyBookBattleCharaSpec* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectEnemyBookBattleCharaSpec>();
	}
};
static_assert(alignof(UEndDataObjectEnemyBookBattleCharaSpec) == 0x000008, "Wrong alignment on UEndDataObjectEnemyBookBattleCharaSpec");
static_assert(sizeof(UEndDataObjectEnemyBookBattleCharaSpec) == 0x000088, "Wrong size on UEndDataObjectEnemyBookBattleCharaSpec");

// Class EndGame.EndMainMateriaChangeSelectWindow
// 0x0028 (0x0388 - 0x0360)
class UEndMainMateriaChangeSelectWindow final : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x28];                                     // 0x0360(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEndEquipChangeEquipCellSetup(class UWidget* ItemWidget, int32 ItemIndex);
	void OnEndEquipChangeMateriaCellSetup(class UWidget* ItemWidget, int32 ItemIndex);
	void OnEndEquipChangeWeaponCellSetup(class UWidget* ItemWidget, int32 ItemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainMateriaChangeSelectWindow">();
	}
	static class UEndMainMateriaChangeSelectWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainMateriaChangeSelectWindow>();
	}
};
static_assert(alignof(UEndMainMateriaChangeSelectWindow) == 0x000008, "Wrong alignment on UEndMainMateriaChangeSelectWindow");
static_assert(sizeof(UEndMainMateriaChangeSelectWindow) == 0x000388, "Wrong size on UEndMainMateriaChangeSelectWindow");

// Class EndGame.EndBattleAIEB0014Controller
// 0x0028 (0x22B0 - 0x2288)
class AEndBattleAIEB0014Controller final : public AEndBattleAIController
{
public:
	uint8                                         Pad_2288[0x28];                                    // 0x2288(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetLayoutDistanceStatus(class FName InName, float InMax, float InMin);
	void OnCanUseParts(class FName keyword);
	void OnDiedParts(class FName keyword);
	void OnEventEasySpawn(class FName keyword, class FName EventName);
	void OnRotateEnd();
	bool RequestBreakTentacle(class FName keyword);
	void RequestPartsKill(class FName keyword, class FName SocketName);
	int32 RequestPartsSpawn(class FName keyword);
	bool RequestSpawnTentacle(class FName keyword, class FName CharaSpecName, class FName SocketName, bool spawnedInvisible, EEndBattleEasySpawnEnableRagdollType enableRagdollType, float deadEventDelayTime, const struct FVector& hidePosition);
	void RequestUniqueRotate(float Yaw, float dulation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEB0014Controller">();
	}
	static class AEndBattleAIEB0014Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEB0014Controller>();
	}
};
static_assert(alignof(AEndBattleAIEB0014Controller) == 0x000008, "Wrong alignment on AEndBattleAIEB0014Controller");
static_assert(sizeof(AEndBattleAIEB0014Controller) == 0x0022B0, "Wrong size on AEndBattleAIEB0014Controller");

// Class EndGame.EndAnimNotifyPlayWeaponSound
// 0x0008 (0x0098 - 0x0090)
class UEndAnimNotifyPlayWeaponSound final : public UEndAnimNotifyPlaySound
{
public:
	EWeaponSlot                                   WeaponSlot;                                        // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyPlayWeaponSound">();
	}
	static class UEndAnimNotifyPlayWeaponSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyPlayWeaponSound>();
	}
};
static_assert(alignof(UEndAnimNotifyPlayWeaponSound) == 0x000008, "Wrong alignment on UEndAnimNotifyPlayWeaponSound");
static_assert(sizeof(UEndAnimNotifyPlayWeaponSound) == 0x000098, "Wrong size on UEndAnimNotifyPlayWeaponSound");
static_assert(offsetof(UEndAnimNotifyPlayWeaponSound, WeaponSlot) == 0x000090, "Member 'UEndAnimNotifyPlayWeaponSound::WeaponSlot' has a wrong offset!");

// Class EndGame.EndAnimNotifyReserveAfterWalkType
// 0x0008 (0x0040 - 0x0038)
class UEndAnimNotifyReserveAfterWalkType final : public UAnimNotify
{
public:
	EEndAnimWalkType                              AfterWalkType;                                     // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AfterLimitedRunningTimer;                          // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyReserveAfterWalkType">();
	}
	static class UEndAnimNotifyReserveAfterWalkType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyReserveAfterWalkType>();
	}
};
static_assert(alignof(UEndAnimNotifyReserveAfterWalkType) == 0x000008, "Wrong alignment on UEndAnimNotifyReserveAfterWalkType");
static_assert(sizeof(UEndAnimNotifyReserveAfterWalkType) == 0x000040, "Wrong size on UEndAnimNotifyReserveAfterWalkType");
static_assert(offsetof(UEndAnimNotifyReserveAfterWalkType, AfterWalkType) == 0x000038, "Member 'UEndAnimNotifyReserveAfterWalkType::AfterWalkType' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyReserveAfterWalkType, AfterLimitedRunningTimer) == 0x00003C, "Member 'UEndAnimNotifyReserveAfterWalkType::AfterLimitedRunningTimer' has a wrong offset!");

// Class EndGame.EndBattleAIEB0007Controller
// 0x0068 (0x22F0 - 0x2288)
class AEndBattleAIEB0007Controller final : public AEndBattleAIController
{
public:
	uint8                                         Pad_2288[0x4C];                                    // 0x2288(0x004C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          EnableOverrideHeight;                              // 0x22D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22D5[0x3];                                     // 0x22D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideHeight;                                    // 0x22D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableOverridePeakBias;                            // 0x22DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22DD[0x3];                                     // 0x22DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverridePeakBias;                                  // 0x22E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableOverrideTurningDuration;                     // 0x22E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22E5[0x3];                                     // 0x22E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideTurningDuration;                           // 0x22E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableSprinkleWaterDraw;                           // 0x22EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22ED[0x3];                                     // 0x22ED(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetSprinkleWaterInAnglePointNames(const TArray<class FName>& nodeNames, float rangeAngle, float rangeDistance, TArray<class FName>* outNames, class FName* outNearName);
	void GetSprinkleWaterInRangePointNames(const TArray<class FName>& nodeNames, float RangeRadius, float rangeDistance, TArray<class FName>* outNames, class FName* outNearName);
	void GetSprinkleWaterInRangeTargetCharacter(const class FName& NodeName, const TArray<EPlayerType>& playerTypes, float RangeRadius, TArray<class AEndCharacter*>* outCharacters);
	void RequestResetBrokenTail();
	void RequestRunBrokenTail();
	void RequestSpawnBrokenTail(class FName CharaSpecName, const struct FVector& hidePosition, bool spawnedInvisible, class FName SocketName);
	void ToGraviticJump(const struct FVector& landingLocation, float Height, float PeakBias, float turningDuration, const struct FVector& UpVector, const struct FVector& forwardVector, bool bToTerrain);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEB0007Controller">();
	}
	static class AEndBattleAIEB0007Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEB0007Controller>();
	}
};
static_assert(alignof(AEndBattleAIEB0007Controller) == 0x000008, "Wrong alignment on AEndBattleAIEB0007Controller");
static_assert(sizeof(AEndBattleAIEB0007Controller) == 0x0022F0, "Wrong size on AEndBattleAIEB0007Controller");
static_assert(offsetof(AEndBattleAIEB0007Controller, EnableOverrideHeight) == 0x0022D4, "Member 'AEndBattleAIEB0007Controller::EnableOverrideHeight' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0007Controller, OverrideHeight) == 0x0022D8, "Member 'AEndBattleAIEB0007Controller::OverrideHeight' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0007Controller, EnableOverridePeakBias) == 0x0022DC, "Member 'AEndBattleAIEB0007Controller::EnableOverridePeakBias' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0007Controller, OverridePeakBias) == 0x0022E0, "Member 'AEndBattleAIEB0007Controller::OverridePeakBias' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0007Controller, EnableOverrideTurningDuration) == 0x0022E4, "Member 'AEndBattleAIEB0007Controller::EnableOverrideTurningDuration' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0007Controller, OverrideTurningDuration) == 0x0022E8, "Member 'AEndBattleAIEB0007Controller::OverrideTurningDuration' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0007Controller, EnableSprinkleWaterDraw) == 0x0022EC, "Member 'AEndBattleAIEB0007Controller::EnableSprinkleWaterDraw' has a wrong offset!");

// Class EndGame.EndNavModifierAdditionalLayerVolume
// 0x0008 (0x0430 - 0x0428)
class AEndNavModifierAdditionalLayerVolume final : public AEndNavModifierVolumeBase
{
public:
	EEndNavLayerType                              LayerType;                                         // 0x0428(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_429[0x7];                                      // 0x0429(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavModifierAdditionalLayerVolume">();
	}
	static class AEndNavModifierAdditionalLayerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndNavModifierAdditionalLayerVolume>();
	}
};
static_assert(alignof(AEndNavModifierAdditionalLayerVolume) == 0x000008, "Wrong alignment on AEndNavModifierAdditionalLayerVolume");
static_assert(sizeof(AEndNavModifierAdditionalLayerVolume) == 0x000430, "Wrong size on AEndNavModifierAdditionalLayerVolume");
static_assert(offsetof(AEndNavModifierAdditionalLayerVolume, LayerType) == 0x000428, "Member 'AEndNavModifierAdditionalLayerVolume::LayerType' has a wrong offset!");

// Class EndGame.EndAnimNotifyRunEnvironmentPhysImpulse
// 0x0008 (0x0040 - 0x0038)
class UEndAnimNotifyRunEnvironmentPhysImpulse final : public UAnimNotify
{
public:
	EEndEnvironmentPhysForceScale                 ImpulseScale;                                      // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyRunEnvironmentPhysImpulse">();
	}
	static class UEndAnimNotifyRunEnvironmentPhysImpulse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyRunEnvironmentPhysImpulse>();
	}
};
static_assert(alignof(UEndAnimNotifyRunEnvironmentPhysImpulse) == 0x000008, "Wrong alignment on UEndAnimNotifyRunEnvironmentPhysImpulse");
static_assert(sizeof(UEndAnimNotifyRunEnvironmentPhysImpulse) == 0x000040, "Wrong size on UEndAnimNotifyRunEnvironmentPhysImpulse");
static_assert(offsetof(UEndAnimNotifyRunEnvironmentPhysImpulse, ImpulseScale) == 0x000038, "Member 'UEndAnimNotifyRunEnvironmentPhysImpulse::ImpulseScale' has a wrong offset!");

// Class EndGame.EndAnimNotifyRunEnvironmentPhysSpawner
// 0x0008 (0x0040 - 0x0038)
class UEndAnimNotifyRunEnvironmentPhysSpawner final : public UAnimNotify
{
public:
	class FName                                   EnvironmentPhysSpawnerName;                        // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyRunEnvironmentPhysSpawner">();
	}
	static class UEndAnimNotifyRunEnvironmentPhysSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyRunEnvironmentPhysSpawner>();
	}
};
static_assert(alignof(UEndAnimNotifyRunEnvironmentPhysSpawner) == 0x000008, "Wrong alignment on UEndAnimNotifyRunEnvironmentPhysSpawner");
static_assert(sizeof(UEndAnimNotifyRunEnvironmentPhysSpawner) == 0x000040, "Wrong size on UEndAnimNotifyRunEnvironmentPhysSpawner");
static_assert(offsetof(UEndAnimNotifyRunEnvironmentPhysSpawner, EnvironmentPhysSpawnerName) == 0x000038, "Member 'UEndAnimNotifyRunEnvironmentPhysSpawner::EnvironmentPhysSpawnerName' has a wrong offset!");

// Class EndGame.EndDataObjectPlayerTable
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectPlayerTable final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectPlayerTable">();
	}
	static class UEndDataObjectPlayerTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectPlayerTable>();
	}
};
static_assert(alignof(UEndDataObjectPlayerTable) == 0x000008, "Wrong alignment on UEndDataObjectPlayerTable");
static_assert(sizeof(UEndDataObjectPlayerTable) == 0x000088, "Wrong size on UEndDataObjectPlayerTable");

// Class EndGame.EndBattleBreakableComponent
// 0x0038 (0x0130 - 0x00F8)
class UEndBattleBreakableComponent final : public UActorComponent
{
public:
	class FName                                   DataTableBreakableID;                              // 0x00F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartWithHidden;                                  // 0x0100(0x0001)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AEndEnvironmentPhysicsStaticMeshActor*  OwnerActor;                                        // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x20];                                     // 0x0110(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleBreakableComponent">();
	}
	static class UEndBattleBreakableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleBreakableComponent>();
	}
};
static_assert(alignof(UEndBattleBreakableComponent) == 0x000008, "Wrong alignment on UEndBattleBreakableComponent");
static_assert(sizeof(UEndBattleBreakableComponent) == 0x000130, "Wrong size on UEndBattleBreakableComponent");
static_assert(offsetof(UEndBattleBreakableComponent, DataTableBreakableID) == 0x0000F8, "Member 'UEndBattleBreakableComponent::DataTableBreakableID' has a wrong offset!");
static_assert(offsetof(UEndBattleBreakableComponent, bStartWithHidden) == 0x000100, "Member 'UEndBattleBreakableComponent::bStartWithHidden' has a wrong offset!");
static_assert(offsetof(UEndBattleBreakableComponent, OwnerActor) == 0x000108, "Member 'UEndBattleBreakableComponent::OwnerActor' has a wrong offset!");

// Class EndGame.EndAnimNotifySeadEventTrigger
// 0x0010 (0x0048 - 0x0038)
class UEndAnimNotifySeadEventTrigger final : public UAnimNotify
{
public:
	class FName                                   SeadEventID;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUsePrefixOwnerID : 1;                             // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifySeadEventTrigger">();
	}
	static class UEndAnimNotifySeadEventTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifySeadEventTrigger>();
	}
};
static_assert(alignof(UEndAnimNotifySeadEventTrigger) == 0x000008, "Wrong alignment on UEndAnimNotifySeadEventTrigger");
static_assert(sizeof(UEndAnimNotifySeadEventTrigger) == 0x000048, "Wrong size on UEndAnimNotifySeadEventTrigger");
static_assert(offsetof(UEndAnimNotifySeadEventTrigger, SeadEventID) == 0x000038, "Member 'UEndAnimNotifySeadEventTrigger::SeadEventID' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateSeadEventTrigger
// 0x0018 (0x0048 - 0x0030)
class UEndAnimNotifyStateSeadEventTrigger final : public UAnimNotifyState
{
public:
	class FName                                   OnBeginSeadEventID;                                // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OnEndSeadEventID;                                  // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUsePrefixOwnerID : 1;                             // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateSeadEventTrigger">();
	}
	static class UEndAnimNotifyStateSeadEventTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateSeadEventTrigger>();
	}
};
static_assert(alignof(UEndAnimNotifyStateSeadEventTrigger) == 0x000008, "Wrong alignment on UEndAnimNotifyStateSeadEventTrigger");
static_assert(sizeof(UEndAnimNotifyStateSeadEventTrigger) == 0x000048, "Wrong size on UEndAnimNotifyStateSeadEventTrigger");
static_assert(offsetof(UEndAnimNotifyStateSeadEventTrigger, OnBeginSeadEventID) == 0x000030, "Member 'UEndAnimNotifyStateSeadEventTrigger::OnBeginSeadEventID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateSeadEventTrigger, OnEndSeadEventID) == 0x000038, "Member 'UEndAnimNotifyStateSeadEventTrigger::OnEndSeadEventID' has a wrong offset!");

// Class EndGame.EndNavQueryFilterBase
// 0x0000 (0x0048 - 0x0048)
class UEndNavQueryFilterBase : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavQueryFilterBase">();
	}
	static class UEndNavQueryFilterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavQueryFilterBase>();
	}
};
static_assert(alignof(UEndNavQueryFilterBase) == 0x000008, "Wrong alignment on UEndNavQueryFilterBase");
static_assert(sizeof(UEndNavQueryFilterBase) == 0x000048, "Wrong size on UEndNavQueryFilterBase");

// Class EndGame.EndNavCinemaQueryFilter
// 0x0000 (0x0048 - 0x0048)
class UEndNavCinemaQueryFilter final : public UEndNavQueryFilterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavCinemaQueryFilter">();
	}
	static class UEndNavCinemaQueryFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavCinemaQueryFilter>();
	}
};
static_assert(alignof(UEndNavCinemaQueryFilter) == 0x000008, "Wrong alignment on UEndNavCinemaQueryFilter");
static_assert(sizeof(UEndNavCinemaQueryFilter) == 0x000048, "Wrong size on UEndNavCinemaQueryFilter");

// Class EndGame.EndBattleAILineWarpController
// 0x0090 (0x2318 - 0x2288)
#pragma pack(push, 0x1)
class alignas(0x08) AEndBattleAILineWarpController : public AEndBattleAIController
{
public:
	uint8                                         Pad_2288[0x8C];                                    // 0x2288(0x008C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ShowLineWarp;                                      // 0x2314(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2315[0x3];                                     // 0x2315(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEventLineWarp(class FName Message);
	bool RequestLineWarp(ELineWarpType InLineWarpType, int32 InDivisionNum, class FName InStartMotion, class FName InLoopMotion, class FName InEndMotion, float InWaitTime, const struct FVector& InEndLocation, const struct FVector& InRandomOffsetRange, float InNearDistance, float InLeaveDistance, float InPointWaitTime, float InTrailVelocityPower, const struct FVector& InHeightOffsetTable, ELineWarpCalcPattern InCalcPattern, const struct FVector& InPatternParameter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAILineWarpController">();
	}
	static class AEndBattleAILineWarpController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAILineWarpController>();
	}
};
#pragma pack(pop)
static_assert(alignof(AEndBattleAILineWarpController) == 0x000008, "Wrong alignment on AEndBattleAILineWarpController");
static_assert(sizeof(AEndBattleAILineWarpController) == 0x002318, "Wrong size on AEndBattleAILineWarpController");
static_assert(offsetof(AEndBattleAILineWarpController, ShowLineWarp) == 0x002314, "Member 'AEndBattleAILineWarpController::ShowLineWarp' has a wrong offset!");

// Class EndGame.EndBattleAIEB1005Controller
// 0x0128 (0x2440 - 0x2318)
class AEndBattleAIEB1005Controller final : public AEndBattleAILineWarpController
{
public:
	float                                         FastNextBlendTime;                                 // 0x2318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FastBeginToLoopBlendTime;                          // 0x231C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FastLoopToEndBlendTime;                            // 0x2320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         rotateLengthTime;                                  // 0x2324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2328[0x100];                                   // 0x2328(0x0100)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ShowDashPoint;                                     // 0x2428(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowGoalPoint;                                     // 0x2429(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowGoalRangePoints;                               // 0x242A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_242B[0x1];                                     // 0x242B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RangePointsYaw;                                    // 0x242C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HideGoalRangePoints;                               // 0x2430(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2431[0xF];                                     // 0x2431(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetFastDashGotoPosition(EPlayerType InPlayerType, EFastDashGoToPositionType InPositionType, EFastDashGoToDistanceType InDistanceType, float InDirYaw);
	void OnEventFastDash(class FName InEventName);
	void OverwriteGoalPositionFastDash(class FName InKeyword, const struct FVector& InGoalPosition);
	void RegisterFastDash(class FName InKeyword, class FName InStartAnimation, class FName InLoopAnimation, class FName InEndAnimation, float InVailableDistance, class FName InEventNameCompleted, class FName InEventNameSuspended, class FName InEventNameTimeOver, class FName InEventNameHitWall, class FName InEventNameMissing, class FName InEventNameArrival, class FName InEventNameNear);
	void RegisterFastDashEffect(class FName InCharaSpecName, class FName InEffectFastDashMove);
	void RegisterFastDashGotoPosition(const struct FVector& InDistance);
	bool RequestReserveActionFastDash(class FName InKeyword, const struct FVector& InGoalPosition, float InFastMoveSpeed, float InMissingDistance, float InMarginDistance, float InLimitTime, float InMoveFriction, bool InUseStartFrontRotate, bool InUseDeceleration, bool InUpdateGoalPosition, bool InDrawTargetPoint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEB1005Controller">();
	}
	static class AEndBattleAIEB1005Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEB1005Controller>();
	}
};
static_assert(alignof(AEndBattleAIEB1005Controller) == 0x000008, "Wrong alignment on AEndBattleAIEB1005Controller");
static_assert(sizeof(AEndBattleAIEB1005Controller) == 0x002440, "Wrong size on AEndBattleAIEB1005Controller");
static_assert(offsetof(AEndBattleAIEB1005Controller, FastNextBlendTime) == 0x002318, "Member 'AEndBattleAIEB1005Controller::FastNextBlendTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB1005Controller, FastBeginToLoopBlendTime) == 0x00231C, "Member 'AEndBattleAIEB1005Controller::FastBeginToLoopBlendTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB1005Controller, FastLoopToEndBlendTime) == 0x002320, "Member 'AEndBattleAIEB1005Controller::FastLoopToEndBlendTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB1005Controller, rotateLengthTime) == 0x002324, "Member 'AEndBattleAIEB1005Controller::rotateLengthTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB1005Controller, ShowDashPoint) == 0x002428, "Member 'AEndBattleAIEB1005Controller::ShowDashPoint' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB1005Controller, ShowGoalPoint) == 0x002429, "Member 'AEndBattleAIEB1005Controller::ShowGoalPoint' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB1005Controller, ShowGoalRangePoints) == 0x00242A, "Member 'AEndBattleAIEB1005Controller::ShowGoalRangePoints' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB1005Controller, RangePointsYaw) == 0x00242C, "Member 'AEndBattleAIEB1005Controller::RangePointsYaw' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB1005Controller, HideGoalRangePoints) == 0x002430, "Member 'AEndBattleAIEB1005Controller::HideGoalRangePoints' has a wrong offset!");

// Class EndGame.EndAnimNotifySendPlannerEventTrigger
// 0x0010 (0x0048 - 0x0038)
class UEndAnimNotifySendPlannerEventTrigger final : public UAnimNotify
{
public:
	class FString                                 TriggerId;                                         // 0x0038(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifySendPlannerEventTrigger">();
	}
	static class UEndAnimNotifySendPlannerEventTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifySendPlannerEventTrigger>();
	}
};
static_assert(alignof(UEndAnimNotifySendPlannerEventTrigger) == 0x000008, "Wrong alignment on UEndAnimNotifySendPlannerEventTrigger");
static_assert(sizeof(UEndAnimNotifySendPlannerEventTrigger) == 0x000048, "Wrong size on UEndAnimNotifySendPlannerEventTrigger");
static_assert(offsetof(UEndAnimNotifySendPlannerEventTrigger, TriggerId) == 0x000038, "Member 'UEndAnimNotifySendPlannerEventTrigger::TriggerId' has a wrong offset!");

// Class EndGame.EndAnimNotifySendStateTrigger
// 0x0010 (0x0048 - 0x0038)
class UEndAnimNotifySendStateTrigger final : public UAnimNotify
{
public:
	class FString                                 StateTriggerName;                                  // 0x0038(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifySendStateTrigger">();
	}
	static class UEndAnimNotifySendStateTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifySendStateTrigger>();
	}
};
static_assert(alignof(UEndAnimNotifySendStateTrigger) == 0x000008, "Wrong alignment on UEndAnimNotifySendStateTrigger");
static_assert(sizeof(UEndAnimNotifySendStateTrigger) == 0x000048, "Wrong size on UEndAnimNotifySendStateTrigger");
static_assert(offsetof(UEndAnimNotifySendStateTrigger, StateTriggerName) == 0x000038, "Member 'UEndAnimNotifySendStateTrigger::StateTriggerName' has a wrong offset!");

// Class EndGame.EndDataObjectResidentParameter
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectResidentParameter final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectResidentParameter">();
	}
	static class UEndDataObjectResidentParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectResidentParameter>();
	}
};
static_assert(alignof(UEndDataObjectResidentParameter) == 0x000008, "Wrong alignment on UEndDataObjectResidentParameter");
static_assert(sizeof(UEndDataObjectResidentParameter) == 0x000088, "Wrong size on UEndDataObjectResidentParameter");

// Class EndGame.EndNavAreaLadder
// 0x0000 (0x0040 - 0x0040)
class UEndNavAreaLadder final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavAreaLadder">();
	}
	static class UEndNavAreaLadder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavAreaLadder>();
	}
};
static_assert(alignof(UEndNavAreaLadder) == 0x000008, "Wrong alignment on UEndNavAreaLadder");
static_assert(sizeof(UEndNavAreaLadder) == 0x000040, "Wrong size on UEndNavAreaLadder");

// Class EndGame.EndBattleCameraLevelScriptActor
// 0x0000 (0x0380 - 0x0380)
class AEndBattleCameraLevelScriptActor final : public ALevelScriptActor
{
public:
	void BattleCameraLevelConstructionScript();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleCameraLevelScriptActor">();
	}
	static class AEndBattleCameraLevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleCameraLevelScriptActor>();
	}
};
static_assert(alignof(AEndBattleCameraLevelScriptActor) == 0x000008, "Wrong alignment on AEndBattleCameraLevelScriptActor");
static_assert(sizeof(AEndBattleCameraLevelScriptActor) == 0x000380, "Wrong size on AEndBattleCameraLevelScriptActor");

// Class EndGame.EndAnimNotifySetChildMesh
// 0x0050 (0x0088 - 0x0038)
class UEndAnimNotifySetChildMesh final : public UAnimNotify
{
public:
	TMap<class FName, class FName>                MeshLabels;                                        // 0x0038(0x0050)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifySetChildMesh">();
	}
	static class UEndAnimNotifySetChildMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifySetChildMesh>();
	}
};
static_assert(alignof(UEndAnimNotifySetChildMesh) == 0x000008, "Wrong alignment on UEndAnimNotifySetChildMesh");
static_assert(sizeof(UEndAnimNotifySetChildMesh) == 0x000088, "Wrong size on UEndAnimNotifySetChildMesh");
static_assert(offsetof(UEndAnimNotifySetChildMesh, MeshLabels) == 0x000038, "Member 'UEndAnimNotifySetChildMesh::MeshLabels' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateBattleAbilityCancel
// 0x0010 (0x0040 - 0x0030)
class UEndAnimNotifyStateBattleAbilityCancel final : public UAnimNotifyState
{
public:
	TArray<int32>                                 CancelNumbers;                                     // 0x0030(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBattleAbilityCancel">();
	}
	static class UEndAnimNotifyStateBattleAbilityCancel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBattleAbilityCancel>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBattleAbilityCancel) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBattleAbilityCancel");
static_assert(sizeof(UEndAnimNotifyStateBattleAbilityCancel) == 0x000040, "Wrong size on UEndAnimNotifyStateBattleAbilityCancel");
static_assert(offsetof(UEndAnimNotifyStateBattleAbilityCancel, CancelNumbers) == 0x000030, "Member 'UEndAnimNotifyStateBattleAbilityCancel::CancelNumbers' has a wrong offset!");

// Class EndGame.EndBattleBossGaugeIcon
// 0x0040 (0x03A0 - 0x0360)
class UEndBattleBossGaugeIcon final : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x40];                                     // 0x0360(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleBossGaugeIcon">();
	}
	static class UEndBattleBossGaugeIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleBossGaugeIcon>();
	}
};
static_assert(alignof(UEndBattleBossGaugeIcon) == 0x000008, "Wrong alignment on UEndBattleBossGaugeIcon");
static_assert(sizeof(UEndBattleBossGaugeIcon) == 0x0003A0, "Wrong size on UEndBattleBossGaugeIcon");

// Class EndGame.EndAnimNotifyStateBattleAbilityCorrectionInvalid
// 0x0008 (0x0038 - 0x0030)
class UEndAnimNotifyStateBattleAbilityCorrectionInvalid final : public UAnimNotifyState
{
public:
	bool                                          Distance;                                          // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Direction;                                         // 0x0031(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBattleAbilityCorrectionInvalid">();
	}
	static class UEndAnimNotifyStateBattleAbilityCorrectionInvalid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBattleAbilityCorrectionInvalid>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBattleAbilityCorrectionInvalid) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBattleAbilityCorrectionInvalid");
static_assert(sizeof(UEndAnimNotifyStateBattleAbilityCorrectionInvalid) == 0x000038, "Wrong size on UEndAnimNotifyStateBattleAbilityCorrectionInvalid");
static_assert(offsetof(UEndAnimNotifyStateBattleAbilityCorrectionInvalid, Distance) == 0x000030, "Member 'UEndAnimNotifyStateBattleAbilityCorrectionInvalid::Distance' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBattleAbilityCorrectionInvalid, Direction) == 0x000031, "Member 'UEndAnimNotifyStateBattleAbilityCorrectionInvalid::Direction' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateBattleAbilityForceReturnWeapon
// 0x0028 (0x0058 - 0x0030)
class UEndAnimNotifyStateBattleAbilityForceReturnWeapon final : public UAnimNotifyState
{
public:
	class FName                                   ReturnDamageSourceID;                              // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnRotateMaxVelocity;                           // 0x0038(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnRotateAcceleration;                          // 0x0044(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDisableWeaponCorrectionDirection;                 // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBattleAbilityForceReturnWeapon">();
	}
	static class UEndAnimNotifyStateBattleAbilityForceReturnWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBattleAbilityForceReturnWeapon>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBattleAbilityForceReturnWeapon) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBattleAbilityForceReturnWeapon");
static_assert(sizeof(UEndAnimNotifyStateBattleAbilityForceReturnWeapon) == 0x000058, "Wrong size on UEndAnimNotifyStateBattleAbilityForceReturnWeapon");
static_assert(offsetof(UEndAnimNotifyStateBattleAbilityForceReturnWeapon, ReturnDamageSourceID) == 0x000030, "Member 'UEndAnimNotifyStateBattleAbilityForceReturnWeapon::ReturnDamageSourceID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBattleAbilityForceReturnWeapon, ReturnRotateMaxVelocity) == 0x000038, "Member 'UEndAnimNotifyStateBattleAbilityForceReturnWeapon::ReturnRotateMaxVelocity' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBattleAbilityForceReturnWeapon, ReturnRotateAcceleration) == 0x000044, "Member 'UEndAnimNotifyStateBattleAbilityForceReturnWeapon::ReturnRotateAcceleration' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBattleAbilityForceReturnWeapon, bDisableWeaponCorrectionDirection) == 0x000050, "Member 'UEndAnimNotifyStateBattleAbilityForceReturnWeapon::bDisableWeaponCorrectionDirection' has a wrong offset!");

// Class EndGame.EndDataObjectReward
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectReward final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectReward">();
	}
	static class UEndDataObjectReward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectReward>();
	}
};
static_assert(alignof(UEndDataObjectReward) == 0x000008, "Wrong alignment on UEndDataObjectReward");
static_assert(sizeof(UEndDataObjectReward) == 0x000088, "Wrong size on UEndDataObjectReward");

// Class EndGame.EndBattleAIEB1004Controller
// 0x0138 (0x23C0 - 0x2288)
class AEndBattleAIEB1004Controller final : public AEndBattleAIController
{
public:
	float                                         FastNextBlendTime;                                 // 0x2288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FastBeginToLoopBlendTime;                          // 0x228C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FastLoopToEndBlendTime;                            // 0x2290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         rotateLengthTime;                                  // 0x2294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2298[0x114];                                   // 0x2298(0x0114)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ShowDashPoint;                                     // 0x23AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowGoalPoint;                                     // 0x23AD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowGoalRangePoints;                               // 0x23AE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23AF[0x1];                                     // 0x23AF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RangePointsYaw;                                    // 0x23B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HideGoalRangePoints;                               // 0x23B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23B5[0xB];                                     // 0x23B5(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CompareAbyssOverAbilityCount(int32 compareCount);
	int32 GetAbyssAbilityCount();
	float GetAbyssElapsedTime();
	struct FVector GetFastDashGotoPosition(EPlayerType InPlayerType, EFastDashGoToPositionType InPositionType, EFastDashGoToDistanceType InDistanceType, float InDirYaw);
	int32 GetTotalDamage();
	int32 GetTotalDamageThreshold();
	void IncrementAbyssAbilityCount();
	void OnAbyssOverTimeEvent();
	void OnAbyssTimeInterruptedEvent();
	void OnEventFastDash(class FName InEventName);
	void OverwriteGoalPositionFastDash(class FName InKeyword, const struct FVector& InGoalPosition);
	void RegisterFastDash(class FName InKeyword, class FName InStartAnimation, class FName InLoopAnimation, class FName InEndAnimation, float InVailableDistance, class FName InEventNameCompleted, class FName InEventNameSuspended, class FName InEventNameTimeOver, class FName InEventNameHitWall, class FName InEventNameMissing, class FName InEventNameArrival, class FName InEventNameNear);
	void RegisterFastDashEffect(class FName InCharaSpecName, class FName InEffectFastDashMove);
	void RegisterFastDashGotoPosition(const struct FVector& InDistance);
	bool RequestReserveActionFastDash(class FName InKeyword, const struct FVector& InGoalPosition, float InFastMoveSpeed, float InMissingDistance, float InMarginDistance, float InLimitTime, float InMoveFriction, bool InUseStartFrontRotate, bool InUseDeceleration, bool InUpdateGoalPosition, bool InDrawTargetPoint);
	void ResetAbyssAbilityCount(bool enableResetTime);
	void SetAbyssOverTimeEvent(float InOverTime, bool InKeepTimer);
	void SetTotalDamage(int32 Value);
	void SetTotalDamageThreshold(int32 Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEB1004Controller">();
	}
	static class AEndBattleAIEB1004Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEB1004Controller>();
	}
};
static_assert(alignof(AEndBattleAIEB1004Controller) == 0x000008, "Wrong alignment on AEndBattleAIEB1004Controller");
static_assert(sizeof(AEndBattleAIEB1004Controller) == 0x0023C0, "Wrong size on AEndBattleAIEB1004Controller");
static_assert(offsetof(AEndBattleAIEB1004Controller, FastNextBlendTime) == 0x002288, "Member 'AEndBattleAIEB1004Controller::FastNextBlendTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB1004Controller, FastBeginToLoopBlendTime) == 0x00228C, "Member 'AEndBattleAIEB1004Controller::FastBeginToLoopBlendTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB1004Controller, FastLoopToEndBlendTime) == 0x002290, "Member 'AEndBattleAIEB1004Controller::FastLoopToEndBlendTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB1004Controller, rotateLengthTime) == 0x002294, "Member 'AEndBattleAIEB1004Controller::rotateLengthTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB1004Controller, ShowDashPoint) == 0x0023AC, "Member 'AEndBattleAIEB1004Controller::ShowDashPoint' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB1004Controller, ShowGoalPoint) == 0x0023AD, "Member 'AEndBattleAIEB1004Controller::ShowGoalPoint' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB1004Controller, ShowGoalRangePoints) == 0x0023AE, "Member 'AEndBattleAIEB1004Controller::ShowGoalRangePoints' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB1004Controller, RangePointsYaw) == 0x0023B0, "Member 'AEndBattleAIEB1004Controller::RangePointsYaw' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB1004Controller, HideGoalRangePoints) == 0x0023B4, "Member 'AEndBattleAIEB1004Controller::HideGoalRangePoints' has a wrong offset!");

// Class EndGame.EndProgressBar
// 0x0278 (0x0370 - 0x00F8)
class UEndProgressBar final : public UWidget
{
public:
	struct FProgressBarStyle                      WidgetStyle;                                       // 0x00F8(0x0170)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         Percent;                                           // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             PercentDelegate;                                   // 0x0270(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PreviewPercent;                                    // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             PreviewPercentDelegate;                            // 0x0288(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	EProgressBarFillType                          BarFillType;                                       // 0x0298(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x3];                                      // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              BorderPadding;                                     // 0x029C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FillColorAndOpacity;                               // 0x02A4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             FillColorAndOpacityDelegate;                       // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           PreviewColorAndOpacity;                            // 0x02C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             PreviewColorAndOpacityDelegate;                    // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FSlateBrush                            PreviewBrush;                                      // 0x02E8(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_360[0x10];                                     // 0x0360(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFillColorAndOpacity(const struct FLinearColor& InColor);
	void SetPercent(float InPercent);
	void SetPreviewColorAndOpacity(const struct FLinearColor& InColor);
	void SetPreviewPercent(float InPercent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndProgressBar">();
	}
	static class UEndProgressBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndProgressBar>();
	}
};
static_assert(alignof(UEndProgressBar) == 0x000008, "Wrong alignment on UEndProgressBar");
static_assert(sizeof(UEndProgressBar) == 0x000370, "Wrong size on UEndProgressBar");
static_assert(offsetof(UEndProgressBar, WidgetStyle) == 0x0000F8, "Member 'UEndProgressBar::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UEndProgressBar, Percent) == 0x000268, "Member 'UEndProgressBar::Percent' has a wrong offset!");
static_assert(offsetof(UEndProgressBar, PercentDelegate) == 0x000270, "Member 'UEndProgressBar::PercentDelegate' has a wrong offset!");
static_assert(offsetof(UEndProgressBar, PreviewPercent) == 0x000280, "Member 'UEndProgressBar::PreviewPercent' has a wrong offset!");
static_assert(offsetof(UEndProgressBar, PreviewPercentDelegate) == 0x000288, "Member 'UEndProgressBar::PreviewPercentDelegate' has a wrong offset!");
static_assert(offsetof(UEndProgressBar, BarFillType) == 0x000298, "Member 'UEndProgressBar::BarFillType' has a wrong offset!");
static_assert(offsetof(UEndProgressBar, BorderPadding) == 0x00029C, "Member 'UEndProgressBar::BorderPadding' has a wrong offset!");
static_assert(offsetof(UEndProgressBar, FillColorAndOpacity) == 0x0002A4, "Member 'UEndProgressBar::FillColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UEndProgressBar, FillColorAndOpacityDelegate) == 0x0002B8, "Member 'UEndProgressBar::FillColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UEndProgressBar, PreviewColorAndOpacity) == 0x0002C8, "Member 'UEndProgressBar::PreviewColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UEndProgressBar, PreviewColorAndOpacityDelegate) == 0x0002D8, "Member 'UEndProgressBar::PreviewColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UEndProgressBar, PreviewBrush) == 0x0002E8, "Member 'UEndProgressBar::PreviewBrush' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateBattleAbilityReaction
// 0x0008 (0x0038 - 0x0030)
class UEndAnimNotifyStateBattleAbilityReaction final : public UAnimNotifyState
{
public:
	int32                                         NotifyIndex;                                       // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBattleAbilityReaction">();
	}
	static class UEndAnimNotifyStateBattleAbilityReaction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBattleAbilityReaction>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBattleAbilityReaction) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBattleAbilityReaction");
static_assert(sizeof(UEndAnimNotifyStateBattleAbilityReaction) == 0x000038, "Wrong size on UEndAnimNotifyStateBattleAbilityReaction");
static_assert(offsetof(UEndAnimNotifyStateBattleAbilityReaction, NotifyIndex) == 0x000030, "Member 'UEndAnimNotifyStateBattleAbilityReaction::NotifyIndex' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateBattleAddSpecialStatusChange
// 0x0008 (0x0038 - 0x0030)
class UEndAnimNotifyStateBattleAddSpecialStatusChange final : public UAnimNotifyState
{
public:
	class FName                                   SpecialStatusChangeID;                             // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBattleAddSpecialStatusChange">();
	}
	static class UEndAnimNotifyStateBattleAddSpecialStatusChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBattleAddSpecialStatusChange>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBattleAddSpecialStatusChange) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBattleAddSpecialStatusChange");
static_assert(sizeof(UEndAnimNotifyStateBattleAddSpecialStatusChange) == 0x000038, "Wrong size on UEndAnimNotifyStateBattleAddSpecialStatusChange");
static_assert(offsetof(UEndAnimNotifyStateBattleAddSpecialStatusChange, SpecialStatusChangeID) == 0x000030, "Member 'UEndAnimNotifyStateBattleAddSpecialStatusChange::SpecialStatusChangeID' has a wrong offset!");

// Class EndGame.EndNavGenerateOnlyTerrainVolume
// 0x0000 (0x0450 - 0x0450)
class AEndNavGenerateOnlyTerrainVolume final : public AEndNavSimpleTerrainVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavGenerateOnlyTerrainVolume">();
	}
	static class AEndNavGenerateOnlyTerrainVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndNavGenerateOnlyTerrainVolume>();
	}
};
static_assert(alignof(AEndNavGenerateOnlyTerrainVolume) == 0x000008, "Wrong alignment on AEndNavGenerateOnlyTerrainVolume");
static_assert(sizeof(AEndNavGenerateOnlyTerrainVolume) == 0x000450, "Wrong size on AEndNavGenerateOnlyTerrainVolume");

// Class EndGame.EndBattleAIEN2101Controller
// 0x0038 (0x22C0 - 0x2288)
class AEndBattleAIEN2101Controller final : public AEndBattleAIController
{
public:
	uint8                                         Pad_2288[0x38];                                    // 0x2288(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEasySpawnEvent(class FName EventName);
	bool RequestBreakRightArm(class FName charaPartsSpecName, class FName SocketName);
	bool RequestDestroyRightArmActor();
	bool RequestKillRightArm(bool forceDestroy);
	bool RequestRepairRightArm(class FName charaPartsSpecName, class FName meshLabelName);
	bool RequestReplaceRightArm(class FName SocketName);
	bool RequestSpawnRightArm(class FName CharaSpecName, bool spawnedInvisible, bool spawnedDisableCollision, EEndBattleEasySpawnEnableRagdollType enableRagdollType, float deadEventDelayTime, const struct FVector& hidePosition, bool recycle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEN2101Controller">();
	}
	static class AEndBattleAIEN2101Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEN2101Controller>();
	}
};
static_assert(alignof(AEndBattleAIEN2101Controller) == 0x000008, "Wrong alignment on AEndBattleAIEN2101Controller");
static_assert(sizeof(AEndBattleAIEN2101Controller) == 0x0022C0, "Wrong size on AEndBattleAIEN2101Controller");

// Class EndGame.EndAnimNotifyStateBattleCancelDodge
// 0x0000 (0x0030 - 0x0030)
class UEndAnimNotifyStateBattleCancelDodge final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBattleCancelDodge">();
	}
	static class UEndAnimNotifyStateBattleCancelDodge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBattleCancelDodge>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBattleCancelDodge) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBattleCancelDodge");
static_assert(sizeof(UEndAnimNotifyStateBattleCancelDodge) == 0x000030, "Wrong size on UEndAnimNotifyStateBattleCancelDodge");

// Class EndGame.EndAnimNotifyStateBattleCancelGuard
// 0x0000 (0x0030 - 0x0030)
class UEndAnimNotifyStateBattleCancelGuard final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBattleCancelGuard">();
	}
	static class UEndAnimNotifyStateBattleCancelGuard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBattleCancelGuard>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBattleCancelGuard) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBattleCancelGuard");
static_assert(sizeof(UEndAnimNotifyStateBattleCancelGuard) == 0x000030, "Wrong size on UEndAnimNotifyStateBattleCancelGuard");

// Class EndGame.EndDataObjectShopItem
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectShopItem final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectShopItem">();
	}
	static class UEndDataObjectShopItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectShopItem>();
	}
};
static_assert(alignof(UEndDataObjectShopItem) == 0x000008, "Wrong alignment on UEndDataObjectShopItem");
static_assert(sizeof(UEndDataObjectShopItem) == 0x000088, "Wrong size on UEndDataObjectShopItem");

// Class EndGame.EndBattleAIEN2000_01Controller
// 0x0008 (0x2290 - 0x2288)
class AEndBattleAIEN2000_01Controller final : public AEndBattleAIController
{
public:
	uint8                                         Pad_2288[0x8];                                     // 0x2288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsChasing();
	void StartChasing();
	void StopChasing();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEN2000_01Controller">();
	}
	static class AEndBattleAIEN2000_01Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEN2000_01Controller>();
	}
};
static_assert(alignof(AEndBattleAIEN2000_01Controller) == 0x000008, "Wrong alignment on AEndBattleAIEN2000_01Controller");
static_assert(sizeof(AEndBattleAIEN2000_01Controller) == 0x002290, "Wrong size on AEndBattleAIEN2000_01Controller");

// Class EndGame.EndAnimNotifyStateBattleChangeMovement
// 0x0000 (0x0030 - 0x0030)
class UEndAnimNotifyStateBattleChangeMovement final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBattleChangeMovement">();
	}
	static class UEndAnimNotifyStateBattleChangeMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBattleChangeMovement>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBattleChangeMovement) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBattleChangeMovement");
static_assert(sizeof(UEndAnimNotifyStateBattleChangeMovement) == 0x000030, "Wrong size on UEndAnimNotifyStateBattleChangeMovement");

// Class EndGame.EndAnimNotifyStateBattleChangePushCollisionDisable
// 0x0008 (0x0038 - 0x0030)
class UEndAnimNotifyStateBattleChangePushCollisionDisable final : public UAnimNotifyState
{
public:
	class FName                                   CharaPartsSpecID;                                  // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBattleChangePushCollisionDisable">();
	}
	static class UEndAnimNotifyStateBattleChangePushCollisionDisable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBattleChangePushCollisionDisable>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBattleChangePushCollisionDisable) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBattleChangePushCollisionDisable");
static_assert(sizeof(UEndAnimNotifyStateBattleChangePushCollisionDisable) == 0x000038, "Wrong size on UEndAnimNotifyStateBattleChangePushCollisionDisable");
static_assert(offsetof(UEndAnimNotifyStateBattleChangePushCollisionDisable, CharaPartsSpecID) == 0x000030, "Member 'UEndAnimNotifyStateBattleChangePushCollisionDisable::CharaPartsSpecID' has a wrong offset!");

// Class EndGame.EndBattleAIEB1001Controller
// 0x0008 (0x2290 - 0x2288)
class AEndBattleAIEB1001Controller final : public AEndBattleAIController
{
public:
	uint8                                         Pad_2288[0x8];                                     // 0x2288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEB1001Controller">();
	}
	static class AEndBattleAIEB1001Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEB1001Controller>();
	}
};
static_assert(alignof(AEndBattleAIEB1001Controller) == 0x000008, "Wrong alignment on AEndBattleAIEB1001Controller");
static_assert(sizeof(AEndBattleAIEB1001Controller) == 0x002290, "Wrong size on AEndBattleAIEB1001Controller");

// Class EndGame.EndPopupMessageEffect
// 0x0030 (0x0390 - 0x0360)
class UEndPopupMessageEffect : public UEndUserWidget
{
public:
	struct FLinearColor                           PartyColor;                                        // 0x0360(0x0010)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           EnemyColor;                                        // 0x0370(0x0010)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_380[0x10];                                     // 0x0380(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndPopupMessageEffect">();
	}
	static class UEndPopupMessageEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndPopupMessageEffect>();
	}
};
static_assert(alignof(UEndPopupMessageEffect) == 0x000008, "Wrong alignment on UEndPopupMessageEffect");
static_assert(sizeof(UEndPopupMessageEffect) == 0x000390, "Wrong size on UEndPopupMessageEffect");
static_assert(offsetof(UEndPopupMessageEffect, PartyColor) == 0x000360, "Member 'UEndPopupMessageEffect::PartyColor' has a wrong offset!");
static_assert(offsetof(UEndPopupMessageEffect, EnemyColor) == 0x000370, "Member 'UEndPopupMessageEffect::EnemyColor' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateBattleDamage
// 0x0028 (0x0058 - 0x0030)
class UEndAnimNotifyStateBattleDamage final : public UAnimNotifyState
{
public:
	class FString                                 DamageSourceID;                                    // 0x0030(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Probability;                                       // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndBattleDamageSourcePositionBaseType        CreatePositionBase;                                // 0x0041(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CreatePositionName;                                // 0x0044(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReplaceOwnerCharaName;                             // 0x004C(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndAnimNotifyBattleDamageOwnerFilterType     OwnerFilterType;                                   // 0x0054(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBattleDamage">();
	}
	static class UEndAnimNotifyStateBattleDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBattleDamage>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBattleDamage) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBattleDamage");
static_assert(sizeof(UEndAnimNotifyStateBattleDamage) == 0x000058, "Wrong size on UEndAnimNotifyStateBattleDamage");
static_assert(offsetof(UEndAnimNotifyStateBattleDamage, DamageSourceID) == 0x000030, "Member 'UEndAnimNotifyStateBattleDamage::DamageSourceID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBattleDamage, Probability) == 0x000040, "Member 'UEndAnimNotifyStateBattleDamage::Probability' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBattleDamage, CreatePositionBase) == 0x000041, "Member 'UEndAnimNotifyStateBattleDamage::CreatePositionBase' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBattleDamage, CreatePositionName) == 0x000044, "Member 'UEndAnimNotifyStateBattleDamage::CreatePositionName' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBattleDamage, ReplaceOwnerCharaName) == 0x00004C, "Member 'UEndAnimNotifyStateBattleDamage::ReplaceOwnerCharaName' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBattleDamage, OwnerFilterType) == 0x000054, "Member 'UEndAnimNotifyStateBattleDamage::OwnerFilterType' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateBattleDamageReactionTimeAdjust
// 0x0000 (0x0030 - 0x0030)
class UEndAnimNotifyStateBattleDamageReactionTimeAdjust final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBattleDamageReactionTimeAdjust">();
	}
	static class UEndAnimNotifyStateBattleDamageReactionTimeAdjust* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBattleDamageReactionTimeAdjust>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBattleDamageReactionTimeAdjust) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBattleDamageReactionTimeAdjust");
static_assert(sizeof(UEndAnimNotifyStateBattleDamageReactionTimeAdjust) == 0x000030, "Wrong size on UEndAnimNotifyStateBattleDamageReactionTimeAdjust");

// Class EndGame.EndEmissiveControlComponent
// 0x0110 (0x03C0 - 0x02B0)
class UEndEmissiveControlComponent final : public USceneComponent
{
public:
	uint8                                         Pad_2B0[0xF0];                                     // 0x02B0(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Intensity;                                         // 0x03A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           EmissiveColor;                                     // 0x03A4(0x0010)(Edit, BlueprintVisible, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Temperature;                                       // 0x03B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B8[0x8];                                      // 0x03B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEmissiveControlComponent">();
	}
	static class UEndEmissiveControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEmissiveControlComponent>();
	}
};
static_assert(alignof(UEndEmissiveControlComponent) == 0x000008, "Wrong alignment on UEndEmissiveControlComponent");
static_assert(sizeof(UEndEmissiveControlComponent) == 0x0003C0, "Wrong size on UEndEmissiveControlComponent");
static_assert(offsetof(UEndEmissiveControlComponent, Intensity) == 0x0003A0, "Member 'UEndEmissiveControlComponent::Intensity' has a wrong offset!");
static_assert(offsetof(UEndEmissiveControlComponent, EmissiveColor) == 0x0003A4, "Member 'UEndEmissiveControlComponent::EmissiveColor' has a wrong offset!");
static_assert(offsetof(UEndEmissiveControlComponent, Temperature) == 0x0003B4, "Member 'UEndEmissiveControlComponent::Temperature' has a wrong offset!");

// Class EndGame.EndBattleAIEN2010Controller
// 0x0008 (0x2290 - 0x2288)
class AEndBattleAIEN2010Controller final : public AEndBattleAIController
{
public:
	uint8                                         Pad_2288[0x8];                                     // 0x2288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEN2010Controller">();
	}
	static class AEndBattleAIEN2010Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEN2010Controller>();
	}
};
static_assert(alignof(AEndBattleAIEN2010Controller) == 0x000008, "Wrong alignment on AEndBattleAIEN2010Controller");
static_assert(sizeof(AEndBattleAIEN2010Controller) == 0x002290, "Wrong size on AEndBattleAIEN2010Controller");

// Class EndGame.EndVE0009ChocoboCharacter
// 0x0010 (0x22D0 - 0x22C0)
class AEndVE0009ChocoboCharacter final : public AEndCharacter
{
public:
	class UEndBoneAttachComponent*                BoneAttach;                                        // 0x22B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AEndVE0003CarriageCharacter*            Carriage;                                          // 0x22C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C8[0x8];                                     // 0x22C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndVE0009ChocoboCharacter">();
	}
	static class AEndVE0009ChocoboCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndVE0009ChocoboCharacter>();
	}
};
static_assert(alignof(AEndVE0009ChocoboCharacter) == 0x000010, "Wrong alignment on AEndVE0009ChocoboCharacter");
static_assert(sizeof(AEndVE0009ChocoboCharacter) == 0x0022D0, "Wrong size on AEndVE0009ChocoboCharacter");
static_assert(offsetof(AEndVE0009ChocoboCharacter, BoneAttach) == 0x0022B8, "Member 'AEndVE0009ChocoboCharacter::BoneAttach' has a wrong offset!");
static_assert(offsetof(AEndVE0009ChocoboCharacter, Carriage) == 0x0022C0, "Member 'AEndVE0009ChocoboCharacter::Carriage' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateBattleDisableKnockback
// 0x0000 (0x0030 - 0x0030)
class UEndAnimNotifyStateBattleDisableKnockback final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBattleDisableKnockback">();
	}
	static class UEndAnimNotifyStateBattleDisableKnockback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBattleDisableKnockback>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBattleDisableKnockback) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBattleDisableKnockback");
static_assert(sizeof(UEndAnimNotifyStateBattleDisableKnockback) == 0x000030, "Wrong size on UEndAnimNotifyStateBattleDisableKnockback");

// Class EndGame.EndAnimNotifyStateBattleEndSlopeAlongSyncAction
// 0x0000 (0x0030 - 0x0030)
class UEndAnimNotifyStateBattleEndSlopeAlongSyncAction final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBattleEndSlopeAlongSyncAction">();
	}
	static class UEndAnimNotifyStateBattleEndSlopeAlongSyncAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBattleEndSlopeAlongSyncAction>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBattleEndSlopeAlongSyncAction) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBattleEndSlopeAlongSyncAction");
static_assert(sizeof(UEndAnimNotifyStateBattleEndSlopeAlongSyncAction) == 0x000030, "Wrong size on UEndAnimNotifyStateBattleEndSlopeAlongSyncAction");

// Class EndGame.EndBattleAISendMetaMessageNotify
// 0x0008 (0x0040 - 0x0038)
class UEndBattleAISendMetaMessageNotify final : public UAnimNotify
{
public:
	class FName                                   Message;                                           // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAISendMetaMessageNotify">();
	}
	static class UEndBattleAISendMetaMessageNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleAISendMetaMessageNotify>();
	}
};
static_assert(alignof(UEndBattleAISendMetaMessageNotify) == 0x000008, "Wrong alignment on UEndBattleAISendMetaMessageNotify");
static_assert(sizeof(UEndBattleAISendMetaMessageNotify) == 0x000040, "Wrong size on UEndBattleAISendMetaMessageNotify");
static_assert(offsetof(UEndBattleAISendMetaMessageNotify, Message) == 0x000038, "Member 'UEndBattleAISendMetaMessageNotify::Message' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateBattleInputDirectionRotate
// 0x0008 (0x0038 - 0x0030)
class UEndAnimNotifyStateBattleInputDirectionRotate final : public UAnimNotifyState
{
public:
	float                                         Angle;                                             // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForce;                                            // 0x0034(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBattleInputDirectionRotate">();
	}
	static class UEndAnimNotifyStateBattleInputDirectionRotate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBattleInputDirectionRotate>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBattleInputDirectionRotate) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBattleInputDirectionRotate");
static_assert(sizeof(UEndAnimNotifyStateBattleInputDirectionRotate) == 0x000038, "Wrong size on UEndAnimNotifyStateBattleInputDirectionRotate");
static_assert(offsetof(UEndAnimNotifyStateBattleInputDirectionRotate, Angle) == 0x000030, "Member 'UEndAnimNotifyStateBattleInputDirectionRotate::Angle' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBattleInputDirectionRotate, bForce) == 0x000034, "Member 'UEndAnimNotifyStateBattleInputDirectionRotate::bForce' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateBattleJustGuard
// 0x0000 (0x0030 - 0x0030)
class UEndAnimNotifyStateBattleJustGuard final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBattleJustGuard">();
	}
	static class UEndAnimNotifyStateBattleJustGuard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBattleJustGuard>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBattleJustGuard) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBattleJustGuard");
static_assert(sizeof(UEndAnimNotifyStateBattleJustGuard) == 0x000030, "Wrong size on UEndAnimNotifyStateBattleJustGuard");

// Class EndGame.EndEnemyReportMenu
// 0x0510 (0x0940 - 0x0430)
class UEndEnemyReportMenu : public UEndMainMenuWindow
{
public:
	uint8                                         Pad_430[0x80];                                     // 0x0430(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndStringScrollBox*                    _DetailFlavorTipsDescriptionScrollBox;             // 0x04B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndTextBlock*                          _DetailScrollTextBlock;                            // 0x04B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C0[0x460];                                    // 0x04C0(0x0460)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DetailFadeInOutLenght;                             // 0x0920(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterDitherFadeInLenght;                       // 0x0924(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationYMin;                                      // 0x0928(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationYMax;                                      // 0x092C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationYDefault;                                  // 0x0930(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationXSpeed;                                    // 0x0934(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationYSpeed;                                    // 0x0938(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_93C[0x4];                                      // 0x093C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAbilityListSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnActionTypeListSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnAreaListSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnBattleLogListSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnBuffIconSetup(class UWidget* ItemWidget, int32 CellIndex);
	void OnDebuffIconSetup(class UWidget* ItemWidget, int32 CellIndex);
	void OnDetailAreaListSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnDetailBattleLogListSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnDropItemListSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	struct FVector2D OnEnemyListMeasureItem(int32 CellIndex);
	void OnEnemyListPressedItem(int32 CellIndex);
	void OnEnemyListSelectedIndexChanged(int32 CellIndex);
	void OnEnemyListSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnRareDropItemListSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnResistanceIconListSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnResistanceListSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnStealListSetupItem(class UWidget* ItemWidget, int32 CellIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnemyReportMenu">();
	}
	static class UEndEnemyReportMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnemyReportMenu>();
	}
};
static_assert(alignof(UEndEnemyReportMenu) == 0x000008, "Wrong alignment on UEndEnemyReportMenu");
static_assert(sizeof(UEndEnemyReportMenu) == 0x000940, "Wrong size on UEndEnemyReportMenu");
static_assert(offsetof(UEndEnemyReportMenu, _DetailFlavorTipsDescriptionScrollBox) == 0x0004B0, "Member 'UEndEnemyReportMenu::_DetailFlavorTipsDescriptionScrollBox' has a wrong offset!");
static_assert(offsetof(UEndEnemyReportMenu, _DetailScrollTextBlock) == 0x0004B8, "Member 'UEndEnemyReportMenu::_DetailScrollTextBlock' has a wrong offset!");
static_assert(offsetof(UEndEnemyReportMenu, DetailFadeInOutLenght) == 0x000920, "Member 'UEndEnemyReportMenu::DetailFadeInOutLenght' has a wrong offset!");
static_assert(offsetof(UEndEnemyReportMenu, CharacterDitherFadeInLenght) == 0x000924, "Member 'UEndEnemyReportMenu::CharacterDitherFadeInLenght' has a wrong offset!");
static_assert(offsetof(UEndEnemyReportMenu, RotationYMin) == 0x000928, "Member 'UEndEnemyReportMenu::RotationYMin' has a wrong offset!");
static_assert(offsetof(UEndEnemyReportMenu, RotationYMax) == 0x00092C, "Member 'UEndEnemyReportMenu::RotationYMax' has a wrong offset!");
static_assert(offsetof(UEndEnemyReportMenu, RotationYDefault) == 0x000930, "Member 'UEndEnemyReportMenu::RotationYDefault' has a wrong offset!");
static_assert(offsetof(UEndEnemyReportMenu, RotationXSpeed) == 0x000934, "Member 'UEndEnemyReportMenu::RotationXSpeed' has a wrong offset!");
static_assert(offsetof(UEndEnemyReportMenu, RotationYSpeed) == 0x000938, "Member 'UEndEnemyReportMenu::RotationYSpeed' has a wrong offset!");

// Class EndGame.EndNavCustomQueryFilter
// 0x0000 (0x0048 - 0x0048)
class UEndNavCustomQueryFilter final : public UEndNavQueryFilterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavCustomQueryFilter">();
	}
	static class UEndNavCustomQueryFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavCustomQueryFilter>();
	}
};
static_assert(alignof(UEndNavCustomQueryFilter) == 0x000008, "Wrong alignment on UEndNavCustomQueryFilter");
static_assert(sizeof(UEndNavCustomQueryFilter) == 0x000048, "Wrong size on UEndNavCustomQueryFilter");

// Class EndGame.EndBattleAIEN9000Controller
// 0x0028 (0x22B0 - 0x2288)
class AEndBattleAIEN9000Controller final : public AEndBattleAIController
{
public:
	uint8                                         Pad_2288[0x1C];                                    // 0x2288(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRepulsiveXY;                                      // 0x22A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRepulsiveZ;                                       // 0x22A5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLineDefence;                                      // 0x22A6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22A7[0x9];                                     // 0x22A7(0x0009)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddChildSyncAction(class FName parentSyncActionID, class FName childSyncActionID, class AEndCharacter* ownerChara, class AEndCharacter* targetChara);
	void CreateSyncActionPlayFromLoop(class FName parentSyncActionID, class FName childSyncActionID1, class FName childSyncActionID2, class FName childSyncActionID3, class FName childSyncActionID4, class FName childOwnerCharaName1, class FName childOwnerCharaName2, class FName childOwnerCharaName3, class FName childOwnerCharaName4, class FName TargetCharaName);
	void DisappearChildSyncAction(class FName parentSyncActionID, class AEndCharacter* parentOwnerChara);
	void ResetEndCutSceneCorrectionHeight(class FName CharaName);
	void ResetEndCutSceneTransformCorrection(class FName CharaName);
	void SetDisableTarget(bool disable);
	void SetLineDefence(bool InVisible);
	void SetLineDefencePoint(const struct FVector& PointA, const struct FVector& PointB);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEN9000Controller">();
	}
	static class AEndBattleAIEN9000Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEN9000Controller>();
	}
};
static_assert(alignof(AEndBattleAIEN9000Controller) == 0x000008, "Wrong alignment on AEndBattleAIEN9000Controller");
static_assert(sizeof(AEndBattleAIEN9000Controller) == 0x0022B0, "Wrong size on AEndBattleAIEN9000Controller");
static_assert(offsetof(AEndBattleAIEN9000Controller, bRepulsiveXY) == 0x0022A4, "Member 'AEndBattleAIEN9000Controller::bRepulsiveXY' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEN9000Controller, bRepulsiveZ) == 0x0022A5, "Member 'AEndBattleAIEN9000Controller::bRepulsiveZ' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEN9000Controller, bLineDefence) == 0x0022A6, "Member 'AEndBattleAIEN9000Controller::bLineDefence' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateBattleKeep
// 0x0008 (0x0038 - 0x0030)
class UEndAnimNotifyStateBattleKeep final : public UAnimNotifyState
{
public:
	int32                                         Value;                                             // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBattleKeep">();
	}
	static class UEndAnimNotifyStateBattleKeep* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBattleKeep>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBattleKeep) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBattleKeep");
static_assert(sizeof(UEndAnimNotifyStateBattleKeep) == 0x000038, "Wrong size on UEndAnimNotifyStateBattleKeep");
static_assert(offsetof(UEndAnimNotifyStateBattleKeep, Value) == 0x000030, "Member 'UEndAnimNotifyStateBattleKeep::Value' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateBattlePressedButton
// 0x0010 (0x0040 - 0x0030)
class UEndAnimNotifyStateBattlePressedButton final : public UAnimNotifyState
{
public:
	float                                         Power;                                             // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPower;                                          // 0x0034(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBattlePressedButton">();
	}
	static class UEndAnimNotifyStateBattlePressedButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBattlePressedButton>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBattlePressedButton) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBattlePressedButton");
static_assert(sizeof(UEndAnimNotifyStateBattlePressedButton) == 0x000040, "Wrong size on UEndAnimNotifyStateBattlePressedButton");
static_assert(offsetof(UEndAnimNotifyStateBattlePressedButton, Power) == 0x000030, "Member 'UEndAnimNotifyStateBattlePressedButton::Power' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBattlePressedButton, MaxPower) == 0x000034, "Member 'UEndAnimNotifyStateBattlePressedButton::MaxPower' has a wrong offset!");

// Class EndGame.EndBattleAIEN2007_00Controller
// 0x0058 (0x22E0 - 0x2288)
class AEndBattleAIEN2007_00Controller final : public AEndBattleAIController
{
public:
	uint8                                         Pad_2288[0x58];                                    // 0x2288(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRequestSmogDash(int32 InCount);
	void SetNextSmogDash(float InDistance, float InAngle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEN2007_00Controller">();
	}
	static class AEndBattleAIEN2007_00Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEN2007_00Controller>();
	}
};
static_assert(alignof(AEndBattleAIEN2007_00Controller) == 0x000008, "Wrong alignment on AEndBattleAIEN2007_00Controller");
static_assert(sizeof(AEndBattleAIEN2007_00Controller) == 0x0022E0, "Wrong size on AEndBattleAIEN2007_00Controller");

// Class EndGame.EndUniqueActionPane
// 0x0080 (0x03E0 - 0x0360)
class UEndUniqueActionPane : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x80];                                     // 0x0360(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndUniqueActionPane">();
	}
	static class UEndUniqueActionPane* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndUniqueActionPane>();
	}
};
static_assert(alignof(UEndUniqueActionPane) == 0x000008, "Wrong alignment on UEndUniqueActionPane");
static_assert(sizeof(UEndUniqueActionPane) == 0x0003E0, "Wrong size on UEndUniqueActionPane");

// Class EndGame.EndAnimNotifyStateBattleSendSocketTransform
// 0x0008 (0x0038 - 0x0030)
class UEndAnimNotifyStateBattleSendSocketTransform final : public UAnimNotifyState
{
public:
	class FName                                   SocketName;                                        // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBattleSendSocketTransform">();
	}
	static class UEndAnimNotifyStateBattleSendSocketTransform* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBattleSendSocketTransform>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBattleSendSocketTransform) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBattleSendSocketTransform");
static_assert(sizeof(UEndAnimNotifyStateBattleSendSocketTransform) == 0x000038, "Wrong size on UEndAnimNotifyStateBattleSendSocketTransform");
static_assert(offsetof(UEndAnimNotifyStateBattleSendSocketTransform, SocketName) == 0x000030, "Member 'UEndAnimNotifyStateBattleSendSocketTransform::SocketName' has a wrong offset!");

// Class EndGame.EndBTService_AIPCSearchSafeLocation
// 0x0028 (0x0098 - 0x0070)
class UEndBTService_AIPCSearchSafeLocation final : public UBTService
{
public:
	struct FBlackboardKeySelector                 SafeLocationBlackboardKey;                         // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTService_AIPCSearchSafeLocation">();
	}
	static class UEndBTService_AIPCSearchSafeLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTService_AIPCSearchSafeLocation>();
	}
};
static_assert(alignof(UEndBTService_AIPCSearchSafeLocation) == 0x000008, "Wrong alignment on UEndBTService_AIPCSearchSafeLocation");
static_assert(sizeof(UEndBTService_AIPCSearchSafeLocation) == 0x000098, "Wrong size on UEndBTService_AIPCSearchSafeLocation");
static_assert(offsetof(UEndBTService_AIPCSearchSafeLocation, SafeLocationBlackboardKey) == 0x000070, "Member 'UEndBTService_AIPCSearchSafeLocation::SafeLocationBlackboardKey' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateBattleSetPushCollisionEnable
// 0x0010 (0x0040 - 0x0030)
class UEndAnimNotifyStateBattleSetPushCollisionEnable final : public UAnimNotifyState
{
public:
	class FName                                   CharaPartsSpecID;                                  // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBattleSetPushCollisionEnable">();
	}
	static class UEndAnimNotifyStateBattleSetPushCollisionEnable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBattleSetPushCollisionEnable>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBattleSetPushCollisionEnable) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBattleSetPushCollisionEnable");
static_assert(sizeof(UEndAnimNotifyStateBattleSetPushCollisionEnable) == 0x000040, "Wrong size on UEndAnimNotifyStateBattleSetPushCollisionEnable");
static_assert(offsetof(UEndAnimNotifyStateBattleSetPushCollisionEnable, CharaPartsSpecID) == 0x000030, "Member 'UEndAnimNotifyStateBattleSetPushCollisionEnable::CharaPartsSpecID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBattleSetPushCollisionEnable, bEnable) == 0x000038, "Member 'UEndAnimNotifyStateBattleSetPushCollisionEnable::bEnable' has a wrong offset!");

// Class EndGame.EndEnvironmentPhysActorSpawner
// 0x0030 (0x03A8 - 0x0378)
class AEndEnvironmentPhysActorSpawner final : public AActor
{
public:
	bool                                          bRunBegin;                                         // 0x0378(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnWithImpulse;                                 // 0x0379(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37A[0x6];                                      // 0x037A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEndEnvironmentPhysActorSpawnerParam> SpawnParams;                                       // 0x0380(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bEnableImpulse;                                    // 0x0390(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndEnvironmentPhysForceScale                 ImpulseScale;                                      // 0x0391(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_392[0x2];                                      // 0x0392(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ImpulseOrigin;                                     // 0x0394(0x000C)(Edit, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseRadius;                                     // 0x03A0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A4[0x4];                                      // 0x03A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvironmentPhysActorSpawner">();
	}
	static class AEndEnvironmentPhysActorSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndEnvironmentPhysActorSpawner>();
	}
};
static_assert(alignof(AEndEnvironmentPhysActorSpawner) == 0x000008, "Wrong alignment on AEndEnvironmentPhysActorSpawner");
static_assert(sizeof(AEndEnvironmentPhysActorSpawner) == 0x0003A8, "Wrong size on AEndEnvironmentPhysActorSpawner");
static_assert(offsetof(AEndEnvironmentPhysActorSpawner, bRunBegin) == 0x000378, "Member 'AEndEnvironmentPhysActorSpawner::bRunBegin' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentPhysActorSpawner, bSpawnWithImpulse) == 0x000379, "Member 'AEndEnvironmentPhysActorSpawner::bSpawnWithImpulse' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentPhysActorSpawner, SpawnParams) == 0x000380, "Member 'AEndEnvironmentPhysActorSpawner::SpawnParams' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentPhysActorSpawner, bEnableImpulse) == 0x000390, "Member 'AEndEnvironmentPhysActorSpawner::bEnableImpulse' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentPhysActorSpawner, ImpulseScale) == 0x000391, "Member 'AEndEnvironmentPhysActorSpawner::ImpulseScale' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentPhysActorSpawner, ImpulseOrigin) == 0x000394, "Member 'AEndEnvironmentPhysActorSpawner::ImpulseOrigin' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentPhysActorSpawner, ImpulseRadius) == 0x0003A0, "Member 'AEndEnvironmentPhysActorSpawner::ImpulseRadius' has a wrong offset!");

// Class EndGame.EndBattleAIPCRecognitionVolume
// 0x0078 (0x03F0 - 0x0378)
class AEndBattleAIPCRecognitionVolume final : public AActor
{
public:
	EAIPCRecognitionVolumeType                    VolumeType;                                        // 0x0378(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_379[0x3];                                      // 0x0379(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        GroupID;                                           // 0x037C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          BoxComponent;                                      // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_388[0x68];                                     // 0x0388(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIPCRecognitionVolume">();
	}
	static class AEndBattleAIPCRecognitionVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIPCRecognitionVolume>();
	}
};
static_assert(alignof(AEndBattleAIPCRecognitionVolume) == 0x000008, "Wrong alignment on AEndBattleAIPCRecognitionVolume");
static_assert(sizeof(AEndBattleAIPCRecognitionVolume) == 0x0003F0, "Wrong size on AEndBattleAIPCRecognitionVolume");
static_assert(offsetof(AEndBattleAIPCRecognitionVolume, VolumeType) == 0x000378, "Member 'AEndBattleAIPCRecognitionVolume::VolumeType' has a wrong offset!");
static_assert(offsetof(AEndBattleAIPCRecognitionVolume, GroupID) == 0x00037C, "Member 'AEndBattleAIPCRecognitionVolume::GroupID' has a wrong offset!");
static_assert(offsetof(AEndBattleAIPCRecognitionVolume, BoxComponent) == 0x000380, "Member 'AEndBattleAIPCRecognitionVolume::BoxComponent' has a wrong offset!");

// Class EndGame.UEndBTD_IsTargetPraeco
// 0x0000 (0x0068 - 0x0068)
class UUEndBTD_IsTargetPraeco final : public UEndBTDecorator_CheckConditionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UEndBTD_IsTargetPraeco">();
	}
	static class UUEndBTD_IsTargetPraeco* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUEndBTD_IsTargetPraeco>();
	}
};
static_assert(alignof(UUEndBTD_IsTargetPraeco) == 0x000008, "Wrong alignment on UUEndBTD_IsTargetPraeco");
static_assert(sizeof(UUEndBTD_IsTargetPraeco) == 0x000068, "Wrong size on UUEndBTD_IsTargetPraeco");

// Class EndGame.EndAnimNotifyStateBattleSetSpecialStatusChangeState
// 0x0038 (0x0068 - 0x0030)
class UEndAnimNotifyStateBattleSetSpecialStatusChangeState final : public UAnimNotifyState
{
public:
	EEndBattleSpecialStatusChangeType             Type;                                              // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BeginStateChangeID;                                // 0x0034(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           BeginParamIDs;                                     // 0x0040(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   EndStateChangeID;                                  // 0x0050(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           EndParamIDs;                                       // 0x0058(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBattleSetSpecialStatusChangeState">();
	}
	static class UEndAnimNotifyStateBattleSetSpecialStatusChangeState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBattleSetSpecialStatusChangeState>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBattleSetSpecialStatusChangeState) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBattleSetSpecialStatusChangeState");
static_assert(sizeof(UEndAnimNotifyStateBattleSetSpecialStatusChangeState) == 0x000068, "Wrong size on UEndAnimNotifyStateBattleSetSpecialStatusChangeState");
static_assert(offsetof(UEndAnimNotifyStateBattleSetSpecialStatusChangeState, Type) == 0x000030, "Member 'UEndAnimNotifyStateBattleSetSpecialStatusChangeState::Type' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBattleSetSpecialStatusChangeState, BeginStateChangeID) == 0x000034, "Member 'UEndAnimNotifyStateBattleSetSpecialStatusChangeState::BeginStateChangeID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBattleSetSpecialStatusChangeState, BeginParamIDs) == 0x000040, "Member 'UEndAnimNotifyStateBattleSetSpecialStatusChangeState::BeginParamIDs' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBattleSetSpecialStatusChangeState, EndStateChangeID) == 0x000050, "Member 'UEndAnimNotifyStateBattleSetSpecialStatusChangeState::EndStateChangeID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBattleSetSpecialStatusChangeState, EndParamIDs) == 0x000058, "Member 'UEndAnimNotifyStateBattleSetSpecialStatusChangeState::EndParamIDs' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateBattleStatusChangeDebuffDisable
// 0x0000 (0x0030 - 0x0030)
class UEndAnimNotifyStateBattleStatusChangeDebuffDisable final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBattleStatusChangeDebuffDisable">();
	}
	static class UEndAnimNotifyStateBattleStatusChangeDebuffDisable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBattleStatusChangeDebuffDisable>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBattleStatusChangeDebuffDisable) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBattleStatusChangeDebuffDisable");
static_assert(sizeof(UEndAnimNotifyStateBattleStatusChangeDebuffDisable) == 0x000030, "Wrong size on UEndAnimNotifyStateBattleStatusChangeDebuffDisable");

// Class EndGame.EndMovePoint
// 0x0000 (0x0378 - 0x0378)
class AEndMovePoint final : public ATargetPoint
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMovePoint">();
	}
	static class AEndMovePoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndMovePoint>();
	}
};
static_assert(alignof(AEndMovePoint) == 0x000008, "Wrong alignment on AEndMovePoint");
static_assert(sizeof(AEndMovePoint) == 0x000378, "Wrong size on AEndMovePoint");

// Class EndGame.EndBTTask_MoveTo
// 0x0068 (0x00D8 - 0x0070)
class UEndBTTask_MoveTo : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 LocationBlackboardKey;                             // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 LookAtBlackboardKey;                               // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)
	EEndAiMoveType                                MoveType;                                          // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndQueryFilterType                           NavQueryFilterType;                                // 0x00C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x2];                                       // 0x00C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ArrivalRadius;                                     // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsStrafe;                                          // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFixMove;                                         // 0x00C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopMoveWhenFinished;                              // 0x00CA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CB[0x1];                                       // 0x00CB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceSwitchWalkMode;                            // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MoveRequestBlackBoardName;                         // 0x00D0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_MoveTo">();
	}
	static class UEndBTTask_MoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_MoveTo>();
	}
};
static_assert(alignof(UEndBTTask_MoveTo) == 0x000008, "Wrong alignment on UEndBTTask_MoveTo");
static_assert(sizeof(UEndBTTask_MoveTo) == 0x0000D8, "Wrong size on UEndBTTask_MoveTo");
static_assert(offsetof(UEndBTTask_MoveTo, LocationBlackboardKey) == 0x000070, "Member 'UEndBTTask_MoveTo::LocationBlackboardKey' has a wrong offset!");
static_assert(offsetof(UEndBTTask_MoveTo, LookAtBlackboardKey) == 0x000098, "Member 'UEndBTTask_MoveTo::LookAtBlackboardKey' has a wrong offset!");
static_assert(offsetof(UEndBTTask_MoveTo, MoveType) == 0x0000C0, "Member 'UEndBTTask_MoveTo::MoveType' has a wrong offset!");
static_assert(offsetof(UEndBTTask_MoveTo, NavQueryFilterType) == 0x0000C1, "Member 'UEndBTTask_MoveTo::NavQueryFilterType' has a wrong offset!");
static_assert(offsetof(UEndBTTask_MoveTo, ArrivalRadius) == 0x0000C4, "Member 'UEndBTTask_MoveTo::ArrivalRadius' has a wrong offset!");
static_assert(offsetof(UEndBTTask_MoveTo, IsStrafe) == 0x0000C8, "Member 'UEndBTTask_MoveTo::IsStrafe' has a wrong offset!");
static_assert(offsetof(UEndBTTask_MoveTo, IsFixMove) == 0x0000C9, "Member 'UEndBTTask_MoveTo::IsFixMove' has a wrong offset!");
static_assert(offsetof(UEndBTTask_MoveTo, StopMoveWhenFinished) == 0x0000CA, "Member 'UEndBTTask_MoveTo::StopMoveWhenFinished' has a wrong offset!");
static_assert(offsetof(UEndBTTask_MoveTo, DistanceSwitchWalkMode) == 0x0000CC, "Member 'UEndBTTask_MoveTo::DistanceSwitchWalkMode' has a wrong offset!");
static_assert(offsetof(UEndBTTask_MoveTo, MoveRequestBlackBoardName) == 0x0000D0, "Member 'UEndBTTask_MoveTo::MoveRequestBlackBoardName' has a wrong offset!");

// Class EndGame.EndBattleAISU0002_02Controller
// 0x0058 (0x22E0 - 0x2288)
class AEndBattleAISU0002_02Controller final : public AEndBattleAIController
{
public:
	float                                         BarrierSpeed;                                      // 0x2288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BarrierRange;                                      // 0x228C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BarrierForceRange;                                 // 0x2290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SpinOffset;                                        // 0x2294(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpinRadius;                                        // 0x22A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpinSpeed;                                         // 0x22A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpinAxisSpeed;                                     // 0x22A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22AC[0x34];                                    // 0x22AC(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHitDamage();
	void OnIfritRoar();
	void OnSuspend();
	void SetTargetDamageSource(class UEndBattleDamageSourceComponent* InDamageSource);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAISU0002_02Controller">();
	}
	static class AEndBattleAISU0002_02Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAISU0002_02Controller>();
	}
};
static_assert(alignof(AEndBattleAISU0002_02Controller) == 0x000008, "Wrong alignment on AEndBattleAISU0002_02Controller");
static_assert(sizeof(AEndBattleAISU0002_02Controller) == 0x0022E0, "Wrong size on AEndBattleAISU0002_02Controller");
static_assert(offsetof(AEndBattleAISU0002_02Controller, BarrierSpeed) == 0x002288, "Member 'AEndBattleAISU0002_02Controller::BarrierSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0002_02Controller, BarrierRange) == 0x00228C, "Member 'AEndBattleAISU0002_02Controller::BarrierRange' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0002_02Controller, BarrierForceRange) == 0x002290, "Member 'AEndBattleAISU0002_02Controller::BarrierForceRange' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0002_02Controller, SpinOffset) == 0x002294, "Member 'AEndBattleAISU0002_02Controller::SpinOffset' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0002_02Controller, SpinRadius) == 0x0022A0, "Member 'AEndBattleAISU0002_02Controller::SpinRadius' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0002_02Controller, SpinSpeed) == 0x0022A4, "Member 'AEndBattleAISU0002_02Controller::SpinSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0002_02Controller, SpinAxisSpeed) == 0x0022A8, "Member 'AEndBattleAISU0002_02Controller::SpinAxisSpeed' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateBattleSuperArmor
// 0x0008 (0x0038 - 0x0030)
class UEndAnimNotifyStateBattleSuperArmor final : public UAnimNotifyState
{
public:
	bool                                          disableAdditive;                                   // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBattleSuperArmor">();
	}
	static class UEndAnimNotifyStateBattleSuperArmor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBattleSuperArmor>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBattleSuperArmor) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBattleSuperArmor");
static_assert(sizeof(UEndAnimNotifyStateBattleSuperArmor) == 0x000038, "Wrong size on UEndAnimNotifyStateBattleSuperArmor");
static_assert(offsetof(UEndAnimNotifyStateBattleSuperArmor, disableAdditive) == 0x000030, "Member 'UEndAnimNotifyStateBattleSuperArmor::disableAdditive' has a wrong offset!");

// Class EndGame.EndMenuSettings
// 0x0C90 (0x0CB8 - 0x0028)
class UEndMenuSettings final : public UObject
{
public:
	TArray<struct FEndMenuColorMapping>           ColorMappings;                                     // 0x0028(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FEndMenuImageMapping>           IconMappings;                                      // 0x0038(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FEndMenuImageMapping>           ButtonMappings;                                    // 0x0048(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FEndMenuImageMapping>           MemberJoinMappings;                                // 0x0058(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FEndMenuImageMapping>           CommandMenuMemberMappings;                         // 0x0068(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	float                                         MenuBattleAngleY;                                  // 0x0078(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubtitleWaitTime;                                  // 0x007C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayTimeSleepTime;                                 // 0x0080(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         SubtitleWidget;                                    // 0x0088(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         FieldTargetWidget;                                 // 0x00A0(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         BattleTargetWidget;                                // 0x00B8(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         BattleEnemyStatusWidget;                           // 0x00D0(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         FieldMenuWidget;                                   // 0x00E8(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         PauseMenuWidget;                                   // 0x0100(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CountdownWidget;                                   // 0x0118(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         NaviMapWidget;                                     // 0x0130(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CharacterJoinWidget;                               // 0x0148(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CharacterReJoinWidget;                             // 0x0160(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         GameOverWidget;                                    // 0x0178(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         SaveDataAccessWidget;                              // 0x0190(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         TalkLogsWidget;                                    // 0x01A8(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         MessageLogsWidget;                                 // 0x01C0(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         EventProgressWidget;                               // 0x01D8(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         TalkSelectCenterWidget;                            // 0x01F0(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         LocationNameWidget;                                // 0x0208(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         LoadingIconWidget;                                 // 0x0220(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         LocationLoadingWidget;                             // 0x0238(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         BattleEnemyOutsideWidget;                          // 0x0250(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         BattleTextWidget;                                  // 0x0268(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         MessageWindowWidget;                               // 0x0280(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         FontTemplateWidget;                                // 0x0298(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         ChapterNameWidget;                                 // 0x02B0(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         NaviMapIconWidget;                                 // 0x02C8(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         MainMenuWidget;                                    // 0x02E0(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         MainMenuTopWidget;                                 // 0x02F8(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         MainMenuItemWidget;                                // 0x0310(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         MainMenuItemListWidget;                            // 0x0328(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         MainMenuEquipWidget;                               // 0x0340(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         BattleEscape;                                      // 0x0358(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         BattleParryEffectWidget;                           // 0x0370(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         BattleTutorialWidget;                              // 0x0388(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         GBikeStatusWidget;                                 // 0x03A0(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         MapJournalWidget;                                  // 0x03B8(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         BattleLockonMarker;                                // 0x03D0(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         BattleDamageSubTextWidget;                         // 0x03E8(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         MainMenuBattleSettingWidget;                       // 0x0400(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         LevelUpTextWidget;                                 // 0x0418(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         AreaMapWidget;                                     // 0x0430(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         MidgarMenuWidget;                                  // 0x0448(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         StoryMenuWidget;                                   // 0x0460(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         AreaMapCursorWidget;                               // 0x0478(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         AreaMapPlayerIconWidget;                           // 0x0490(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         AreaMapTargetIconWidget;                           // 0x04A8(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         AreaMapButtonWidget;                               // 0x04C0(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         NaviMapFootprintWidget;                            // 0x04D8(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         ShopWidget;                                        // 0x04F0(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         MainMenuSystemWidget;                              // 0x0508(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         MainMenuWeaponUpgradeMenuWidget;                   // 0x0520(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         MainMenuWeaponUpgradeWidget;                       // 0x0538(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         BattleSkillFrameWidget;                            // 0x0550(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         EnemySkillFrameWidget;                             // 0x0568(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         BattleTargetNewWidget;                             // 0x0580(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         MainMenuSaveLoadWidget;                            // 0x0598(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         AtbEffectWidget;                                   // 0x05B0(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         AttackSigneWidget;                                 // 0x05C8(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         BurstStartWidget;                                  // 0x05E0(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         GBikeEnemyStatusWidget;                            // 0x05F8(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         PartyCommandRequestWidget;                         // 0x0610(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         BattleTipsWidget;                                  // 0x0628(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         FieldQuestIconWidget;                              // 0x0640(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CompassWidget;                                     // 0x0658(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         EnemyDetailWidget;                                 // 0x0670(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         MainMenuStatusWidget;                              // 0x0688(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         MainMenuItemSelectMemberWidget;                    // 0x06A0(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         KeyGuideWidget;                                    // 0x06B8(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         ColosseumMenuWidget;                               // 0x06D0(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         ColosseumResultMenuWidget;                         // 0x06E8(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         ColosseumConfirmWindow;                            // 0x0700(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CommandMenuWidget;                                 // 0x0718(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         MainMenuMagicWidget;                               // 0x0730(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         QuestMenuWidget;                                   // 0x0748(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         QuestDetailWidget;                                 // 0x0760(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CinemaButtonWidget;                                // 0x0778(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         QuestCompleteMessageWidget;                        // 0x0790(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         Mako5MonitorsWidget;                               // 0x07A8(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         BattleReportWidget;                                // 0x07C0(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         JukeboxMenuWidget;                                 // 0x07D8(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         StatusSummonIconWidget;                            // 0x07F0(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         ReverseDrainIconWidget;                            // 0x0808(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         EnemyReportWidget;                                 // 0x0820(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         SummonGaugeIcontWidget;                            // 0x0838(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         SummonChantGaugeIcontWidget;                       // 0x0850(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         BattleLockonMarker00Widget;                        // 0x0868(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         BattleLockonMarker01Widget;                        // 0x0880(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         BattleLockonMarker02Widget;                        // 0x0898(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         SoundTitleWidget;                                  // 0x08B0(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         BillboardThrobberWidget;                           // 0x08C8(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         FieldTargetSearchWidget;                           // 0x08E0(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         FieldTargetSearchIconWidget;                       // 0x08F8(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         FieldTarget01Widget;                               // 0x0910(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         ChocoboFastTravelMenuWidget;                       // 0x0928(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         KeyGuideHelpWidget;                                // 0x0940(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         Slum7BoardWidget;                                  // 0x0958(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         MainMenuManualWidget;                              // 0x0970(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         QuickMateriaMenuWidget;                            // 0x0988(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         Undg6MeterWidget;                                  // 0x09A0(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         StatusBuildingFloor;                               // 0x09B8(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         TurnBackAlertWidget;                               // 0x09D0(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         ClearVRCountWidget;                                // 0x09E8(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         MainMenuDlcWidget;                                 // 0x0A00(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         BattleTextNumberWidget;                            // 0x0A18(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         SkippingIconWidget;                                // 0x0A30(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         VRMenuWidget;                                      // 0x0A48(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         VRResultMenuWidget;                                // 0x0A60(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         VRConfirmWindow;                                   // 0x0A78(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         ReturnFastTravelIcontWidget;                       // 0x0A90(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         ColosseumBattleTelop;                              // 0x0AA8(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         VRBattleTelop;                                     // 0x0AC0(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         MainMenuTutorialWindowWidget;                      // 0x0AD8(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         MainMenuTutorialFrameWidget;                       // 0x0AF0(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         ThrobberWidget;                                    // 0x0B08(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         WeakTargetWidget;                                  // 0x0B20(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CondorFortPreapreWidget;                           // 0x0B38(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CondorFortTopWidget;                               // 0x0B50(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         StatusCooperationWidget;                           // 0x0B68(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         StatusIconAffinityWidget;                          // 0x0B80(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CondorFortRoleIconWidget;                          // 0x0B98(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CondorFortEditWidget;                              // 0x0BB0(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         VRplus_MenuWidget;                                 // 0x0BC8(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         VRplus_ResultMenuWidget;                           // 0x0BE0(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         VRplus_ConfirmWindow;                              // 0x0BF8(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CondorFortStatusWidget;                            // 0x0C10(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CameraModeWidget;                                  // 0x0C28(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         SkillFrameEffectWidget;                            // 0x0C40(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         CondorFortTimerWidget;                             // 0x0C58(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         FieldTargetBlockWidget;                            // 0x0C70(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         DlcWindowWidget;                                   // 0x0C88(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         YuffieBoxGameResultWidget;                         // 0x0CA0(0x0018)(Edit, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMenuSettings">();
	}
	static class UEndMenuSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMenuSettings>();
	}
};
static_assert(alignof(UEndMenuSettings) == 0x000008, "Wrong alignment on UEndMenuSettings");
static_assert(sizeof(UEndMenuSettings) == 0x000CB8, "Wrong size on UEndMenuSettings");
static_assert(offsetof(UEndMenuSettings, ColorMappings) == 0x000028, "Member 'UEndMenuSettings::ColorMappings' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, IconMappings) == 0x000038, "Member 'UEndMenuSettings::IconMappings' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, ButtonMappings) == 0x000048, "Member 'UEndMenuSettings::ButtonMappings' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, MemberJoinMappings) == 0x000058, "Member 'UEndMenuSettings::MemberJoinMappings' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, CommandMenuMemberMappings) == 0x000068, "Member 'UEndMenuSettings::CommandMenuMemberMappings' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, MenuBattleAngleY) == 0x000078, "Member 'UEndMenuSettings::MenuBattleAngleY' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, SubtitleWaitTime) == 0x00007C, "Member 'UEndMenuSettings::SubtitleWaitTime' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, PlayTimeSleepTime) == 0x000080, "Member 'UEndMenuSettings::PlayTimeSleepTime' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, SubtitleWidget) == 0x000088, "Member 'UEndMenuSettings::SubtitleWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, FieldTargetWidget) == 0x0000A0, "Member 'UEndMenuSettings::FieldTargetWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, BattleTargetWidget) == 0x0000B8, "Member 'UEndMenuSettings::BattleTargetWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, BattleEnemyStatusWidget) == 0x0000D0, "Member 'UEndMenuSettings::BattleEnemyStatusWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, FieldMenuWidget) == 0x0000E8, "Member 'UEndMenuSettings::FieldMenuWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, PauseMenuWidget) == 0x000100, "Member 'UEndMenuSettings::PauseMenuWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, CountdownWidget) == 0x000118, "Member 'UEndMenuSettings::CountdownWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, NaviMapWidget) == 0x000130, "Member 'UEndMenuSettings::NaviMapWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, CharacterJoinWidget) == 0x000148, "Member 'UEndMenuSettings::CharacterJoinWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, CharacterReJoinWidget) == 0x000160, "Member 'UEndMenuSettings::CharacterReJoinWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, GameOverWidget) == 0x000178, "Member 'UEndMenuSettings::GameOverWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, SaveDataAccessWidget) == 0x000190, "Member 'UEndMenuSettings::SaveDataAccessWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, TalkLogsWidget) == 0x0001A8, "Member 'UEndMenuSettings::TalkLogsWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, MessageLogsWidget) == 0x0001C0, "Member 'UEndMenuSettings::MessageLogsWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, EventProgressWidget) == 0x0001D8, "Member 'UEndMenuSettings::EventProgressWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, TalkSelectCenterWidget) == 0x0001F0, "Member 'UEndMenuSettings::TalkSelectCenterWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, LocationNameWidget) == 0x000208, "Member 'UEndMenuSettings::LocationNameWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, LoadingIconWidget) == 0x000220, "Member 'UEndMenuSettings::LoadingIconWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, LocationLoadingWidget) == 0x000238, "Member 'UEndMenuSettings::LocationLoadingWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, BattleEnemyOutsideWidget) == 0x000250, "Member 'UEndMenuSettings::BattleEnemyOutsideWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, BattleTextWidget) == 0x000268, "Member 'UEndMenuSettings::BattleTextWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, MessageWindowWidget) == 0x000280, "Member 'UEndMenuSettings::MessageWindowWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, FontTemplateWidget) == 0x000298, "Member 'UEndMenuSettings::FontTemplateWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, ChapterNameWidget) == 0x0002B0, "Member 'UEndMenuSettings::ChapterNameWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, NaviMapIconWidget) == 0x0002C8, "Member 'UEndMenuSettings::NaviMapIconWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, MainMenuWidget) == 0x0002E0, "Member 'UEndMenuSettings::MainMenuWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, MainMenuTopWidget) == 0x0002F8, "Member 'UEndMenuSettings::MainMenuTopWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, MainMenuItemWidget) == 0x000310, "Member 'UEndMenuSettings::MainMenuItemWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, MainMenuItemListWidget) == 0x000328, "Member 'UEndMenuSettings::MainMenuItemListWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, MainMenuEquipWidget) == 0x000340, "Member 'UEndMenuSettings::MainMenuEquipWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, BattleEscape) == 0x000358, "Member 'UEndMenuSettings::BattleEscape' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, BattleParryEffectWidget) == 0x000370, "Member 'UEndMenuSettings::BattleParryEffectWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, BattleTutorialWidget) == 0x000388, "Member 'UEndMenuSettings::BattleTutorialWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, GBikeStatusWidget) == 0x0003A0, "Member 'UEndMenuSettings::GBikeStatusWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, MapJournalWidget) == 0x0003B8, "Member 'UEndMenuSettings::MapJournalWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, BattleLockonMarker) == 0x0003D0, "Member 'UEndMenuSettings::BattleLockonMarker' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, BattleDamageSubTextWidget) == 0x0003E8, "Member 'UEndMenuSettings::BattleDamageSubTextWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, MainMenuBattleSettingWidget) == 0x000400, "Member 'UEndMenuSettings::MainMenuBattleSettingWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, LevelUpTextWidget) == 0x000418, "Member 'UEndMenuSettings::LevelUpTextWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, AreaMapWidget) == 0x000430, "Member 'UEndMenuSettings::AreaMapWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, MidgarMenuWidget) == 0x000448, "Member 'UEndMenuSettings::MidgarMenuWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, StoryMenuWidget) == 0x000460, "Member 'UEndMenuSettings::StoryMenuWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, AreaMapCursorWidget) == 0x000478, "Member 'UEndMenuSettings::AreaMapCursorWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, AreaMapPlayerIconWidget) == 0x000490, "Member 'UEndMenuSettings::AreaMapPlayerIconWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, AreaMapTargetIconWidget) == 0x0004A8, "Member 'UEndMenuSettings::AreaMapTargetIconWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, AreaMapButtonWidget) == 0x0004C0, "Member 'UEndMenuSettings::AreaMapButtonWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, NaviMapFootprintWidget) == 0x0004D8, "Member 'UEndMenuSettings::NaviMapFootprintWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, ShopWidget) == 0x0004F0, "Member 'UEndMenuSettings::ShopWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, MainMenuSystemWidget) == 0x000508, "Member 'UEndMenuSettings::MainMenuSystemWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, MainMenuWeaponUpgradeMenuWidget) == 0x000520, "Member 'UEndMenuSettings::MainMenuWeaponUpgradeMenuWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, MainMenuWeaponUpgradeWidget) == 0x000538, "Member 'UEndMenuSettings::MainMenuWeaponUpgradeWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, BattleSkillFrameWidget) == 0x000550, "Member 'UEndMenuSettings::BattleSkillFrameWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, EnemySkillFrameWidget) == 0x000568, "Member 'UEndMenuSettings::EnemySkillFrameWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, BattleTargetNewWidget) == 0x000580, "Member 'UEndMenuSettings::BattleTargetNewWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, MainMenuSaveLoadWidget) == 0x000598, "Member 'UEndMenuSettings::MainMenuSaveLoadWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, AtbEffectWidget) == 0x0005B0, "Member 'UEndMenuSettings::AtbEffectWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, AttackSigneWidget) == 0x0005C8, "Member 'UEndMenuSettings::AttackSigneWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, BurstStartWidget) == 0x0005E0, "Member 'UEndMenuSettings::BurstStartWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, GBikeEnemyStatusWidget) == 0x0005F8, "Member 'UEndMenuSettings::GBikeEnemyStatusWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, PartyCommandRequestWidget) == 0x000610, "Member 'UEndMenuSettings::PartyCommandRequestWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, BattleTipsWidget) == 0x000628, "Member 'UEndMenuSettings::BattleTipsWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, FieldQuestIconWidget) == 0x000640, "Member 'UEndMenuSettings::FieldQuestIconWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, CompassWidget) == 0x000658, "Member 'UEndMenuSettings::CompassWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, EnemyDetailWidget) == 0x000670, "Member 'UEndMenuSettings::EnemyDetailWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, MainMenuStatusWidget) == 0x000688, "Member 'UEndMenuSettings::MainMenuStatusWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, MainMenuItemSelectMemberWidget) == 0x0006A0, "Member 'UEndMenuSettings::MainMenuItemSelectMemberWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, KeyGuideWidget) == 0x0006B8, "Member 'UEndMenuSettings::KeyGuideWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, ColosseumMenuWidget) == 0x0006D0, "Member 'UEndMenuSettings::ColosseumMenuWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, ColosseumResultMenuWidget) == 0x0006E8, "Member 'UEndMenuSettings::ColosseumResultMenuWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, ColosseumConfirmWindow) == 0x000700, "Member 'UEndMenuSettings::ColosseumConfirmWindow' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, CommandMenuWidget) == 0x000718, "Member 'UEndMenuSettings::CommandMenuWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, MainMenuMagicWidget) == 0x000730, "Member 'UEndMenuSettings::MainMenuMagicWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, QuestMenuWidget) == 0x000748, "Member 'UEndMenuSettings::QuestMenuWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, QuestDetailWidget) == 0x000760, "Member 'UEndMenuSettings::QuestDetailWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, CinemaButtonWidget) == 0x000778, "Member 'UEndMenuSettings::CinemaButtonWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, QuestCompleteMessageWidget) == 0x000790, "Member 'UEndMenuSettings::QuestCompleteMessageWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, Mako5MonitorsWidget) == 0x0007A8, "Member 'UEndMenuSettings::Mako5MonitorsWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, BattleReportWidget) == 0x0007C0, "Member 'UEndMenuSettings::BattleReportWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, JukeboxMenuWidget) == 0x0007D8, "Member 'UEndMenuSettings::JukeboxMenuWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, StatusSummonIconWidget) == 0x0007F0, "Member 'UEndMenuSettings::StatusSummonIconWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, ReverseDrainIconWidget) == 0x000808, "Member 'UEndMenuSettings::ReverseDrainIconWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, EnemyReportWidget) == 0x000820, "Member 'UEndMenuSettings::EnemyReportWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, SummonGaugeIcontWidget) == 0x000838, "Member 'UEndMenuSettings::SummonGaugeIcontWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, SummonChantGaugeIcontWidget) == 0x000850, "Member 'UEndMenuSettings::SummonChantGaugeIcontWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, BattleLockonMarker00Widget) == 0x000868, "Member 'UEndMenuSettings::BattleLockonMarker00Widget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, BattleLockonMarker01Widget) == 0x000880, "Member 'UEndMenuSettings::BattleLockonMarker01Widget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, BattleLockonMarker02Widget) == 0x000898, "Member 'UEndMenuSettings::BattleLockonMarker02Widget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, SoundTitleWidget) == 0x0008B0, "Member 'UEndMenuSettings::SoundTitleWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, BillboardThrobberWidget) == 0x0008C8, "Member 'UEndMenuSettings::BillboardThrobberWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, FieldTargetSearchWidget) == 0x0008E0, "Member 'UEndMenuSettings::FieldTargetSearchWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, FieldTargetSearchIconWidget) == 0x0008F8, "Member 'UEndMenuSettings::FieldTargetSearchIconWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, FieldTarget01Widget) == 0x000910, "Member 'UEndMenuSettings::FieldTarget01Widget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, ChocoboFastTravelMenuWidget) == 0x000928, "Member 'UEndMenuSettings::ChocoboFastTravelMenuWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, KeyGuideHelpWidget) == 0x000940, "Member 'UEndMenuSettings::KeyGuideHelpWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, Slum7BoardWidget) == 0x000958, "Member 'UEndMenuSettings::Slum7BoardWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, MainMenuManualWidget) == 0x000970, "Member 'UEndMenuSettings::MainMenuManualWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, QuickMateriaMenuWidget) == 0x000988, "Member 'UEndMenuSettings::QuickMateriaMenuWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, Undg6MeterWidget) == 0x0009A0, "Member 'UEndMenuSettings::Undg6MeterWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, StatusBuildingFloor) == 0x0009B8, "Member 'UEndMenuSettings::StatusBuildingFloor' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, TurnBackAlertWidget) == 0x0009D0, "Member 'UEndMenuSettings::TurnBackAlertWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, ClearVRCountWidget) == 0x0009E8, "Member 'UEndMenuSettings::ClearVRCountWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, MainMenuDlcWidget) == 0x000A00, "Member 'UEndMenuSettings::MainMenuDlcWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, BattleTextNumberWidget) == 0x000A18, "Member 'UEndMenuSettings::BattleTextNumberWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, SkippingIconWidget) == 0x000A30, "Member 'UEndMenuSettings::SkippingIconWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, VRMenuWidget) == 0x000A48, "Member 'UEndMenuSettings::VRMenuWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, VRResultMenuWidget) == 0x000A60, "Member 'UEndMenuSettings::VRResultMenuWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, VRConfirmWindow) == 0x000A78, "Member 'UEndMenuSettings::VRConfirmWindow' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, ReturnFastTravelIcontWidget) == 0x000A90, "Member 'UEndMenuSettings::ReturnFastTravelIcontWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, ColosseumBattleTelop) == 0x000AA8, "Member 'UEndMenuSettings::ColosseumBattleTelop' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, VRBattleTelop) == 0x000AC0, "Member 'UEndMenuSettings::VRBattleTelop' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, MainMenuTutorialWindowWidget) == 0x000AD8, "Member 'UEndMenuSettings::MainMenuTutorialWindowWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, MainMenuTutorialFrameWidget) == 0x000AF0, "Member 'UEndMenuSettings::MainMenuTutorialFrameWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, ThrobberWidget) == 0x000B08, "Member 'UEndMenuSettings::ThrobberWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, WeakTargetWidget) == 0x000B20, "Member 'UEndMenuSettings::WeakTargetWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, CondorFortPreapreWidget) == 0x000B38, "Member 'UEndMenuSettings::CondorFortPreapreWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, CondorFortTopWidget) == 0x000B50, "Member 'UEndMenuSettings::CondorFortTopWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, StatusCooperationWidget) == 0x000B68, "Member 'UEndMenuSettings::StatusCooperationWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, StatusIconAffinityWidget) == 0x000B80, "Member 'UEndMenuSettings::StatusIconAffinityWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, CondorFortRoleIconWidget) == 0x000B98, "Member 'UEndMenuSettings::CondorFortRoleIconWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, CondorFortEditWidget) == 0x000BB0, "Member 'UEndMenuSettings::CondorFortEditWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, VRplus_MenuWidget) == 0x000BC8, "Member 'UEndMenuSettings::VRplus_MenuWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, VRplus_ResultMenuWidget) == 0x000BE0, "Member 'UEndMenuSettings::VRplus_ResultMenuWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, VRplus_ConfirmWindow) == 0x000BF8, "Member 'UEndMenuSettings::VRplus_ConfirmWindow' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, CondorFortStatusWidget) == 0x000C10, "Member 'UEndMenuSettings::CondorFortStatusWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, CameraModeWidget) == 0x000C28, "Member 'UEndMenuSettings::CameraModeWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, SkillFrameEffectWidget) == 0x000C40, "Member 'UEndMenuSettings::SkillFrameEffectWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, CondorFortTimerWidget) == 0x000C58, "Member 'UEndMenuSettings::CondorFortTimerWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, FieldTargetBlockWidget) == 0x000C70, "Member 'UEndMenuSettings::FieldTargetBlockWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, DlcWindowWidget) == 0x000C88, "Member 'UEndMenuSettings::DlcWindowWidget' has a wrong offset!");
static_assert(offsetof(UEndMenuSettings, YuffieBoxGameResultWidget) == 0x000CA0, "Member 'UEndMenuSettings::YuffieBoxGameResultWidget' has a wrong offset!");

// Class EndGame.EndBTService_RunEQS
// 0x0000 (0x0120 - 0x0120)
class UEndBTService_RunEQS final : public UBTService_RunEQS
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTService_RunEQS">();
	}
	static class UEndBTService_RunEQS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTService_RunEQS>();
	}
};
static_assert(alignof(UEndBTService_RunEQS) == 0x000008, "Wrong alignment on UEndBTService_RunEQS");
static_assert(sizeof(UEndBTService_RunEQS) == 0x000120, "Wrong size on UEndBTService_RunEQS");

// Class EndGame.EndAnimNotifyStateBattleTargetCorrection
// 0x01A0 (0x01D0 - 0x0030)
class UEndAnimNotifyStateBattleTargetCorrection final : public UAnimNotifyState
{
public:
	EEndBattleTargetCorrectionType                Type;                                              // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideDirectionAngle;                           // 0x0031(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideDirectionAngle;                            // 0x0034(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideDirectionAngleLeftRight;                  // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideDirectionAngleLeft;                        // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideDirectionAngleRight;                       // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideDistance;                                 // 0x0044(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideDistance;                                  // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableDistanceBehind;                            // 0x004C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideNotDistanceMoveStop;                      // 0x004D(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndBattleAbilityTargetCloseMoveType          OverrideNotDistanceMoveStopType;                   // 0x004E(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F[0x181];                                     // 0x004F(0x0181)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBattleTargetCorrection">();
	}
	static class UEndAnimNotifyStateBattleTargetCorrection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBattleTargetCorrection>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBattleTargetCorrection) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBattleTargetCorrection");
static_assert(sizeof(UEndAnimNotifyStateBattleTargetCorrection) == 0x0001D0, "Wrong size on UEndAnimNotifyStateBattleTargetCorrection");
static_assert(offsetof(UEndAnimNotifyStateBattleTargetCorrection, Type) == 0x000030, "Member 'UEndAnimNotifyStateBattleTargetCorrection::Type' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBattleTargetCorrection, bOverrideDirectionAngle) == 0x000031, "Member 'UEndAnimNotifyStateBattleTargetCorrection::bOverrideDirectionAngle' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBattleTargetCorrection, OverrideDirectionAngle) == 0x000034, "Member 'UEndAnimNotifyStateBattleTargetCorrection::OverrideDirectionAngle' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBattleTargetCorrection, bOverrideDirectionAngleLeftRight) == 0x000038, "Member 'UEndAnimNotifyStateBattleTargetCorrection::bOverrideDirectionAngleLeftRight' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBattleTargetCorrection, OverrideDirectionAngleLeft) == 0x00003C, "Member 'UEndAnimNotifyStateBattleTargetCorrection::OverrideDirectionAngleLeft' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBattleTargetCorrection, OverrideDirectionAngleRight) == 0x000040, "Member 'UEndAnimNotifyStateBattleTargetCorrection::OverrideDirectionAngleRight' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBattleTargetCorrection, bOverrideDistance) == 0x000044, "Member 'UEndAnimNotifyStateBattleTargetCorrection::bOverrideDistance' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBattleTargetCorrection, OverrideDistance) == 0x000048, "Member 'UEndAnimNotifyStateBattleTargetCorrection::OverrideDistance' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBattleTargetCorrection, bDisableDistanceBehind) == 0x00004C, "Member 'UEndAnimNotifyStateBattleTargetCorrection::bDisableDistanceBehind' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBattleTargetCorrection, bOverrideNotDistanceMoveStop) == 0x00004D, "Member 'UEndAnimNotifyStateBattleTargetCorrection::bOverrideNotDistanceMoveStop' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBattleTargetCorrection, OverrideNotDistanceMoveStopType) == 0x00004E, "Member 'UEndAnimNotifyStateBattleTargetCorrection::OverrideNotDistanceMoveStopType' has a wrong offset!");

// Class EndGame.EndEnvironmentPhysicsStaticMeshActor
// 0x02D8 (0x06B8 - 0x03E0)
class AEndEnvironmentPhysicsStaticMeshActor final : public AEndEnvironmentStaticMeshActor
{
public:
	bool                                          bNoPhysOffLock;                                    // 0x03E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoInitMask;                                       // 0x03E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreStateManagement;                            // 0x03E2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bParentCollisionPresetsToOther;                    // 0x03E3(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E4[0x4];                                      // 0x03E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEndPhysicsChangeCollisionResponseData> EnabledChangeCollisionResponses;                   // 0x03E8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UStaticMesh*>                    OtherStaticMeshs;                                  // 0x03F8(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class UStaticMeshComponent*>           OtherStaticMeshComponents;                         // 0x0408(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        AssetUserData;                                     // 0x0418(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class FName                                   EnvironmentPhysicsSpecName;                        // 0x0428(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEndPhysicsSeSetting                   SeSetting;                                         // 0x0430(0x00B0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bPostLoadedLevelAwake;                             // 0x04E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeverAwake;                                       // 0x04E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E2[0x6];                                      // 0x04E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndItemDropComponent*                  ItemDropComponent;                                 // 0x04E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      BattleOverlapCapsuleComponent;                     // 0x04F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F8[0x108];                                    // 0x04F8(0x0108)(Fixing Size After Last Property [ Dumper-7 ])
	class USQEXSEADSound*                         HitSoundAsset;                                     // 0x0600(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USQEXSEADSound*                         FractureSoundAsset;                                // 0x0608(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_610[0xA8];                                     // 0x0610(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnEndImpulseInterval();
	void PlayHitSe_TimerFunc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvironmentPhysicsStaticMeshActor">();
	}
	static class AEndEnvironmentPhysicsStaticMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndEnvironmentPhysicsStaticMeshActor>();
	}
};
static_assert(alignof(AEndEnvironmentPhysicsStaticMeshActor) == 0x000008, "Wrong alignment on AEndEnvironmentPhysicsStaticMeshActor");
static_assert(sizeof(AEndEnvironmentPhysicsStaticMeshActor) == 0x0006B8, "Wrong size on AEndEnvironmentPhysicsStaticMeshActor");
static_assert(offsetof(AEndEnvironmentPhysicsStaticMeshActor, bNoPhysOffLock) == 0x0003E0, "Member 'AEndEnvironmentPhysicsStaticMeshActor::bNoPhysOffLock' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentPhysicsStaticMeshActor, bNoInitMask) == 0x0003E1, "Member 'AEndEnvironmentPhysicsStaticMeshActor::bNoInitMask' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentPhysicsStaticMeshActor, bIgnoreStateManagement) == 0x0003E2, "Member 'AEndEnvironmentPhysicsStaticMeshActor::bIgnoreStateManagement' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentPhysicsStaticMeshActor, bParentCollisionPresetsToOther) == 0x0003E3, "Member 'AEndEnvironmentPhysicsStaticMeshActor::bParentCollisionPresetsToOther' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentPhysicsStaticMeshActor, EnabledChangeCollisionResponses) == 0x0003E8, "Member 'AEndEnvironmentPhysicsStaticMeshActor::EnabledChangeCollisionResponses' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentPhysicsStaticMeshActor, OtherStaticMeshs) == 0x0003F8, "Member 'AEndEnvironmentPhysicsStaticMeshActor::OtherStaticMeshs' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentPhysicsStaticMeshActor, OtherStaticMeshComponents) == 0x000408, "Member 'AEndEnvironmentPhysicsStaticMeshActor::OtherStaticMeshComponents' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentPhysicsStaticMeshActor, AssetUserData) == 0x000418, "Member 'AEndEnvironmentPhysicsStaticMeshActor::AssetUserData' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentPhysicsStaticMeshActor, EnvironmentPhysicsSpecName) == 0x000428, "Member 'AEndEnvironmentPhysicsStaticMeshActor::EnvironmentPhysicsSpecName' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentPhysicsStaticMeshActor, SeSetting) == 0x000430, "Member 'AEndEnvironmentPhysicsStaticMeshActor::SeSetting' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentPhysicsStaticMeshActor, bPostLoadedLevelAwake) == 0x0004E0, "Member 'AEndEnvironmentPhysicsStaticMeshActor::bPostLoadedLevelAwake' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentPhysicsStaticMeshActor, bNeverAwake) == 0x0004E1, "Member 'AEndEnvironmentPhysicsStaticMeshActor::bNeverAwake' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentPhysicsStaticMeshActor, ItemDropComponent) == 0x0004E8, "Member 'AEndEnvironmentPhysicsStaticMeshActor::ItemDropComponent' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentPhysicsStaticMeshActor, BattleOverlapCapsuleComponent) == 0x0004F0, "Member 'AEndEnvironmentPhysicsStaticMeshActor::BattleOverlapCapsuleComponent' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentPhysicsStaticMeshActor, HitSoundAsset) == 0x000600, "Member 'AEndEnvironmentPhysicsStaticMeshActor::HitSoundAsset' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentPhysicsStaticMeshActor, FractureSoundAsset) == 0x000608, "Member 'AEndEnvironmentPhysicsStaticMeshActor::FractureSoundAsset' has a wrong offset!");

// Class EndGame.EndBattleAISononController
// 0x0160 (0x3A00 - 0x38A0)
class AEndBattleAISononController final : public AEndBattleAIPcBaseController
{
public:
	float                                         LinkCommandMaxDistanceToLeader;                    // 0x38A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LinkCommandBestDistanceToLeader;                   // 0x38A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LinkCommandTeleportMinDistance;                    // 0x38A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LinkCommandFirstStrikeDistance;                    // 0x38AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LinkCommandFirstStrikeDiffHeight;                  // 0x38B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   LinkCommandFirstStrikeAbility;                     // 0x38B4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LinkAfterEscortWarpDeterTime;                      // 0x38BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SacrificeAbilityID;                                // 0x38C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBattleParam                           ConcentrationBattleParam;                          // 0x38C8(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         DummyTargetDistanceDefault;                        // 0x38F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SacrificeDamageSourceID_Heal;                      // 0x38FC(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SacrificeDamageSourceID_ATB;                       // 0x3904(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SacrificeDamageSourceID_Damage;                    // 0x390C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3914[0x4];                                     // 0x3914(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, float>                      DummyTargetDistanceLists;                          // 0x3918(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3968[0x98];                                    // 0x3968(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool RequestLinkAbility(class FName ID, EEndLinkAbilityType Type, bool bSupport, bool bAerial, bool bDoWithoutTarget, bool bInstance);
	void StartSacrifice();
	void TeleportToCachedLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAISononController">();
	}
	static class AEndBattleAISononController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAISononController>();
	}
};
static_assert(alignof(AEndBattleAISononController) == 0x000008, "Wrong alignment on AEndBattleAISononController");
static_assert(sizeof(AEndBattleAISononController) == 0x003A00, "Wrong size on AEndBattleAISononController");
static_assert(offsetof(AEndBattleAISononController, LinkCommandMaxDistanceToLeader) == 0x0038A0, "Member 'AEndBattleAISononController::LinkCommandMaxDistanceToLeader' has a wrong offset!");
static_assert(offsetof(AEndBattleAISononController, LinkCommandBestDistanceToLeader) == 0x0038A4, "Member 'AEndBattleAISononController::LinkCommandBestDistanceToLeader' has a wrong offset!");
static_assert(offsetof(AEndBattleAISononController, LinkCommandTeleportMinDistance) == 0x0038A8, "Member 'AEndBattleAISononController::LinkCommandTeleportMinDistance' has a wrong offset!");
static_assert(offsetof(AEndBattleAISononController, LinkCommandFirstStrikeDistance) == 0x0038AC, "Member 'AEndBattleAISononController::LinkCommandFirstStrikeDistance' has a wrong offset!");
static_assert(offsetof(AEndBattleAISononController, LinkCommandFirstStrikeDiffHeight) == 0x0038B0, "Member 'AEndBattleAISononController::LinkCommandFirstStrikeDiffHeight' has a wrong offset!");
static_assert(offsetof(AEndBattleAISononController, LinkCommandFirstStrikeAbility) == 0x0038B4, "Member 'AEndBattleAISononController::LinkCommandFirstStrikeAbility' has a wrong offset!");
static_assert(offsetof(AEndBattleAISononController, LinkAfterEscortWarpDeterTime) == 0x0038BC, "Member 'AEndBattleAISononController::LinkAfterEscortWarpDeterTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAISononController, SacrificeAbilityID) == 0x0038C0, "Member 'AEndBattleAISononController::SacrificeAbilityID' has a wrong offset!");
static_assert(offsetof(AEndBattleAISononController, ConcentrationBattleParam) == 0x0038C8, "Member 'AEndBattleAISononController::ConcentrationBattleParam' has a wrong offset!");
static_assert(offsetof(AEndBattleAISononController, DummyTargetDistanceDefault) == 0x0038F8, "Member 'AEndBattleAISononController::DummyTargetDistanceDefault' has a wrong offset!");
static_assert(offsetof(AEndBattleAISononController, SacrificeDamageSourceID_Heal) == 0x0038FC, "Member 'AEndBattleAISononController::SacrificeDamageSourceID_Heal' has a wrong offset!");
static_assert(offsetof(AEndBattleAISononController, SacrificeDamageSourceID_ATB) == 0x003904, "Member 'AEndBattleAISononController::SacrificeDamageSourceID_ATB' has a wrong offset!");
static_assert(offsetof(AEndBattleAISononController, SacrificeDamageSourceID_Damage) == 0x00390C, "Member 'AEndBattleAISononController::SacrificeDamageSourceID_Damage' has a wrong offset!");
static_assert(offsetof(AEndBattleAISononController, DummyTargetDistanceLists) == 0x003918, "Member 'AEndBattleAISononController::DummyTargetDistanceLists' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateBikeAllyMove
// 0x0008 (0x0038 - 0x0030)
class UEndAnimNotifyStateBikeAllyMove final : public UAnimNotifyState
{
public:
	uint8                                         EnabledHitCount;                                   // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MileageOffset;                                     // 0x0034(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBikeAllyMove">();
	}
	static class UEndAnimNotifyStateBikeAllyMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBikeAllyMove>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBikeAllyMove) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBikeAllyMove");
static_assert(sizeof(UEndAnimNotifyStateBikeAllyMove) == 0x000038, "Wrong size on UEndAnimNotifyStateBikeAllyMove");
static_assert(offsetof(UEndAnimNotifyStateBikeAllyMove, EnabledHitCount) == 0x000030, "Member 'UEndAnimNotifyStateBikeAllyMove::EnabledHitCount' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeAllyMove, MileageOffset) == 0x000034, "Member 'UEndAnimNotifyStateBikeAllyMove::MileageOffset' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateBikeCameraRoll
// 0x0010 (0x0040 - 0x0030)
class UEndAnimNotifyStateBikeCameraRoll final : public UAnimNotifyState
{
public:
	float                                         RollAngle;                                         // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurningPointRatio;                                 // 0x0034(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InterpExp;                                         // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBikeCameraRoll">();
	}
	static class UEndAnimNotifyStateBikeCameraRoll* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBikeCameraRoll>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBikeCameraRoll) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBikeCameraRoll");
static_assert(sizeof(UEndAnimNotifyStateBikeCameraRoll) == 0x000040, "Wrong size on UEndAnimNotifyStateBikeCameraRoll");
static_assert(offsetof(UEndAnimNotifyStateBikeCameraRoll, RollAngle) == 0x000030, "Member 'UEndAnimNotifyStateBikeCameraRoll::RollAngle' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeCameraRoll, TurningPointRatio) == 0x000034, "Member 'UEndAnimNotifyStateBikeCameraRoll::TurningPointRatio' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeCameraRoll, InterpExp) == 0x000038, "Member 'UEndAnimNotifyStateBikeCameraRoll::InterpExp' has a wrong offset!");

// Class EndGame.EndBTService_AIPCSearchCoverLocation
// 0x0028 (0x0098 - 0x0070)
class UEndBTService_AIPCSearchCoverLocation final : public UBTService
{
public:
	struct FBlackboardKeySelector                 CoverLocationBlackboardKey;                        // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTService_AIPCSearchCoverLocation">();
	}
	static class UEndBTService_AIPCSearchCoverLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTService_AIPCSearchCoverLocation>();
	}
};
static_assert(alignof(UEndBTService_AIPCSearchCoverLocation) == 0x000008, "Wrong alignment on UEndBTService_AIPCSearchCoverLocation");
static_assert(sizeof(UEndBTService_AIPCSearchCoverLocation) == 0x000098, "Wrong size on UEndBTService_AIPCSearchCoverLocation");
static_assert(offsetof(UEndBTService_AIPCSearchCoverLocation, CoverLocationBlackboardKey) == 0x000070, "Member 'UEndBTService_AIPCSearchCoverLocation::CoverLocationBlackboardKey' has a wrong offset!");

// Class EndGame.EndBattleAIMessageNotifyState
// 0x0010 (0x0040 - 0x0030)
class UEndBattleAIMessageNotifyState final : public UAnimNotifyState
{
public:
	class FName                                   Message;                                           // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntValue;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatValue;                                        // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIMessageNotifyState">();
	}
	static class UEndBattleAIMessageNotifyState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleAIMessageNotifyState>();
	}
};
static_assert(alignof(UEndBattleAIMessageNotifyState) == 0x000008, "Wrong alignment on UEndBattleAIMessageNotifyState");
static_assert(sizeof(UEndBattleAIMessageNotifyState) == 0x000040, "Wrong size on UEndBattleAIMessageNotifyState");
static_assert(offsetof(UEndBattleAIMessageNotifyState, Message) == 0x000030, "Member 'UEndBattleAIMessageNotifyState::Message' has a wrong offset!");
static_assert(offsetof(UEndBattleAIMessageNotifyState, IntValue) == 0x000038, "Member 'UEndBattleAIMessageNotifyState::IntValue' has a wrong offset!");
static_assert(offsetof(UEndBattleAIMessageNotifyState, FloatValue) == 0x00003C, "Member 'UEndBattleAIMessageNotifyState::FloatValue' has a wrong offset!");

// Class EndGame.AnimNotify_EndFA0122Message
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_EndFA0122Message final : public UAnimNotify
{
public:
	EFA0122_ArmMessage                            Message;                                           // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EndFA0122Message">();
	}
	static class UAnimNotify_EndFA0122Message* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EndFA0122Message>();
	}
};
static_assert(alignof(UAnimNotify_EndFA0122Message) == 0x000008, "Wrong alignment on UAnimNotify_EndFA0122Message");
static_assert(sizeof(UAnimNotify_EndFA0122Message) == 0x000040, "Wrong size on UAnimNotify_EndFA0122Message");
static_assert(offsetof(UAnimNotify_EndFA0122Message, Message) == 0x000038, "Member 'UAnimNotify_EndFA0122Message::Message' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateBikeDamage
// 0x0068 (0x0098 - 0x0030)
class UEndAnimNotifyStateBikeDamage final : public UAnimNotifyState
{
public:
	class FName                                   DamageSourceID;                                    // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndBattleDamageSourcePositionBaseType        CreatePositionBase;                                // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CreatePositionName;                                // 0x003C(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AActor*>                           mDestroyDamageSourceOnEnd;                         // 0x0048(0x0050)(BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBikeDamage">();
	}
	static class UEndAnimNotifyStateBikeDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBikeDamage>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBikeDamage) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBikeDamage");
static_assert(sizeof(UEndAnimNotifyStateBikeDamage) == 0x000098, "Wrong size on UEndAnimNotifyStateBikeDamage");
static_assert(offsetof(UEndAnimNotifyStateBikeDamage, DamageSourceID) == 0x000030, "Member 'UEndAnimNotifyStateBikeDamage::DamageSourceID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeDamage, CreatePositionBase) == 0x000038, "Member 'UEndAnimNotifyStateBikeDamage::CreatePositionBase' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeDamage, CreatePositionName) == 0x00003C, "Member 'UEndAnimNotifyStateBikeDamage::CreatePositionName' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeDamage, mDestroyDamageSourceOnEnd) == 0x000048, "Member 'UEndAnimNotifyStateBikeDamage::mDestroyDamageSourceOnEnd' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateBikeDanger
// 0x0018 (0x0048 - 0x0030)
class UEndAnimNotifyStateBikeDanger final : public UAnimNotifyState
{
public:
	class FName                                   BaseSocketName;                                    // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Offset;                                            // 0x0038(0x000C)(Edit, BlueprintReadOnly, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBikeDanger">();
	}
	static class UEndAnimNotifyStateBikeDanger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBikeDanger>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBikeDanger) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBikeDanger");
static_assert(sizeof(UEndAnimNotifyStateBikeDanger) == 0x000048, "Wrong size on UEndAnimNotifyStateBikeDanger");
static_assert(offsetof(UEndAnimNotifyStateBikeDanger, BaseSocketName) == 0x000030, "Member 'UEndAnimNotifyStateBikeDanger::BaseSocketName' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeDanger, Offset) == 0x000038, "Member 'UEndAnimNotifyStateBikeDanger::Offset' has a wrong offset!");

// Class EndGame.EndDataObjectTalkInsertSetting
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectTalkInsertSetting final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectTalkInsertSetting">();
	}
	static class UEndDataObjectTalkInsertSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectTalkInsertSetting>();
	}
};
static_assert(alignof(UEndDataObjectTalkInsertSetting) == 0x000008, "Wrong alignment on UEndDataObjectTalkInsertSetting");
static_assert(sizeof(UEndDataObjectTalkInsertSetting) == 0x000088, "Wrong size on UEndDataObjectTalkInsertSetting");

// Class EndGame.EndSkeletalMeshComponent
// 0x0420 (0x14D0 - 0x10B0)
#pragma pack(push, 0x1)
class alignas(0x10) UEndSkeletalMeshComponent : public USkeletalMeshComponentBudgeted
{
public:
	class USkeletalMeshComponent*                 SyncPoseComponent;                                 // 0x10A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEndPhysicalConstraintEvaluator        PhysicalConstraintEvaluator;                       // 0x10B0(0x01C8)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FEndPhysicalConstraintEvaluator        PostPhysicalConstraintEvaluator;                   // 0x1278(0x01C8)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bAutoLinkAttachChildren : 1;                       // 0x1440(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1441[0x3F];                                    // 0x1441(0x003F)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 PrerequisiteMesh;                                  // 0x1480(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USQEX_KBD_Component*                    PrerequisiteKBD;                                   // 0x1488(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class USkeletalMeshComponent*>         LinkedMeshes;                                      // 0x1490(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14A0[0x28];                                    // 0x14A0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndSkeletalMeshComponent">();
	}
	static class UEndSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndSkeletalMeshComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UEndSkeletalMeshComponent) == 0x000010, "Wrong alignment on UEndSkeletalMeshComponent");
static_assert(sizeof(UEndSkeletalMeshComponent) == 0x0014D0, "Wrong size on UEndSkeletalMeshComponent");
static_assert(offsetof(UEndSkeletalMeshComponent, SyncPoseComponent) == 0x0010A8, "Member 'UEndSkeletalMeshComponent::SyncPoseComponent' has a wrong offset!");
static_assert(offsetof(UEndSkeletalMeshComponent, PhysicalConstraintEvaluator) == 0x0010B0, "Member 'UEndSkeletalMeshComponent::PhysicalConstraintEvaluator' has a wrong offset!");
static_assert(offsetof(UEndSkeletalMeshComponent, PostPhysicalConstraintEvaluator) == 0x001278, "Member 'UEndSkeletalMeshComponent::PostPhysicalConstraintEvaluator' has a wrong offset!");
static_assert(offsetof(UEndSkeletalMeshComponent, PrerequisiteMesh) == 0x001480, "Member 'UEndSkeletalMeshComponent::PrerequisiteMesh' has a wrong offset!");
static_assert(offsetof(UEndSkeletalMeshComponent, PrerequisiteKBD) == 0x001488, "Member 'UEndSkeletalMeshComponent::PrerequisiteKBD' has a wrong offset!");
static_assert(offsetof(UEndSkeletalMeshComponent, LinkedMeshes) == 0x001490, "Member 'UEndSkeletalMeshComponent::LinkedMeshes' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateBikeDangerWithLockonMarker
// 0x0018 (0x0048 - 0x0030)
class UEndAnimNotifyStateBikeDangerWithLockonMarker final : public UAnimNotifyState
{
public:
	class FName                                   DamageSourceID;                                    // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDeleteMarkerOnEnd;                                // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0xF];                                       // 0x0039(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBikeDangerWithLockonMarker">();
	}
	static class UEndAnimNotifyStateBikeDangerWithLockonMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBikeDangerWithLockonMarker>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBikeDangerWithLockonMarker) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBikeDangerWithLockonMarker");
static_assert(sizeof(UEndAnimNotifyStateBikeDangerWithLockonMarker) == 0x000048, "Wrong size on UEndAnimNotifyStateBikeDangerWithLockonMarker");
static_assert(offsetof(UEndAnimNotifyStateBikeDangerWithLockonMarker, DamageSourceID) == 0x000030, "Member 'UEndAnimNotifyStateBikeDangerWithLockonMarker::DamageSourceID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeDangerWithLockonMarker, bDeleteMarkerOnEnd) == 0x000038, "Member 'UEndAnimNotifyStateBikeDangerWithLockonMarker::bDeleteMarkerOnEnd' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateBikeDisableAddBlend
// 0x0010 (0x0040 - 0x0030)
class UEndAnimNotifyStateBikeDisableAddBlend final : public UAnimNotifyState
{
public:
	float                                         BlendOutTime;                                      // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0034(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBikeDisableAddBlend">();
	}
	static class UEndAnimNotifyStateBikeDisableAddBlend* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBikeDisableAddBlend>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBikeDisableAddBlend) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBikeDisableAddBlend");
static_assert(sizeof(UEndAnimNotifyStateBikeDisableAddBlend) == 0x000040, "Wrong size on UEndAnimNotifyStateBikeDisableAddBlend");
static_assert(offsetof(UEndAnimNotifyStateBikeDisableAddBlend, BlendOutTime) == 0x000030, "Member 'UEndAnimNotifyStateBikeDisableAddBlend::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeDisableAddBlend, BlendInTime) == 0x000034, "Member 'UEndAnimNotifyStateBikeDisableAddBlend::BlendInTime' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeDisableAddBlend, Priority) == 0x000038, "Member 'UEndAnimNotifyStateBikeDisableAddBlend::Priority' has a wrong offset!");

// Class EndGame.EndMainEquipSelectButtonText
// 0x0000 (0x0360 - 0x0360)
class UEndMainEquipSelectButtonText final : public UEndUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainEquipSelectButtonText">();
	}
	static class UEndMainEquipSelectButtonText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainEquipSelectButtonText>();
	}
};
static_assert(alignof(UEndMainEquipSelectButtonText) == 0x000008, "Wrong alignment on UEndMainEquipSelectButtonText");
static_assert(sizeof(UEndMainEquipSelectButtonText) == 0x000360, "Wrong size on UEndMainEquipSelectButtonText");

// Class EndGame.EndBattleAISU0005Controller
// 0x0058 (0x22E0 - 0x2288)
class AEndBattleAISU0005Controller final : public AEndBattleAIController
{
public:
	float                                         MeteorDivePrepareRotateYaw;                        // 0x2288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeteorDivePrepareRotatePitch;                      // 0x228C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeteorDiveLoopRotateYaw;                           // 0x2290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeteorDiveLoopRotatePitch;                         // 0x2294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeteorDiveBeginSpeed;                              // 0x2298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeteorDiveAddSpeed;                                // 0x229C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeteorDiveOffsetZ;                                 // 0x22A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A4[0x3C];                                    // 0x22A4(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OverrideTargetLocation(bool enableOverride, const struct FVector& overrideLocation);
	void ResetAIPCOverrideCautionDistance(EPlayerType PlayerType);
	void SetAIPCOverrideCautionDistance(EPlayerType PlayerType, float Distance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAISU0005Controller">();
	}
	static class AEndBattleAISU0005Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAISU0005Controller>();
	}
};
static_assert(alignof(AEndBattleAISU0005Controller) == 0x000008, "Wrong alignment on AEndBattleAISU0005Controller");
static_assert(sizeof(AEndBattleAISU0005Controller) == 0x0022E0, "Wrong size on AEndBattleAISU0005Controller");
static_assert(offsetof(AEndBattleAISU0005Controller, MeteorDivePrepareRotateYaw) == 0x002288, "Member 'AEndBattleAISU0005Controller::MeteorDivePrepareRotateYaw' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0005Controller, MeteorDivePrepareRotatePitch) == 0x00228C, "Member 'AEndBattleAISU0005Controller::MeteorDivePrepareRotatePitch' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0005Controller, MeteorDiveLoopRotateYaw) == 0x002290, "Member 'AEndBattleAISU0005Controller::MeteorDiveLoopRotateYaw' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0005Controller, MeteorDiveLoopRotatePitch) == 0x002294, "Member 'AEndBattleAISU0005Controller::MeteorDiveLoopRotatePitch' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0005Controller, MeteorDiveBeginSpeed) == 0x002298, "Member 'AEndBattleAISU0005Controller::MeteorDiveBeginSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0005Controller, MeteorDiveAddSpeed) == 0x00229C, "Member 'AEndBattleAISU0005Controller::MeteorDiveAddSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0005Controller, MeteorDiveOffsetZ) == 0x0022A0, "Member 'AEndBattleAISU0005Controller::MeteorDiveOffsetZ' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateBikeExtraRadius
// 0x0008 (0x0038 - 0x0030)
class UEndAnimNotifyStateBikeExtraRadius final : public UAnimNotifyState
{
public:
	float                                         ExtraRadius;                                       // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBikeExtraRadius">();
	}
	static class UEndAnimNotifyStateBikeExtraRadius* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBikeExtraRadius>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBikeExtraRadius) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBikeExtraRadius");
static_assert(sizeof(UEndAnimNotifyStateBikeExtraRadius) == 0x000038, "Wrong size on UEndAnimNotifyStateBikeExtraRadius");
static_assert(offsetof(UEndAnimNotifyStateBikeExtraRadius, ExtraRadius) == 0x000030, "Member 'UEndAnimNotifyStateBikeExtraRadius::ExtraRadius' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateBikeHitFilter
// 0x0058 (0x0088 - 0x0030)
class UEndAnimNotifyStateBikeHitFilter final : public UAnimNotifyState
{
public:
	EEndBikeHitFilterPartsType                    PartsType;                                         // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<EEndBikeAbilityDistanceType>             PassAbilityDistanceTypes;                          // 0x0038(0x0050)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBikeHitFilter">();
	}
	static class UEndAnimNotifyStateBikeHitFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBikeHitFilter>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBikeHitFilter) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBikeHitFilter");
static_assert(sizeof(UEndAnimNotifyStateBikeHitFilter) == 0x000088, "Wrong size on UEndAnimNotifyStateBikeHitFilter");
static_assert(offsetof(UEndAnimNotifyStateBikeHitFilter, PartsType) == 0x000030, "Member 'UEndAnimNotifyStateBikeHitFilter::PartsType' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeHitFilter, PassAbilityDistanceTypes) == 0x000038, "Member 'UEndAnimNotifyStateBikeHitFilter::PassAbilityDistanceTypes' has a wrong offset!");

// Class EndGame.EndDataObjectTalkSpeaker
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectTalkSpeaker final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectTalkSpeaker">();
	}
	static class UEndDataObjectTalkSpeaker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectTalkSpeaker>();
	}
};
static_assert(alignof(UEndDataObjectTalkSpeaker) == 0x000008, "Wrong alignment on UEndDataObjectTalkSpeaker");
static_assert(sizeof(UEndDataObjectTalkSpeaker) == 0x000088, "Wrong size on UEndDataObjectTalkSpeaker");

// Class EndGame.EndLockOnSiteDrawComponent
// 0x0000 (0x00F8 - 0x00F8)
class UEndLockOnSiteDrawComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndLockOnSiteDrawComponent">();
	}
	static class UEndLockOnSiteDrawComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndLockOnSiteDrawComponent>();
	}
};
static_assert(alignof(UEndLockOnSiteDrawComponent) == 0x000008, "Wrong alignment on UEndLockOnSiteDrawComponent");
static_assert(sizeof(UEndLockOnSiteDrawComponent) == 0x0000F8, "Wrong size on UEndLockOnSiteDrawComponent");

// Class EndGame.EndBattleAIBarretController
// 0x0000 (0x38A0 - 0x38A0)
class AEndBattleAIBarretController final : public AEndBattleAIPcBaseController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIBarretController">();
	}
	static class AEndBattleAIBarretController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIBarretController>();
	}
};
static_assert(alignof(AEndBattleAIBarretController) == 0x000008, "Wrong alignment on AEndBattleAIBarretController");
static_assert(sizeof(AEndBattleAIBarretController) == 0x0038A0, "Wrong size on AEndBattleAIBarretController");

// Class EndGame.EndAnimNotifyStateBikeKeepRelativePosition
// 0x0008 (0x0038 - 0x0030)
class UEndAnimNotifyStateBikeKeepRelativePosition final : public UAnimNotifyState
{
public:
	EEndBikeKeepRelativePositionType              Type;                                              // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Position;                                          // 0x0034(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBikeKeepRelativePosition">();
	}
	static class UEndAnimNotifyStateBikeKeepRelativePosition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBikeKeepRelativePosition>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBikeKeepRelativePosition) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBikeKeepRelativePosition");
static_assert(sizeof(UEndAnimNotifyStateBikeKeepRelativePosition) == 0x000038, "Wrong size on UEndAnimNotifyStateBikeKeepRelativePosition");
static_assert(offsetof(UEndAnimNotifyStateBikeKeepRelativePosition, Type) == 0x000030, "Member 'UEndAnimNotifyStateBikeKeepRelativePosition::Type' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeKeepRelativePosition, Position) == 0x000034, "Member 'UEndAnimNotifyStateBikeKeepRelativePosition::Position' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateBikeLaserPointer
// 0x0030 (0x0060 - 0x0030)
class UEndAnimNotifyStateBikeLaserPointer final : public UAnimNotifyState
{
public:
	uint8                                         ID;                                                // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndBikeLaserPointerEffectResourceCategory    EffectResourceCategory;                            // 0x0031(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EffectResourceName;                                // 0x0034(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingDelayTime;                                   // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingSpeed;                                       // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndBikeLaserPointerCharacterType             FromCharacterType;                                 // 0x0044(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FromSocketName;                                    // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndBikeLaserPointerCharacterType             TargetCharacterType;                               // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TargetSocketName;                                  // 0x0054(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBikeLaserPointer">();
	}
	static class UEndAnimNotifyStateBikeLaserPointer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBikeLaserPointer>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBikeLaserPointer) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBikeLaserPointer");
static_assert(sizeof(UEndAnimNotifyStateBikeLaserPointer) == 0x000060, "Wrong size on UEndAnimNotifyStateBikeLaserPointer");
static_assert(offsetof(UEndAnimNotifyStateBikeLaserPointer, ID) == 0x000030, "Member 'UEndAnimNotifyStateBikeLaserPointer::ID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeLaserPointer, EffectResourceCategory) == 0x000031, "Member 'UEndAnimNotifyStateBikeLaserPointer::EffectResourceCategory' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeLaserPointer, EffectResourceName) == 0x000034, "Member 'UEndAnimNotifyStateBikeLaserPointer::EffectResourceName' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeLaserPointer, HomingDelayTime) == 0x00003C, "Member 'UEndAnimNotifyStateBikeLaserPointer::HomingDelayTime' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeLaserPointer, HomingSpeed) == 0x000040, "Member 'UEndAnimNotifyStateBikeLaserPointer::HomingSpeed' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeLaserPointer, FromCharacterType) == 0x000044, "Member 'UEndAnimNotifyStateBikeLaserPointer::FromCharacterType' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeLaserPointer, FromSocketName) == 0x000048, "Member 'UEndAnimNotifyStateBikeLaserPointer::FromSocketName' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeLaserPointer, TargetCharacterType) == 0x000050, "Member 'UEndAnimNotifyStateBikeLaserPointer::TargetCharacterType' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeLaserPointer, TargetSocketName) == 0x000054, "Member 'UEndAnimNotifyStateBikeLaserPointer::TargetSocketName' has a wrong offset!");

// Class EndGame.EndBalancingSolver
// 0x0018 (0x0040 - 0x0028)
class UEndBalancingSolver final : public UObject
{
public:
	float                                         AngleInterpSpeed;                                  // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEndBalancingSolveBone>         Bones;                                             // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBalancingSolver">();
	}
	static class UEndBalancingSolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBalancingSolver>();
	}
};
static_assert(alignof(UEndBalancingSolver) == 0x000008, "Wrong alignment on UEndBalancingSolver");
static_assert(sizeof(UEndBalancingSolver) == 0x000040, "Wrong size on UEndBalancingSolver");
static_assert(offsetof(UEndBalancingSolver, AngleInterpSpeed) == 0x000028, "Member 'UEndBalancingSolver::AngleInterpSpeed' has a wrong offset!");
static_assert(offsetof(UEndBalancingSolver, Bones) == 0x000030, "Member 'UEndBalancingSolver::Bones' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateBikeLockonMarker
// 0x0010 (0x0040 - 0x0030)
class UEndAnimNotifyStateBikeLockonMarker final : public UAnimNotifyState
{
public:
	EEndBikeLaserPointerCharacterType             TargetCharacterType;                               // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TargetSocketName;                                  // 0x0034(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBikeLockonMarker">();
	}
	static class UEndAnimNotifyStateBikeLockonMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBikeLockonMarker>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBikeLockonMarker) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBikeLockonMarker");
static_assert(sizeof(UEndAnimNotifyStateBikeLockonMarker) == 0x000040, "Wrong size on UEndAnimNotifyStateBikeLockonMarker");
static_assert(offsetof(UEndAnimNotifyStateBikeLockonMarker, TargetCharacterType) == 0x000030, "Member 'UEndAnimNotifyStateBikeLockonMarker::TargetCharacterType' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeLockonMarker, TargetSocketName) == 0x000034, "Member 'UEndAnimNotifyStateBikeLockonMarker::TargetSocketName' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateBikeMoveStatusUI
// 0x0018 (0x0048 - 0x0030)
class UEndAnimNotifyStateBikeMoveStatusUI final : public UAnimNotifyState
{
public:
	class FName                                   SocketName;                                        // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZOffset;                                           // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveInTime;                                        // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveOutTime;                                       // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBikeMoveStatusUI">();
	}
	static class UEndAnimNotifyStateBikeMoveStatusUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBikeMoveStatusUI>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBikeMoveStatusUI) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBikeMoveStatusUI");
static_assert(sizeof(UEndAnimNotifyStateBikeMoveStatusUI) == 0x000048, "Wrong size on UEndAnimNotifyStateBikeMoveStatusUI");
static_assert(offsetof(UEndAnimNotifyStateBikeMoveStatusUI, SocketName) == 0x000030, "Member 'UEndAnimNotifyStateBikeMoveStatusUI::SocketName' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeMoveStatusUI, ZOffset) == 0x000038, "Member 'UEndAnimNotifyStateBikeMoveStatusUI::ZOffset' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeMoveStatusUI, MoveInTime) == 0x00003C, "Member 'UEndAnimNotifyStateBikeMoveStatusUI::MoveInTime' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeMoveStatusUI, MoveOutTime) == 0x000040, "Member 'UEndAnimNotifyStateBikeMoveStatusUI::MoveOutTime' has a wrong offset!");

// Class EndGame.EndDataObjectTestPlayModeSettingData
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectTestPlayModeSettingData final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectTestPlayModeSettingData">();
	}
	static class UEndDataObjectTestPlayModeSettingData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectTestPlayModeSettingData>();
	}
};
static_assert(alignof(UEndDataObjectTestPlayModeSettingData) == 0x000008, "Wrong alignment on UEndDataObjectTestPlayModeSettingData");
static_assert(sizeof(UEndDataObjectTestPlayModeSettingData) == 0x000088, "Wrong size on UEndDataObjectTestPlayModeSettingData");

// Class EndGame.EndBattleAISU0004Controller
// 0x0008 (0x2340 - 0x2338)
class AEndBattleAISU0004Controller final : public AEndBattleAIFitSplineController
{
public:
	float                                         Su0004AirTurnThreshold;                            // 0x2338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_233C[0x4];                                     // 0x233C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RequestTornadoFollowLocation(int32 InIndex, const struct FVector& InLocation, float InTolerance);
	void UpdateAirTurn(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAISU0004Controller">();
	}
	static class AEndBattleAISU0004Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAISU0004Controller>();
	}
};
static_assert(alignof(AEndBattleAISU0004Controller) == 0x000008, "Wrong alignment on AEndBattleAISU0004Controller");
static_assert(sizeof(AEndBattleAISU0004Controller) == 0x002340, "Wrong size on AEndBattleAISU0004Controller");
static_assert(offsetof(AEndBattleAISU0004Controller, Su0004AirTurnThreshold) == 0x002338, "Member 'AEndBattleAISU0004Controller::Su0004AirTurnThreshold' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateBikeNextAbility
// 0x0000 (0x0030 - 0x0030)
class UEndAnimNotifyStateBikeNextAbility final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBikeNextAbility">();
	}
	static class UEndAnimNotifyStateBikeNextAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBikeNextAbility>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBikeNextAbility) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBikeNextAbility");
static_assert(sizeof(UEndAnimNotifyStateBikeNextAbility) == 0x000030, "Wrong size on UEndAnimNotifyStateBikeNextAbility");

// Class EndGame.EndAnimNotifyStateBikeNextAction
// 0x0008 (0x0038 - 0x0030)
class UEndAnimNotifyStateBikeNextAction final : public UAnimNotifyState
{
public:
	uint8                                         Pad_30[0x1];                                       // 0x0030(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAbility;                                          // 0x0031(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x1];                                       // 0x0032(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAccel;                                            // 0x0033(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBikeNextAction">();
	}
	static class UEndAnimNotifyStateBikeNextAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBikeNextAction>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBikeNextAction) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBikeNextAction");
static_assert(sizeof(UEndAnimNotifyStateBikeNextAction) == 0x000038, "Wrong size on UEndAnimNotifyStateBikeNextAction");
static_assert(offsetof(UEndAnimNotifyStateBikeNextAction, bAbility) == 0x000031, "Member 'UEndAnimNotifyStateBikeNextAction::bAbility' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeNextAction, bAccel) == 0x000033, "Member 'UEndAnimNotifyStateBikeNextAction::bAccel' has a wrong offset!");

// Class EndGame.EndMainManualDetailMenu
// 0x0208 (0x0568 - 0x0360)
class UEndMainManualDetailMenu : public UEndUserWidget
{
public:
	class UEndCanvasPanel*                        Block0;                                            // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Group00;                                           // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt00;                                             // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Img00;                                             // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndBillboard*                          Billboard_00;                                      // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Group01;                                           // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt01;                                             // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Img01;                                             // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndBillboard*                          Billboard_01;                                      // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Group02;                                           // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt02;                                             // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Img02;                                             // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndBillboard*                          Billboard_02;                                      // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Block1;                                            // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Group10;                                           // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt10;                                             // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Img10;                                             // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndBillboard*                          Billboard_10;                                      // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Group11;                                           // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt11;                                             // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Img11;                                             // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndBillboard*                          Billboard_11;                                      // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Group12;                                           // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt12;                                             // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Img12;                                             // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndBillboard*                          Billboard_12;                                      // 0x0428(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Block2;                                            // 0x0430(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Group20;                                           // 0x0438(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt20;                                             // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Img20;                                             // 0x0448(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndBillboard*                          Billboard_20;                                      // 0x0450(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Group21;                                           // 0x0458(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt21;                                             // 0x0460(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Img21;                                             // 0x0468(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndBillboard*                          Billboard_21;                                      // 0x0470(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Group22;                                           // 0x0478(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt22;                                             // 0x0480(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Img22;                                             // 0x0488(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndBillboard*                          Billboard_22;                                      // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Block3;                                            // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Group30;                                           // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt30;                                             // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Img30;                                             // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndBillboard*                          Billboard_30;                                      // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Group31;                                           // 0x04C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt31;                                             // 0x04C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Img31;                                             // 0x04D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndBillboard*                          Billboard_31;                                      // 0x04D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Group32;                                           // 0x04E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt32;                                             // 0x04E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Img32;                                             // 0x04F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndBillboard*                          Billboard_32;                                      // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Block4;                                            // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Group40;                                           // 0x0508(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt40;                                             // 0x0510(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Img40;                                             // 0x0518(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndBillboard*                          Billboard_40;                                      // 0x0520(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Group41;                                           // 0x0528(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt41;                                             // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Img41;                                             // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndBillboard*                          Billboard_41;                                      // 0x0540(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Group42;                                           // 0x0548(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt42;                                             // 0x0550(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Img42;                                             // 0x0558(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndBillboard*                          Billboard_42;                                      // 0x0560(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainManualDetailMenu">();
	}
	static class UEndMainManualDetailMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainManualDetailMenu>();
	}
};
static_assert(alignof(UEndMainManualDetailMenu) == 0x000008, "Wrong alignment on UEndMainManualDetailMenu");
static_assert(sizeof(UEndMainManualDetailMenu) == 0x000568, "Wrong size on UEndMainManualDetailMenu");
static_assert(offsetof(UEndMainManualDetailMenu, Block0) == 0x000360, "Member 'UEndMainManualDetailMenu::Block0' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Group00) == 0x000368, "Member 'UEndMainManualDetailMenu::Group00' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Txt00) == 0x000370, "Member 'UEndMainManualDetailMenu::Txt00' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Img00) == 0x000378, "Member 'UEndMainManualDetailMenu::Img00' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Billboard_00) == 0x000380, "Member 'UEndMainManualDetailMenu::Billboard_00' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Group01) == 0x000388, "Member 'UEndMainManualDetailMenu::Group01' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Txt01) == 0x000390, "Member 'UEndMainManualDetailMenu::Txt01' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Img01) == 0x000398, "Member 'UEndMainManualDetailMenu::Img01' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Billboard_01) == 0x0003A0, "Member 'UEndMainManualDetailMenu::Billboard_01' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Group02) == 0x0003A8, "Member 'UEndMainManualDetailMenu::Group02' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Txt02) == 0x0003B0, "Member 'UEndMainManualDetailMenu::Txt02' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Img02) == 0x0003B8, "Member 'UEndMainManualDetailMenu::Img02' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Billboard_02) == 0x0003C0, "Member 'UEndMainManualDetailMenu::Billboard_02' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Block1) == 0x0003C8, "Member 'UEndMainManualDetailMenu::Block1' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Group10) == 0x0003D0, "Member 'UEndMainManualDetailMenu::Group10' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Txt10) == 0x0003D8, "Member 'UEndMainManualDetailMenu::Txt10' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Img10) == 0x0003E0, "Member 'UEndMainManualDetailMenu::Img10' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Billboard_10) == 0x0003E8, "Member 'UEndMainManualDetailMenu::Billboard_10' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Group11) == 0x0003F0, "Member 'UEndMainManualDetailMenu::Group11' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Txt11) == 0x0003F8, "Member 'UEndMainManualDetailMenu::Txt11' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Img11) == 0x000400, "Member 'UEndMainManualDetailMenu::Img11' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Billboard_11) == 0x000408, "Member 'UEndMainManualDetailMenu::Billboard_11' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Group12) == 0x000410, "Member 'UEndMainManualDetailMenu::Group12' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Txt12) == 0x000418, "Member 'UEndMainManualDetailMenu::Txt12' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Img12) == 0x000420, "Member 'UEndMainManualDetailMenu::Img12' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Billboard_12) == 0x000428, "Member 'UEndMainManualDetailMenu::Billboard_12' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Block2) == 0x000430, "Member 'UEndMainManualDetailMenu::Block2' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Group20) == 0x000438, "Member 'UEndMainManualDetailMenu::Group20' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Txt20) == 0x000440, "Member 'UEndMainManualDetailMenu::Txt20' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Img20) == 0x000448, "Member 'UEndMainManualDetailMenu::Img20' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Billboard_20) == 0x000450, "Member 'UEndMainManualDetailMenu::Billboard_20' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Group21) == 0x000458, "Member 'UEndMainManualDetailMenu::Group21' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Txt21) == 0x000460, "Member 'UEndMainManualDetailMenu::Txt21' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Img21) == 0x000468, "Member 'UEndMainManualDetailMenu::Img21' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Billboard_21) == 0x000470, "Member 'UEndMainManualDetailMenu::Billboard_21' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Group22) == 0x000478, "Member 'UEndMainManualDetailMenu::Group22' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Txt22) == 0x000480, "Member 'UEndMainManualDetailMenu::Txt22' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Img22) == 0x000488, "Member 'UEndMainManualDetailMenu::Img22' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Billboard_22) == 0x000490, "Member 'UEndMainManualDetailMenu::Billboard_22' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Block3) == 0x000498, "Member 'UEndMainManualDetailMenu::Block3' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Group30) == 0x0004A0, "Member 'UEndMainManualDetailMenu::Group30' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Txt30) == 0x0004A8, "Member 'UEndMainManualDetailMenu::Txt30' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Img30) == 0x0004B0, "Member 'UEndMainManualDetailMenu::Img30' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Billboard_30) == 0x0004B8, "Member 'UEndMainManualDetailMenu::Billboard_30' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Group31) == 0x0004C0, "Member 'UEndMainManualDetailMenu::Group31' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Txt31) == 0x0004C8, "Member 'UEndMainManualDetailMenu::Txt31' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Img31) == 0x0004D0, "Member 'UEndMainManualDetailMenu::Img31' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Billboard_31) == 0x0004D8, "Member 'UEndMainManualDetailMenu::Billboard_31' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Group32) == 0x0004E0, "Member 'UEndMainManualDetailMenu::Group32' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Txt32) == 0x0004E8, "Member 'UEndMainManualDetailMenu::Txt32' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Img32) == 0x0004F0, "Member 'UEndMainManualDetailMenu::Img32' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Billboard_32) == 0x0004F8, "Member 'UEndMainManualDetailMenu::Billboard_32' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Block4) == 0x000500, "Member 'UEndMainManualDetailMenu::Block4' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Group40) == 0x000508, "Member 'UEndMainManualDetailMenu::Group40' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Txt40) == 0x000510, "Member 'UEndMainManualDetailMenu::Txt40' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Img40) == 0x000518, "Member 'UEndMainManualDetailMenu::Img40' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Billboard_40) == 0x000520, "Member 'UEndMainManualDetailMenu::Billboard_40' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Group41) == 0x000528, "Member 'UEndMainManualDetailMenu::Group41' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Txt41) == 0x000530, "Member 'UEndMainManualDetailMenu::Txt41' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Img41) == 0x000538, "Member 'UEndMainManualDetailMenu::Img41' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Billboard_41) == 0x000540, "Member 'UEndMainManualDetailMenu::Billboard_41' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Group42) == 0x000548, "Member 'UEndMainManualDetailMenu::Group42' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Txt42) == 0x000550, "Member 'UEndMainManualDetailMenu::Txt42' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Img42) == 0x000558, "Member 'UEndMainManualDetailMenu::Img42' has a wrong offset!");
static_assert(offsetof(UEndMainManualDetailMenu, Billboard_42) == 0x000560, "Member 'UEndMainManualDetailMenu::Billboard_42' has a wrong offset!");

// Class EndGame.EndBattleAITifaController
// 0x0000 (0x38A0 - 0x38A0)
class AEndBattleAITifaController final : public AEndBattleAIPcBaseController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAITifaController">();
	}
	static class AEndBattleAITifaController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAITifaController>();
	}
};
static_assert(alignof(AEndBattleAITifaController) == 0x000008, "Wrong alignment on AEndBattleAITifaController");
static_assert(sizeof(AEndBattleAITifaController) == 0x0038A0, "Wrong size on AEndBattleAITifaController");

// Class EndGame.EndAnimNotifyStateBikeOverrideDamageMotion
// 0x0008 (0x0038 - 0x0030)
class UEndAnimNotifyStateBikeOverrideDamageMotion final : public UAnimNotifyState
{
public:
	class FName                                   DamageMotionName;                                  // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBikeOverrideDamageMotion">();
	}
	static class UEndAnimNotifyStateBikeOverrideDamageMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBikeOverrideDamageMotion>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBikeOverrideDamageMotion) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBikeOverrideDamageMotion");
static_assert(sizeof(UEndAnimNotifyStateBikeOverrideDamageMotion) == 0x000038, "Wrong size on UEndAnimNotifyStateBikeOverrideDamageMotion");
static_assert(offsetof(UEndAnimNotifyStateBikeOverrideDamageMotion, DamageMotionName) == 0x000030, "Member 'UEndAnimNotifyStateBikeOverrideDamageMotion::DamageMotionName' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateBikePositioning
// 0x0018 (0x0048 - 0x0030)
class UEndAnimNotifyStateBikePositioning final : public UAnimNotifyState
{
public:
	bool                                          bEnable_Forward;                                   // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PositionOffset_Forward;                            // 0x0034(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PositioningSpeed_Forward;                          // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnable_Right;                                     // 0x003C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PositionOffset_Right;                              // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PositioningSpeed_Right;                            // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBikePositioning">();
	}
	static class UEndAnimNotifyStateBikePositioning* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBikePositioning>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBikePositioning) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBikePositioning");
static_assert(sizeof(UEndAnimNotifyStateBikePositioning) == 0x000048, "Wrong size on UEndAnimNotifyStateBikePositioning");
static_assert(offsetof(UEndAnimNotifyStateBikePositioning, bEnable_Forward) == 0x000030, "Member 'UEndAnimNotifyStateBikePositioning::bEnable_Forward' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikePositioning, PositionOffset_Forward) == 0x000034, "Member 'UEndAnimNotifyStateBikePositioning::PositionOffset_Forward' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikePositioning, PositioningSpeed_Forward) == 0x000038, "Member 'UEndAnimNotifyStateBikePositioning::PositioningSpeed_Forward' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikePositioning, bEnable_Right) == 0x00003C, "Member 'UEndAnimNotifyStateBikePositioning::bEnable_Right' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikePositioning, PositionOffset_Right) == 0x000040, "Member 'UEndAnimNotifyStateBikePositioning::PositionOffset_Right' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikePositioning, PositioningSpeed_Right) == 0x000044, "Member 'UEndAnimNotifyStateBikePositioning::PositioningSpeed_Right' has a wrong offset!");

// Class EndGame.EndDataObjectTrophy
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectTrophy final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectTrophy">();
	}
	static class UEndDataObjectTrophy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectTrophy>();
	}
};
static_assert(alignof(UEndDataObjectTrophy) == 0x000008, "Wrong alignment on UEndDataObjectTrophy");
static_assert(sizeof(UEndDataObjectTrophy) == 0x000088, "Wrong size on UEndDataObjectTrophy");

// Class EndGame.EndMainEquipChangeSelectWindow
// 0x0000 (0x0360 - 0x0360)
class UEndMainEquipChangeSelectWindow final : public UEndUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainEquipChangeSelectWindow">();
	}
	static class UEndMainEquipChangeSelectWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainEquipChangeSelectWindow>();
	}
};
static_assert(alignof(UEndMainEquipChangeSelectWindow) == 0x000008, "Wrong alignment on UEndMainEquipChangeSelectWindow");
static_assert(sizeof(UEndMainEquipChangeSelectWindow) == 0x000360, "Wrong size on UEndMainEquipChangeSelectWindow");

// Class EndGame.EndBattleAISummonBaseController
// 0x0258 (0x24E0 - 0x2288)
class AEndBattleAISummonBaseController : public AEndBattleAIController
{
public:
	float                                         WarpMoveDistance;                                  // 0x2288(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UseWarpPointDistance;                              // 0x228C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CoolDownDistance;                                  // 0x2290(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EscortDistance;                                    // 0x2294(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SightAngle;                                        // 0x2298(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDistanceFromOwner;                              // 0x229C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSummonComboAbility                    ComboAbility;                                      // 0x22A0(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   MaxRangeAbility;                                   // 0x22B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           FreeAngleAbilities;                                // 0x22C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FEndBattleSummonMinRangeLimitAbility> MinRangeLimitAbilities;                            // 0x22D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSummonWarpPointMoveOnlyBattle> WarpPointMoveOnlyBattles;                          // 0x22E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_22F0[0x1F0];                                   // 0x22F0(0x01F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAppearNotify();
	void OnChangeBattleBehavior(ESummonBattleBehavior NewBattleBehavior);
	void RequestShowCutSceneAbilityName();
	bool RequestWarpTo(const struct FVector& WarpLocation);
	void SetDrawPause(bool bFlag);
	void WarpToCachedLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAISummonBaseController">();
	}
	static class AEndBattleAISummonBaseController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAISummonBaseController>();
	}
};
static_assert(alignof(AEndBattleAISummonBaseController) == 0x000008, "Wrong alignment on AEndBattleAISummonBaseController");
static_assert(sizeof(AEndBattleAISummonBaseController) == 0x0024E0, "Wrong size on AEndBattleAISummonBaseController");
static_assert(offsetof(AEndBattleAISummonBaseController, WarpMoveDistance) == 0x002288, "Member 'AEndBattleAISummonBaseController::WarpMoveDistance' has a wrong offset!");
static_assert(offsetof(AEndBattleAISummonBaseController, UseWarpPointDistance) == 0x00228C, "Member 'AEndBattleAISummonBaseController::UseWarpPointDistance' has a wrong offset!");
static_assert(offsetof(AEndBattleAISummonBaseController, CoolDownDistance) == 0x002290, "Member 'AEndBattleAISummonBaseController::CoolDownDistance' has a wrong offset!");
static_assert(offsetof(AEndBattleAISummonBaseController, EscortDistance) == 0x002294, "Member 'AEndBattleAISummonBaseController::EscortDistance' has a wrong offset!");
static_assert(offsetof(AEndBattleAISummonBaseController, SightAngle) == 0x002298, "Member 'AEndBattleAISummonBaseController::SightAngle' has a wrong offset!");
static_assert(offsetof(AEndBattleAISummonBaseController, MaxDistanceFromOwner) == 0x00229C, "Member 'AEndBattleAISummonBaseController::MaxDistanceFromOwner' has a wrong offset!");
static_assert(offsetof(AEndBattleAISummonBaseController, ComboAbility) == 0x0022A0, "Member 'AEndBattleAISummonBaseController::ComboAbility' has a wrong offset!");
static_assert(offsetof(AEndBattleAISummonBaseController, MaxRangeAbility) == 0x0022B8, "Member 'AEndBattleAISummonBaseController::MaxRangeAbility' has a wrong offset!");
static_assert(offsetof(AEndBattleAISummonBaseController, FreeAngleAbilities) == 0x0022C0, "Member 'AEndBattleAISummonBaseController::FreeAngleAbilities' has a wrong offset!");
static_assert(offsetof(AEndBattleAISummonBaseController, MinRangeLimitAbilities) == 0x0022D0, "Member 'AEndBattleAISummonBaseController::MinRangeLimitAbilities' has a wrong offset!");
static_assert(offsetof(AEndBattleAISummonBaseController, WarpPointMoveOnlyBattles) == 0x0022E0, "Member 'AEndBattleAISummonBaseController::WarpPointMoveOnlyBattles' has a wrong offset!");

// Class EndGame.EndBattleAISU0007BaseController
// 0x0010 (0x24F0 - 0x24E0)
class AEndBattleAISU0007BaseController final : public AEndBattleAISummonBaseController
{
public:
	float                                         DoRubyhealHPRate;                                  // 0x24E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ShakeHeadMotionName;                               // 0x24E4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24EC[0x4];                                     // 0x24EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAISU0007BaseController">();
	}
	static class AEndBattleAISU0007BaseController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAISU0007BaseController>();
	}
};
static_assert(alignof(AEndBattleAISU0007BaseController) == 0x000008, "Wrong alignment on AEndBattleAISU0007BaseController");
static_assert(sizeof(AEndBattleAISU0007BaseController) == 0x0024F0, "Wrong size on AEndBattleAISU0007BaseController");
static_assert(offsetof(AEndBattleAISU0007BaseController, DoRubyhealHPRate) == 0x0024E0, "Member 'AEndBattleAISU0007BaseController::DoRubyhealHPRate' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0007BaseController, ShakeHeadMotionName) == 0x0024E4, "Member 'AEndBattleAISU0007BaseController::ShakeHeadMotionName' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateBikeRoll
// 0x0008 (0x0038 - 0x0030)
class UEndAnimNotifyStateBikeRoll final : public UAnimNotifyState
{
public:
	float                                         RollAngle;                                         // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBikeRoll">();
	}
	static class UEndAnimNotifyStateBikeRoll* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBikeRoll>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBikeRoll) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBikeRoll");
static_assert(sizeof(UEndAnimNotifyStateBikeRoll) == 0x000038, "Wrong size on UEndAnimNotifyStateBikeRoll");
static_assert(offsetof(UEndAnimNotifyStateBikeRoll, RollAngle) == 0x000030, "Member 'UEndAnimNotifyStateBikeRoll::RollAngle' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateBikeRotateYaw
// 0x0020 (0x0050 - 0x0030)
class UEndAnimNotifyStateBikeRotateYaw final : public UAnimNotifyState
{
public:
	EEndBikeRotateYawType                         Type;                                              // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAcceleration;                                  // 0x0031(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotateSpeed;                                       // 0x0034(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateMaxSpeed;                                    // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateAcceleration;                                // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateArrivalTime;                                 // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatParam1;                                       // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IdParam1;                                          // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBikeRotateYaw">();
	}
	static class UEndAnimNotifyStateBikeRotateYaw* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBikeRotateYaw>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBikeRotateYaw) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBikeRotateYaw");
static_assert(sizeof(UEndAnimNotifyStateBikeRotateYaw) == 0x000050, "Wrong size on UEndAnimNotifyStateBikeRotateYaw");
static_assert(offsetof(UEndAnimNotifyStateBikeRotateYaw, Type) == 0x000030, "Member 'UEndAnimNotifyStateBikeRotateYaw::Type' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeRotateYaw, bUseAcceleration) == 0x000031, "Member 'UEndAnimNotifyStateBikeRotateYaw::bUseAcceleration' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeRotateYaw, RotateSpeed) == 0x000034, "Member 'UEndAnimNotifyStateBikeRotateYaw::RotateSpeed' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeRotateYaw, RotateMaxSpeed) == 0x000038, "Member 'UEndAnimNotifyStateBikeRotateYaw::RotateMaxSpeed' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeRotateYaw, RotateAcceleration) == 0x00003C, "Member 'UEndAnimNotifyStateBikeRotateYaw::RotateAcceleration' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeRotateYaw, RotateArrivalTime) == 0x000040, "Member 'UEndAnimNotifyStateBikeRotateYaw::RotateArrivalTime' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeRotateYaw, FloatParam1) == 0x000044, "Member 'UEndAnimNotifyStateBikeRotateYaw::FloatParam1' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeRotateYaw, IdParam1) == 0x000048, "Member 'UEndAnimNotifyStateBikeRotateYaw::IdParam1' has a wrong offset!");

// Class EndGame.EndBattleAISU0004_02Controller
// 0x0068 (0x22F0 - 0x2288)
class AEndBattleAISU0004_02Controller final : public AEndBattleAIController
{
public:
	float                                         TornadoMaxSpeed;                                   // 0x2288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UcpcDistance;                                      // 0x228C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RepulsiveDistance;                                 // 0x2290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RepulsiveAccQuantity;                              // 0x2294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           IgnoreRepulsiveActgions;                           // 0x2298(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         TornadoMoveInterval;                               // 0x22A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RepulsiveOriginInterval;                           // 0x22AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           IgnoreStopFollowAction;                            // 0x22B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bCanFollow;                                        // 0x22C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22C1[0x3];                                     // 0x22C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveEndQuantity;                                   // 0x22C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22C8[0x28];                                    // 0x22C8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsFollowLocation();
	void OnArrivalFollowLocation();
	void RequestFollowLocation(const struct FVector& InLocation, float InTolerance);
	void RequestFollowLocationFromName(const class FName& InName, float InTolerance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAISU0004_02Controller">();
	}
	static class AEndBattleAISU0004_02Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAISU0004_02Controller>();
	}
};
static_assert(alignof(AEndBattleAISU0004_02Controller) == 0x000008, "Wrong alignment on AEndBattleAISU0004_02Controller");
static_assert(sizeof(AEndBattleAISU0004_02Controller) == 0x0022F0, "Wrong size on AEndBattleAISU0004_02Controller");
static_assert(offsetof(AEndBattleAISU0004_02Controller, TornadoMaxSpeed) == 0x002288, "Member 'AEndBattleAISU0004_02Controller::TornadoMaxSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0004_02Controller, UcpcDistance) == 0x00228C, "Member 'AEndBattleAISU0004_02Controller::UcpcDistance' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0004_02Controller, RepulsiveDistance) == 0x002290, "Member 'AEndBattleAISU0004_02Controller::RepulsiveDistance' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0004_02Controller, RepulsiveAccQuantity) == 0x002294, "Member 'AEndBattleAISU0004_02Controller::RepulsiveAccQuantity' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0004_02Controller, IgnoreRepulsiveActgions) == 0x002298, "Member 'AEndBattleAISU0004_02Controller::IgnoreRepulsiveActgions' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0004_02Controller, TornadoMoveInterval) == 0x0022A8, "Member 'AEndBattleAISU0004_02Controller::TornadoMoveInterval' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0004_02Controller, RepulsiveOriginInterval) == 0x0022AC, "Member 'AEndBattleAISU0004_02Controller::RepulsiveOriginInterval' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0004_02Controller, IgnoreStopFollowAction) == 0x0022B0, "Member 'AEndBattleAISU0004_02Controller::IgnoreStopFollowAction' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0004_02Controller, bCanFollow) == 0x0022C0, "Member 'AEndBattleAISU0004_02Controller::bCanFollow' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0004_02Controller, MoveEndQuantity) == 0x0022C4, "Member 'AEndBattleAISU0004_02Controller::MoveEndQuantity' has a wrong offset!");

// Class EndGame.EndSoundAPI
// 0x0000 (0x0028 - 0x0028)
class UEndSoundAPI final : public UObject
{
public:
	static void CallEvent(EEndSoundLayer TargetLayer);
	static void SetExternalParameter(class FName ParameterName, float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndSoundAPI">();
	}
	static class UEndSoundAPI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndSoundAPI>();
	}
};
static_assert(alignof(UEndSoundAPI) == 0x000008, "Wrong alignment on UEndSoundAPI");
static_assert(sizeof(UEndSoundAPI) == 0x000028, "Wrong size on UEndSoundAPI");

// Class EndGame.EndAnimNotifyStateBikeSpecialAttack
// 0x0008 (0x0038 - 0x0030)
class UEndAnimNotifyStateBikeSpecialAttack final : public UAnimNotifyState
{
public:
	float                                         RollAngle;                                         // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBikeSpecialAttack">();
	}
	static class UEndAnimNotifyStateBikeSpecialAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBikeSpecialAttack>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBikeSpecialAttack) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBikeSpecialAttack");
static_assert(sizeof(UEndAnimNotifyStateBikeSpecialAttack) == 0x000038, "Wrong size on UEndAnimNotifyStateBikeSpecialAttack");
static_assert(offsetof(UEndAnimNotifyStateBikeSpecialAttack, RollAngle) == 0x000030, "Member 'UEndAnimNotifyStateBikeSpecialAttack::RollAngle' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateBikeSpecialDamage
// 0x0018 (0x0048 - 0x0030)
class UEndAnimNotifyStateBikeSpecialDamage final : public UAnimNotifyState
{
public:
	class FName                                   DamageSourceID;                                    // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndBattleDamageSourcePositionBaseType        CreatePositionBase;                                // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CreatePositionName;                                // 0x003C(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Parameter;                                         // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBikeSpecialDamage">();
	}
	static class UEndAnimNotifyStateBikeSpecialDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBikeSpecialDamage>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBikeSpecialDamage) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBikeSpecialDamage");
static_assert(sizeof(UEndAnimNotifyStateBikeSpecialDamage) == 0x000048, "Wrong size on UEndAnimNotifyStateBikeSpecialDamage");
static_assert(offsetof(UEndAnimNotifyStateBikeSpecialDamage, DamageSourceID) == 0x000030, "Member 'UEndAnimNotifyStateBikeSpecialDamage::DamageSourceID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeSpecialDamage, CreatePositionBase) == 0x000038, "Member 'UEndAnimNotifyStateBikeSpecialDamage::CreatePositionBase' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeSpecialDamage, CreatePositionName) == 0x00003C, "Member 'UEndAnimNotifyStateBikeSpecialDamage::CreatePositionName' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateBikeSpecialDamage, Parameter) == 0x000044, "Member 'UEndAnimNotifyStateBikeSpecialDamage::Parameter' has a wrong offset!");

// Class EndGame.EndDataObjectObjectLayout
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectObjectLayout final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectObjectLayout">();
	}
	static class UEndDataObjectObjectLayout* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectObjectLayout>();
	}
};
static_assert(alignof(UEndDataObjectObjectLayout) == 0x000008, "Wrong alignment on UEndDataObjectObjectLayout");
static_assert(sizeof(UEndDataObjectObjectLayout) == 0x000088, "Wrong size on UEndDataObjectObjectLayout");

// Class EndGame.EndBattleAISU1000BaseController
// 0x0010 (0x24F0 - 0x24E0)
class AEndBattleAISU1000BaseController final : public AEndBattleAISummonBaseController
{
public:
	uint8                                         Pad_24E0[0x10];                                    // 0x24E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetLightningStrikeTargetLocation(int32 Index_0);
	void SetHidePowerUpFX(bool bHide, bool bImmediately);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAISU1000BaseController">();
	}
	static class AEndBattleAISU1000BaseController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAISU1000BaseController>();
	}
};
static_assert(alignof(AEndBattleAISU1000BaseController) == 0x000008, "Wrong alignment on AEndBattleAISU1000BaseController");
static_assert(sizeof(AEndBattleAISU1000BaseController) == 0x0024F0, "Wrong size on AEndBattleAISU1000BaseController");

// Class EndGame.EndPathWayDrawComponent
// 0x0000 (0x00F8 - 0x00F8)
class UEndPathWayDrawComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndPathWayDrawComponent">();
	}
	static class UEndPathWayDrawComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndPathWayDrawComponent>();
	}
};
static_assert(alignof(UEndPathWayDrawComponent) == 0x000008, "Wrong alignment on UEndPathWayDrawComponent");
static_assert(sizeof(UEndPathWayDrawComponent) == 0x0000F8, "Wrong size on UEndPathWayDrawComponent");

// Class EndGame.EndAnimNotifyStateBikeSuperArmor
// 0x0000 (0x0030 - 0x0030)
class UEndAnimNotifyStateBikeSuperArmor final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBikeSuperArmor">();
	}
	static class UEndAnimNotifyStateBikeSuperArmor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBikeSuperArmor>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBikeSuperArmor) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBikeSuperArmor");
static_assert(sizeof(UEndAnimNotifyStateBikeSuperArmor) == 0x000030, "Wrong size on UEndAnimNotifyStateBikeSuperArmor");

// Class EndGame.EndAnimNotifyStateBikeUsePhysics
// 0x0008 (0x0038 - 0x0030)
class UEndAnimNotifyStateBikeUsePhysics final : public UAnimNotifyState
{
public:
	bool                                          bWheelRotationOnly;                                // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBikeUsePhysics">();
	}
	static class UEndAnimNotifyStateBikeUsePhysics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBikeUsePhysics>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBikeUsePhysics) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBikeUsePhysics");
static_assert(sizeof(UEndAnimNotifyStateBikeUsePhysics) == 0x000038, "Wrong size on UEndAnimNotifyStateBikeUsePhysics");
static_assert(offsetof(UEndAnimNotifyStateBikeUsePhysics, bWheelRotationOnly) == 0x000030, "Member 'UEndAnimNotifyStateBikeUsePhysics::bWheelRotationOnly' has a wrong offset!");

// Class EndGame.EndNavAreaImpassable2
// 0x0000 (0x0040 - 0x0040)
class UEndNavAreaImpassable2 final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavAreaImpassable2">();
	}
	static class UEndNavAreaImpassable2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavAreaImpassable2>();
	}
};
static_assert(alignof(UEndNavAreaImpassable2) == 0x000008, "Wrong alignment on UEndNavAreaImpassable2");
static_assert(sizeof(UEndNavAreaImpassable2) == 0x000040, "Wrong size on UEndNavAreaImpassable2");

// Class EndGame.EndBattleAreaBoxComponentBase
// 0x0000 (0x0720 - 0x0720)
class UEndBattleAreaBoxComponentBase : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAreaBoxComponentBase">();
	}
	static class UEndBattleAreaBoxComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleAreaBoxComponentBase>();
	}
};
static_assert(alignof(UEndBattleAreaBoxComponentBase) == 0x000010, "Wrong alignment on UEndBattleAreaBoxComponentBase");
static_assert(sizeof(UEndBattleAreaBoxComponentBase) == 0x000720, "Wrong size on UEndBattleAreaBoxComponentBase");

// Class EndGame.EndCationAreaBoxComponent
// 0x0000 (0x0720 - 0x0720)
class UEndCationAreaBoxComponent final : public UEndBattleAreaBoxComponentBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCationAreaBoxComponent">();
	}
	static class UEndCationAreaBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndCationAreaBoxComponent>();
	}
};
static_assert(alignof(UEndCationAreaBoxComponent) == 0x000010, "Wrong alignment on UEndCationAreaBoxComponent");
static_assert(sizeof(UEndCationAreaBoxComponent) == 0x000720, "Wrong size on UEndCationAreaBoxComponent");

// Class EndGame.EndAnimNotifyStateBikeWeaponRight
// 0x0000 (0x0030 - 0x0030)
class UEndAnimNotifyStateBikeWeaponRight final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateBikeWeaponRight">();
	}
	static class UEndAnimNotifyStateBikeWeaponRight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateBikeWeaponRight>();
	}
};
static_assert(alignof(UEndAnimNotifyStateBikeWeaponRight) == 0x000008, "Wrong alignment on UEndAnimNotifyStateBikeWeaponRight");
static_assert(sizeof(UEndAnimNotifyStateBikeWeaponRight) == 0x000030, "Wrong size on UEndAnimNotifyStateBikeWeaponRight");

// Class EndGame.EndAnimNotifyStateCustomFieldActionCamera
// 0x0008 (0x0038 - 0x0030)
class UEndAnimNotifyStateCustomFieldActionCamera final : public UAnimNotifyState
{
public:
	class FName                                   DatatableName;                                     // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateCustomFieldActionCamera">();
	}
	static class UEndAnimNotifyStateCustomFieldActionCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateCustomFieldActionCamera>();
	}
};
static_assert(alignof(UEndAnimNotifyStateCustomFieldActionCamera) == 0x000008, "Wrong alignment on UEndAnimNotifyStateCustomFieldActionCamera");
static_assert(sizeof(UEndAnimNotifyStateCustomFieldActionCamera) == 0x000038, "Wrong size on UEndAnimNotifyStateCustomFieldActionCamera");
static_assert(offsetof(UEndAnimNotifyStateCustomFieldActionCamera, DatatableName) == 0x000030, "Member 'UEndAnimNotifyStateCustomFieldActionCamera::DatatableName' has a wrong offset!");

// Class EndGame.EndDataObjectOverrideWalkType
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectOverrideWalkType final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectOverrideWalkType">();
	}
	static class UEndDataObjectOverrideWalkType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectOverrideWalkType>();
	}
};
static_assert(alignof(UEndDataObjectOverrideWalkType) == 0x000008, "Wrong alignment on UEndDataObjectOverrideWalkType");
static_assert(sizeof(UEndDataObjectOverrideWalkType) == 0x000088, "Wrong size on UEndDataObjectOverrideWalkType");

// Class EndGame.EndMainEquipWeaponInfoWindow
// 0x0000 (0x0380 - 0x0380)
class UEndMainEquipWeaponInfoWindow : public UEndMainEquipInfoWindowBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainEquipWeaponInfoWindow">();
	}
	static class UEndMainEquipWeaponInfoWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainEquipWeaponInfoWindow>();
	}
};
static_assert(alignof(UEndMainEquipWeaponInfoWindow) == 0x000008, "Wrong alignment on UEndMainEquipWeaponInfoWindow");
static_assert(sizeof(UEndMainEquipWeaponInfoWindow) == 0x000380, "Wrong size on UEndMainEquipWeaponInfoWindow");

// Class EndGame.EndBattleAITown7BiggsController
// 0x0010 (0x38B0 - 0x38A0)
class AEndBattleAITown7BiggsController final : public AEndBattleAIPcBaseController
{
public:
	int32                                         Level;                                             // 0x38A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38A4[0xC];                                     // 0x38A4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAITown7BiggsController">();
	}
	static class AEndBattleAITown7BiggsController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAITown7BiggsController>();
	}
};
static_assert(alignof(AEndBattleAITown7BiggsController) == 0x000008, "Wrong alignment on AEndBattleAITown7BiggsController");
static_assert(sizeof(AEndBattleAITown7BiggsController) == 0x0038B0, "Wrong size on AEndBattleAITown7BiggsController");
static_assert(offsetof(AEndBattleAITown7BiggsController, Level) == 0x0038A0, "Member 'AEndBattleAITown7BiggsController::Level' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateEffectCharaProperty
// 0x00B8 (0x00E8 - 0x0030)
class UEndAnimNotifyStateEffectCharaProperty final : public UAnimNotifyState
{
public:
	class FString                                 ID;                                                // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EEndAnimNotifyEffectCharaPropertyReplaceType> ReplaceTypes;                                      // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EEndAnimNotifyEffectCharaPropertyAttachType   AttachType;                                        // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachSocketName;                                  // 0x0054(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x005C(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0068(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Attached : 1;                                      // 0x0074(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEndPlayParticleActorInfo              m_CasterActorInfo;                                 // 0x0078(0x000C)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndPlayParticleActorInfo              m_TargetActorInfo;                                 // 0x0084(0x000C)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x58];                                      // 0x0090(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateEffectCharaProperty">();
	}
	static class UEndAnimNotifyStateEffectCharaProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateEffectCharaProperty>();
	}
};
static_assert(alignof(UEndAnimNotifyStateEffectCharaProperty) == 0x000008, "Wrong alignment on UEndAnimNotifyStateEffectCharaProperty");
static_assert(sizeof(UEndAnimNotifyStateEffectCharaProperty) == 0x0000E8, "Wrong size on UEndAnimNotifyStateEffectCharaProperty");
static_assert(offsetof(UEndAnimNotifyStateEffectCharaProperty, ID) == 0x000030, "Member 'UEndAnimNotifyStateEffectCharaProperty::ID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateEffectCharaProperty, ReplaceTypes) == 0x000040, "Member 'UEndAnimNotifyStateEffectCharaProperty::ReplaceTypes' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateEffectCharaProperty, AttachType) == 0x000050, "Member 'UEndAnimNotifyStateEffectCharaProperty::AttachType' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateEffectCharaProperty, AttachSocketName) == 0x000054, "Member 'UEndAnimNotifyStateEffectCharaProperty::AttachSocketName' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateEffectCharaProperty, LocationOffset) == 0x00005C, "Member 'UEndAnimNotifyStateEffectCharaProperty::LocationOffset' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateEffectCharaProperty, RotationOffset) == 0x000068, "Member 'UEndAnimNotifyStateEffectCharaProperty::RotationOffset' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateEffectCharaProperty, m_CasterActorInfo) == 0x000078, "Member 'UEndAnimNotifyStateEffectCharaProperty::m_CasterActorInfo' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateEffectCharaProperty, m_TargetActorInfo) == 0x000084, "Member 'UEndAnimNotifyStateEffectCharaProperty::m_TargetActorInfo' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateFieldExtraRadius
// 0x0050 (0x0080 - 0x0030)
class UEndAnimNotifyStateFieldExtraRadius final : public UAnimNotifyState
{
public:
	float                                         ExtraRadius;                                       // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAlphaBlend                            BlendIn;                                           // 0x0038(0x0038)(Edit, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ElapsedTime;                                       // 0x0070(0x0004)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OriginalFieldExtraRadius;                          // 0x0074(0x0004)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OriginalBattleExtraRadius;                         // 0x0078(0x0004)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateFieldExtraRadius">();
	}
	static class UEndAnimNotifyStateFieldExtraRadius* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateFieldExtraRadius>();
	}
};
static_assert(alignof(UEndAnimNotifyStateFieldExtraRadius) == 0x000008, "Wrong alignment on UEndAnimNotifyStateFieldExtraRadius");
static_assert(sizeof(UEndAnimNotifyStateFieldExtraRadius) == 0x000080, "Wrong size on UEndAnimNotifyStateFieldExtraRadius");
static_assert(offsetof(UEndAnimNotifyStateFieldExtraRadius, ExtraRadius) == 0x000030, "Member 'UEndAnimNotifyStateFieldExtraRadius::ExtraRadius' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateFieldExtraRadius, BlendIn) == 0x000038, "Member 'UEndAnimNotifyStateFieldExtraRadius::BlendIn' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateFieldExtraRadius, ElapsedTime) == 0x000070, "Member 'UEndAnimNotifyStateFieldExtraRadius::ElapsedTime' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateFieldExtraRadius, OriginalFieldExtraRadius) == 0x000074, "Member 'UEndAnimNotifyStateFieldExtraRadius::OriginalFieldExtraRadius' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateFieldExtraRadius, OriginalBattleExtraRadius) == 0x000078, "Member 'UEndAnimNotifyStateFieldExtraRadius::OriginalBattleExtraRadius' has a wrong offset!");

// Class EndGame.EndBattleAISU0009BaseController
// 0x0080 (0x2560 - 0x24E0)
class AEndBattleAISU0009BaseController final : public AEndBattleAISummonBaseController
{
public:
	TArray<class FName>                           FireMagics;                                        // 0x24E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           IceMagics;                                         // 0x24F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           ThunderMagics;                                     // 0x2500(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           WindMagics;                                        // 0x2510(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         AreaAbilityCoefficient;                            // 0x2520(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WinningPoseMotionName;                             // 0x2524(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_252C[0x34];                                    // 0x252C(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateFlareDamage(const class FName ToTargetDamageID, const class FName ToOthersDamageID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAISU0009BaseController">();
	}
	static class AEndBattleAISU0009BaseController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAISU0009BaseController>();
	}
};
static_assert(alignof(AEndBattleAISU0009BaseController) == 0x000008, "Wrong alignment on AEndBattleAISU0009BaseController");
static_assert(sizeof(AEndBattleAISU0009BaseController) == 0x002560, "Wrong size on AEndBattleAISU0009BaseController");
static_assert(offsetof(AEndBattleAISU0009BaseController, FireMagics) == 0x0024E0, "Member 'AEndBattleAISU0009BaseController::FireMagics' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0009BaseController, IceMagics) == 0x0024F0, "Member 'AEndBattleAISU0009BaseController::IceMagics' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0009BaseController, ThunderMagics) == 0x002500, "Member 'AEndBattleAISU0009BaseController::ThunderMagics' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0009BaseController, WindMagics) == 0x002510, "Member 'AEndBattleAISU0009BaseController::WindMagics' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0009BaseController, AreaAbilityCoefficient) == 0x002520, "Member 'AEndBattleAISU0009BaseController::AreaAbilityCoefficient' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0009BaseController, WinningPoseMotionName) == 0x002524, "Member 'AEndBattleAISU0009BaseController::WinningPoseMotionName' has a wrong offset!");

// Class EndGame.EndPartyAPI
// 0x0000 (0x0028 - 0x0028)
class UEndPartyAPI final : public UObject
{
public:
	static void CallTeleported(const struct FVector& NewLocation, class AActor* InLeader);
	static void ChangeActorToad(EPlayerType Type);
	static void CheckPlayerStream(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	static void FinishPlayerStream();
	static int32 GetArrivalPartyMemberCount();
	static class AActor* GetPartyLeader();
	static class FName GetPartyLeaderName();
	static EPlayerType GetPartyLeaderType();
	static class AEndCharacter* GetPartyMember(int32 Index_0);
	static int32 GetPartyMemberCount();
	static int32 GetPartyMemberCountForPartyStatus(EPlayerStatus findPlayerStatus);
	static TArray<class AEndCharacter*> GetPartyMembers();
	static EPlayerType GetPartyMemberType(int32 Slot);
	static class AActor* GetPlayerActor(EEquipmentType equipment, EPlayerType Type);
	static class FName GetPlayerActorName(EPlayerType Type);
	static EPlayerActorRefreshState GetPlayerActorRefreshState(EEquipmentType equipment, EPlayerType Type);
	static class FName GetPlayerName(EEquipmentType equipment, EPlayerType Type);
	static class AActor* GetPlayerReturnActor(EPlayerType Type);
	static EPlayerStatus GetPlayerStatus(EPlayerType Type);
	static class AActor* GetPlayerToadActor(EPlayerType Type);
	static void InitPartyLevel(const class UObject* WorldContextObject, class AActor* InPlayerTrigger);
	static bool IsCurrentCharaSpecListPreloadFinished();
	static bool IsFinishPlayerStream();
	static bool IsPlayerActorRefreshState();
	static void LoadCache();
	static void PreloadCurrentCharaSpecList(const TArray<EPlayerType>& players, const TArray<EEquipmentType>& equipments);
	static void ResetPlayerPosition();
	static void ReturnActorToad(EPlayerType Type);
	static void SetPartyLeader(class AActor* InLeader, bool bIsInputTrigered);
	static void SetPartyLeaderType(EPlayerType InLeader, bool bIsInputTrigered, bool bForce);
	static void SetPlayerActor(EEquipmentType equipment, EPlayerType Type, class AActor* Actor);
	static void SetPlayerName(EEquipmentType equipment, EPlayerType Type, class FName Name_0);
	static void SetPlayerStatus(EPlayerType Type, EPlayerStatus Status);
	static bool ShouldUsePreloadCharaSpecsForPartyDebug();
	static void StartPlayerStream();
	static void UpdatePreloadCurrentCharaSpecList();
	static void WaitLoadCache(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	static void WaitPlayerStream(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndPartyAPI">();
	}
	static class UEndPartyAPI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndPartyAPI>();
	}
};
static_assert(alignof(UEndPartyAPI) == 0x000008, "Wrong alignment on UEndPartyAPI");
static_assert(sizeof(UEndPartyAPI) == 0x000028, "Wrong size on UEndPartyAPI");

// Class EndGame.EndAnimNotifyStateLinkAbility
// 0x0018 (0x0048 - 0x0030)
class UEndAnimNotifyStateLinkAbility final : public UAnimNotifyState
{
public:
	class FName                                   AbilityID;                                         // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupport;                                          // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAerial;                                           // 0x0039(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoWithoutTarget;                                  // 0x003A(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInstance;                                         // 0x003B(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreLinkMode;                                   // 0x003C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SpecifiedAbilityID;                                // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateLinkAbility">();
	}
	static class UEndAnimNotifyStateLinkAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateLinkAbility>();
	}
};
static_assert(alignof(UEndAnimNotifyStateLinkAbility) == 0x000008, "Wrong alignment on UEndAnimNotifyStateLinkAbility");
static_assert(sizeof(UEndAnimNotifyStateLinkAbility) == 0x000048, "Wrong size on UEndAnimNotifyStateLinkAbility");
static_assert(offsetof(UEndAnimNotifyStateLinkAbility, AbilityID) == 0x000030, "Member 'UEndAnimNotifyStateLinkAbility::AbilityID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateLinkAbility, bSupport) == 0x000038, "Member 'UEndAnimNotifyStateLinkAbility::bSupport' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateLinkAbility, bAerial) == 0x000039, "Member 'UEndAnimNotifyStateLinkAbility::bAerial' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateLinkAbility, bDoWithoutTarget) == 0x00003A, "Member 'UEndAnimNotifyStateLinkAbility::bDoWithoutTarget' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateLinkAbility, bInstance) == 0x00003B, "Member 'UEndAnimNotifyStateLinkAbility::bInstance' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateLinkAbility, bIgnoreLinkMode) == 0x00003C, "Member 'UEndAnimNotifyStateLinkAbility::bIgnoreLinkMode' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateLinkAbility, SpecifiedAbilityID) == 0x000040, "Member 'UEndAnimNotifyStateLinkAbility::SpecifiedAbilityID' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateMovementModeMaxWeight
// 0x0008 (0x0038 - 0x0030)
class UEndAnimNotifyStateMovementModeMaxWeight final : public UAnimNotifyState
{
public:
	bool                                          NoWriteMode;                                       // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateMovementModeMaxWeight">();
	}
	static class UEndAnimNotifyStateMovementModeMaxWeight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateMovementModeMaxWeight>();
	}
};
static_assert(alignof(UEndAnimNotifyStateMovementModeMaxWeight) == 0x000008, "Wrong alignment on UEndAnimNotifyStateMovementModeMaxWeight");
static_assert(sizeof(UEndAnimNotifyStateMovementModeMaxWeight) == 0x000038, "Wrong size on UEndAnimNotifyStateMovementModeMaxWeight");
static_assert(offsetof(UEndAnimNotifyStateMovementModeMaxWeight, NoWriteMode) == 0x000030, "Member 'UEndAnimNotifyStateMovementModeMaxWeight::NoWriteMode' has a wrong offset!");

// Class EndGame.EndDataObjectPlannerEventChara
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectPlannerEventChara final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectPlannerEventChara">();
	}
	static class UEndDataObjectPlannerEventChara* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectPlannerEventChara>();
	}
};
static_assert(alignof(UEndDataObjectPlannerEventChara) == 0x000008, "Wrong alignment on UEndDataObjectPlannerEventChara");
static_assert(sizeof(UEndDataObjectPlannerEventChara) == 0x000088, "Wrong size on UEndDataObjectPlannerEventChara");

// Class EndGame.EndPhysicsHandleComponent
// 0x0028 (0x01C0 - 0x0198)
class UEndPhysicsHandleComponent final : public UPhysicsHandleComponent
{
public:
	class USceneComponent*                        TargetScene;                                       // 0x0198(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A0[0x20];                                     // 0x01A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndPhysicsHandleComponent">();
	}
	static class UEndPhysicsHandleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndPhysicsHandleComponent>();
	}
};
static_assert(alignof(UEndPhysicsHandleComponent) == 0x000008, "Wrong alignment on UEndPhysicsHandleComponent");
static_assert(sizeof(UEndPhysicsHandleComponent) == 0x0001C0, "Wrong size on UEndPhysicsHandleComponent");
static_assert(offsetof(UEndPhysicsHandleComponent, TargetScene) == 0x000198, "Member 'UEndPhysicsHandleComponent::TargetScene' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateOverrideCameraParams
// 0x0050 (0x0080 - 0x0030)
class UEndAnimNotifyStateOverrideCameraParams final : public UAnimNotifyState
{
public:
	struct FEndFieldCameraOverrideParam           OverrideParameters;                                // 0x0030(0x0040)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bBeginBlend;                                       // 0x0070(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             BeginBlendOption;                                  // 0x0071(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x2];                                       // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BeginBlendTime;                                    // 0x0074(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndBlend;                                         // 0x0078(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             EndBlendOption;                                    // 0x0079(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x2];                                       // 0x007A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EndBlendTime;                                      // 0x007C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateOverrideCameraParams">();
	}
	static class UEndAnimNotifyStateOverrideCameraParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateOverrideCameraParams>();
	}
};
static_assert(alignof(UEndAnimNotifyStateOverrideCameraParams) == 0x000008, "Wrong alignment on UEndAnimNotifyStateOverrideCameraParams");
static_assert(sizeof(UEndAnimNotifyStateOverrideCameraParams) == 0x000080, "Wrong size on UEndAnimNotifyStateOverrideCameraParams");
static_assert(offsetof(UEndAnimNotifyStateOverrideCameraParams, OverrideParameters) == 0x000030, "Member 'UEndAnimNotifyStateOverrideCameraParams::OverrideParameters' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateOverrideCameraParams, bBeginBlend) == 0x000070, "Member 'UEndAnimNotifyStateOverrideCameraParams::bBeginBlend' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateOverrideCameraParams, BeginBlendOption) == 0x000071, "Member 'UEndAnimNotifyStateOverrideCameraParams::BeginBlendOption' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateOverrideCameraParams, BeginBlendTime) == 0x000074, "Member 'UEndAnimNotifyStateOverrideCameraParams::BeginBlendTime' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateOverrideCameraParams, bEndBlend) == 0x000078, "Member 'UEndAnimNotifyStateOverrideCameraParams::bEndBlend' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateOverrideCameraParams, EndBlendOption) == 0x000079, "Member 'UEndAnimNotifyStateOverrideCameraParams::EndBlendOption' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateOverrideCameraParams, EndBlendTime) == 0x00007C, "Member 'UEndAnimNotifyStateOverrideCameraParams::EndBlendTime' has a wrong offset!");

// Class EndGame.EndAnimNotifyStatePlaySound
// 0x00E0 (0x0110 - 0x0030)
class UEndAnimNotifyStatePlaySound : public UAnimNotifyState
{
public:
	TSoftObjectPtr<class USoundBase>              SoundRef;                                          // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SoundName;                                         // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartWaitTime;                                     // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutDuration;                                   // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bFollow : 1;                                       // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachPointName;                                   // 0x0074(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAttenuation*                      Attenuation;                                       // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              OnEndSoundRef;                                     // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OnEndSoundName;                                    // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPauseOnAnimKeep : 1;                              // 0x00B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bVirtualizePlayWhenSilent : 1;                     // 0x00B8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSyncOwnerHiddenState : 1;                         // 0x00B8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bVibrationUCPCOnly : 1;                            // 0x00B8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B9[0x57];                                      // 0x00B9(0x0057)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStatePlaySound">();
	}
	static class UEndAnimNotifyStatePlaySound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStatePlaySound>();
	}
};
static_assert(alignof(UEndAnimNotifyStatePlaySound) == 0x000008, "Wrong alignment on UEndAnimNotifyStatePlaySound");
static_assert(sizeof(UEndAnimNotifyStatePlaySound) == 0x000110, "Wrong size on UEndAnimNotifyStatePlaySound");
static_assert(offsetof(UEndAnimNotifyStatePlaySound, SoundRef) == 0x000030, "Member 'UEndAnimNotifyStatePlaySound::SoundRef' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStatePlaySound, SoundName) == 0x000058, "Member 'UEndAnimNotifyStatePlaySound::SoundName' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStatePlaySound, StartWaitTime) == 0x000060, "Member 'UEndAnimNotifyStatePlaySound::StartWaitTime' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStatePlaySound, VolumeMultiplier) == 0x000064, "Member 'UEndAnimNotifyStatePlaySound::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStatePlaySound, PitchMultiplier) == 0x000068, "Member 'UEndAnimNotifyStatePlaySound::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStatePlaySound, FadeOutDuration) == 0x00006C, "Member 'UEndAnimNotifyStatePlaySound::FadeOutDuration' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStatePlaySound, AttachPointName) == 0x000074, "Member 'UEndAnimNotifyStatePlaySound::AttachPointName' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStatePlaySound, Attenuation) == 0x000080, "Member 'UEndAnimNotifyStatePlaySound::Attenuation' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStatePlaySound, OnEndSoundRef) == 0x000088, "Member 'UEndAnimNotifyStatePlaySound::OnEndSoundRef' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStatePlaySound, OnEndSoundName) == 0x0000B0, "Member 'UEndAnimNotifyStatePlaySound::OnEndSoundName' has a wrong offset!");

// Class EndGame.EndNavAreaVersatile4
// 0x0000 (0x0040 - 0x0040)
class UEndNavAreaVersatile4 final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavAreaVersatile4">();
	}
	static class UEndNavAreaVersatile4* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavAreaVersatile4>();
	}
};
static_assert(alignof(UEndNavAreaVersatile4) == 0x000008, "Wrong alignment on UEndNavAreaVersatile4");
static_assert(sizeof(UEndNavAreaVersatile4) == 0x000040, "Wrong size on UEndNavAreaVersatile4");

// Class EndGame.EndBattleCameraActor
// 0x0390 (0x0D20 - 0x0990)
class AEndBattleCameraActor final : public ACameraActor
{
public:
	float                                         AimTarget0_to1_Rate;                               // 0x0990(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AimTarget0_to1_RelativeLocation;                   // 0x0994(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndBattleCameraTargetType                    AimTarget0_Type;                                   // 0x09A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A1[0x7];                                      // 0x09A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AimTarget0_PartName;                               // 0x09A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Interp, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AimTarget0_Offset;                                 // 0x09B8(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AimTarget0_RelativeLocation;                       // 0x09C4(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAimTarget0_Fix;                                   // 0x09D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D1[0x7];                                      // 0x09D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AimTarget0_OverrideActorName;                      // 0x09D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Interp, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AimTarget0_OverridePartName;                       // 0x09E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Interp, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AimTarget0_OverrideActorOffset;                    // 0x09F8(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndBattleCameraTargetType                    AimTarget1_Type;                                   // 0x0A04(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A05[0x3];                                      // 0x0A05(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AimTarget1_PartName;                               // 0x0A08(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Interp, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AimTarget1_Offset;                                 // 0x0A18(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AimTarget1_RelativeLocation;                       // 0x0A24(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAimTarget1_Fix;                                   // 0x0A30(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A31[0x7];                                      // 0x0A31(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AimTarget1_OverrideActorName;                      // 0x0A38(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Interp, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AimTarget1_OverridePartName;                       // 0x0A48(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Interp, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AimTarget1_OverrideActorOffset;                    // 0x0A58(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndBattleCameraRelativeLocationRotateType    AimTarget_RelativeLocation_RotateType;             // 0x0A64(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndBattleCameraTargetType                    EyeTargetType;                                     // 0x0A65(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A66[0x2];                                      // 0x0A66(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EyeTargetPartName;                                 // 0x0A68(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Interp, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EyeTargetOffset;                                   // 0x0A78(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EyeTargetRelativeLocation;                         // 0x0A84(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndBattleCameraSLerpType                     EyeTargetRelativeLocationSLerpType;                // 0x0A90(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A91[0x3];                                      // 0x0A91(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EyeTargetMovableFOV;                               // 0x0A94(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEyeTarget_Fix;                                    // 0x0A98(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A99[0x7];                                      // 0x0A99(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EyeTargetOverrideActorName;                        // 0x0AA0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Interp, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EyeTargetOverridePartName;                         // 0x0AB0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Interp, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EyeTargetOverrideActorOffset;                      // 0x0AC0(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndBattleCameraEyeToAimTargetRotateType      EyeToAimTargetRotateType;                          // 0x0ACC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEyeToAimTargetRotateIncludePitch;                 // 0x0ACD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEyePointFix;                                      // 0x0ACE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEyeToAimTargetRot_Fix;                            // 0x0ACF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimLeapTime;                                       // 0x0AD0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeLeapTime;                                       // 0x0AD4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Roll;                                              // 0x0AD8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OthersGameSpeed;                                   // 0x0ADC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoOthersGameSpeed;                                 // 0x0AE0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeOwnerGameSpeed;                            // 0x0AE4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoIncludeOwnerCameraGameSpeed;                    // 0x0AE5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AE6[0x2];                                      // 0x0AE6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 NoIncludeActorNameOthersGameSpeed;                 // 0x0AE8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Interp, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EndBattleCameraInputOffsetType                InputOffsetType;                                   // 0x0AF8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AF9[0x7];                                      // 0x0AF9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEndCameraShakeParam                   ShakeParam;                                        // 0x0B00(0x0068)(Edit, BlueprintVisible, DisableEditOnInstance, Interp, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 NoFadeOutActorName;                                // 0x0B68(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Interp, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveUpEyeWhenHitWall;                             // 0x0B78(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B79[0x7];                                      // 0x0B79(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OwnerActor;                                        // 0x0B80(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 TargetActor;                                       // 0x0B88(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B90[0x10];                                     // 0x0B90(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AEndBattleLevelSequenceActor*           SequenceActor;                                     // 0x0BA0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BA8[0x110];                                    // 0x0BA8(0x0110)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         NoIncludeActorList_OthersGameSpeed;                // 0x0CB8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CC8[0x8];                                      // 0x0CC8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 AimTarget0_Actor;                                  // 0x0CD0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 AimTarget1_Actor;                                  // 0x0CD8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 EyeTargetActor;                                    // 0x0CE0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CE8[0x10];                                     // 0x0CE8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         NoFadeOutActorList;                                // 0x0CF8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D08[0x18];                                     // 0x0D08(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindTargetActor(class AActor* OwnerActor_0, class AActor* TargetActor_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleCameraActor">();
	}
	static class AEndBattleCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleCameraActor>();
	}
};
static_assert(alignof(AEndBattleCameraActor) == 0x000010, "Wrong alignment on AEndBattleCameraActor");
static_assert(sizeof(AEndBattleCameraActor) == 0x000D20, "Wrong size on AEndBattleCameraActor");
static_assert(offsetof(AEndBattleCameraActor, AimTarget0_to1_Rate) == 0x000990, "Member 'AEndBattleCameraActor::AimTarget0_to1_Rate' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, AimTarget0_to1_RelativeLocation) == 0x000994, "Member 'AEndBattleCameraActor::AimTarget0_to1_RelativeLocation' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, AimTarget0_Type) == 0x0009A0, "Member 'AEndBattleCameraActor::AimTarget0_Type' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, AimTarget0_PartName) == 0x0009A8, "Member 'AEndBattleCameraActor::AimTarget0_PartName' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, AimTarget0_Offset) == 0x0009B8, "Member 'AEndBattleCameraActor::AimTarget0_Offset' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, AimTarget0_RelativeLocation) == 0x0009C4, "Member 'AEndBattleCameraActor::AimTarget0_RelativeLocation' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, bAimTarget0_Fix) == 0x0009D0, "Member 'AEndBattleCameraActor::bAimTarget0_Fix' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, AimTarget0_OverrideActorName) == 0x0009D8, "Member 'AEndBattleCameraActor::AimTarget0_OverrideActorName' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, AimTarget0_OverridePartName) == 0x0009E8, "Member 'AEndBattleCameraActor::AimTarget0_OverridePartName' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, AimTarget0_OverrideActorOffset) == 0x0009F8, "Member 'AEndBattleCameraActor::AimTarget0_OverrideActorOffset' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, AimTarget1_Type) == 0x000A04, "Member 'AEndBattleCameraActor::AimTarget1_Type' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, AimTarget1_PartName) == 0x000A08, "Member 'AEndBattleCameraActor::AimTarget1_PartName' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, AimTarget1_Offset) == 0x000A18, "Member 'AEndBattleCameraActor::AimTarget1_Offset' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, AimTarget1_RelativeLocation) == 0x000A24, "Member 'AEndBattleCameraActor::AimTarget1_RelativeLocation' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, bAimTarget1_Fix) == 0x000A30, "Member 'AEndBattleCameraActor::bAimTarget1_Fix' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, AimTarget1_OverrideActorName) == 0x000A38, "Member 'AEndBattleCameraActor::AimTarget1_OverrideActorName' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, AimTarget1_OverridePartName) == 0x000A48, "Member 'AEndBattleCameraActor::AimTarget1_OverridePartName' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, AimTarget1_OverrideActorOffset) == 0x000A58, "Member 'AEndBattleCameraActor::AimTarget1_OverrideActorOffset' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, AimTarget_RelativeLocation_RotateType) == 0x000A64, "Member 'AEndBattleCameraActor::AimTarget_RelativeLocation_RotateType' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, EyeTargetType) == 0x000A65, "Member 'AEndBattleCameraActor::EyeTargetType' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, EyeTargetPartName) == 0x000A68, "Member 'AEndBattleCameraActor::EyeTargetPartName' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, EyeTargetOffset) == 0x000A78, "Member 'AEndBattleCameraActor::EyeTargetOffset' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, EyeTargetRelativeLocation) == 0x000A84, "Member 'AEndBattleCameraActor::EyeTargetRelativeLocation' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, EyeTargetRelativeLocationSLerpType) == 0x000A90, "Member 'AEndBattleCameraActor::EyeTargetRelativeLocationSLerpType' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, EyeTargetMovableFOV) == 0x000A94, "Member 'AEndBattleCameraActor::EyeTargetMovableFOV' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, bEyeTarget_Fix) == 0x000A98, "Member 'AEndBattleCameraActor::bEyeTarget_Fix' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, EyeTargetOverrideActorName) == 0x000AA0, "Member 'AEndBattleCameraActor::EyeTargetOverrideActorName' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, EyeTargetOverridePartName) == 0x000AB0, "Member 'AEndBattleCameraActor::EyeTargetOverridePartName' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, EyeTargetOverrideActorOffset) == 0x000AC0, "Member 'AEndBattleCameraActor::EyeTargetOverrideActorOffset' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, EyeToAimTargetRotateType) == 0x000ACC, "Member 'AEndBattleCameraActor::EyeToAimTargetRotateType' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, bEyeToAimTargetRotateIncludePitch) == 0x000ACD, "Member 'AEndBattleCameraActor::bEyeToAimTargetRotateIncludePitch' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, bEyePointFix) == 0x000ACE, "Member 'AEndBattleCameraActor::bEyePointFix' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, bEyeToAimTargetRot_Fix) == 0x000ACF, "Member 'AEndBattleCameraActor::bEyeToAimTargetRot_Fix' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, AimLeapTime) == 0x000AD0, "Member 'AEndBattleCameraActor::AimLeapTime' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, EyeLeapTime) == 0x000AD4, "Member 'AEndBattleCameraActor::EyeLeapTime' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, Roll) == 0x000AD8, "Member 'AEndBattleCameraActor::Roll' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, OthersGameSpeed) == 0x000ADC, "Member 'AEndBattleCameraActor::OthersGameSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, NoOthersGameSpeed) == 0x000AE0, "Member 'AEndBattleCameraActor::NoOthersGameSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, bIncludeOwnerGameSpeed) == 0x000AE4, "Member 'AEndBattleCameraActor::bIncludeOwnerGameSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, bNoIncludeOwnerCameraGameSpeed) == 0x000AE5, "Member 'AEndBattleCameraActor::bNoIncludeOwnerCameraGameSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, NoIncludeActorNameOthersGameSpeed) == 0x000AE8, "Member 'AEndBattleCameraActor::NoIncludeActorNameOthersGameSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, InputOffsetType) == 0x000AF8, "Member 'AEndBattleCameraActor::InputOffsetType' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, ShakeParam) == 0x000B00, "Member 'AEndBattleCameraActor::ShakeParam' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, NoFadeOutActorName) == 0x000B68, "Member 'AEndBattleCameraActor::NoFadeOutActorName' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, bMoveUpEyeWhenHitWall) == 0x000B78, "Member 'AEndBattleCameraActor::bMoveUpEyeWhenHitWall' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, OwnerActor) == 0x000B80, "Member 'AEndBattleCameraActor::OwnerActor' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, TargetActor) == 0x000B88, "Member 'AEndBattleCameraActor::TargetActor' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, SequenceActor) == 0x000BA0, "Member 'AEndBattleCameraActor::SequenceActor' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, NoIncludeActorList_OthersGameSpeed) == 0x000CB8, "Member 'AEndBattleCameraActor::NoIncludeActorList_OthersGameSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, AimTarget0_Actor) == 0x000CD0, "Member 'AEndBattleCameraActor::AimTarget0_Actor' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, AimTarget1_Actor) == 0x000CD8, "Member 'AEndBattleCameraActor::AimTarget1_Actor' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, EyeTargetActor) == 0x000CE0, "Member 'AEndBattleCameraActor::EyeTargetActor' has a wrong offset!");
static_assert(offsetof(AEndBattleCameraActor, NoFadeOutActorList) == 0x000CF8, "Member 'AEndBattleCameraActor::NoFadeOutActorList' has a wrong offset!");

// Class EndGame.EndAnimNotifyStatePlayCharacterSound
// 0x0018 (0x0128 - 0x0110)
class UEndAnimNotifyStatePlayCharacterSound final : public UEndAnimNotifyStatePlaySound
{
public:
	bool                                          bDedicatedAction;                                  // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             DedicatedActionSound;                              // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             DedicatedActionOnEndSound;                         // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStatePlayCharacterSound">();
	}
	static class UEndAnimNotifyStatePlayCharacterSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStatePlayCharacterSound>();
	}
};
static_assert(alignof(UEndAnimNotifyStatePlayCharacterSound) == 0x000008, "Wrong alignment on UEndAnimNotifyStatePlayCharacterSound");
static_assert(sizeof(UEndAnimNotifyStatePlayCharacterSound) == 0x000128, "Wrong size on UEndAnimNotifyStatePlayCharacterSound");
static_assert(offsetof(UEndAnimNotifyStatePlayCharacterSound, bDedicatedAction) == 0x000110, "Member 'UEndAnimNotifyStatePlayCharacterSound::bDedicatedAction' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStatePlayCharacterSound, DedicatedActionSound) == 0x000118, "Member 'UEndAnimNotifyStatePlayCharacterSound::DedicatedActionSound' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStatePlayCharacterSound, DedicatedActionOnEndSound) == 0x000120, "Member 'UEndAnimNotifyStatePlayCharacterSound::DedicatedActionOnEndSound' has a wrong offset!");

// Class EndGame.EndAnimNotifyStatePlayWeaponSound
// 0x0008 (0x0118 - 0x0110)
class UEndAnimNotifyStatePlayWeaponSound final : public UEndAnimNotifyStatePlaySound
{
public:
	EWeaponSlot                                   WeaponSlot;                                        // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStatePlayWeaponSound">();
	}
	static class UEndAnimNotifyStatePlayWeaponSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStatePlayWeaponSound>();
	}
};
static_assert(alignof(UEndAnimNotifyStatePlayWeaponSound) == 0x000008, "Wrong alignment on UEndAnimNotifyStatePlayWeaponSound");
static_assert(sizeof(UEndAnimNotifyStatePlayWeaponSound) == 0x000118, "Wrong size on UEndAnimNotifyStatePlayWeaponSound");
static_assert(offsetof(UEndAnimNotifyStatePlayWeaponSound, WeaponSlot) == 0x000110, "Member 'UEndAnimNotifyStatePlayWeaponSound::WeaponSlot' has a wrong offset!");

// Class EndGame.EndDataObjectPlannerEventTalkInfo
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectPlannerEventTalkInfo final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectPlannerEventTalkInfo">();
	}
	static class UEndDataObjectPlannerEventTalkInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectPlannerEventTalkInfo>();
	}
};
static_assert(alignof(UEndDataObjectPlannerEventTalkInfo) == 0x000008, "Wrong alignment on UEndDataObjectPlannerEventTalkInfo");
static_assert(sizeof(UEndDataObjectPlannerEventTalkInfo) == 0x000088, "Wrong size on UEndDataObjectPlannerEventTalkInfo");

// Class EndGame.EndNavAreaWaterSurface
// 0x0000 (0x0040 - 0x0040)
class UEndNavAreaWaterSurface final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavAreaWaterSurface">();
	}
	static class UEndNavAreaWaterSurface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavAreaWaterSurface>();
	}
};
static_assert(alignof(UEndNavAreaWaterSurface) == 0x000008, "Wrong alignment on UEndNavAreaWaterSurface");
static_assert(sizeof(UEndNavAreaWaterSurface) == 0x000040, "Wrong size on UEndNavAreaWaterSurface");

// Class EndGame.EndBattleAreaActor
// 0x0088 (0x0400 - 0x0378)
class AEndBattleAreaActor final : public AActor
{
public:
	uint8                                         Pad_378[0x8];                                      // 0x0378(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BattleSceneID;                                     // 0x0380(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           SeriesBattleIDs;                                   // 0x0388(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class UEndBattleAreaBoxComponent*             EndBattleAreaBoxComponent;                         // 0x0398(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndCationAreaBoxComponent*             EndCationAreaBoxComponent;                         // 0x03A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndNavModifierComponent*               BattleModifierVolume;                              // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndNavModifierComponent*               CationModifierVolume;                              // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndNavModifierComponent*               ExtendedBattleModifierVolume;                      // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndTextRenderComponent*                TextRenderComponent;                               // 0x03C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<uint64>                                AffectedPolysCacheRef;                             // 0x03C8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FNavPriorRegistInfo                    NavPriorInfo;                                      // 0x03D8(0x0028)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAreaActor">();
	}
	static class AEndBattleAreaActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAreaActor>();
	}
};
static_assert(alignof(AEndBattleAreaActor) == 0x000008, "Wrong alignment on AEndBattleAreaActor");
static_assert(sizeof(AEndBattleAreaActor) == 0x000400, "Wrong size on AEndBattleAreaActor");
static_assert(offsetof(AEndBattleAreaActor, BattleSceneID) == 0x000380, "Member 'AEndBattleAreaActor::BattleSceneID' has a wrong offset!");
static_assert(offsetof(AEndBattleAreaActor, SeriesBattleIDs) == 0x000388, "Member 'AEndBattleAreaActor::SeriesBattleIDs' has a wrong offset!");
static_assert(offsetof(AEndBattleAreaActor, EndBattleAreaBoxComponent) == 0x000398, "Member 'AEndBattleAreaActor::EndBattleAreaBoxComponent' has a wrong offset!");
static_assert(offsetof(AEndBattleAreaActor, EndCationAreaBoxComponent) == 0x0003A0, "Member 'AEndBattleAreaActor::EndCationAreaBoxComponent' has a wrong offset!");
static_assert(offsetof(AEndBattleAreaActor, BattleModifierVolume) == 0x0003A8, "Member 'AEndBattleAreaActor::BattleModifierVolume' has a wrong offset!");
static_assert(offsetof(AEndBattleAreaActor, CationModifierVolume) == 0x0003B0, "Member 'AEndBattleAreaActor::CationModifierVolume' has a wrong offset!");
static_assert(offsetof(AEndBattleAreaActor, ExtendedBattleModifierVolume) == 0x0003B8, "Member 'AEndBattleAreaActor::ExtendedBattleModifierVolume' has a wrong offset!");
static_assert(offsetof(AEndBattleAreaActor, TextRenderComponent) == 0x0003C0, "Member 'AEndBattleAreaActor::TextRenderComponent' has a wrong offset!");
static_assert(offsetof(AEndBattleAreaActor, AffectedPolysCacheRef) == 0x0003C8, "Member 'AEndBattleAreaActor::AffectedPolysCacheRef' has a wrong offset!");
static_assert(offsetof(AEndBattleAreaActor, NavPriorInfo) == 0x0003D8, "Member 'AEndBattleAreaActor::NavPriorInfo' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateSetExtraRadius
// 0x0050 (0x0080 - 0x0030)
class UEndAnimNotifyStateSetExtraRadius final : public UAnimNotifyState
{
public:
	float                                         FieldExtraRadius;                                  // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattleExtraRadius;                                 // 0x0034(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAlphaBlend                            BlendIn;                                           // 0x0038(0x0038)(Edit, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ElapsedTime;                                       // 0x0070(0x0004)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OriginalFieldExtraRadius;                          // 0x0074(0x0004)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OriginalBattleExtraRadius;                         // 0x0078(0x0004)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateSetExtraRadius">();
	}
	static class UEndAnimNotifyStateSetExtraRadius* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateSetExtraRadius>();
	}
};
static_assert(alignof(UEndAnimNotifyStateSetExtraRadius) == 0x000008, "Wrong alignment on UEndAnimNotifyStateSetExtraRadius");
static_assert(sizeof(UEndAnimNotifyStateSetExtraRadius) == 0x000080, "Wrong size on UEndAnimNotifyStateSetExtraRadius");
static_assert(offsetof(UEndAnimNotifyStateSetExtraRadius, FieldExtraRadius) == 0x000030, "Member 'UEndAnimNotifyStateSetExtraRadius::FieldExtraRadius' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateSetExtraRadius, BattleExtraRadius) == 0x000034, "Member 'UEndAnimNotifyStateSetExtraRadius::BattleExtraRadius' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateSetExtraRadius, BlendIn) == 0x000038, "Member 'UEndAnimNotifyStateSetExtraRadius::BlendIn' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateSetExtraRadius, ElapsedTime) == 0x000070, "Member 'UEndAnimNotifyStateSetExtraRadius::ElapsedTime' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateSetExtraRadius, OriginalFieldExtraRadius) == 0x000074, "Member 'UEndAnimNotifyStateSetExtraRadius::OriginalFieldExtraRadius' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateSetExtraRadius, OriginalBattleExtraRadius) == 0x000078, "Member 'UEndAnimNotifyStateSetExtraRadius::OriginalBattleExtraRadius' has a wrong offset!");

// Class EndGame.EndAnimNotifyStateStopAutoRotation
// 0x0000 (0x0030 - 0x0030)
class UEndAnimNotifyStateStopAutoRotation final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateStopAutoRotation">();
	}
	static class UEndAnimNotifyStateStopAutoRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateStopAutoRotation>();
	}
};
static_assert(alignof(UEndAnimNotifyStateStopAutoRotation) == 0x000008, "Wrong alignment on UEndAnimNotifyStateStopAutoRotation");
static_assert(sizeof(UEndAnimNotifyStateStopAutoRotation) == 0x000030, "Wrong size on UEndAnimNotifyStateStopAutoRotation");

// Class EndGame.EndBattleAIYuffieController
// 0x0060 (0x3900 - 0x38A0)
class AEndBattleAIYuffieController final : public AEndBattleAIPcBaseController
{
public:
	struct FBattleParam                           AutoPlayBareHandsBattleParam;                      // 0x38A0(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBattleParam                           AutoPlayLinkModeBattleParam;                       // 0x38D0(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIYuffieController">();
	}
	static class AEndBattleAIYuffieController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIYuffieController>();
	}
};
static_assert(alignof(AEndBattleAIYuffieController) == 0x000008, "Wrong alignment on AEndBattleAIYuffieController");
static_assert(sizeof(AEndBattleAIYuffieController) == 0x003900, "Wrong size on AEndBattleAIYuffieController");
static_assert(offsetof(AEndBattleAIYuffieController, AutoPlayBareHandsBattleParam) == 0x0038A0, "Member 'AEndBattleAIYuffieController::AutoPlayBareHandsBattleParam' has a wrong offset!");
static_assert(offsetof(AEndBattleAIYuffieController, AutoPlayLinkModeBattleParam) == 0x0038D0, "Member 'AEndBattleAIYuffieController::AutoPlayLinkModeBattleParam' has a wrong offset!");

// Class EndGame.EndPhysicsAPI
// 0x0000 (0x0028 - 0x0028)
class UEndPhysicsAPI final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndPhysicsAPI">();
	}
	static class UEndPhysicsAPI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndPhysicsAPI>();
	}
};
static_assert(alignof(UEndPhysicsAPI) == 0x000008, "Wrong alignment on UEndPhysicsAPI");
static_assert(sizeof(UEndPhysicsAPI) == 0x000028, "Wrong size on UEndPhysicsAPI");

// Class EndGame.EndAnimNotifyStateTransparent
// 0x0008 (0x0038 - 0x0030)
class UEndAnimNotifyStateTransparent final : public UAnimNotifyState
{
public:
	float                                         TurnTransparentTime;                               // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnOpaqueTime;                                    // 0x0034(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifyStateTransparent">();
	}
	static class UEndAnimNotifyStateTransparent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifyStateTransparent>();
	}
};
static_assert(alignof(UEndAnimNotifyStateTransparent) == 0x000008, "Wrong alignment on UEndAnimNotifyStateTransparent");
static_assert(sizeof(UEndAnimNotifyStateTransparent) == 0x000038, "Wrong size on UEndAnimNotifyStateTransparent");
static_assert(offsetof(UEndAnimNotifyStateTransparent, TurnTransparentTime) == 0x000030, "Member 'UEndAnimNotifyStateTransparent::TurnTransparentTime' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifyStateTransparent, TurnOpaqueTime) == 0x000034, "Member 'UEndAnimNotifyStateTransparent::TurnOpaqueTime' has a wrong offset!");

// Class EndGame.EndAnimNotifySyncProtectStart
// 0x0010 (0x0048 - 0x0038)
class UEndAnimNotifySyncProtectStart final : public UAnimNotify
{
public:
	class FName                                   AbilityID;                                         // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAerial;                                           // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimNotifySyncProtectStart">();
	}
	static class UEndAnimNotifySyncProtectStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimNotifySyncProtectStart>();
	}
};
static_assert(alignof(UEndAnimNotifySyncProtectStart) == 0x000008, "Wrong alignment on UEndAnimNotifySyncProtectStart");
static_assert(sizeof(UEndAnimNotifySyncProtectStart) == 0x000048, "Wrong size on UEndAnimNotifySyncProtectStart");
static_assert(offsetof(UEndAnimNotifySyncProtectStart, AbilityID) == 0x000038, "Member 'UEndAnimNotifySyncProtectStart::AbilityID' has a wrong offset!");
static_assert(offsetof(UEndAnimNotifySyncProtectStart, bAerial) == 0x000040, "Member 'UEndAnimNotifySyncProtectStart::bAerial' has a wrong offset!");

// Class EndGame.EndDataObjectBattleConditionTriggerGroup
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleConditionTriggerGroup final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleConditionTriggerGroup">();
	}
	static class UEndDataObjectBattleConditionTriggerGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleConditionTriggerGroup>();
	}
};
static_assert(alignof(UEndDataObjectBattleConditionTriggerGroup) == 0x000008, "Wrong alignment on UEndDataObjectBattleConditionTriggerGroup");
static_assert(sizeof(UEndDataObjectBattleConditionTriggerGroup) == 0x000088, "Wrong size on UEndDataObjectBattleConditionTriggerGroup");

// Class EndGame.EndAnimSequencerInstance
// 0x0000 (0x0430 - 0x0430)
class UEndAnimSequencerInstance final : public UAnimSequencerInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimSequencerInstance">();
	}
	static class UEndAnimSequencerInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimSequencerInstance>();
	}
};
static_assert(alignof(UEndAnimSequencerInstance) == 0x000008, "Wrong alignment on UEndAnimSequencerInstance");
static_assert(sizeof(UEndAnimSequencerInstance) == 0x000430, "Wrong size on UEndAnimSequencerInstance");

// Class EndGame.EndDataObjectBattleDamageSourceLevel
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleDamageSourceLevel final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleDamageSourceLevel">();
	}
	static class UEndDataObjectBattleDamageSourceLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleDamageSourceLevel>();
	}
};
static_assert(alignof(UEndDataObjectBattleDamageSourceLevel) == 0x000008, "Wrong alignment on UEndDataObjectBattleDamageSourceLevel");
static_assert(sizeof(UEndDataObjectBattleDamageSourceLevel) == 0x000088, "Wrong size on UEndDataObjectBattleDamageSourceLevel");

// Class EndGame.EndAnimSinglePlayInstance
// 0x0008 (0x0430 - 0x0428)
class UEndAnimSinglePlayInstance final : public UAnimInstance
{
public:
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimSinglePlayInstance">();
	}
	static class UEndAnimSinglePlayInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimSinglePlayInstance>();
	}
};
static_assert(alignof(UEndAnimSinglePlayInstance) == 0x000008, "Wrong alignment on UEndAnimSinglePlayInstance");
static_assert(sizeof(UEndAnimSinglePlayInstance) == 0x000430, "Wrong size on UEndAnimSinglePlayInstance");

// Class EndGame.EndDataObjectBattlePlayerParameter
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattlePlayerParameter final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattlePlayerParameter">();
	}
	static class UEndDataObjectBattlePlayerParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattlePlayerParameter>();
	}
};
static_assert(alignof(UEndDataObjectBattlePlayerParameter) == 0x000008, "Wrong alignment on UEndDataObjectBattlePlayerParameter");
static_assert(sizeof(UEndDataObjectBattlePlayerParameter) == 0x000088, "Wrong size on UEndDataObjectBattlePlayerParameter");

// Class EndGame.EndAnimWeaponInstance
// 0x0060 (0x04B0 - 0x0450)
class UEndAnimWeaponInstance final : public UEndAnimSingleNodeInstance
{
public:
	uint8                                         Pad_450[0x60];                                     // 0x0450(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAnimWeaponInstance">();
	}
	static class UEndAnimWeaponInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAnimWeaponInstance>();
	}
};
static_assert(alignof(UEndAnimWeaponInstance) == 0x000008, "Wrong alignment on UEndAnimWeaponInstance");
static_assert(sizeof(UEndAnimWeaponInstance) == 0x0004B0, "Wrong size on UEndAnimWeaponInstance");

// Class EndGame.EndDataObjectBattleRole
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleRole final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleRole">();
	}
	static class UEndDataObjectBattleRole* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleRole>();
	}
};
static_assert(alignof(UEndDataObjectBattleRole) == 0x000008, "Wrong alignment on UEndDataObjectBattleRole");
static_assert(sizeof(UEndDataObjectBattleRole) == 0x000088, "Wrong size on UEndDataObjectBattleRole");

// Class EndGame.EndAreaMapObjectiveLabel
// 0x0020 (0x0380 - 0x0360)
class UEndAreaMapObjectiveLabel : public UEndUserWidget
{
public:
	struct FLinearColor                           MainStoryColor;                                    // 0x0360(0x0010)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SubStoryColor;                                     // 0x0370(0x0010)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAreaMapObjectiveLabel">();
	}
	static class UEndAreaMapObjectiveLabel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAreaMapObjectiveLabel>();
	}
};
static_assert(alignof(UEndAreaMapObjectiveLabel) == 0x000008, "Wrong alignment on UEndAreaMapObjectiveLabel");
static_assert(sizeof(UEndAreaMapObjectiveLabel) == 0x000380, "Wrong size on UEndAreaMapObjectiveLabel");
static_assert(offsetof(UEndAreaMapObjectiveLabel, MainStoryColor) == 0x000360, "Member 'UEndAreaMapObjectiveLabel::MainStoryColor' has a wrong offset!");
static_assert(offsetof(UEndAreaMapObjectiveLabel, SubStoryColor) == 0x000370, "Member 'UEndAreaMapObjectiveLabel::SubStoryColor' has a wrong offset!");

// Class EndGame.EndCondorFortMiniGameMateriaInfo
// 0x00B8 (0x0418 - 0x0360)
class UEndCondorFortMiniGameMateriaInfo final : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0xB8];                                     // 0x0360(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCondorFortMiniGameMateriaInfo">();
	}
	static class UEndCondorFortMiniGameMateriaInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndCondorFortMiniGameMateriaInfo>();
	}
};
static_assert(alignof(UEndCondorFortMiniGameMateriaInfo) == 0x000008, "Wrong alignment on UEndCondorFortMiniGameMateriaInfo");
static_assert(sizeof(UEndCondorFortMiniGameMateriaInfo) == 0x000418, "Wrong size on UEndCondorFortMiniGameMateriaInfo");

// Class EndGame.EndAssetClassActor
// 0x0010 (0x0388 - 0x0378)
class AEndAssetClassActor final : public AActor
{
public:
	TArray<TSubclassOf<class UObject>>            AssetUserData;                                     // 0x0378(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAssetClassActor">();
	}
	static class AEndAssetClassActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndAssetClassActor>();
	}
};
static_assert(alignof(AEndAssetClassActor) == 0x000008, "Wrong alignment on AEndAssetClassActor");
static_assert(sizeof(AEndAssetClassActor) == 0x000388, "Wrong size on AEndAssetClassActor");
static_assert(offsetof(AEndAssetClassActor, AssetUserData) == 0x000378, "Member 'AEndAssetClassActor::AssetUserData' has a wrong offset!");

// Class EndGame.EndAssetLoader
// 0x0000 (0x0028 - 0x0028)
class UEndAssetLoader final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAssetLoader">();
	}
	static class UEndAssetLoader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAssetLoader>();
	}
};
static_assert(alignof(UEndAssetLoader) == 0x000008, "Wrong alignment on UEndAssetLoader");
static_assert(sizeof(UEndAssetLoader) == 0x000028, "Wrong size on UEndAssetLoader");

// Class EndGame.EndCondorFortMiniGameTopWindow
// 0x03B8 (0x0718 - 0x0360)
class UEndCondorFortMiniGameTopWindow final : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x3B8];                                    // 0x0360(0x03B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector2D OnMeasureStatusItemEnemy(int32 ItemIndex);
	struct FVector2D OnMeasureStatusItemPlayer(int32 ItemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCondorFortMiniGameTopWindow">();
	}
	static class UEndCondorFortMiniGameTopWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndCondorFortMiniGameTopWindow>();
	}
};
static_assert(alignof(UEndCondorFortMiniGameTopWindow) == 0x000008, "Wrong alignment on UEndCondorFortMiniGameTopWindow");
static_assert(sizeof(UEndCondorFortMiniGameTopWindow) == 0x000718, "Wrong size on UEndCondorFortMiniGameTopWindow");

// Class EndGame.EndAssetSaveData
// 0x0070 (0x0098 - 0x0028)
class UEndAssetSaveData final : public UObject
{
public:
	class FString                                 Name_0;                                            // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 ResidentChunkData;                                 // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 ResidentSaveData;                                  // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 LocationChunkData;                                 // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 LocationSaveData;                                  // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 SaveData;                                          // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSEndAssetLocationSaveData>     LocationSaveDataSet;                               // 0x0088(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAssetSaveData">();
	}
	static class UEndAssetSaveData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAssetSaveData>();
	}
};
static_assert(alignof(UEndAssetSaveData) == 0x000008, "Wrong alignment on UEndAssetSaveData");
static_assert(sizeof(UEndAssetSaveData) == 0x000098, "Wrong size on UEndAssetSaveData");
static_assert(offsetof(UEndAssetSaveData, Name_0) == 0x000028, "Member 'UEndAssetSaveData::Name_0' has a wrong offset!");
static_assert(offsetof(UEndAssetSaveData, ResidentChunkData) == 0x000038, "Member 'UEndAssetSaveData::ResidentChunkData' has a wrong offset!");
static_assert(offsetof(UEndAssetSaveData, ResidentSaveData) == 0x000048, "Member 'UEndAssetSaveData::ResidentSaveData' has a wrong offset!");
static_assert(offsetof(UEndAssetSaveData, LocationChunkData) == 0x000058, "Member 'UEndAssetSaveData::LocationChunkData' has a wrong offset!");
static_assert(offsetof(UEndAssetSaveData, LocationSaveData) == 0x000068, "Member 'UEndAssetSaveData::LocationSaveData' has a wrong offset!");
static_assert(offsetof(UEndAssetSaveData, SaveData) == 0x000078, "Member 'UEndAssetSaveData::SaveData' has a wrong offset!");
static_assert(offsetof(UEndAssetSaveData, LocationSaveDataSet) == 0x000088, "Member 'UEndAssetSaveData::LocationSaveDataSet' has a wrong offset!");

// Class EndGame.EndBattleAbilityRotateState
// 0x0018 (0x0048 - 0x0030)
class UEndBattleAbilityRotateState final : public UAnimNotifyState
{
public:
	EBattleAbilityRotateNotifyState               Type;                                              // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartAngle;                                        // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GoalAngle;                                         // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateVelocity;                                    // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAbilityRotateStartType                 StartType;                                         // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAbilityInterpolationType               InterpolationType;                                 // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FrameDeltaTimeSpeed;                               // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAbilityRotateState">();
	}
	static class UEndBattleAbilityRotateState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleAbilityRotateState>();
	}
};
static_assert(alignof(UEndBattleAbilityRotateState) == 0x000008, "Wrong alignment on UEndBattleAbilityRotateState");
static_assert(sizeof(UEndBattleAbilityRotateState) == 0x000048, "Wrong size on UEndBattleAbilityRotateState");
static_assert(offsetof(UEndBattleAbilityRotateState, Type) == 0x000030, "Member 'UEndBattleAbilityRotateState::Type' has a wrong offset!");
static_assert(offsetof(UEndBattleAbilityRotateState, StartAngle) == 0x000034, "Member 'UEndBattleAbilityRotateState::StartAngle' has a wrong offset!");
static_assert(offsetof(UEndBattleAbilityRotateState, GoalAngle) == 0x000038, "Member 'UEndBattleAbilityRotateState::GoalAngle' has a wrong offset!");
static_assert(offsetof(UEndBattleAbilityRotateState, RotateVelocity) == 0x00003C, "Member 'UEndBattleAbilityRotateState::RotateVelocity' has a wrong offset!");
static_assert(offsetof(UEndBattleAbilityRotateState, StartType) == 0x000040, "Member 'UEndBattleAbilityRotateState::StartType' has a wrong offset!");
static_assert(offsetof(UEndBattleAbilityRotateState, InterpolationType) == 0x000041, "Member 'UEndBattleAbilityRotateState::InterpolationType' has a wrong offset!");
static_assert(offsetof(UEndBattleAbilityRotateState, FrameDeltaTimeSpeed) == 0x000044, "Member 'UEndBattleAbilityRotateState::FrameDeltaTimeSpeed' has a wrong offset!");

// Class EndGame.EndCutAPI
// 0x0000 (0x0028 - 0x0028)
class UEndCutAPI final : public UObject
{
public:
	static float GetCurrentTime(class FName LevelName);
	static float GetTimeRange(class FName LevelName);
	static bool IsActorCreated(class FName LevelName);
	static bool IsExistEvent(class FName LevelName);
	static bool IsPlayFinished(class FName LevelName);
	static bool IsPlaying();
	static bool IsPlaying_TypeSpecify(const bool EV, const bool LV, const bool MV, const bool fv);
	static bool IsPlayReady(class FName LevelName);
	static bool IsSkipCinema();
	static bool IsSkipCinemaAtThisFrame();
	static bool IsStable();
	static bool IsValidSelectWidget();
	static void LoadSequenceAssets(class FName LevelName, int32 Priority);
	static bool PlayCutScene(class FName LevelName, class FName OnPlayTriggerName, bool bStopSkip);
	static bool ReadyCutScene(class FName LevelName);
	static void RequestPlayCutScene(class FName LevelName);
	static void SetCurrentTime(class FName LevelName, float InTime);
	static void SkipCinema(bool Enable);
	static void UnloadSequenceAssets(class FName LevelName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCutAPI">();
	}
	static class UEndCutAPI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndCutAPI>();
	}
};
static_assert(alignof(UEndCutAPI) == 0x000008, "Wrong alignment on UEndCutAPI");
static_assert(sizeof(UEndCutAPI) == 0x000028, "Wrong size on UEndCutAPI");

// Class EndGame.EndBattleAIAttachedController
// 0x0008 (0x2290 - 0x2288)
class AEndBattleAIAttachedController final : public AEndBattleAIController
{
public:
	uint8                                         Pad_2288[0x8];                                     // 0x2288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIAttachedController">();
	}
	static class AEndBattleAIAttachedController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIAttachedController>();
	}
};
static_assert(alignof(AEndBattleAIAttachedController) == 0x000008, "Wrong alignment on AEndBattleAIAttachedController");
static_assert(sizeof(AEndBattleAIAttachedController) == 0x002290, "Wrong size on AEndBattleAIAttachedController");

// Class EndGame.EndDataObjectAction
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectAction final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectAction">();
	}
	static class UEndDataObjectAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectAction>();
	}
};
static_assert(alignof(UEndDataObjectAction) == 0x000008, "Wrong alignment on UEndDataObjectAction");
static_assert(sizeof(UEndDataObjectAction) == 0x000088, "Wrong size on UEndDataObjectAction");

// Class EndGame.EndBattleAIBaseAsyncComponent
// 0x0030 (0x0128 - 0x00F8)
class UEndBattleAIBaseAsyncComponent final : public UActorComponent
{
public:
	class AEndCharacter*                          thiz;                                              // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AEndBattleAIController*                 bai;                                               // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x20];                                     // 0x0108(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIBaseAsyncComponent">();
	}
	static class UEndBattleAIBaseAsyncComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleAIBaseAsyncComponent>();
	}
};
static_assert(alignof(UEndBattleAIBaseAsyncComponent) == 0x000008, "Wrong alignment on UEndBattleAIBaseAsyncComponent");
static_assert(sizeof(UEndBattleAIBaseAsyncComponent) == 0x000128, "Wrong size on UEndBattleAIBaseAsyncComponent");
static_assert(offsetof(UEndBattleAIBaseAsyncComponent, thiz) == 0x0000F8, "Member 'UEndBattleAIBaseAsyncComponent::thiz' has a wrong offset!");
static_assert(offsetof(UEndBattleAIBaseAsyncComponent, bai) == 0x000100, "Member 'UEndBattleAIBaseAsyncComponent::bai' has a wrong offset!");

// Class EndGame.EndBattleAICloudController
// 0x0040 (0x38E0 - 0x38A0)
class AEndBattleAICloudController : public AEndBattleAIPcBaseController
{
public:
	struct FBattleParam                           BraveBattleParam;                                  // 0x38A0(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         CombatDistanceBatBrave;                            // 0x38D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38D4[0xC];                                     // 0x38D4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAICloudController">();
	}
	static class AEndBattleAICloudController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAICloudController>();
	}
};
static_assert(alignof(AEndBattleAICloudController) == 0x000008, "Wrong alignment on AEndBattleAICloudController");
static_assert(sizeof(AEndBattleAICloudController) == 0x0038E0, "Wrong size on AEndBattleAICloudController");
static_assert(offsetof(AEndBattleAICloudController, BraveBattleParam) == 0x0038A0, "Member 'AEndBattleAICloudController::BraveBattleParam' has a wrong offset!");
static_assert(offsetof(AEndBattleAICloudController, CombatDistanceBatBrave) == 0x0038D0, "Member 'AEndBattleAICloudController::CombatDistanceBatBrave' has a wrong offset!");

// Class EndGame.EndBTTask_WarpTo
// 0x0058 (0x00C8 - 0x0070)
class UEndBTTask_WarpTo final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 LocationBlackboardKey;                             // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 FromBlackboardKey_InWarp;                          // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_WarpTo">();
	}
	static class UEndBTTask_WarpTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_WarpTo>();
	}
};
static_assert(alignof(UEndBTTask_WarpTo) == 0x000008, "Wrong alignment on UEndBTTask_WarpTo");
static_assert(sizeof(UEndBTTask_WarpTo) == 0x0000C8, "Wrong size on UEndBTTask_WarpTo");
static_assert(offsetof(UEndBTTask_WarpTo, LocationBlackboardKey) == 0x000070, "Member 'UEndBTTask_WarpTo::LocationBlackboardKey' has a wrong offset!");
static_assert(offsetof(UEndBTTask_WarpTo, FromBlackboardKey_InWarp) == 0x000098, "Member 'UEndBTTask_WarpTo::FromBlackboardKey_InWarp' has a wrong offset!");

// Class EndGame.NumberBranch
// 0x0068 (0x0090 - 0x0028)
class UNumberBranch final : public UOnlineBlueprintCallProxyBase
{
public:
	UMulticastDelegateProperty_                   Greater;                                           // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   GreaterEqual;                                      // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Equal;                                             // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   LessEqual;                                         // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Less;                                              // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotEqual;                                          // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UNumberBranch* NumberBranch(int32 InNumA, int32 InNumB);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NumberBranch">();
	}
	static class UNumberBranch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNumberBranch>();
	}
};
static_assert(alignof(UNumberBranch) == 0x000008, "Wrong alignment on UNumberBranch");
static_assert(sizeof(UNumberBranch) == 0x000090, "Wrong size on UNumberBranch");
static_assert(offsetof(UNumberBranch, Greater) == 0x000028, "Member 'UNumberBranch::Greater' has a wrong offset!");
static_assert(offsetof(UNumberBranch, GreaterEqual) == 0x000038, "Member 'UNumberBranch::GreaterEqual' has a wrong offset!");
static_assert(offsetof(UNumberBranch, Equal) == 0x000048, "Member 'UNumberBranch::Equal' has a wrong offset!");
static_assert(offsetof(UNumberBranch, LessEqual) == 0x000058, "Member 'UNumberBranch::LessEqual' has a wrong offset!");
static_assert(offsetof(UNumberBranch, Less) == 0x000068, "Member 'UNumberBranch::Less' has a wrong offset!");
static_assert(offsetof(UNumberBranch, NotEqual) == 0x000078, "Member 'UNumberBranch::NotEqual' has a wrong offset!");

// Class EndGame.EndCameraComponent
// 0x0010 (0x0920 - 0x0910)
class UEndCameraComponent final : public UCameraComponent
{
public:
	float                                         FocalLength;                                       // 0x0910(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusDistance;                                     // 0x0914(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilmWidth;                                         // 0x0918(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Roll;                                              // 0x091C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetFocalLength(float NewValue);
	void SetFocusDistance(float NewValue);
	void SetHorizontalAperture(float NewValue);
	void SetRoll(float NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCameraComponent">();
	}
	static class UEndCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndCameraComponent>();
	}
};
static_assert(alignof(UEndCameraComponent) == 0x000010, "Wrong alignment on UEndCameraComponent");
static_assert(sizeof(UEndCameraComponent) == 0x000920, "Wrong size on UEndCameraComponent");
static_assert(offsetof(UEndCameraComponent, FocalLength) == 0x000910, "Member 'UEndCameraComponent::FocalLength' has a wrong offset!");
static_assert(offsetof(UEndCameraComponent, FocusDistance) == 0x000914, "Member 'UEndCameraComponent::FocusDistance' has a wrong offset!");
static_assert(offsetof(UEndCameraComponent, FilmWidth) == 0x000918, "Member 'UEndCameraComponent::FilmWidth' has a wrong offset!");
static_assert(offsetof(UEndCameraComponent, Roll) == 0x00091C, "Member 'UEndCameraComponent::Roll' has a wrong offset!");

// Class EndGame.RangeSwitch3
// 0x0060 (0x0088 - 0x0028)
class URangeSwitch3 final : public UOnlineBlueprintCallProxyBase
{
public:
	UMulticastDelegateProperty_                   Case1;                                             // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Case2;                                             // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Case3;                                             // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Other;                                             // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x20];                                      // 0x0068(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class URangeSwitch3* RangeSwitch3(float Value, float Min1, float Max1, float Min2, float Max2, float Min3, float Max3, bool ContainEqual, bool FirstOnly);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RangeSwitch3">();
	}
	static class URangeSwitch3* GetDefaultObj()
	{
		return GetDefaultObjImpl<URangeSwitch3>();
	}
};
static_assert(alignof(URangeSwitch3) == 0x000008, "Wrong alignment on URangeSwitch3");
static_assert(sizeof(URangeSwitch3) == 0x000088, "Wrong size on URangeSwitch3");
static_assert(offsetof(URangeSwitch3, Case1) == 0x000028, "Member 'URangeSwitch3::Case1' has a wrong offset!");
static_assert(offsetof(URangeSwitch3, Case2) == 0x000038, "Member 'URangeSwitch3::Case2' has a wrong offset!");
static_assert(offsetof(URangeSwitch3, Case3) == 0x000048, "Member 'URangeSwitch3::Case3' has a wrong offset!");
static_assert(offsetof(URangeSwitch3, Other) == 0x000058, "Member 'URangeSwitch3::Other' has a wrong offset!");

// Class EndGame.EndBattleAIEB0000Controller
// 0x0048 (0x22D0 - 0x2288)
class AEndBattleAIEB0000Controller final : public AEndBattleAIController
{
public:
	float                                         JumpTurnTime;                                      // 0x2288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpTurnBias;                                      // 0x228C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpTurnAngle;                                     // 0x2290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2294[0x3C];                                    // 0x2294(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsGSFly();
	bool IsOnFloor();
	bool IsOnWall();
	bool IsTurnJump();
	void OnTurnJumpBegin();
	void OnTurnJumpEnd();
	void ReleaseWallJump(int32 InID, float InTime, float InBias);
	void RequestWallJump(int32 InID, float InTime, float InBias);
	void SetForceJumpEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEB0000Controller">();
	}
	static class AEndBattleAIEB0000Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEB0000Controller>();
	}
};
static_assert(alignof(AEndBattleAIEB0000Controller) == 0x000008, "Wrong alignment on AEndBattleAIEB0000Controller");
static_assert(sizeof(AEndBattleAIEB0000Controller) == 0x0022D0, "Wrong size on AEndBattleAIEB0000Controller");
static_assert(offsetof(AEndBattleAIEB0000Controller, JumpTurnTime) == 0x002288, "Member 'AEndBattleAIEB0000Controller::JumpTurnTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0000Controller, JumpTurnBias) == 0x00228C, "Member 'AEndBattleAIEB0000Controller::JumpTurnBias' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0000Controller, JumpTurnAngle) == 0x002290, "Member 'AEndBattleAIEB0000Controller::JumpTurnAngle' has a wrong offset!");

// Class EndGame.EndDebugRailCameraObject
// 0x0008 (0x0030 - 0x0028)
class UEndDebugRailCameraObject final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDebugRailCameraObject">();
	}
	static class UEndDebugRailCameraObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDebugRailCameraObject>();
	}
};
static_assert(alignof(UEndDebugRailCameraObject) == 0x000008, "Wrong alignment on UEndDebugRailCameraObject");
static_assert(sizeof(UEndDebugRailCameraObject) == 0x000030, "Wrong size on UEndDebugRailCameraObject");

// Class EndGame.EndBattleAIEB0002Controller
// 0x00A8 (0x2330 - 0x2288)
class AEndBattleAIEB0002Controller final : public AEndBattleAIController
{
public:
	uint8                                         Pad_2288[0x18];                                    // 0x2288(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AEndEmitter*>                    Vernier;                                           // 0x22A0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_22B0[0x74];                                    // 0x22B0(0x0074)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          DebugShowSocketWayPoint;                           // 0x2324(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2325[0xB];                                     // 0x2325(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDetachArm(EEndBattleCharaAttachCharacterType armType);
	void OnDetachArms();
	void OnRemoveStatusChangeStopToChildCharacter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEB0002Controller">();
	}
	static class AEndBattleAIEB0002Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEB0002Controller>();
	}
};
static_assert(alignof(AEndBattleAIEB0002Controller) == 0x000008, "Wrong alignment on AEndBattleAIEB0002Controller");
static_assert(sizeof(AEndBattleAIEB0002Controller) == 0x002330, "Wrong size on AEndBattleAIEB0002Controller");
static_assert(offsetof(AEndBattleAIEB0002Controller, Vernier) == 0x0022A0, "Member 'AEndBattleAIEB0002Controller::Vernier' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0002Controller, DebugShowSocketWayPoint) == 0x002324, "Member 'AEndBattleAIEB0002Controller::DebugShowSocketWayPoint' has a wrong offset!");

// Class EndGame.EndBattleAIEB0003MineController
// 0x00D8 (0x2360 - 0x2288)
class AEndBattleAIEB0003MineController final : public AEndBattleAIController
{
public:
	float                                         MineMaxSpeed;                                      // 0x2288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MineSnapSpeed;                                     // 0x228C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MineSnapEndQuantity;                               // 0x2290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RenoDistance;                                      // 0x2294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UcpcDistance;                                      // 0x2298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RepulsiveDistance;                                 // 0x229C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RepulsiveAccQuantity;                              // 0x22A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22A4[0x4];                                     // 0x22A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           IgnoreRepulsiveActgions;                           // 0x22A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         MineMoveInterval;                                  // 0x22B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RepulsiveOriginInterval;                           // 0x22BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           IgnoreStopFollowAction;                            // 0x22C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           IgnoreStopReturnAction;                            // 0x22D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bCanFollow;                                        // 0x22E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanRollingAtack;                                  // 0x22E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22E2[0x2];                                     // 0x22E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RollingAtackStartDistance;                         // 0x22E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RollingAtackPhase1Time;                            // 0x22E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RollingAtackPhase1Height;                          // 0x22EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RollingAtackSpeed;                                 // 0x22F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RollingAtackRadius;                                // 0x22F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RollingAtackFinish;                                // 0x22F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ReturnLocation;                                    // 0x22FC(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReturnSpeed;                                       // 0x2308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnSpeed;                                         // 0x230C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2310[0x50];                                    // 0x2310(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsPlayerInConfirmSpark();
	bool IsRolling();
	void OnCheckFollow(bool OutBattleArea, bool NotOwnerTrace, bool NotUcpcTrace);
	void OnReadySpark(int32 sparkID);
	void ReadySpark(int32 sparkID);
	void SetFollow(bool InFollow, const struct FVector& InLocation);
	void SetOverrideFollowTarget(class AEndCharacter* InChara);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEB0003MineController">();
	}
	static class AEndBattleAIEB0003MineController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEB0003MineController>();
	}
};
static_assert(alignof(AEndBattleAIEB0003MineController) == 0x000008, "Wrong alignment on AEndBattleAIEB0003MineController");
static_assert(sizeof(AEndBattleAIEB0003MineController) == 0x002360, "Wrong size on AEndBattleAIEB0003MineController");
static_assert(offsetof(AEndBattleAIEB0003MineController, MineMaxSpeed) == 0x002288, "Member 'AEndBattleAIEB0003MineController::MineMaxSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0003MineController, MineSnapSpeed) == 0x00228C, "Member 'AEndBattleAIEB0003MineController::MineSnapSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0003MineController, MineSnapEndQuantity) == 0x002290, "Member 'AEndBattleAIEB0003MineController::MineSnapEndQuantity' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0003MineController, RenoDistance) == 0x002294, "Member 'AEndBattleAIEB0003MineController::RenoDistance' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0003MineController, UcpcDistance) == 0x002298, "Member 'AEndBattleAIEB0003MineController::UcpcDistance' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0003MineController, RepulsiveDistance) == 0x00229C, "Member 'AEndBattleAIEB0003MineController::RepulsiveDistance' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0003MineController, RepulsiveAccQuantity) == 0x0022A0, "Member 'AEndBattleAIEB0003MineController::RepulsiveAccQuantity' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0003MineController, IgnoreRepulsiveActgions) == 0x0022A8, "Member 'AEndBattleAIEB0003MineController::IgnoreRepulsiveActgions' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0003MineController, MineMoveInterval) == 0x0022B8, "Member 'AEndBattleAIEB0003MineController::MineMoveInterval' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0003MineController, RepulsiveOriginInterval) == 0x0022BC, "Member 'AEndBattleAIEB0003MineController::RepulsiveOriginInterval' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0003MineController, IgnoreStopFollowAction) == 0x0022C0, "Member 'AEndBattleAIEB0003MineController::IgnoreStopFollowAction' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0003MineController, IgnoreStopReturnAction) == 0x0022D0, "Member 'AEndBattleAIEB0003MineController::IgnoreStopReturnAction' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0003MineController, bCanFollow) == 0x0022E0, "Member 'AEndBattleAIEB0003MineController::bCanFollow' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0003MineController, bCanRollingAtack) == 0x0022E1, "Member 'AEndBattleAIEB0003MineController::bCanRollingAtack' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0003MineController, RollingAtackStartDistance) == 0x0022E4, "Member 'AEndBattleAIEB0003MineController::RollingAtackStartDistance' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0003MineController, RollingAtackPhase1Time) == 0x0022E8, "Member 'AEndBattleAIEB0003MineController::RollingAtackPhase1Time' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0003MineController, RollingAtackPhase1Height) == 0x0022EC, "Member 'AEndBattleAIEB0003MineController::RollingAtackPhase1Height' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0003MineController, RollingAtackSpeed) == 0x0022F0, "Member 'AEndBattleAIEB0003MineController::RollingAtackSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0003MineController, RollingAtackRadius) == 0x0022F4, "Member 'AEndBattleAIEB0003MineController::RollingAtackRadius' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0003MineController, RollingAtackFinish) == 0x0022F8, "Member 'AEndBattleAIEB0003MineController::RollingAtackFinish' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0003MineController, ReturnLocation) == 0x0022FC, "Member 'AEndBattleAIEB0003MineController::ReturnLocation' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0003MineController, ReturnSpeed) == 0x002308, "Member 'AEndBattleAIEB0003MineController::ReturnSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0003MineController, TurnSpeed) == 0x00230C, "Member 'AEndBattleAIEB0003MineController::TurnSpeed' has a wrong offset!");

// Class EndGame.EndCanvasPanelSlot
// 0x0040 (0x0078 - 0x0038)
class UEndCanvasPanelSlot final : public UPanelSlot
{
public:
	struct FAnchorData                            LayoutData;                                        // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAutoSize;                                         // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDelayedBuild;                                     // 0x0061(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x2];                                       // 0x0062(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ZOrder;                                            // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         XAngle;                                            // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YAngle;                                            // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAlignment(const struct FVector2D& InAlignment);
	void SetAnchors(const struct FAnchors& InAnchors);
	void SetAutoSize(bool InbAutoSize);
	void SetLayout(const struct FAnchorData& InLayoutData);
	void SetMaximum(const struct FVector2D& InMaximumAnchors);
	void SetMinimum(const struct FVector2D& InMinimumAnchors);
	void SetOffsets(const struct FMargin& InOffset);
	void SetPosition(const struct FVector2D& InPosition);
	void SetSize(const struct FVector2D& InSize);
	void SetXAngle(float InYAngle);
	void SetYAngle(float InYAngle);
	void SetZOrder(int32 InZOrder);

	struct FVector2D GetAlignment() const;
	struct FAnchors GetAnchors() const;
	bool GetAutoSize() const;
	struct FAnchorData GetLayout() const;
	struct FMargin GetOffsets() const;
	struct FVector2D GetPosition() const;
	struct FVector2D GetSize() const;
	float GetXAngle() const;
	float GetYAngle() const;
	int32 GetZOrder() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCanvasPanelSlot">();
	}
	static class UEndCanvasPanelSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndCanvasPanelSlot>();
	}
};
static_assert(alignof(UEndCanvasPanelSlot) == 0x000008, "Wrong alignment on UEndCanvasPanelSlot");
static_assert(sizeof(UEndCanvasPanelSlot) == 0x000078, "Wrong size on UEndCanvasPanelSlot");
static_assert(offsetof(UEndCanvasPanelSlot, LayoutData) == 0x000038, "Member 'UEndCanvasPanelSlot::LayoutData' has a wrong offset!");
static_assert(offsetof(UEndCanvasPanelSlot, bAutoSize) == 0x000060, "Member 'UEndCanvasPanelSlot::bAutoSize' has a wrong offset!");
static_assert(offsetof(UEndCanvasPanelSlot, bDelayedBuild) == 0x000061, "Member 'UEndCanvasPanelSlot::bDelayedBuild' has a wrong offset!");
static_assert(offsetof(UEndCanvasPanelSlot, ZOrder) == 0x000064, "Member 'UEndCanvasPanelSlot::ZOrder' has a wrong offset!");
static_assert(offsetof(UEndCanvasPanelSlot, XAngle) == 0x000068, "Member 'UEndCanvasPanelSlot::XAngle' has a wrong offset!");
static_assert(offsetof(UEndCanvasPanelSlot, YAngle) == 0x00006C, "Member 'UEndCanvasPanelSlot::YAngle' has a wrong offset!");

// Class EndGame.EndBattleAIEB0006Controller
// 0x0088 (0x2310 - 0x2288)
class AEndBattleAIEB0006Controller final : public AEndBattleAIController
{
public:
	float                                         JumpTurnTime;                                      // 0x2288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpTurnBias;                                      // 0x228C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DivePrepareRotateYaw;                              // 0x2290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DivePrepareRotatePitch;                            // 0x2294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DiveLoopRotateYaw;                                 // 0x2298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DiveLoopRotatePitch;                               // 0x229C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DiveBeginSpeed;                                    // 0x22A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DiveAddSpeed;                                      // 0x22A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DiveOffsetZ;                                       // 0x22A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22AC[0x64];                                    // 0x22AC(0x0064)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsHHFly();
	bool IsOnFloor();
	bool IsOnWall();
	void ReleaseWallJump(int32 InID, float InTime, float InBias);
	void RequestTurnJump(const struct FVector& Target);
	void RequestWallJump(int32 InID, float InTime, float InBias);
	void SetForceJumpEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEB0006Controller">();
	}
	static class AEndBattleAIEB0006Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEB0006Controller>();
	}
};
static_assert(alignof(AEndBattleAIEB0006Controller) == 0x000008, "Wrong alignment on AEndBattleAIEB0006Controller");
static_assert(sizeof(AEndBattleAIEB0006Controller) == 0x002310, "Wrong size on AEndBattleAIEB0006Controller");
static_assert(offsetof(AEndBattleAIEB0006Controller, JumpTurnTime) == 0x002288, "Member 'AEndBattleAIEB0006Controller::JumpTurnTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0006Controller, JumpTurnBias) == 0x00228C, "Member 'AEndBattleAIEB0006Controller::JumpTurnBias' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0006Controller, DivePrepareRotateYaw) == 0x002290, "Member 'AEndBattleAIEB0006Controller::DivePrepareRotateYaw' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0006Controller, DivePrepareRotatePitch) == 0x002294, "Member 'AEndBattleAIEB0006Controller::DivePrepareRotatePitch' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0006Controller, DiveLoopRotateYaw) == 0x002298, "Member 'AEndBattleAIEB0006Controller::DiveLoopRotateYaw' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0006Controller, DiveLoopRotatePitch) == 0x00229C, "Member 'AEndBattleAIEB0006Controller::DiveLoopRotatePitch' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0006Controller, DiveBeginSpeed) == 0x0022A0, "Member 'AEndBattleAIEB0006Controller::DiveBeginSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0006Controller, DiveAddSpeed) == 0x0022A4, "Member 'AEndBattleAIEB0006Controller::DiveAddSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0006Controller, DiveOffsetZ) == 0x0022A8, "Member 'AEndBattleAIEB0006Controller::DiveOffsetZ' has a wrong offset!");

// Class EndGame.EndBattleAIEB0009Controller
// 0x0008 (0x2290 - 0x2288)
class AEndBattleAIEB0009Controller final : public AEndBattleAIController
{
public:
	uint8                                         Pad_2288[0x8];                                     // 0x2288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDisableRangePartsBarrier(float baseAngle, float rangeAngle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEB0009Controller">();
	}
	static class AEndBattleAIEB0009Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEB0009Controller>();
	}
};
static_assert(alignof(AEndBattleAIEB0009Controller) == 0x000008, "Wrong alignment on AEndBattleAIEB0009Controller");
static_assert(sizeof(AEndBattleAIEB0009Controller) == 0x002290, "Wrong size on AEndBattleAIEB0009Controller");

// Class EndGame.EndDataObjectBattleAIActionMotion
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleAIActionMotion final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleAIActionMotion">();
	}
	static class UEndDataObjectBattleAIActionMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleAIActionMotion>();
	}
};
static_assert(alignof(UEndDataObjectBattleAIActionMotion) == 0x000008, "Wrong alignment on UEndDataObjectBattleAIActionMotion");
static_assert(sizeof(UEndDataObjectBattleAIActionMotion) == 0x000088, "Wrong size on UEndDataObjectBattleAIActionMotion");

// Class EndGame.EndBattleAIEB0011Controller
// 0x0028 (0x22B0 - 0x2288)
class AEndBattleAIEB0011Controller final : public AEndBattleAIController
{
public:
	uint8                                         Pad_2288[0x28];                                    // 0x2288(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RequestReserveActionRush();
	void SuspendReserveActionRush();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEB0011Controller">();
	}
	static class AEndBattleAIEB0011Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEB0011Controller>();
	}
};
static_assert(alignof(AEndBattleAIEB0011Controller) == 0x000008, "Wrong alignment on AEndBattleAIEB0011Controller");
static_assert(sizeof(AEndBattleAIEB0011Controller) == 0x0022B0, "Wrong size on AEndBattleAIEB0011Controller");

// Class EndGame.EndBattleAIEB0012OptController
// 0x0008 (0x2290 - 0x2288)
class AEndBattleAIEB0012OptController final : public AEndBattleAIController
{
public:
	uint8                                         Pad_2288[0x8];                                     // 0x2288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEB0012OptController">();
	}
	static class AEndBattleAIEB0012OptController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEB0012OptController>();
	}
};
static_assert(alignof(AEndBattleAIEB0012OptController) == 0x000008, "Wrong alignment on AEndBattleAIEB0012OptController");
static_assert(sizeof(AEndBattleAIEB0012OptController) == 0x002290, "Wrong size on AEndBattleAIEB0012OptController");

// Class EndGame.EndDataObjectBattleBreakable
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleBreakable final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleBreakable">();
	}
	static class UEndDataObjectBattleBreakable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleBreakable>();
	}
};
static_assert(alignof(UEndDataObjectBattleBreakable) == 0x000008, "Wrong alignment on UEndDataObjectBattleBreakable");
static_assert(sizeof(UEndDataObjectBattleBreakable) == 0x000088, "Wrong size on UEndDataObjectBattleBreakable");

// Class EndGame.EndBattleAIEB0016Controller
// 0x0128 (0x23B0 - 0x2288)
class AEndBattleAIEB0016Controller final : public AEndBattleAIController
{
public:
	float                                         FastNextBlendTime;                                 // 0x2288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FastBeginToLoopBlendTime;                          // 0x228C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FastLoopToEndBlendTime;                            // 0x2290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         rotateLengthTime;                                  // 0x2294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERufusLinkMode                                linkMode_;                                         // 0x2298(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2299[0xFF];                                    // 0x2299(0x00FF)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ShowLinkMode;                                      // 0x2398(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowDashPoint;                                     // 0x2399(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowGoalPoint;                                     // 0x239A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowGoalRangePoints;                               // 0x239B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangePointsYaw;                                    // 0x239C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HideGoalRangePoints_;                              // 0x23A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23A1[0xF];                                     // 0x23A1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeGunMode(ERufusGunMode gunMode);
	bool CheckGunMode(ERufusGunMode gunMode);
	bool CheckLinkMode(ERufusLinkMode linkMode);
	int32 GetBulletCount();
	struct FVector GetGotoPosition(EPlayerType PlayerType, ERufusGoToPositionType positionType, ERufusGoToDistanceType DistanceType, float dirYaw);
	void OnEventFastDash(class FName EventName);
	void RegisterFastDash(class FName keyword, class FName startAnimation, class FName LoopAnimation, class FName endAnimation, float vailableDistance, class FName eventNameCompleted, class FName eventNameSuspended, class FName eventNameTimeOver, class FName eventNameHitWall, class FName eventNameMissing, class FName eventNameArrival, class FName eventNameNear);
	void RegisterFastDashEffect(class FName CharaSpecName, class FName effectFastDashMove);
	void RegisterGotoPosition(const struct FVector& Distance);
	void ReloadBullet();
	bool RequestReserveActionFastDash(class FName keyword, const struct FVector& goalPosition, float FastMoveSpeed, float missingDistance, float marginDistance, float limitTime, float moveFriction, bool useStartFrontRotate, bool useDeceleration, bool updateGoalPosition, bool drawTargetPoint);
	void SetLinkMode(ERufusLinkMode linkMode);
	void SetupBullet(int32 Count);
	void UsedBullet();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEB0016Controller">();
	}
	static class AEndBattleAIEB0016Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEB0016Controller>();
	}
};
static_assert(alignof(AEndBattleAIEB0016Controller) == 0x000008, "Wrong alignment on AEndBattleAIEB0016Controller");
static_assert(sizeof(AEndBattleAIEB0016Controller) == 0x0023B0, "Wrong size on AEndBattleAIEB0016Controller");
static_assert(offsetof(AEndBattleAIEB0016Controller, FastNextBlendTime) == 0x002288, "Member 'AEndBattleAIEB0016Controller::FastNextBlendTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0016Controller, FastBeginToLoopBlendTime) == 0x00228C, "Member 'AEndBattleAIEB0016Controller::FastBeginToLoopBlendTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0016Controller, FastLoopToEndBlendTime) == 0x002290, "Member 'AEndBattleAIEB0016Controller::FastLoopToEndBlendTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0016Controller, rotateLengthTime) == 0x002294, "Member 'AEndBattleAIEB0016Controller::rotateLengthTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0016Controller, linkMode_) == 0x002298, "Member 'AEndBattleAIEB0016Controller::linkMode_' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0016Controller, ShowLinkMode) == 0x002398, "Member 'AEndBattleAIEB0016Controller::ShowLinkMode' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0016Controller, ShowDashPoint) == 0x002399, "Member 'AEndBattleAIEB0016Controller::ShowDashPoint' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0016Controller, ShowGoalPoint) == 0x00239A, "Member 'AEndBattleAIEB0016Controller::ShowGoalPoint' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0016Controller, ShowGoalRangePoints) == 0x00239B, "Member 'AEndBattleAIEB0016Controller::ShowGoalRangePoints' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0016Controller, RangePointsYaw) == 0x00239C, "Member 'AEndBattleAIEB0016Controller::RangePointsYaw' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0016Controller, HideGoalRangePoints_) == 0x0023A0, "Member 'AEndBattleAIEB0016Controller::HideGoalRangePoints_' has a wrong offset!");

// Class EndGame.EndBattleAIEB0020Controller
// 0x0028 (0x22B0 - 0x2288)
class AEndBattleAIEB0020Controller final : public AEndBattleAIController
{
public:
	uint8                                         Pad_2288[0x28];                                    // 0x2288(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEasySpawnEvent(class FName keywordName, class FName EventName);
	bool RequestBreakParts(class FName keyword, class FName brokenAnimationName, bool syncPlayMotion, float BlendInTime);
	void RequestPraecoTurn(float InYaw, float InTime);
	void RequestPraecoTurnToPoint(const struct FVector& InLocation, float InTime);
	bool RequestSpawnParts(class FName keyword, class FName CharaSpecName, bool spawnedInvisible, bool updateSpawn, float respawnTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEB0020Controller">();
	}
	static class AEndBattleAIEB0020Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEB0020Controller>();
	}
};
static_assert(alignof(AEndBattleAIEB0020Controller) == 0x000008, "Wrong alignment on AEndBattleAIEB0020Controller");
static_assert(sizeof(AEndBattleAIEB0020Controller) == 0x0022B0, "Wrong size on AEndBattleAIEB0020Controller");

// Class EndGame.EndDataObjectBattleCharaCategory
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleCharaCategory final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleCharaCategory">();
	}
	static class UEndDataObjectBattleCharaCategory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleCharaCategory>();
	}
};
static_assert(alignof(UEndDataObjectBattleCharaCategory) == 0x000008, "Wrong alignment on UEndDataObjectBattleCharaCategory");
static_assert(sizeof(UEndDataObjectBattleCharaCategory) == 0x000088, "Wrong size on UEndDataObjectBattleCharaCategory");

// Class EndGame.EndBattleAIEB0025Controller
// 0x0008 (0x2290 - 0x2288)
class AEndBattleAIEB0025Controller final : public AEndBattleAIController
{
public:
	uint8                                         Pad_2288[0x8];                                     // 0x2288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEB0025Controller">();
	}
	static class AEndBattleAIEB0025Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEB0025Controller>();
	}
};
static_assert(alignof(AEndBattleAIEB0025Controller) == 0x000008, "Wrong alignment on AEndBattleAIEB0025Controller");
static_assert(sizeof(AEndBattleAIEB0025Controller) == 0x002290, "Wrong size on AEndBattleAIEB0025Controller");

// Class EndGame.EndBattleAIEB0029Controller
// 0x01A8 (0x2430 - 0x2288)
class AEndBattleAIEB0029Controller final : public AEndBattleAIController
{
public:
	float                                         FastNextBlendTime;                                 // 0x2288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FastBeginToLoopBlendTime;                          // 0x228C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FastLoopToEndBlendTime;                            // 0x2290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         rotateLengthTime;                                  // 0x2294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2298[0x184];                                   // 0x2298(0x0184)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ShowDashPoint;                                     // 0x241C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowGoalPoint;                                     // 0x241D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowGoalRangePoints;                               // 0x241E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_241F[0x1];                                     // 0x241F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RangePointsYaw;                                    // 0x2420(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HideGoalRangePoints_;                              // 0x2424(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2425[0xB];                                     // 0x2425(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetGotoPosition(EPlayerType PlayerType, EPraecoMiniGoToPositionType positionType, EPraecoMiniGoToDistanceType DistanceType, float dirYaw, EPraecoMiniGoToMode gotoMode);
	void OnCompleteTransAttach(class FName InName);
	void OnEventFastDash(class FName EventName);
	void RegisterFastDash(class FName keyword, class FName startAnimation, class FName LoopAnimation, class FName endAnimation, float vailableDistance, class FName eventNameCompleted, class FName eventNameSuspended, class FName eventNameTimeOver, class FName eventNameHitWall, class FName eventNameMissing, class FName eventNameArrival, class FName eventNameNear);
	void RegisterFastDashEffect(class FName CharaSpecName, class FName effectFastDashMove);
	void RegisterGotoPosition(const struct FVector& Distance);
	bool RequestReserveActionFastDash(class FName keyword, const struct FVector& goalPosition, float FastMoveSpeed, float missingDistance, float marginDistance, float limitTime, float moveFriction, bool useStartFrontRotate, bool useDeceleration, bool updateGoalPosition, bool drawTargetPoint);
	bool RequestReserveActionTransAttach(class FName InSocket, const struct FTransform& InTargetTransform, float InDuration, class FName InName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEB0029Controller">();
	}
	static class AEndBattleAIEB0029Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEB0029Controller>();
	}
};
static_assert(alignof(AEndBattleAIEB0029Controller) == 0x000008, "Wrong alignment on AEndBattleAIEB0029Controller");
static_assert(sizeof(AEndBattleAIEB0029Controller) == 0x002430, "Wrong size on AEndBattleAIEB0029Controller");
static_assert(offsetof(AEndBattleAIEB0029Controller, FastNextBlendTime) == 0x002288, "Member 'AEndBattleAIEB0029Controller::FastNextBlendTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0029Controller, FastBeginToLoopBlendTime) == 0x00228C, "Member 'AEndBattleAIEB0029Controller::FastBeginToLoopBlendTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0029Controller, FastLoopToEndBlendTime) == 0x002290, "Member 'AEndBattleAIEB0029Controller::FastLoopToEndBlendTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0029Controller, rotateLengthTime) == 0x002294, "Member 'AEndBattleAIEB0029Controller::rotateLengthTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0029Controller, ShowDashPoint) == 0x00241C, "Member 'AEndBattleAIEB0029Controller::ShowDashPoint' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0029Controller, ShowGoalPoint) == 0x00241D, "Member 'AEndBattleAIEB0029Controller::ShowGoalPoint' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0029Controller, ShowGoalRangePoints) == 0x00241E, "Member 'AEndBattleAIEB0029Controller::ShowGoalRangePoints' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0029Controller, RangePointsYaw) == 0x002420, "Member 'AEndBattleAIEB0029Controller::RangePointsYaw' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEB0029Controller, HideGoalRangePoints_) == 0x002424, "Member 'AEndBattleAIEB0029Controller::HideGoalRangePoints_' has a wrong offset!");

// Class EndGame.EndDataObjectBattleCharaWeakCondition
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleCharaWeakCondition final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleCharaWeakCondition">();
	}
	static class UEndDataObjectBattleCharaWeakCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleCharaWeakCondition>();
	}
};
static_assert(alignof(UEndDataObjectBattleCharaWeakCondition) == 0x000008, "Wrong alignment on UEndDataObjectBattleCharaWeakCondition");
static_assert(sizeof(UEndDataObjectBattleCharaWeakCondition) == 0x000088, "Wrong size on UEndDataObjectBattleCharaWeakCondition");

// Class EndGame.EndBattleAIEB1000Controller
// 0x0008 (0x2340 - 0x2338)
class AEndBattleAIEB1000Controller final : public AEndBattleAIFitSplineController
{
public:
	uint8                                         Pad_2338[0x8];                                     // 0x2338(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateCameraFlavorCustomizableFieldAction(class FName DatatableName);
	void DeactivateCameraFlavorCustomizableFieldAction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEB1000Controller">();
	}
	static class AEndBattleAIEB1000Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEB1000Controller>();
	}
};
static_assert(alignof(AEndBattleAIEB1000Controller) == 0x000008, "Wrong alignment on AEndBattleAIEB1000Controller");
static_assert(sizeof(AEndBattleAIEB1000Controller) == 0x002340, "Wrong size on AEndBattleAIEB1000Controller");

// Class EndGame.EndBattleAIEB1003Controller
// 0x0008 (0x2290 - 0x2288)
class AEndBattleAIEB1003Controller final : public AEndBattleAIController
{
public:
	uint8                                         Pad_2288[0x8];                                     // 0x2288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEB1003Controller">();
	}
	static class AEndBattleAIEB1003Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEB1003Controller>();
	}
};
static_assert(alignof(AEndBattleAIEB1003Controller) == 0x000008, "Wrong alignment on AEndBattleAIEB1003Controller");
static_assert(sizeof(AEndBattleAIEB1003Controller) == 0x002290, "Wrong size on AEndBattleAIEB1003Controller");

// Class EndGame.EndDataObjectChocoboFastTravelPoint
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectChocoboFastTravelPoint final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectChocoboFastTravelPoint">();
	}
	static class UEndDataObjectChocoboFastTravelPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectChocoboFastTravelPoint>();
	}
};
static_assert(alignof(UEndDataObjectChocoboFastTravelPoint) == 0x000008, "Wrong alignment on UEndDataObjectChocoboFastTravelPoint");
static_assert(sizeof(UEndDataObjectChocoboFastTravelPoint) == 0x000088, "Wrong size on UEndDataObjectChocoboFastTravelPoint");

// Class EndGame.EndBattleAIEN0007Controller
// 0x0008 (0x2290 - 0x2288)
class AEndBattleAIEN0007Controller final : public AEndBattleAIController
{
public:
	uint8                                         Pad_2288[0x8];                                     // 0x2288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReleaseBattleFieldByEN0007();
	void RestrictBattleFieldByEN0007(class FName ExclusionID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEN0007Controller">();
	}
	static class AEndBattleAIEN0007Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEN0007Controller>();
	}
};
static_assert(alignof(AEndBattleAIEN0007Controller) == 0x000008, "Wrong alignment on AEndBattleAIEN0007Controller");
static_assert(sizeof(AEndBattleAIEN0007Controller) == 0x002290, "Wrong size on AEndBattleAIEN0007Controller");

// Class EndGame.EndDataObjectCondorFortBase
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectCondorFortBase final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectCondorFortBase">();
	}
	static class UEndDataObjectCondorFortBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectCondorFortBase>();
	}
};
static_assert(alignof(UEndDataObjectCondorFortBase) == 0x000008, "Wrong alignment on UEndDataObjectCondorFortBase");
static_assert(sizeof(UEndDataObjectCondorFortBase) == 0x000088, "Wrong size on UEndDataObjectCondorFortBase");

// Class EndGame.EndBattleAIEN2002_02Controller
// 0x0018 (0x22A0 - 0x2288)
class AEndBattleAIEN2002_02Controller final : public AEndBattleAIController
{
public:
	class AEndNavModifierVolume*                  CurrentVolume;                                     // 0x2288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AEndNavModifierVolume*                  WebVolume;                                         // 0x2290(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AEndNavModifierVolume*                  NextVolume;                                        // 0x2298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool GetJumpNavVolume(const TArray<struct FVector>& InPoints, const class FString& InBattleScene);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEN2002_02Controller">();
	}
	static class AEndBattleAIEN2002_02Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEN2002_02Controller>();
	}
};
static_assert(alignof(AEndBattleAIEN2002_02Controller) == 0x000008, "Wrong alignment on AEndBattleAIEN2002_02Controller");
static_assert(sizeof(AEndBattleAIEN2002_02Controller) == 0x0022A0, "Wrong size on AEndBattleAIEN2002_02Controller");
static_assert(offsetof(AEndBattleAIEN2002_02Controller, CurrentVolume) == 0x002288, "Member 'AEndBattleAIEN2002_02Controller::CurrentVolume' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEN2002_02Controller, WebVolume) == 0x002290, "Member 'AEndBattleAIEN2002_02Controller::WebVolume' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEN2002_02Controller, NextVolume) == 0x002298, "Member 'AEndBattleAIEN2002_02Controller::NextVolume' has a wrong offset!");

// Class EndGame.EndBattleAIEN2009Controller
// 0x0028 (0x22B0 - 0x2288)
class AEndBattleAIEN2009Controller final : public AEndBattleAIController
{
public:
	uint8                                         Pad_2288[0x28];                                    // 0x2288(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEN2009Controller">();
	}
	static class AEndBattleAIEN2009Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEN2009Controller>();
	}
};
static_assert(alignof(AEndBattleAIEN2009Controller) == 0x000008, "Wrong alignment on AEndBattleAIEN2009Controller");
static_assert(sizeof(AEndBattleAIEN2009Controller) == 0x0022B0, "Wrong size on AEndBattleAIEN2009Controller");

// Class EndGame.EndDataObjectCondorFortCommonParameter
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectCondorFortCommonParameter final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectCondorFortCommonParameter">();
	}
	static class UEndDataObjectCondorFortCommonParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectCondorFortCommonParameter>();
	}
};
static_assert(alignof(UEndDataObjectCondorFortCommonParameter) == 0x000008, "Wrong alignment on UEndDataObjectCondorFortCommonParameter");
static_assert(sizeof(UEndDataObjectCondorFortCommonParameter) == 0x000088, "Wrong size on UEndDataObjectCondorFortCommonParameter");

// Class EndGame.EndBattleAIEN2013Controller
// 0x0028 (0x22B0 - 0x2288)
class AEndBattleAIEN2013Controller final : public AEndBattleAIController
{
public:
	uint8                                         Pad_2288[0x28];                                    // 0x2288(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEN2013Controller">();
	}
	static class AEndBattleAIEN2013Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEN2013Controller>();
	}
};
static_assert(alignof(AEndBattleAIEN2013Controller) == 0x000008, "Wrong alignment on AEndBattleAIEN2013Controller");
static_assert(sizeof(AEndBattleAIEN2013Controller) == 0x0022B0, "Wrong size on AEndBattleAIEN2013Controller");

// Class EndGame.EndBattleAIEN3000_01Controller
// 0x0068 (0x22F0 - 0x2288)
class AEndBattleAIEN3000_01Controller final : public AEndBattleAIController
{
public:
	uint8                                         Pad_2288[0x38];                                    // 0x2288(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxRange;                                          // 0x22C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinRange;                                          // 0x22C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HoamingQuantity;                                   // 0x22C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HoamingTime;                                       // 0x22CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22D0[0x20];                                    // 0x22D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIEN3000_01Controller">();
	}
	static class AEndBattleAIEN3000_01Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIEN3000_01Controller>();
	}
};
static_assert(alignof(AEndBattleAIEN3000_01Controller) == 0x000008, "Wrong alignment on AEndBattleAIEN3000_01Controller");
static_assert(sizeof(AEndBattleAIEN3000_01Controller) == 0x0022F0, "Wrong size on AEndBattleAIEN3000_01Controller");
static_assert(offsetof(AEndBattleAIEN3000_01Controller, MaxRange) == 0x0022C0, "Member 'AEndBattleAIEN3000_01Controller::MaxRange' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEN3000_01Controller, MinRange) == 0x0022C4, "Member 'AEndBattleAIEN3000_01Controller::MinRange' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEN3000_01Controller, HoamingQuantity) == 0x0022C8, "Member 'AEndBattleAIEN3000_01Controller::HoamingQuantity' has a wrong offset!");
static_assert(offsetof(AEndBattleAIEN3000_01Controller, HoamingTime) == 0x0022CC, "Member 'AEndBattleAIEN3000_01Controller::HoamingTime' has a wrong offset!");

// Class EndGame.EndDataObjectCondorFortUnit
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectCondorFortUnit final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectCondorFortUnit">();
	}
	static class UEndDataObjectCondorFortUnit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectCondorFortUnit>();
	}
};
static_assert(alignof(UEndDataObjectCondorFortUnit) == 0x000008, "Wrong alignment on UEndDataObjectCondorFortUnit");
static_assert(sizeof(UEndDataObjectCondorFortUnit) == 0x000088, "Wrong size on UEndDataObjectCondorFortUnit");

// Class EndGame.EndBattleAIMessageNotify
// 0x0010 (0x0048 - 0x0038)
class UEndBattleAIMessageNotify final : public UAnimNotify
{
public:
	class FName                                   Message;                                           // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntValue;                                          // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatValue;                                        // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIMessageNotify">();
	}
	static class UEndBattleAIMessageNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleAIMessageNotify>();
	}
};
static_assert(alignof(UEndBattleAIMessageNotify) == 0x000008, "Wrong alignment on UEndBattleAIMessageNotify");
static_assert(sizeof(UEndBattleAIMessageNotify) == 0x000048, "Wrong size on UEndBattleAIMessageNotify");
static_assert(offsetof(UEndBattleAIMessageNotify, Message) == 0x000038, "Member 'UEndBattleAIMessageNotify::Message' has a wrong offset!");
static_assert(offsetof(UEndBattleAIMessageNotify, IntValue) == 0x000040, "Member 'UEndBattleAIMessageNotify::IntValue' has a wrong offset!");
static_assert(offsetof(UEndBattleAIMessageNotify, FloatValue) == 0x000044, "Member 'UEndBattleAIMessageNotify::FloatValue' has a wrong offset!");

// Class EndGame.EndBattleAIOverlapComponent
// 0x0070 (0x0168 - 0x00F8)
class UEndBattleAIOverlapComponent final : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   OnArrivalListener;                                 // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDepartureListener;                               // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x50];                                     // 0x0118(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddVolume(class AEndNavModifierVolume* InVolume);
	void ResetVolume();
	void SubVolume(class AEndNavModifierVolume* InVolume);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIOverlapComponent">();
	}
	static class UEndBattleAIOverlapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleAIOverlapComponent>();
	}
};
static_assert(alignof(UEndBattleAIOverlapComponent) == 0x000008, "Wrong alignment on UEndBattleAIOverlapComponent");
static_assert(sizeof(UEndBattleAIOverlapComponent) == 0x000168, "Wrong size on UEndBattleAIOverlapComponent");
static_assert(offsetof(UEndBattleAIOverlapComponent, OnArrivalListener) == 0x0000F8, "Member 'UEndBattleAIOverlapComponent::OnArrivalListener' has a wrong offset!");
static_assert(offsetof(UEndBattleAIOverlapComponent, OnDepartureListener) == 0x000108, "Member 'UEndBattleAIOverlapComponent::OnDepartureListener' has a wrong offset!");

// Class EndGame.EndDataObjectBattleScenePopTable
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleScenePopTable final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleScenePopTable">();
	}
	static class UEndDataObjectBattleScenePopTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleScenePopTable>();
	}
};
static_assert(alignof(UEndDataObjectBattleScenePopTable) == 0x000008, "Wrong alignment on UEndDataObjectBattleScenePopTable");
static_assert(sizeof(UEndDataObjectBattleScenePopTable) == 0x000088, "Wrong size on UEndDataObjectBattleScenePopTable");

// Class EndGame.EndFieldActionActorLadder
// 0x0078 (0x0690 - 0x0618)
class AEndFieldActionActorLadder final : public AEndFieldActionActorBase
{
public:
	int32                                         RungCount;                                         // 0x0618(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperSpace;                                        // 0x061C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowerSpace;                                        // 0x0620(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBrokenLadder;                                    // 0x0624(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ExceptionFlg;                                      // 0x0625(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_626[0x2];                                      // 0x0626(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndFieldActionTriggerComponent*        UpperVolume;                                       // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        LowerVolume;                                       // 0x0630(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0638(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENavLinkDirection                             LinkType;                                          // 0x0640(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_641[0x4F];                                     // 0x0641(0x004F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorLadder">();
	}
	static class AEndFieldActionActorLadder* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorLadder>();
	}
};
static_assert(alignof(AEndFieldActionActorLadder) == 0x000008, "Wrong alignment on AEndFieldActionActorLadder");
static_assert(sizeof(AEndFieldActionActorLadder) == 0x000690, "Wrong size on AEndFieldActionActorLadder");
static_assert(offsetof(AEndFieldActionActorLadder, RungCount) == 0x000618, "Member 'AEndFieldActionActorLadder::RungCount' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorLadder, UpperSpace) == 0x00061C, "Member 'AEndFieldActionActorLadder::UpperSpace' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorLadder, LowerSpace) == 0x000620, "Member 'AEndFieldActionActorLadder::LowerSpace' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorLadder, IsBrokenLadder) == 0x000624, "Member 'AEndFieldActionActorLadder::IsBrokenLadder' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorLadder, ExceptionFlg) == 0x000625, "Member 'AEndFieldActionActorLadder::ExceptionFlg' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorLadder, UpperVolume) == 0x000628, "Member 'AEndFieldActionActorLadder::UpperVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorLadder, LowerVolume) == 0x000630, "Member 'AEndFieldActionActorLadder::LowerVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorLadder, ModifierVolume) == 0x000638, "Member 'AEndFieldActionActorLadder::ModifierVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorLadder, LinkType) == 0x000640, "Member 'AEndFieldActionActorLadder::LinkType' has a wrong offset!");

// Class EndGame.EndBattleAIRedXIIIController
// 0x0170 (0x3A10 - 0x38A0)
class AEndBattleAIRedXIIIController final : public AEndBattleAIPcBaseController
{
public:
	class FName                                   StarDustLayAbilityID;                              // 0x38A0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   HealAbilityID;                                     // 0x38A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           AttackAbilityIDList;                               // 0x38B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FEndBattleAIRedXIIIAttackAbility> AttackAbilityList;                                 // 0x38C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         StarDustLayProb;                                   // 0x38D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StarDustLayCoolTime;                               // 0x38D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HealCheckInterval;                                 // 0x38D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HealProb;                                          // 0x38DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HealCoolTime;                                      // 0x38E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38E4[0x12C];                                   // 0x38E4(0x012C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIRedXIIIController">();
	}
	static class AEndBattleAIRedXIIIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIRedXIIIController>();
	}
};
static_assert(alignof(AEndBattleAIRedXIIIController) == 0x000008, "Wrong alignment on AEndBattleAIRedXIIIController");
static_assert(sizeof(AEndBattleAIRedXIIIController) == 0x003A10, "Wrong size on AEndBattleAIRedXIIIController");
static_assert(offsetof(AEndBattleAIRedXIIIController, StarDustLayAbilityID) == 0x0038A0, "Member 'AEndBattleAIRedXIIIController::StarDustLayAbilityID' has a wrong offset!");
static_assert(offsetof(AEndBattleAIRedXIIIController, HealAbilityID) == 0x0038A8, "Member 'AEndBattleAIRedXIIIController::HealAbilityID' has a wrong offset!");
static_assert(offsetof(AEndBattleAIRedXIIIController, AttackAbilityIDList) == 0x0038B0, "Member 'AEndBattleAIRedXIIIController::AttackAbilityIDList' has a wrong offset!");
static_assert(offsetof(AEndBattleAIRedXIIIController, AttackAbilityList) == 0x0038C0, "Member 'AEndBattleAIRedXIIIController::AttackAbilityList' has a wrong offset!");
static_assert(offsetof(AEndBattleAIRedXIIIController, StarDustLayProb) == 0x0038D0, "Member 'AEndBattleAIRedXIIIController::StarDustLayProb' has a wrong offset!");
static_assert(offsetof(AEndBattleAIRedXIIIController, StarDustLayCoolTime) == 0x0038D4, "Member 'AEndBattleAIRedXIIIController::StarDustLayCoolTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAIRedXIIIController, HealCheckInterval) == 0x0038D8, "Member 'AEndBattleAIRedXIIIController::HealCheckInterval' has a wrong offset!");
static_assert(offsetof(AEndBattleAIRedXIIIController, HealProb) == 0x0038DC, "Member 'AEndBattleAIRedXIIIController::HealProb' has a wrong offset!");
static_assert(offsetof(AEndBattleAIRedXIIIController, HealCoolTime) == 0x0038E0, "Member 'AEndBattleAIRedXIIIController::HealCoolTime' has a wrong offset!");

// Class EndGame.EndBattleAISlu5bAerithController
// 0x0038 (0x22C0 - 0x2288)
class AEndBattleAISlu5bAerithController final : public AEndBattleAIController
{
public:
	float                                         EncourageRecastTime;                               // 0x2288(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CheeringRecastTime;                                // 0x228C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WorryRecastTime;                                   // 0x2290(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimumHideTime;                                   // 0x2294(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ATBIncreasment;                                    // 0x2298(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_229C[0x24];                                    // 0x229C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeAerithState(EGuestAerithState NewState);
	void CheckBattleField();
	void CheckEncouragment(float Probability, float DeltaTime);
	void CheckGarden();
	void CheckSelf(float SafeDistance);
	void DrawDebugCurrnetState();
	EGuestAerithState GetCurrnetState();
	void LookAtOff();
	void LookAtOn(class AEndCharacter* LookTarget);
	void OnUpdateGuestAerith(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAISlu5bAerithController">();
	}
	static class AEndBattleAISlu5bAerithController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAISlu5bAerithController>();
	}
};
static_assert(alignof(AEndBattleAISlu5bAerithController) == 0x000008, "Wrong alignment on AEndBattleAISlu5bAerithController");
static_assert(sizeof(AEndBattleAISlu5bAerithController) == 0x0022C0, "Wrong size on AEndBattleAISlu5bAerithController");
static_assert(offsetof(AEndBattleAISlu5bAerithController, EncourageRecastTime) == 0x002288, "Member 'AEndBattleAISlu5bAerithController::EncourageRecastTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAISlu5bAerithController, CheeringRecastTime) == 0x00228C, "Member 'AEndBattleAISlu5bAerithController::CheeringRecastTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAISlu5bAerithController, WorryRecastTime) == 0x002290, "Member 'AEndBattleAISlu5bAerithController::WorryRecastTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAISlu5bAerithController, MinimumHideTime) == 0x002294, "Member 'AEndBattleAISlu5bAerithController::MinimumHideTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAISlu5bAerithController, ATBIncreasment) == 0x002298, "Member 'AEndBattleAISlu5bAerithController::ATBIncreasment' has a wrong offset!");

// Class EndGame.EndDataObjectBattleSpecialStatusChange
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleSpecialStatusChange final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleSpecialStatusChange">();
	}
	static class UEndDataObjectBattleSpecialStatusChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleSpecialStatusChange>();
	}
};
static_assert(alignof(UEndDataObjectBattleSpecialStatusChange) == 0x000008, "Wrong alignment on UEndDataObjectBattleSpecialStatusChange");
static_assert(sizeof(UEndDataObjectBattleSpecialStatusChange) == 0x000088, "Wrong size on UEndDataObjectBattleSpecialStatusChange");

// Class EndGame.EndFieldActionActorJukeBox
// 0x0170 (0x0788 - 0x0618)
class AEndFieldActionActorJukeBox final : public AEndFieldActionActorBase
{
public:
	uint8                                         Pad_618[0x8];                                      // 0x0618(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   JukeBoxFirstActionID;                              // 0x0620(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   JukeBoxActionID;                                   // 0x0628(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StateConditionRecordID;                            // 0x0630(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioActorName;                                    // 0x0638(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterestRadius;                                    // 0x0640(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InterestActionID;                                  // 0x0644(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64C[0x4];                                      // 0x064C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndFieldActionTriggerComponent*        PressVolume;                                       // 0x0650(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          Party01BoxComponent;                               // 0x0658(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          Party02BoxComponent;                               // 0x0660(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0668(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_670[0x118];                                    // 0x0670(0x0118)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorJukeBox">();
	}
	static class AEndFieldActionActorJukeBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorJukeBox>();
	}
};
static_assert(alignof(AEndFieldActionActorJukeBox) == 0x000008, "Wrong alignment on AEndFieldActionActorJukeBox");
static_assert(sizeof(AEndFieldActionActorJukeBox) == 0x000788, "Wrong size on AEndFieldActionActorJukeBox");
static_assert(offsetof(AEndFieldActionActorJukeBox, JukeBoxFirstActionID) == 0x000620, "Member 'AEndFieldActionActorJukeBox::JukeBoxFirstActionID' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorJukeBox, JukeBoxActionID) == 0x000628, "Member 'AEndFieldActionActorJukeBox::JukeBoxActionID' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorJukeBox, StateConditionRecordID) == 0x000630, "Member 'AEndFieldActionActorJukeBox::StateConditionRecordID' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorJukeBox, AudioActorName) == 0x000638, "Member 'AEndFieldActionActorJukeBox::AudioActorName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorJukeBox, InterestRadius) == 0x000640, "Member 'AEndFieldActionActorJukeBox::InterestRadius' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorJukeBox, InterestActionID) == 0x000644, "Member 'AEndFieldActionActorJukeBox::InterestActionID' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorJukeBox, PressVolume) == 0x000650, "Member 'AEndFieldActionActorJukeBox::PressVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorJukeBox, Party01BoxComponent) == 0x000658, "Member 'AEndFieldActionActorJukeBox::Party01BoxComponent' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorJukeBox, Party02BoxComponent) == 0x000660, "Member 'AEndFieldActionActorJukeBox::Party02BoxComponent' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorJukeBox, ModifierVolume) == 0x000668, "Member 'AEndFieldActionActorJukeBox::ModifierVolume' has a wrong offset!");

// Class EndGame.EndBTTask_AIPCComboAttack
// 0x0008 (0x0078 - 0x0070)
class UEndBTTask_AIPCComboAttack final : public UBTTaskNode
{
public:
	bool                                          bForceMaxCombo;                                    // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_AIPCComboAttack">();
	}
	static class UEndBTTask_AIPCComboAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_AIPCComboAttack>();
	}
};
static_assert(alignof(UEndBTTask_AIPCComboAttack) == 0x000008, "Wrong alignment on UEndBTTask_AIPCComboAttack");
static_assert(sizeof(UEndBTTask_AIPCComboAttack) == 0x000078, "Wrong size on UEndBTTask_AIPCComboAttack");
static_assert(offsetof(UEndBTTask_AIPCComboAttack, bForceMaxCombo) == 0x000070, "Member 'UEndBTTask_AIPCComboAttack::bForceMaxCombo' has a wrong offset!");

// Class EndGame.EndBattleAISpline
// 0x0018 (0x03A0 - 0x0388)
class AEndBattleAISpline final : public AEndSplineActorBase
{
public:
	TArray<struct FBattleAISplineConnect>         Connect;                                           // 0x0388(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0398(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAISpline">();
	}
	static class AEndBattleAISpline* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAISpline>();
	}
};
static_assert(alignof(AEndBattleAISpline) == 0x000008, "Wrong alignment on AEndBattleAISpline");
static_assert(sizeof(AEndBattleAISpline) == 0x0003A0, "Wrong size on AEndBattleAISpline");
static_assert(offsetof(AEndBattleAISpline, Connect) == 0x000388, "Member 'AEndBattleAISpline::Connect' has a wrong offset!");
static_assert(offsetof(AEndBattleAISpline, Time) == 0x000398, "Member 'AEndBattleAISpline::Time' has a wrong offset!");

// Class EndGame.EndDataObjectBattleSummonConditions
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleSummonConditions final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleSummonConditions">();
	}
	static class UEndDataObjectBattleSummonConditions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleSummonConditions>();
	}
};
static_assert(alignof(UEndDataObjectBattleSummonConditions) == 0x000008, "Wrong alignment on UEndDataObjectBattleSummonConditions");
static_assert(sizeof(UEndDataObjectBattleSummonConditions) == 0x000088, "Wrong size on UEndDataObjectBattleSummonConditions");

// Class EndGame.EndFieldActionActorPassOver
// 0x0068 (0x0680 - 0x0618)
class AEndFieldActionActorPassOver final : public AEndFieldActionActorBase
{
public:
	class UEndFieldActionTriggerComponent*        EnterVolume;                                       // 0x0618(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        ExitVolume;                                        // 0x0620(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPassOverType                                 PassOverType;                                      // 0x0628(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_629[0x3];                                      // 0x0629(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraFOV;                                         // 0x062C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CameraLookAtName;                                  // 0x0630(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0638(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_640[0x40];                                     // 0x0640(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorPassOver">();
	}
	static class AEndFieldActionActorPassOver* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorPassOver>();
	}
};
static_assert(alignof(AEndFieldActionActorPassOver) == 0x000008, "Wrong alignment on AEndFieldActionActorPassOver");
static_assert(sizeof(AEndFieldActionActorPassOver) == 0x000680, "Wrong size on AEndFieldActionActorPassOver");
static_assert(offsetof(AEndFieldActionActorPassOver, EnterVolume) == 0x000618, "Member 'AEndFieldActionActorPassOver::EnterVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorPassOver, ExitVolume) == 0x000620, "Member 'AEndFieldActionActorPassOver::ExitVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorPassOver, PassOverType) == 0x000628, "Member 'AEndFieldActionActorPassOver::PassOverType' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorPassOver, CameraFOV) == 0x00062C, "Member 'AEndFieldActionActorPassOver::CameraFOV' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorPassOver, CameraLookAtName) == 0x000630, "Member 'AEndFieldActionActorPassOver::CameraLookAtName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorPassOver, ModifierVolume) == 0x000638, "Member 'AEndFieldActionActorPassOver::ModifierVolume' has a wrong offset!");

// Class EndGame.EndBattleAISU0000BaseController
// 0x0030 (0x2510 - 0x24E0)
class AEndBattleAISU0000BaseController final : public AEndBattleAISummonBaseController
{
public:
	class FName                                   ShoutAttackID;                                     // 0x24E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24E8[0x28];                                    // 0x24E8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RequestShoutAttack();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAISU0000BaseController">();
	}
	static class AEndBattleAISU0000BaseController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAISU0000BaseController>();
	}
};
static_assert(alignof(AEndBattleAISU0000BaseController) == 0x000008, "Wrong alignment on AEndBattleAISU0000BaseController");
static_assert(sizeof(AEndBattleAISU0000BaseController) == 0x002510, "Wrong size on AEndBattleAISU0000BaseController");
static_assert(offsetof(AEndBattleAISU0000BaseController, ShoutAttackID) == 0x0024E0, "Member 'AEndBattleAISU0000BaseController::ShoutAttackID' has a wrong offset!");

// Class EndGame.EndBattleAISU0001BaseController
// 0x0060 (0x2540 - 0x24E0)
class AEndBattleAISU0001BaseController final : public AEndBattleAISummonBaseController
{
public:
	class FName                                   MoogleBombHoldingStartAnimation;                   // 0x24E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MoogleBombHoldingIdleAnimation;                    // 0x24E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRageDush                              RageDushHandler;                                   // 0x24F0(0x0040)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_2530[0x10];                                    // 0x2530(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMoogleBombHidden(bool IsHidden);
	void SetTarget(class AEndCharacter* InChara);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAISU0001BaseController">();
	}
	static class AEndBattleAISU0001BaseController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAISU0001BaseController>();
	}
};
static_assert(alignof(AEndBattleAISU0001BaseController) == 0x000008, "Wrong alignment on AEndBattleAISU0001BaseController");
static_assert(sizeof(AEndBattleAISU0001BaseController) == 0x002540, "Wrong size on AEndBattleAISU0001BaseController");
static_assert(offsetof(AEndBattleAISU0001BaseController, MoogleBombHoldingStartAnimation) == 0x0024E0, "Member 'AEndBattleAISU0001BaseController::MoogleBombHoldingStartAnimation' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0001BaseController, MoogleBombHoldingIdleAnimation) == 0x0024E8, "Member 'AEndBattleAISU0001BaseController::MoogleBombHoldingIdleAnimation' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0001BaseController, RageDushHandler) == 0x0024F0, "Member 'AEndBattleAISU0001BaseController::RageDushHandler' has a wrong offset!");

// Class EndGame.EndBattleAISU0002BaseController
// 0x0000 (0x24E0 - 0x24E0)
class AEndBattleAISU0002BaseController final : public AEndBattleAISummonBaseController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAISU0002BaseController">();
	}
	static class AEndBattleAISU0002BaseController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAISU0002BaseController>();
	}
};
static_assert(alignof(AEndBattleAISU0002BaseController) == 0x000008, "Wrong alignment on AEndBattleAISU0002BaseController");
static_assert(sizeof(AEndBattleAISU0002BaseController) == 0x0024E0, "Wrong size on AEndBattleAISU0002BaseController");

// Class EndGame.EndDataObjectBikeAbility
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBikeAbility final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBikeAbility">();
	}
	static class UEndDataObjectBikeAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBikeAbility>();
	}
};
static_assert(alignof(UEndDataObjectBikeAbility) == 0x000008, "Wrong alignment on UEndDataObjectBikeAbility");
static_assert(sizeof(UEndDataObjectBikeAbility) == 0x000088, "Wrong size on UEndDataObjectBikeAbility");

// Class EndGame.EndMenuViewport
// 0x0028 (0x0138 - 0x0110)
class UEndMenuViewport final : public UContentWidget
{
public:
	struct FLinearColor                           BackgroundColor;                                   // 0x0110(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_120[0x18];                                     // 0x0120(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetViewLocation(const struct FVector& Location);
	void SetViewRotation(const struct FRotator& Rotation);
	class AActor* Spawn(TSubclassOf<class AActor> ActorClass);

	struct FVector GetViewLocation() const;
	class UWorld* GetViewportWorld() const;
	struct FRotator GetViewRotation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMenuViewport">();
	}
	static class UEndMenuViewport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMenuViewport>();
	}
};
static_assert(alignof(UEndMenuViewport) == 0x000008, "Wrong alignment on UEndMenuViewport");
static_assert(sizeof(UEndMenuViewport) == 0x000138, "Wrong size on UEndMenuViewport");
static_assert(offsetof(UEndMenuViewport, BackgroundColor) == 0x000110, "Member 'UEndMenuViewport::BackgroundColor' has a wrong offset!");

// Class EndGame.EndBattleAISU0002Controller
// 0x0098 (0x2320 - 0x2288)
class AEndBattleAISU0002Controller final : public AEndBattleAIController
{
public:
	float                                         ShivaMoveSpeed;                                    // 0x2288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShivaMoveRange;                                    // 0x228C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShivaMoveAngle;                                    // 0x2290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShivaMoveDirectionTime;                            // 0x2294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IfritRoarTime;                                     // 0x2298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229C[0x84];                                    // 0x229C(0x0084)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableEndShivaMove();
	void OnEndShivaMoveStart();
	void OnIfritRoar(class FName IDamageSourceID);
	void OnRequestShivaMove(int32 InMoveCount, bool InContactWall);
	void SetNextShivaMove();
	void SetNextShivaMoveLocation(const struct FVector& InLocation);
	void StartIfritRoar();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAISU0002Controller">();
	}
	static class AEndBattleAISU0002Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAISU0002Controller>();
	}
};
static_assert(alignof(AEndBattleAISU0002Controller) == 0x000008, "Wrong alignment on AEndBattleAISU0002Controller");
static_assert(sizeof(AEndBattleAISU0002Controller) == 0x002320, "Wrong size on AEndBattleAISU0002Controller");
static_assert(offsetof(AEndBattleAISU0002Controller, ShivaMoveSpeed) == 0x002288, "Member 'AEndBattleAISU0002Controller::ShivaMoveSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0002Controller, ShivaMoveRange) == 0x00228C, "Member 'AEndBattleAISU0002Controller::ShivaMoveRange' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0002Controller, ShivaMoveAngle) == 0x002290, "Member 'AEndBattleAISU0002Controller::ShivaMoveAngle' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0002Controller, ShivaMoveDirectionTime) == 0x002294, "Member 'AEndBattleAISU0002Controller::ShivaMoveDirectionTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0002Controller, IfritRoarTime) == 0x002298, "Member 'AEndBattleAISU0002Controller::IfritRoarTime' has a wrong offset!");

// Class EndGame.EndBattleAISU0003BaseController
// 0x0020 (0x2500 - 0x24E0)
class AEndBattleAISU0003BaseController final : public AEndBattleAISummonBaseController
{
public:
	class FName                                   RollAbilityID;                                     // 0x24E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RollBackAbilityID;                                 // 0x24E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AbilityTurnAngle;                                  // 0x24F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RollBackAngle;                                     // 0x24F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24F8[0x8];                                     // 0x24F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAISU0003BaseController">();
	}
	static class AEndBattleAISU0003BaseController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAISU0003BaseController>();
	}
};
static_assert(alignof(AEndBattleAISU0003BaseController) == 0x000008, "Wrong alignment on AEndBattleAISU0003BaseController");
static_assert(sizeof(AEndBattleAISU0003BaseController) == 0x002500, "Wrong size on AEndBattleAISU0003BaseController");
static_assert(offsetof(AEndBattleAISU0003BaseController, RollAbilityID) == 0x0024E0, "Member 'AEndBattleAISU0003BaseController::RollAbilityID' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0003BaseController, RollBackAbilityID) == 0x0024E8, "Member 'AEndBattleAISU0003BaseController::RollBackAbilityID' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0003BaseController, AbilityTurnAngle) == 0x0024F0, "Member 'AEndBattleAISU0003BaseController::AbilityTurnAngle' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0003BaseController, RollBackAngle) == 0x0024F4, "Member 'AEndBattleAISU0003BaseController::RollBackAngle' has a wrong offset!");

// Class EndGame.EndFieldActionActorOperationBoard
// 0x0040 (0x0658 - 0x0618)
class AEndFieldActionActorOperationBoard final : public AEndFieldActionActorBase
{
public:
	EOperationType                                OperationType;                                     // 0x0618(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EElevatorButtonType                           ElevatorButtonType;                                // 0x0619(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61A[0x2];                                      // 0x061A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ElevatorActorName;                                 // 0x061C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PushImpactTrigger;                                 // 0x0624(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PushImpactKeyBoardStartTrigger;                    // 0x062C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableHandIK;                                      // 0x0634(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_635[0x3];                                      // 0x0635(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HandIKOffsetZ;                                     // 0x0638(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceDisableInputCancel;                           // 0x063C(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_63D[0x3];                                      // 0x063D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndFieldActionTriggerComponent*        PressVolume;                                       // 0x0640(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        TargetIconVolume;                                  // 0x0648(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0650(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorOperationBoard">();
	}
	static class AEndFieldActionActorOperationBoard* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorOperationBoard>();
	}
};
static_assert(alignof(AEndFieldActionActorOperationBoard) == 0x000008, "Wrong alignment on AEndFieldActionActorOperationBoard");
static_assert(sizeof(AEndFieldActionActorOperationBoard) == 0x000658, "Wrong size on AEndFieldActionActorOperationBoard");
static_assert(offsetof(AEndFieldActionActorOperationBoard, OperationType) == 0x000618, "Member 'AEndFieldActionActorOperationBoard::OperationType' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorOperationBoard, ElevatorButtonType) == 0x000619, "Member 'AEndFieldActionActorOperationBoard::ElevatorButtonType' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorOperationBoard, ElevatorActorName) == 0x00061C, "Member 'AEndFieldActionActorOperationBoard::ElevatorActorName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorOperationBoard, PushImpactTrigger) == 0x000624, "Member 'AEndFieldActionActorOperationBoard::PushImpactTrigger' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorOperationBoard, PushImpactKeyBoardStartTrigger) == 0x00062C, "Member 'AEndFieldActionActorOperationBoard::PushImpactKeyBoardStartTrigger' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorOperationBoard, EnableHandIK) == 0x000634, "Member 'AEndFieldActionActorOperationBoard::EnableHandIK' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorOperationBoard, HandIKOffsetZ) == 0x000638, "Member 'AEndFieldActionActorOperationBoard::HandIKOffsetZ' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorOperationBoard, ForceDisableInputCancel) == 0x00063C, "Member 'AEndFieldActionActorOperationBoard::ForceDisableInputCancel' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorOperationBoard, PressVolume) == 0x000640, "Member 'AEndFieldActionActorOperationBoard::PressVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorOperationBoard, TargetIconVolume) == 0x000648, "Member 'AEndFieldActionActorOperationBoard::TargetIconVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorOperationBoard, ModifierVolume) == 0x000650, "Member 'AEndFieldActionActorOperationBoard::ModifierVolume' has a wrong offset!");

// Class EndGame.EndBattleAISU0004BaseController
// 0x0010 (0x24F0 - 0x24E0)
class AEndBattleAISU0004BaseController final : public AEndBattleAISummonBaseController
{
public:
	TArray<class FName>                           FlyModeBattleSceneID;                              // 0x24E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	bool IsInFlyModeBattleScene() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAISU0004BaseController">();
	}
	static class AEndBattleAISU0004BaseController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAISU0004BaseController>();
	}
};
static_assert(alignof(AEndBattleAISU0004BaseController) == 0x000008, "Wrong alignment on AEndBattleAISU0004BaseController");
static_assert(sizeof(AEndBattleAISU0004BaseController) == 0x0024F0, "Wrong size on AEndBattleAISU0004BaseController");
static_assert(offsetof(AEndBattleAISU0004BaseController, FlyModeBattleSceneID) == 0x0024E0, "Member 'AEndBattleAISU0004BaseController::FlyModeBattleSceneID' has a wrong offset!");

// Class EndGame.EndDataTableAPI
// 0x0000 (0x0028 - 0x0028)
class UEndDataTableAPI final : public UObject
{
public:
	static void CallBackOnLoadLocationData();
	static void CallBackOnLoadResidentData();
	static void ClearDebugFlag(EEndDataTableDebugFlag Flag);
	static void DebugReimportDataTable(const class FString& residentOrLocation);
	static TMap<EPlayerType, class FName> GetActorNameMap();
	static TArray<EEquipmentType> GetEquipmentTypeList();
	static TArray<class FString> GetFieldTestLocationNameDetails();
	static TArray<class FString> GetLocationDetails();
	static TArray<class FString> GetLocationNameDetails();
	static TArray<class FString> GetLocationNames();
	static TArray<class FName> GetLocationPresetList(const class FString& LocationName);
	static TArray<class FString> GetLocationSlotList(const class FString& LocationName);
	static float GetResidentParameterFloatBP(const class FName ID, float DefaultValue);
	static int32 GetResidentParameterIntegerBP(const class FName ID, int32 DefaultValue);
	static class FName GetResidentParameterNameBP(const class FName ID, class FName DefaultValue);
	static class FString GetResidentParameterStringBP(const class FName ID, const class FString& DefaultValue);
	static TArray<class FString> GetTestCutSceneEnviSetNameList(const TArray<class FString>& CutSceneNames);
	static TArray<class FString> GetTestCutSceneNameList(const class FString& LocationName);
	static class FName GetTestPlayModeSettingDataName(const class FName& TableID);
	static TArray<class FName> GetTestPlayModeSettingDataTableIds();
	static class FName GetTestPlayModeTitleLocation(const class FName& TableID);
	static TMap<EPlayerType, class FName> GetWeaponNameMap();
	static void InitDataTable(EDataTableType Type, class AEndAssetActor* Asset);
	static bool IsDebugFlag(EEndDataTableDebugFlag Flag);
	static bool IsExistDataTableBP();
	static bool IsExistDataTableFromTypeBP(EDataTableType Type);
	static void SetDebugFlag(EEndDataTableDebugFlag Flag);
	static void UnInitDataTable(EDataTableType Type, class AEndAssetActor* Asset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataTableAPI">();
	}
	static class UEndDataTableAPI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataTableAPI>();
	}
};
static_assert(alignof(UEndDataTableAPI) == 0x000008, "Wrong alignment on UEndDataTableAPI");
static_assert(sizeof(UEndDataTableAPI) == 0x000028, "Wrong size on UEndDataTableAPI");

// Class EndGame.EndBattleAISU0005BaseController
// 0x0020 (0x2500 - 0x24E0)
class AEndBattleAISU0005BaseController final : public AEndBattleAISummonBaseController
{
public:
	float                                         EXModeTime;                                        // 0x24E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24E4[0x4];                                     // 0x24E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EXAbilityPostfix;                                  // 0x24E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PathFindHeight;                                    // 0x24F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24FC[0x4];                                     // 0x24FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTurnRed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAISU0005BaseController">();
	}
	static class AEndBattleAISU0005BaseController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAISU0005BaseController>();
	}
};
static_assert(alignof(AEndBattleAISU0005BaseController) == 0x000008, "Wrong alignment on AEndBattleAISU0005BaseController");
static_assert(sizeof(AEndBattleAISU0005BaseController) == 0x002500, "Wrong size on AEndBattleAISU0005BaseController");
static_assert(offsetof(AEndBattleAISU0005BaseController, EXModeTime) == 0x0024E0, "Member 'AEndBattleAISU0005BaseController::EXModeTime' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0005BaseController, EXAbilityPostfix) == 0x0024E8, "Member 'AEndBattleAISU0005BaseController::EXAbilityPostfix' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0005BaseController, PathFindHeight) == 0x0024F8, "Member 'AEndBattleAISU0005BaseController::PathFindHeight' has a wrong offset!");

// Class EndGame.EndBattleAISU0006BaseController
// 0x0000 (0x24E0 - 0x24E0)
class AEndBattleAISU0006BaseController final : public AEndBattleAISummonBaseController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAISU0006BaseController">();
	}
	static class AEndBattleAISU0006BaseController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAISU0006BaseController>();
	}
};
static_assert(alignof(AEndBattleAISU0006BaseController) == 0x000008, "Wrong alignment on AEndBattleAISU0006BaseController");
static_assert(sizeof(AEndBattleAISU0006BaseController) == 0x0024E0, "Wrong size on AEndBattleAISU0006BaseController");

// Class EndGame.EndDataObjectAutoCameraImaginaryLineLogic
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectAutoCameraImaginaryLineLogic final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectAutoCameraImaginaryLineLogic">();
	}
	static class UEndDataObjectAutoCameraImaginaryLineLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectAutoCameraImaginaryLineLogic>();
	}
};
static_assert(alignof(UEndDataObjectAutoCameraImaginaryLineLogic) == 0x000008, "Wrong alignment on UEndDataObjectAutoCameraImaginaryLineLogic");
static_assert(sizeof(UEndDataObjectAutoCameraImaginaryLineLogic) == 0x000088, "Wrong size on UEndDataObjectAutoCameraImaginaryLineLogic");

// Class EndGame.EndBattleAISU0008BaseController
// 0x0030 (0x2510 - 0x24E0)
class AEndBattleAISU0008BaseController final : public AEndBattleAISummonBaseController
{
public:
	class FName                                   DashDamageID;                                      // 0x24E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RunJumpAnimationName;                              // 0x24E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DoJumpDistance;                                    // 0x24F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DoJumpHeight;                                      // 0x24F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpIntervalTime;                                  // 0x24F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24FC[0x14];                                    // 0x24FC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAISU0008BaseController">();
	}
	static class AEndBattleAISU0008BaseController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAISU0008BaseController>();
	}
};
static_assert(alignof(AEndBattleAISU0008BaseController) == 0x000008, "Wrong alignment on AEndBattleAISU0008BaseController");
static_assert(sizeof(AEndBattleAISU0008BaseController) == 0x002510, "Wrong size on AEndBattleAISU0008BaseController");
static_assert(offsetof(AEndBattleAISU0008BaseController, DashDamageID) == 0x0024E0, "Member 'AEndBattleAISU0008BaseController::DashDamageID' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0008BaseController, RunJumpAnimationName) == 0x0024E8, "Member 'AEndBattleAISU0008BaseController::RunJumpAnimationName' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0008BaseController, DoJumpDistance) == 0x0024F0, "Member 'AEndBattleAISU0008BaseController::DoJumpDistance' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0008BaseController, DoJumpHeight) == 0x0024F4, "Member 'AEndBattleAISU0008BaseController::DoJumpHeight' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU0008BaseController, JumpIntervalTime) == 0x0024F8, "Member 'AEndBattleAISU0008BaseController::JumpIntervalTime' has a wrong offset!");

// Class EndGame.EndBattleAISU1000_02Controller
// 0x0118 (0x23A0 - 0x2288)
class AEndBattleAISU1000_02Controller final : public AEndBattleAIController
{
public:
	float                                         CoreMaxSpeed;                                      // 0x2288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CoreSnapSpeed;                                     // 0x228C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CoreSnapEndQuantity;                               // 0x2290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RamuhDistance;                                     // 0x2294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UcpcDistance;                                      // 0x2298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RepulsiveDistance;                                 // 0x229C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RepulsiveAccQuantity;                              // 0x22A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22A4[0x4];                                     // 0x22A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           IgnoreRepulsiveActgions;                           // 0x22A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         CoreMoveInterval;                                  // 0x22B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RepulsiveOriginInterval;                           // 0x22BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           IgnoreStopFollowAction;                            // 0x22C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           IgnoreStopReturnAction;                            // 0x22D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bCanFollow;                                        // 0x22E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22E1[0x3];                                     // 0x22E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnLocation;                                    // 0x22E4(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReturnSpeed;                                       // 0x22F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnSpeed;                                         // 0x22F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EEndBattleDamageSourceHitReactionType, float> OverrideKnockbackDistance;                         // 0x22F8(0x0050)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         FixedFieldLocationInterpSpeed;                     // 0x2348(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_234C[0x4];                                     // 0x234C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEndRamuhCoreKnockbackParam>    KnockbackParam;                                    // 0x2350(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2360[0x40];                                    // 0x2360(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCheckFollow(bool OutBattleArea, bool NotOwnerTrace, bool NotUcpcTrace);
	void ResetConditionAfterThrown();
	void SetFollow(bool InFollow, const struct FVector& InLocation);
	void SetOverrideFollowTarget(class AEndCharacter* InChara);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAISU1000_02Controller">();
	}
	static class AEndBattleAISU1000_02Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAISU1000_02Controller>();
	}
};
static_assert(alignof(AEndBattleAISU1000_02Controller) == 0x000008, "Wrong alignment on AEndBattleAISU1000_02Controller");
static_assert(sizeof(AEndBattleAISU1000_02Controller) == 0x0023A0, "Wrong size on AEndBattleAISU1000_02Controller");
static_assert(offsetof(AEndBattleAISU1000_02Controller, CoreMaxSpeed) == 0x002288, "Member 'AEndBattleAISU1000_02Controller::CoreMaxSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU1000_02Controller, CoreSnapSpeed) == 0x00228C, "Member 'AEndBattleAISU1000_02Controller::CoreSnapSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU1000_02Controller, CoreSnapEndQuantity) == 0x002290, "Member 'AEndBattleAISU1000_02Controller::CoreSnapEndQuantity' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU1000_02Controller, RamuhDistance) == 0x002294, "Member 'AEndBattleAISU1000_02Controller::RamuhDistance' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU1000_02Controller, UcpcDistance) == 0x002298, "Member 'AEndBattleAISU1000_02Controller::UcpcDistance' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU1000_02Controller, RepulsiveDistance) == 0x00229C, "Member 'AEndBattleAISU1000_02Controller::RepulsiveDistance' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU1000_02Controller, RepulsiveAccQuantity) == 0x0022A0, "Member 'AEndBattleAISU1000_02Controller::RepulsiveAccQuantity' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU1000_02Controller, IgnoreRepulsiveActgions) == 0x0022A8, "Member 'AEndBattleAISU1000_02Controller::IgnoreRepulsiveActgions' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU1000_02Controller, CoreMoveInterval) == 0x0022B8, "Member 'AEndBattleAISU1000_02Controller::CoreMoveInterval' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU1000_02Controller, RepulsiveOriginInterval) == 0x0022BC, "Member 'AEndBattleAISU1000_02Controller::RepulsiveOriginInterval' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU1000_02Controller, IgnoreStopFollowAction) == 0x0022C0, "Member 'AEndBattleAISU1000_02Controller::IgnoreStopFollowAction' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU1000_02Controller, IgnoreStopReturnAction) == 0x0022D0, "Member 'AEndBattleAISU1000_02Controller::IgnoreStopReturnAction' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU1000_02Controller, bCanFollow) == 0x0022E0, "Member 'AEndBattleAISU1000_02Controller::bCanFollow' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU1000_02Controller, ReturnLocation) == 0x0022E4, "Member 'AEndBattleAISU1000_02Controller::ReturnLocation' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU1000_02Controller, ReturnSpeed) == 0x0022F0, "Member 'AEndBattleAISU1000_02Controller::ReturnSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU1000_02Controller, TurnSpeed) == 0x0022F4, "Member 'AEndBattleAISU1000_02Controller::TurnSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU1000_02Controller, OverrideKnockbackDistance) == 0x0022F8, "Member 'AEndBattleAISU1000_02Controller::OverrideKnockbackDistance' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU1000_02Controller, FixedFieldLocationInterpSpeed) == 0x002348, "Member 'AEndBattleAISU1000_02Controller::FixedFieldLocationInterpSpeed' has a wrong offset!");
static_assert(offsetof(AEndBattleAISU1000_02Controller, KnockbackParam) == 0x002350, "Member 'AEndBattleAISU1000_02Controller::KnockbackParam' has a wrong offset!");

// Class EndGame.EndDataObjectAutoCameraPositionLogic
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectAutoCameraPositionLogic final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectAutoCameraPositionLogic">();
	}
	static class UEndDataObjectAutoCameraPositionLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectAutoCameraPositionLogic>();
	}
};
static_assert(alignof(UEndDataObjectAutoCameraPositionLogic) == 0x000008, "Wrong alignment on UEndDataObjectAutoCameraPositionLogic");
static_assert(sizeof(UEndDataObjectAutoCameraPositionLogic) == 0x000088, "Wrong size on UEndDataObjectAutoCameraPositionLogic");

// Class EndGame.EndBattleAISU1000Controller
// 0x0008 (0x2290 - 0x2288)
class AEndBattleAISU1000Controller final : public AEndBattleAIController
{
public:
	uint8                                         Pad_2288[0x8];                                     // 0x2288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddPowerUpMagnitude(float Magnitude);
	void ClearPowerUp();
	void PowerLose();
	void SetHidePowerUpFX(bool bHide, bool bImmediately);
	void SetPowerUpSpeed(float Speed);

	float GetPowerUpMagnitude() const;
	float GetPowerUpSpeed() const;
	bool IsPowerUpMax() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAISU1000Controller">();
	}
	static class AEndBattleAISU1000Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAISU1000Controller>();
	}
};
static_assert(alignof(AEndBattleAISU1000Controller) == 0x000008, "Wrong alignment on AEndBattleAISU1000Controller");
static_assert(sizeof(AEndBattleAISU1000Controller) == 0x002290, "Wrong size on AEndBattleAISU1000Controller");

// Class EndGame.EndBattleAIToadController
// 0x0000 (0x38A0 - 0x38A0)
class AEndBattleAIToadController : public AEndBattleAIPcBaseController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAIToadController">();
	}
	static class AEndBattleAIToadController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAIToadController>();
	}
};
static_assert(alignof(AEndBattleAIToadController) == 0x000008, "Wrong alignment on AEndBattleAIToadController");
static_assert(sizeof(AEndBattleAIToadController) == 0x0038A0, "Wrong size on AEndBattleAIToadController");

// Class EndGame.EndDataObjectBattleAbilityReactionInfluence
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleAbilityReactionInfluence final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleAbilityReactionInfluence">();
	}
	static class UEndDataObjectBattleAbilityReactionInfluence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleAbilityReactionInfluence>();
	}
};
static_assert(alignof(UEndDataObjectBattleAbilityReactionInfluence) == 0x000008, "Wrong alignment on UEndDataObjectBattleAbilityReactionInfluence");
static_assert(sizeof(UEndDataObjectBattleAbilityReactionInfluence) == 0x000088, "Wrong size on UEndDataObjectBattleAbilityReactionInfluence");

// Class EndGame.EndBattleAITown7WedgeController
// 0x0040 (0x38E0 - 0x38A0)
class AEndBattleAITown7WedgeController final : public AEndBattleAIPcBaseController
{
public:
	uint8                                         Pad_38A0[0x4];                                     // 0x38A0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x38A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FleeMovementGoalRadius;                            // 0x38A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38AC[0x14];                                    // 0x38AC(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FleeLocationResetDuration;                         // 0x38C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FleeLocationResetDistance;                         // 0x38C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38C8[0x18];                                    // 0x38C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginRootMovement();
	void EndRootMovement();
	bool IsConfronting();
	bool IsFleeing();
	void StartConfront(float Distance);
	void StartFlee(const TArray<class AEndCharacter*>& Targets);
	void StopConfront();
	void StopFlee();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAITown7WedgeController">();
	}
	static class AEndBattleAITown7WedgeController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleAITown7WedgeController>();
	}
};
static_assert(alignof(AEndBattleAITown7WedgeController) == 0x000008, "Wrong alignment on AEndBattleAITown7WedgeController");
static_assert(sizeof(AEndBattleAITown7WedgeController) == 0x0038E0, "Wrong size on AEndBattleAITown7WedgeController");
static_assert(offsetof(AEndBattleAITown7WedgeController, Level) == 0x0038A4, "Member 'AEndBattleAITown7WedgeController::Level' has a wrong offset!");
static_assert(offsetof(AEndBattleAITown7WedgeController, FleeMovementGoalRadius) == 0x0038A8, "Member 'AEndBattleAITown7WedgeController::FleeMovementGoalRadius' has a wrong offset!");
static_assert(offsetof(AEndBattleAITown7WedgeController, FleeLocationResetDuration) == 0x0038C0, "Member 'AEndBattleAITown7WedgeController::FleeLocationResetDuration' has a wrong offset!");
static_assert(offsetof(AEndBattleAITown7WedgeController, FleeLocationResetDistance) == 0x0038C4, "Member 'AEndBattleAITown7WedgeController::FleeLocationResetDistance' has a wrong offset!");

// Class EndGame.EndBattleAPI
// 0x0000 (0x0028 - 0x0028)
class UEndBattleAPI final : public UObject
{
public:
	static void AddAttachEffect(class AEndCharacter* chara, const struct FEndCharacterAttachEffectArguments& args);
	static int32 AddBattleSceneCount(class FName InName, int32 InAddCount);
	static void AddCollisionIgnoreActor(class AEndCharacter* ownerChara, class FName IgnoreActorName);
	static void AddDodgeCharacter(class UEndBattleDamageSourceComponent* InDamageSourceComponent, class AEndCharacter* InDodgeChara);
	static void BeginAIPCConfrontIdle(EPlayerType PlayerType);
	static void BeginAIPCMeleeAttackMode(const EPlayerType PlayerCharacter);
	static bool CalcPartyCenterLocation(struct FVector* outCenterLocation);
	static void CancelAIPCAbilityGuard(const EPlayerType PlayerCharacter, class AEndCharacter* TargetCharacter, const class FName AbilityID);
	static bool CanSyncAction(class AEndCharacter* chara);
	static void ClearAIPCDefenceParam(EPlayerType PlayerType);
	static void ClearDangerWarning();
	static void ClearEffectsByCategoryBattle();
	static void CreateDamageSource(class FName DamageSourceID, class AEndCharacter* ownerChara, class AEndCharacter* targetChara, class FName AbilityID, bool bOverrideDamage, int32 OverrideDamage);
	static void CreateSyncAction(class FName syncActionID, class AEndCharacter* ownerChara, class AEndCharacter* targetChara);
	static void CreateSyncActionOwners(class FName syncActionID0, class AEndCharacter* ownerChara0, class FName syncActionID1, class AEndCharacter* ownerChara1, class FName syncActionID2, class AEndCharacter* ownerChara2);
	static void CreateSyncActionOwnersByName(class FName syncActionID0, class FName ownerCharaName0, class FName syncActionID1, class FName ownerCharaName1, class FName syncActionID2, class FName ownerCharaName2);
	static void DebugSetHP(class AEndCharacter* chara, int32 HP);
	static int32 DecBattleSceneCount(class FName InName);
	static void DestroyDamageSource(class FName DamageSourceID, class AEndCharacter* OwnerCharacter, bool bDestroyEffect);
	static void DestroyDamageSourceAll(bool bDestroyEffect);
	static void DestroyDamageSourceAllCharacter(class AEndCharacter* Character, bool bDestroyEffect);
	static bool DisableFogControllerAPI(const class FName& InFogName);
	static void DisableSelfRevive(EPlayerType PlayerType);
	static float DivEqualFloat(float& ValueA, float ValueB);
	static int32 DivEqualInterger(int32& ValueA, int32 ValueB);
	static void DodgeDirection(int32 Group);
	static bool EnableFogControllerAPI(const class FName& InFogName);
	static void EnableSelfRevive(EPlayerType PlayerType, float TimeForRevive, float HpRecoverRate);
	static void EndAIPCConfrontIdle(EPlayerType PlayerType);
	static void EndAIPCMeleeAttackMode(const EPlayerType PlayerCharacter);
	static bool ExistDamageSourceRevive();
	static TArray<class AEndNavModifierVolume*> FindNavVolumesInRange(class AEndCharacter* Character, const TArray<int32>& Groups, float angleRange, EEndBattleCompareDistanceType Type, bool behind, float Distance);
	static TArray<class AEndNavModifierVolume*> FindNavVolumesOutRange(class AEndCharacter* Character, const TArray<int32>& Groups, float angleRange, EEndBattleCompareDistanceType Type, bool behind, float Distance);
	static void FinishSummonOmenEffect();
	static void GameOverForce();
	static int32 GetAbilityElement(class FName InAbilityName);
	static struct FVector GetActorDirection(class AActor* From, class AActor* To);
	static float GetActorDistance(class AActor* From, class AActor* To);
	static class FName GetActorName(class AEndCharacter* InChara);
	static float GetAIActionAbilityTableFloat(class FName InName, EEndBattleAIActionAbility InElem);
	static int32 GetAIActionAbilityTableInt(class FName InName, EEndBattleAIActionAbility InElem);
	static class FString GetAIActionAbilityTableString(class FName InName, EEndBattleAIActionAbility InElem);
	static int32 GetAimedCountFromID(class AEndCharacter* InCharacter, class FName Upper, class FName Lower);
	static TArray<struct FVector> GetAllDamageSourceLocations(class FName InFindDamageSourceID);
	static void GetAttackableCharacters(TArray<class AEndCharacter*>* OutList, const TArray<class AEndCharacter*>& InList);
	static class AEndBattleAIController* GetBattleAI(class AEndCharacter* InChara);
	static class AEndBattleAIController* GetBattleAIControllerFromID(class AEndCharacter* InChara, int32 InID);
	static float GetBattleAreaDistanceFromAngle(class AEndCharacter* InCharacter, class AEndCharacter* InTargetCharacter, float InAngle);
	static class FName GetBattleCharaSpec_DataTableID(class AEndCharacter* InChara);
	static class FName GetBattleCharaSpec_WeakCondition(class AEndCharacter* InChara, int32 InIndex);
	static bool GetBattleCountLogBoolByBP(class FName ownerCharaName, EEndBattleCountLogType Type, class FName TargetCharaName, class FName subTypeName, const class FName& battleScenId);
	static bool GetBattleCountLogBoolForUCPCByBP(EEndBattleCountLogType Type, class FName TargetCharaName, class FName subTypeName, const class FName& battleScenId);
	static float GetBattleCountLogFloatByBP(class FName ownerCharaName, EEndBattleCountLogType Type, class FName TargetCharaName, class FName subTypeName, const class FName& battleScenId);
	static float GetBattleCountLogFloatForUCPCByBP(EEndBattleCountLogType Type, class FName TargetCharaName, class FName subTypeName, const class FName& battleScenId);
	static int32 GetBattleCountLogIntByBP(class FName ownerCharaName, EEndBattleCountLogType Type, class FName TargetCharaName, class FName subTypeName, const class FName& battleScenId);
	static int32 GetBattleCountLogIntForUCPCByBP(EEndBattleCountLogType Type, class FName TargetCharaName, class FName subTypeName, const class FName& battleScenId);
	static int32 GetBattleMemberConditionList(bool dead, bool sleep, bool Stop, bool petrify, bool toad, TArray<class AEndCharacter*>* memberList);
	static int32 GetBattleSceneCount(class FName InName);
	static class FName GetBattleSceneID();
	static class FName GetBattleSceneIDFromChara(class AEndCharacter* InChara, bool InParent);
	static class FName GetBattleSceneSituationID(const class FName& BattleSceneID);
	static EEndBattleSceneSituationType GetBattleSceneSituationType(const class FName& BattleSceneID);
	static void GetCharactersFromID(class FName Upper, class FName Lower, TArray<class AEndCharacter*>* OutList, const TArray<class AEndCharacter*>& InList);
	static class AEndCharacter* GetCharaFromActorName(class FName InActorName);
	static class AEndCharacter* GetCharaFromRaceID(class FName InRaceName, int32 InID);
	static int32 GetCharaHP(class AEndCharacter* InChara);
	static int32 GetCharaHPMax(class AEndCharacter* InChara);
	static int32 GetCharaHPP(class AEndCharacter* InChara);
	static class FName GetCharaID(class AEndCharacter* InChara);
	static float GetCommandLinkageMagnificate(class AEndCharacter* chara);
	static class FName GetCurrentAbilityID(class AEndCharacter* InChara);
	static EEndLocomotionState GetCurrentLocomotionState(class AEndCharacter* InChara);
	static int32 GetDamageSourceCount(class FName InDamageSourceID);
	static void GetDamageSourceInfo(class FName InAbilityName, int32* OutTarget, int32* OutTargetParty, int32* OutCut, int32* OutProperty, int32* OutCollision, bool* OutDisableFinish, float* OutCreateDelay);
	static void GetDamageSourceInfoFromDamage(class FName InDamageSourceID, int32* OutTarget, int32* OutTargetParty, int32* OutCut, int32* OutProperty, int32* OutCollision, bool* OutDisableFinish, float* OutCreateDelay);
	static TArray<class AEndCharacter*> GetDummyEnemies();
	static TArray<class AEndCharacter*> GetDummyNPCsFromID(class FName Upper, class FName Lower);
	static TArray<class AEndCharacter*> GetDummyPartyMembers();
	static const TArray<class FName> GetEncountBattleSceneIDs();
	static int32 GetEnemyMemberCount(class FName ContainRaceID);
	static int32 GetEnemyMemberCountFromID(class FName Upper, class FName Lower, bool Flip, bool bRemoveDummy);
	static class AEndCharacter* GetEnemyMemberFromIDWithIndex(class FName Upper, class FName Lower, int32 InIndex);
	static TArray<class AEndCharacter*> GetEnemyMembers(class FName ContainRaceID, bool Flip);
	static TArray<class AEndCharacter*> GetEnemyMembersFromID(class FName Upper, class FName Lower, bool Flip);
	static void GetEnemyMembersRef(TArray<class AEndCharacter*>* Out);
	static int32 GetExpectationCountInCapsuleArea(class AEndCharacter* InCharacter, EEndAiBattleTargetType targetType, float CapsuleRadius, float CapsuleLength, float FowardVectorRotateAngle);
	static int32 GetExpectationCountInCapsuleAreaByLocation(class AEndCharacter* InCharacter, EEndAiBattleTargetType targetType, float CapsuleRadius, float CapsuleLength, const struct FVector& TargetLocation, float FowardVectorRotateAngle);
	static int32 GetExpectationCountInConeArea(class AEndCharacter* InCharacter, EEndAiBattleTargetType targetType, float ConeRadius, float ConeAngle, float FowardVectorRotateAngle);
	static int32 GetExpectationCountInConeAreaByLocation(class AEndCharacter* InCharacter, EEndAiBattleTargetType targetType, float ConeRadius, float ConeAngle, const struct FVector& TargetLocation, float FowardVectorRotateAngle);
	static void GetFarestActor(class AActor** outActor, class AActor* baseActor, const TArray<class AActor*>& compareActorList, const TArray<class AActor*>& ignoreActorList);
	static class AEndCharacter* GetFarestCharacter(const struct FVector& InLocation, const TArray<class AEndCharacter*>& InList);
	static float GetGuardTime(class AEndCharacter* InChara);
	static bool GetHiddenBreakable(class FName BreakableID);
	static EEndBattleCharaCategoryType GetHighestPriorityBattleCharaCategory(const class FName& BattleSceneID);
	static int32 GetKeep(class AEndCharacter* InChara);
	static struct FTransform GetLayoutTransform(class FName NodeName);
	static int32 GetMagicDefense(class AEndCharacter* InChara);
	static bool GetMateriaParam(class AEndCharacter* InChara, bool bWeapon, int32 Slot, struct FEndBattleAIMateriaParam* Param);
	static TArray<class FName> GetMotionList(class AEndCharacter* InChara);
	static class AEndNavModifierVolume* GetNavVolumeFromAngle(class AEndCharacter* InChara, float InAngleRange, EEndBattleCompareDistanceType InType, int32 InGroup, bool InBehind);
	static TArray<class AEndNavModifierVolume*> GetNavVolumeFromType(class FName InBattleSceneID, EModifierVolumeType InType);
	static void GetNearestActor(class AActor** outActor, class AActor* baseActor, const TArray<class AActor*>& compareActorList, const TArray<class AActor*>& ignoreActorList);
	static class AEndCharacter* GetNearestCharacter(const struct FVector& InLocation, const TArray<class AEndCharacter*>& InList);
	static struct FVector GetNearestOwnVolume(class AEndCharacter* InChara, const struct FVector& InLocation);
	static struct FVector GetNearestOwnVolumeWithExtent(class AEndCharacter* InChara, const struct FVector& InLocation, const struct FVector& InExtent);
	static class AActor* GetNearestPhisics(class AEndCharacter* InChara, class FName InName, bool InContain);
	static class AActor* GetNearestPhisicsFromActorName(class AEndCharacter* InChara, class FName InName, bool InContain);
	static class AActor* GetNearestPhisicsInVolume(class AEndCharacter* InChara, class FName InVolumeName, class FName InName, bool InContain, bool InPossetion);
	static class AActor* GetNearestPhysicsInVolumeFromLocation(class AEndCharacter* InChara, class FName InVolumeName, class FName LocationName, class FName InName, bool InContain, bool InPossetion, bool InCanPosettion);
	static class AEndCharacter* GetNearestRangePartyCharacter(class AEndCharacter* InChara, float Range, bool ZVisible);
	static float GetObstractDistance(class AEndCharacter* chara);
	static float GetObstractDistanceAvarage(class AEndCharacter* chara);
	static float GetObstractDistanceFromAngle(class AEndCharacter* chara, float Angle);
	static struct FTransform GetOffsetTransform(const struct FTransform& Transform, const struct FVector& Offset, EGetOffsetTransform RotationType);
	static TArray<class AEndNavModifierVolume*> GetOverlapVolumes(class AEndCharacter* InChara);
	static TArray<class AEndCharacter*> GetPartyMembersIgnoreDead();
	static TArray<class AActor*> GetPhisics(class FName InName, bool InContain);
	static TArray<class AActor*> GetPhisicsFromActorName(class FName InName, bool InContain);
	static TArray<class AActor*> GetPhisicsInVolume(class FName InVolumeName, class FName InName, bool InContain, bool InPossetion);
	static int32 GetPhysicsDefense(class AEndCharacter* InChara);
	static TArray<class AEndEnvironmentPhysicsStaticMeshActor*> GetPhysicsFromLocation(class FName LocationName);
	static TArray<class AActor*> GetPhysicsInVolumeFromLocation(class FName InVolumeName, class FName LocationName, class FName InName, bool InContain, bool InPossetion, bool InCanPosettion);
	static class AEndCharacter* GetPlayerCharacter(EPlayerType Type);
	static EPlayerType GetPlayerType(class AEndCharacter* InChara);
	static void GetPlayingExtraActionSequenceNames(TArray<class FName>* outNames, class AEndCharacter* InChara);
	static int32 GetRaceID(class AEndCharacter* InChara);
	static class FName GetRaceName(class AEndCharacter* InChara);
	static class FName GetReplaceDamageSourceID(class FName InAbilityName);
	static int32 GetResistanceElement(class AEndCharacter* InChara, int32 InType);
	static struct FTransform GetSocketTransform(class AEndCharacter* InChara, class FName InSocketName);
	static int32 GetSpendATBBarTotal(class AEndCharacter* EndCharacter);
	static int32 GetStoryFlagConditionNum(const TArray<class FName>& storyFlagNames, bool Condition, int32 initializeNum);
	static class AEndCharacter* GetSummom(EEndBattleSummonType Type);
	static float GetSummonAvilableTime();
	static class AEndCharacter* GetSummonMaster(class AEndCharacter* InChara);
	static class FName GetSyncActionID(class AEndCharacter* chara);
	static int32 GetTakeActionCount(class AEndCharacter* InCharacter);
	static int32 GetTakeRequestActionCount(class AEndCharacter* InCharacter, class FName InName, bool InIgnoreBind);
	static int32 GetTakeRequestActionCountContainedName(class AEndCharacter* InCharacter, class FName InName, bool InIgnoreBind);
	static int32 GetTakeRequestActionCountContainedNameFromID(class AEndCharacter* InCharacter, class FName InName, class FName Upper, class FName Lower, bool InIgnoreBind);
	static int32 GetTotalWaveCount(class FName InName);
	static struct FVector GetVectorRange(float X, float Y, float Z, float IgnoreX, float IgnoreY, float IgnoreZ);
	static int32 GetWaveCount(class FName InName);
	static float GetWorldLocationAngle(const struct FVector& BaseLocation, const struct FVector& TargetLocation);
	static bool HasAbilityElement(class FName InAbilityName, EEndBattleAttributeType InType);
	static bool HasDamageSource(class AEndCharacter* InChara, class FName InDamageSourceID);
	static bool HasSpecialStatusChangeType(class AEndCharacter* InChara, EEndBattleSpecialStatusChangeType InType);
	static bool HasStatusChange(EPlayerType PlayerType, EEndBattleStatusChangeType statusTypeype);
	static bool HasStatusChangeFromChara(class AEndCharacter* InChara, EEndBattleStatusChangeType statusTypeype);
	static void HidePhysics(class FName ActorName);
	static int32 IncBattleSceneCount(class FName InName);
	static void InitializeBreakable();
	static void InvalidNearFadeEnvPhysicsActor();
	static bool IsAbility(class FName InAbilityName);
	static bool IsAdditiveDamagePlaying(class AEndCharacter* InChara);
	static bool IsAerialNormalAttack(class AEndCharacter* InChara);
	static bool IsAIPC(class AEndCharacter* InChara);
	static bool IsAIPCRangedWeaponEquipped(const EPlayerType PlayerCharacter);
	static bool IsBurst(class AEndCharacter* InChara);
	static bool IsCharacterValid(class AEndCharacter* InCharacter);
	static void IsCharacterValidBranch(class AEndCharacter* InCharacter, EEndAIBranchBit* OutSignal);
	static bool IsCharaHPP(class AEndCharacter* InChara, int32 Percent, EEndAiMathCmp cmp);
	static bool IsCharaID(class AEndCharacter* InChara, const class FName Upper, const class FName Lower);
	static bool IsCheckBattleSceneFlag(EEndAiBattleSceneFlag InType);
	static bool IsCloudOffensiveMode();
	static bool IsContainedMotionList(class AEndCharacter* InChara, class FName InMot1);
	static bool IsContainedMotionList2(class AEndCharacter* InChara, class FName InMot1, class FName InMot2);
	static bool IsContainedMotionList3(class AEndCharacter* InChara, class FName InMot1, class FName InMot2, class FName InMot3);
	static bool IsContainedMotionList4(class AEndCharacter* InChara, class FName InMot1, class FName InMot2, class FName InMot3, class FName InMot4);
	static bool IsContainedMotionList5(class AEndCharacter* InChara, class FName InMot1, class FName InMot2, class FName InMot3, class FName InMot4, class FName InMot5);
	static bool IsContainedMotionListArray(class AEndCharacter* InChara, const TArray<class FName>& InMot);
	static bool IsDamage(class AEndCharacter* InChara);
	static bool IsDamageSourceFlagDisableFinish(int32 Flag);
	static bool IsDisableTarget(class AEndCharacter* InChara);
	static bool IsDodge(class AEndCharacter* InChara);
	static bool IsDodgeInvincible(class AEndCharacter* InChara);
	static bool IsDodgeResetUniqueAbility(class AEndCharacter* InChara);
	static bool IsDummyPartyMember(class AEndCharacter* InChara);
	static bool IsEntryNavVolumeArea(class AEndCharacter* InChara, EModifierVolumeType InType);
	static bool IsExistCurrentAerialVolume();
	static bool IsFillLimitPlayer(class FName PlayerCharaName);
	static bool IsGuard(class AEndCharacter* InChara);
	static bool IsInAIPCDangerWarning(const EPlayerType PlayerCharacter);
	static bool IsInFanRange(class AEndCharacter* OwnerCharacter, float baseYaw, float angleRange, float RadiusMin, float RadiusMax, const struct FVector& targetPosition);
	static bool IsInScreen(class AActor* Actor);
	static bool IsInSummonCutScene();
	static bool IsInSyncAction(class AEndCharacter* chara);
	static bool IsItem(class FName InAbilityName);
	static bool IsLaunchActionPlaying(class AEndCharacter* InChara);
	static bool IsLimit(class FName InAbilityName);
	static bool IsMagic(class FName InAbilityName);
	static bool IsNormal(class FName InAbilityName);
	static bool IsOverlapCharaFromName(class FName InVolumeName, class AEndCharacter* InChara);
	static bool IsOverlapPoint(class AEndNavModifierVolume* InVolume, const struct FVector& InPoint);
	static bool IsPartyPinch();
	static bool IsPlayer(class AEndCharacter* InChara);
	static bool IsPlayerCharacterValid(EPlayerType Type);
	static bool IsPlayerPinch(const EPlayerType PlayerType);
	static bool IsRaceID(class AEndCharacter* InChara, int32 InID);
	static bool IsRequestWaveData(class FName BattleSceneID);
	static bool IsRewardEnable(class AEndCharacter* InChara, EEndBattleRewardType InType);
	static bool IsSummon(class AEndCharacter* InChara);
	static bool IsSummonGaugeZero();
	static bool IsUniqueAbility(class FName AbilityID);
	static bool IsWithinCharaEQS(class AEndCharacter* InChara, const struct FVector& InPoint);
	static float MinusEqualFloat(float& ValueA, float ValueB);
	static int32 MinusEqualInterger(int32& ValueA, int32 ValueB);
	static float MulEqualFloat(float& ValueA, float ValueB);
	static int32 MulEqualInterger(int32& ValueA, int32 ValueB);
	static void NotifyHGFireWallToAIPC(bool onoff);
	static void OnSeparateBodyAndRootForAIPC(class AEndCharacter* Character, bool onoff);
	static void OnSummonActivateTriggerAction();
	static void OnSummonFinishActivatePhase();
	static void OverrideAIPCLeader(const EPlayerType PlayerCharacter, const EPlayerType NewLeader);
	static void OverrideSummonCaptureTimeLimit(float Time);
	static void OverrideSummonCutSceneReturnLocation(class AEndCharacter* Character, const struct FTransform& Transform);
	static void OverrideSummonPointToIncreaseOneSecond(float Point);
	static int32 PlayBattleCameraSequence(class FName CameraSequenceID, class AEndCharacter* ownerChara, class AEndCharacter* HasResourceChara);
	static void PlayBreakableDestructionAnim(class FName BreakableID);
	static int32 PlayEffect(int32 CategoryType, class FName ResourceName, class AActor* AttachActor, class FName AttachSocketName);
	static float PlusEqualFloat(float& ValueA, float ValueB);
	static int32 PlusEqualInterger(int32& ValueA, int32 ValueB);
	static void RangeSwitch2(float Value, float Min1, float Max1, float Min2, float Max2, bool bContainEqual, EEndAIBranch2Other* OutSignal);
	static void RangeSwitch3(float Value, float Min1, float Max1, float Min2, float Max2, float Min3, float Max3, bool bContainEqual, EEndAIBranch3Other* OutSignal);
	static void RangeSwitch4(float Value, float Min1, float Max1, float Min2, float Max2, float Min3, float Max3, float Min4, float Max4, bool bContainEqual, EEndAIBranch4Other* OutSignal);
	static void RatioBranch2(int32 Case1, int32 Case2, EEndAIBranch2* OutSignal);
	static void RatioBranch3(int32 Case1, int32 Case2, int32 Case3, EEndAIBranch3* OutSignal);
	static void RatioBranch4(int32 Case1, int32 Case2, int32 Case3, int32 Case4, EEndAIBranch4* OutSignal);
	static void RatioBranch5(int32 Case1, int32 Case2, int32 Case3, int32 Case4, int32 Case5, EEndAIBranch5* OutSignal);
	static void RatioBranch6(int32 Case1, int32 Case2, int32 Case3, int32 Case4, int32 Case5, int32 Case6, EEndAIBranch6* OutSignal);
	static void RatioBranch7(int32 Case1, int32 Case2, int32 Case3, int32 Case4, int32 Case5, int32 Case6, int32 Case7, EEndAIBranch7* OutSignal);
	static void RatioBranch8(int32 Case1, int32 Case2, int32 Case3, int32 Case4, int32 Case5, int32 Case6, int32 Case7, int32 Case8, EEndAIBranch8* OutSignal);
	static void RaycastSphereWallFromChara(class AEndCharacter* InCharacter, float InOffsetYaw, float InCastRange, float InRadius, bool* OutHit, float* OutDistance, struct FHitResult* OutParam);
	static void RaycastWallFromChara(class AEndCharacter* InCharacter, float InOffsetYaw, float InCastRange, bool* OutHit, float* OutDistance, struct FHitResult* OutParam);
	static void RefreshRole();
	static void ReleaseBattleFieldBySummonBoss();
	static void RemoveAttachEffect(class AEndCharacter* chara, const class FName AttachSocketName, const class FName ResourceName, bool bDestroy);
	static void RemoveCollisionIgnoreActor(class AEndCharacter* ownerChara, class FName IgnoreActorName);
	static void RemoveFreeAct(class FName InName);
	static void RemoveSpecialStatusChangeType(class AEndCharacter* InChara, EEndBattleSpecialStatusChangeType InType);
	static void RemoveStatusChange(EPlayerType PlayerType, EEndBattleStatusChangeType statusTypeype);
	static bool RequestAIPCAbility(EPlayerType PlayerType, class FName AbilityID, class AActor* TargetActor);
	static void RequestAIPCExecuteAbility(class AEndCharacter* TargetCharacter, const class FName AbilityID, const EPlayerType PlayerCharacter);
	static void RequestFreeActMotion(class FName InName, class AEndCharacter* InChara, class FName InMotionName, bool InLoop);
	static void RequestFreeActMotionEnd(class FName InName, class AEndCharacter* InChara, class FName InEndName);
	static void RequestFreeActMove(class FName InName, class AEndCharacter* InChara, const struct FVector& InLocation, float ToleranceWalkRadius, float ToleranceGoalRadius, bool InDash);
	static void RequestFreeActMoves(class FName InName, class AEndCharacter* InChara, const TArray<struct FVector>& InLocations, float ToleranceWalkRadius, float ToleranceGoalRadius, bool InDash);
	static void RequestFreeActTurn(class FName InName, class AEndCharacter* InChara, float InYaw, float ToleranceYaw);
	static void RequestFreeActWarp(class FName InName, class AEndCharacter* InChara, const struct FVector& InLocation, float InYaw);
	static void RequestSyncActionEnd(class AEndCharacter* chara, EEndBattleSyncActionEndType Type);
	static class FName RequestWaveBattleScene(class UObject* WorldContextObject, class FName baseBattleSceneId, class AEndCharacter* causerChara, EndWaveBattleSceneType Type, int32 IntegerArgument00, int32 IntegerArgument01, int32 IntegerArgument02, int32 IntegerArgument03);
	static class FName RequestWaveBattleSceneWithPopTransform(class UObject* WorldContextObject, class FName baseBattleSceneId, class AEndCharacter* causerChara, EndWaveBattleSceneType Type, int32 IntegerArgument00, int32 IntegerArgument01, int32 IntegerArgument02, int32 IntegerArgument03, const TArray<struct FTransform>& popTransforms);
	static void ResetActiveBattleAIController(class AEndCharacter* InChara);
	static void ResetAIPCCombatArea(const EPlayerType PlayerCharacter);
	static void ResetAIPCExcludeTarget(EPlayerType PlayerType);
	static void ResetAIPCTargetChoosingParam(const EPlayerType PlayerCharacter);
	static void ResetAIPCTargetDirect(const EPlayerType PlayerCharacter);
	static void ResetCharacterMovementMode(class AEndCharacter* InChara);
	static void ResetFreeAct();
	static void ResetFreeActFromChara(class AEndCharacter* InChara);
	static void ResetRedXIIIAbilityExclusionTarget();
	static void ResetSummonCutSceneReturnLocation(class AEndCharacter* Character);
	static void ResetSummonPointToIncreaseOneSecond();
	static void RestrictBattleFieldBySummonBoss();
	static void SendBattleMessage(EBattleMessageTarget InTarget, const class FString& InMessage);
	static void SendDangerWarning(class AEndCharacter* Instigator, EEndBattleAIDangerAreaType DangerAreaType, const struct FVector& CenterLocation, const struct FVector& Direction, float Radius, float Length, float Width, float Duration);
	static void SendDangerWarningMultipleShape(const struct FEndBattleAIDangerWarningParam& DangerWarning);
	static void SendDangerWarningStaticVolume(class AEndCharacter* Instigator, float Duration, int32 GroupID);
	static void SendMetaMessage(const class FString& InMessage);
	static void SendMetaMessageAboutCharacter(class AEndCharacter* InChara, const class FString& InMessage);
	static void SendMetaMessageToChara(class AEndCharacter* InSend, class AEndCharacter* InResv, const class FString& InMessage);
	static void SendSystemMessage(const class FString& InMessage);
	static void SetActiveBattleAIController(class AEndCharacter* InChara, class AEndBattleAIController* BattleAIController);
	static void SetActiveBattleAIControllerFromID(class AEndCharacter* InChara, int32 InID);
	static void SetActorLocationAndRotationToRoot(class AEndCharacter* Character, const struct FVector& NewLocation, const struct FRotator& NewRotator);
	static void SetActorPause(class AActor* Actor, bool bTickPause, bool bDrawPause);
	static void SetAIPCCombatDistanceOffset(const EPlayerType PlayerCharacter, float Offset, bool AlsoAbilityOffset);
	static void SetAIPCDefenceActor(EPlayerType PlayerType, class AActor* TargetActor, float MaxDistance, float BestDistance);
	static void SetAIPCDefenceLocation(EPlayerType PlayerType, const struct FVector& TargetLocation, float MaxDistance, float BestDistance);
	static void SetAIPCExcludeTarget(EPlayerType PlayerType, class AEndCharacter* TargetCharacter);
	static void SetAIPCFleeTargets(class AEndCharacter* PlayerCharacter, const TArray<class AEndCharacter*>& FleeTargets);
	static void SetAIPCTakeCover(EPlayerType PlayerCharacter, bool Flag, class AEndCharacter* CoverTarget, class FName CoverTargetPartsID);
	static void SetAIPCTargetChoosingParam(const EPlayerType PlayerCharacter, const TArray<ETargetChoosingTag>& PriorityTagList, ETargetChoosingSort SortMethod, const TArray<class AEndCharacter*>& AssignedTargets);
	static void SetAIPCTargetDirect(const EPlayerType PlayerCharacter, class AEndCharacter* TargetCharacter, const class FName partsID, float TargetOverrideTime);
	static void SetAIPCTargetDirectMultipleParts(const EPlayerType PlayerCharacter, class AEndCharacter* TargetCharacter, const TArray<class FName>& PartsIDList);
	static void SetAIPCToSafeArea(const EPlayerType PlayerCharacter, const bool Flag);
	static void SetATB(EPlayerType PlayerType, float Value);
	static void SetATBAll(float Value);
	static void SetBattleSafeTransform(class AEndCharacter* InChara, bool bEnable);
	static void SetBattleSceneCount(class FName InName, int32 InCount);
	static void SetBattleSceneCountLifeCycle(class FName InName, EEndBattleSceneCountLifeCycleType InType, int32 InValue);
	static void SetCharacterMovementMode(class AEndCharacter* InChara, bool bMovable, bool bHitWall, bool bHitObject, bool bFitFloor, bool bMaxWeight);
	static void SetDisableTarget(class AEndCharacter* InChara, bool InDisable, bool hitDamage, bool TargetParts, bool refreshTargetLock);
	static void SetDisplayEnemyStatusCharacter(class AEndCharacter* Character);
	static void SetDrawDangerArea(bool Flag);
	static void SetDrawPauseEnvironmentPhysicsActors(const TArray<class AActor*>& objectList, bool drawPause, bool tickPause);
	static void SetEnableEquipmentSkillFrogAlways(bool Enable, bool frogAfterDebuffDisable);
	static void SetEnableSensorInfluence(EPlayerType PlayerType, bool Enable, class AEndCharacter* causerCharacter);
	static void SetFindTargetNoLimit(bool Value);
	static bool SetForceWeakConditionPointMax(class AEndCharacter* TargetCharacter, int32 Number);
	static void SetHiddenBreakable(bool bHidden, const TArray<class FName>& BreakableIDs);
	static void SetHiddenVolumeRelatedBreakable(EEndBattleBreakableRelationVolumeType VolumeType, bool bHidden, const TArray<class FName>& BreakableIDs);
	static void SetImmotality(class AEndCharacter* InChara, bool InImmotality);
	static void SetNoCheckDyningFilterTifaFlag(bool Flag);
	static void SetOverrideTextLabelID(class AEndCharacter* InCharacter, class FName InOverrideTextLabelID);
	static bool SetPartyLeader(EPlayerType Player, bool bIsInputTrigered);
	static void SetRedXIIIAbilityExclusionTarget(class AEndCharacter* TargetCharacter);
	static void SetRewardEnable(class AEndCharacter* InChara, EEndBattleRewardType InType, bool bEnable);
	static void SetStoryFlagCondition(class FName storyFlagNames, bool Condition);
	static void SetSummonInBossCutScene(bool bFlag);
	static void ShowPhysics(class FName ActorName, bool bSimulatePhysics);
	static void ShowWaveBattleScene(class FName BattleSceneID, const TArray<struct FTransform>& enemyPopTransforms);
	static void ShowWaveBattleSceneNoPopTransform(class FName BattleSceneID);
	static void SkipFadeCharaPopActor(class FName ActorName);
	static void StartEnvironmentPhysFieldForce(class FName GroupName);
	static void StopBattleCameraSequence(int32 sequenceActorUID);
	static void StopEnvironmentPhysFieldForce(class FName GroupName);
	static void StopLoopEffect(int32 EffectHandle);
	static void SummonTrigger();
	static bool TryLayoutTransform(class FName NodeName);
	static bool TrySetAIPCCombatArea(const EPlayerType PlayerCharacter, int32 GroupID);
	static void ValidNearFadeEnvPhysicsActor();
	static float VecToPitch(const struct FVector& InVec);
	static float VecToYaw(const struct FVector& InVec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAPI">();
	}
	static class UEndBattleAPI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleAPI>();
	}
};
static_assert(alignof(UEndBattleAPI) == 0x000008, "Wrong alignment on UEndBattleAPI");
static_assert(sizeof(UEndBattleAPI) == 0x000028, "Wrong size on UEndBattleAPI");

// Class EndGame.EndDataObjectBikeSplineMetaData
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBikeSplineMetaData final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBikeSplineMetaData">();
	}
	static class UEndDataObjectBikeSplineMetaData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBikeSplineMetaData>();
	}
};
static_assert(alignof(UEndDataObjectBikeSplineMetaData) == 0x000008, "Wrong alignment on UEndDataObjectBikeSplineMetaData");
static_assert(sizeof(UEndDataObjectBikeSplineMetaData) == 0x000088, "Wrong size on UEndDataObjectBikeSplineMetaData");

// Class EndGame.EndBattleAreaBoxComponent
// 0x0000 (0x0720 - 0x0720)
class UEndBattleAreaBoxComponent final : public UEndBattleAreaBoxComponentBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAreaBoxComponent">();
	}
	static class UEndBattleAreaBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleAreaBoxComponent>();
	}
};
static_assert(alignof(UEndBattleAreaBoxComponent) == 0x000010, "Wrong alignment on UEndBattleAreaBoxComponent");
static_assert(sizeof(UEndBattleAreaBoxComponent) == 0x000720, "Wrong size on UEndBattleAreaBoxComponent");

// Class EndGame.EndExtendedBattleAreaBoxComponent
// 0x0000 (0x0720 - 0x0720)
class UEndExtendedBattleAreaBoxComponent final : public UEndBattleAreaBoxComponentBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndExtendedBattleAreaBoxComponent">();
	}
	static class UEndExtendedBattleAreaBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndExtendedBattleAreaBoxComponent>();
	}
};
static_assert(alignof(UEndExtendedBattleAreaBoxComponent) == 0x000010, "Wrong alignment on UEndExtendedBattleAreaBoxComponent");
static_assert(sizeof(UEndExtendedBattleAreaBoxComponent) == 0x000720, "Wrong size on UEndExtendedBattleAreaBoxComponent");

// Class EndGame.EndDataObjectCameraFlavor
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectCameraFlavor final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectCameraFlavor">();
	}
	static class UEndDataObjectCameraFlavor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectCameraFlavor>();
	}
};
static_assert(alignof(UEndDataObjectCameraFlavor) == 0x000008, "Wrong alignment on UEndDataObjectCameraFlavor");
static_assert(sizeof(UEndDataObjectCameraFlavor) == 0x000088, "Wrong size on UEndDataObjectCameraFlavor");

// Class EndGame.EndBattleAreaDrawComponent
// 0x0000 (0x00F8 - 0x00F8)
class UEndBattleAreaDrawComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleAreaDrawComponent">();
	}
	static class UEndBattleAreaDrawComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleAreaDrawComponent>();
	}
};
static_assert(alignof(UEndBattleAreaDrawComponent) == 0x000008, "Wrong alignment on UEndBattleAreaDrawComponent");
static_assert(sizeof(UEndBattleAreaDrawComponent) == 0x0000F8, "Wrong size on UEndBattleAreaDrawComponent");

// Class EndGame.EndBattleBreakableCharacterComponent
// 0x0048 (0x0140 - 0x00F8)
class UEndBattleBreakableCharacterComponent final : public UActorComponent
{
public:
	TArray<struct FEndBattleBreakableAttachData>  BreakableAttachDataList;                           // 0x00F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x38];                                     // 0x0108(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleBreakableCharacterComponent">();
	}
	static class UEndBattleBreakableCharacterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleBreakableCharacterComponent>();
	}
};
static_assert(alignof(UEndBattleBreakableCharacterComponent) == 0x000008, "Wrong alignment on UEndBattleBreakableCharacterComponent");
static_assert(sizeof(UEndBattleBreakableCharacterComponent) == 0x000140, "Wrong size on UEndBattleBreakableCharacterComponent");
static_assert(offsetof(UEndBattleBreakableCharacterComponent, BreakableAttachDataList) == 0x0000F8, "Member 'UEndBattleBreakableCharacterComponent::BreakableAttachDataList' has a wrong offset!");

// Class EndGame.EndDataObjectChadlieVRBattle
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectChadlieVRBattle final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectChadlieVRBattle">();
	}
	static class UEndDataObjectChadlieVRBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectChadlieVRBattle>();
	}
};
static_assert(alignof(UEndDataObjectChadlieVRBattle) == 0x000008, "Wrong alignment on UEndDataObjectChadlieVRBattle");
static_assert(sizeof(UEndDataObjectChadlieVRBattle) == 0x000088, "Wrong size on UEndDataObjectChadlieVRBattle");

// Class EndGame.EndBattleCameraShakeNotify
// 0x0020 (0x0058 - 0x0038)
class UEndBattleCameraShakeNotify final : public UAnimNotify
{
public:
	float                                         Cycle;                                             // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Power;                                             // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Decay;                                             // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Inner;                                             // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Outer_0;                                           // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleCameraShakeNotify">();
	}
	static class UEndBattleCameraShakeNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleCameraShakeNotify>();
	}
};
static_assert(alignof(UEndBattleCameraShakeNotify) == 0x000008, "Wrong alignment on UEndBattleCameraShakeNotify");
static_assert(sizeof(UEndBattleCameraShakeNotify) == 0x000058, "Wrong size on UEndBattleCameraShakeNotify");
static_assert(offsetof(UEndBattleCameraShakeNotify, Cycle) == 0x000038, "Member 'UEndBattleCameraShakeNotify::Cycle' has a wrong offset!");
static_assert(offsetof(UEndBattleCameraShakeNotify, Power) == 0x00003C, "Member 'UEndBattleCameraShakeNotify::Power' has a wrong offset!");
static_assert(offsetof(UEndBattleCameraShakeNotify, Decay) == 0x000040, "Member 'UEndBattleCameraShakeNotify::Decay' has a wrong offset!");
static_assert(offsetof(UEndBattleCameraShakeNotify, BlendInTime) == 0x000044, "Member 'UEndBattleCameraShakeNotify::BlendInTime' has a wrong offset!");
static_assert(offsetof(UEndBattleCameraShakeNotify, BlendOutTime) == 0x000048, "Member 'UEndBattleCameraShakeNotify::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UEndBattleCameraShakeNotify, Inner) == 0x00004C, "Member 'UEndBattleCameraShakeNotify::Inner' has a wrong offset!");
static_assert(offsetof(UEndBattleCameraShakeNotify, Outer_0) == 0x000050, "Member 'UEndBattleCameraShakeNotify::Outer_0' has a wrong offset!");
static_assert(offsetof(UEndBattleCameraShakeNotify, Duration) == 0x000054, "Member 'UEndBattleCameraShakeNotify::Duration' has a wrong offset!");

// Class EndGame.EndBTDecorator_IsInDangerArea
// 0x0028 (0x0090 - 0x0068)
class UEndBTDecorator_IsInDangerArea final : public UEndBTDecorator_CheckConditionBase
{
public:
	struct FBlackboardKeySelector                 BlackboardKey;                                     // 0x0068(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_IsInDangerArea">();
	}
	static class UEndBTDecorator_IsInDangerArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_IsInDangerArea>();
	}
};
static_assert(alignof(UEndBTDecorator_IsInDangerArea) == 0x000008, "Wrong alignment on UEndBTDecorator_IsInDangerArea");
static_assert(sizeof(UEndBTDecorator_IsInDangerArea) == 0x000090, "Wrong size on UEndBTDecorator_IsInDangerArea");
static_assert(offsetof(UEndBTDecorator_IsInDangerArea, BlackboardKey) == 0x000068, "Member 'UEndBTDecorator_IsInDangerArea::BlackboardKey' has a wrong offset!");

// Class EndGame.EndBattleCameraShakeNotifyState
// 0x0020 (0x0050 - 0x0030)
class UEndBattleCameraShakeNotifyState final : public UAnimNotifyState
{
public:
	float                                         Cycle;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Power;                                             // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Decay;                                             // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Inner;                                             // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Outer_0;                                           // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableLoop;                                        // 0x004C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleCameraShakeNotifyState">();
	}
	static class UEndBattleCameraShakeNotifyState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleCameraShakeNotifyState>();
	}
};
static_assert(alignof(UEndBattleCameraShakeNotifyState) == 0x000008, "Wrong alignment on UEndBattleCameraShakeNotifyState");
static_assert(sizeof(UEndBattleCameraShakeNotifyState) == 0x000050, "Wrong size on UEndBattleCameraShakeNotifyState");
static_assert(offsetof(UEndBattleCameraShakeNotifyState, Cycle) == 0x000030, "Member 'UEndBattleCameraShakeNotifyState::Cycle' has a wrong offset!");
static_assert(offsetof(UEndBattleCameraShakeNotifyState, Power) == 0x000034, "Member 'UEndBattleCameraShakeNotifyState::Power' has a wrong offset!");
static_assert(offsetof(UEndBattleCameraShakeNotifyState, Decay) == 0x000038, "Member 'UEndBattleCameraShakeNotifyState::Decay' has a wrong offset!");
static_assert(offsetof(UEndBattleCameraShakeNotifyState, BlendInTime) == 0x00003C, "Member 'UEndBattleCameraShakeNotifyState::BlendInTime' has a wrong offset!");
static_assert(offsetof(UEndBattleCameraShakeNotifyState, BlendOutTime) == 0x000040, "Member 'UEndBattleCameraShakeNotifyState::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UEndBattleCameraShakeNotifyState, Inner) == 0x000044, "Member 'UEndBattleCameraShakeNotifyState::Inner' has a wrong offset!");
static_assert(offsetof(UEndBattleCameraShakeNotifyState, Outer_0) == 0x000048, "Member 'UEndBattleCameraShakeNotifyState::Outer_0' has a wrong offset!");
static_assert(offsetof(UEndBattleCameraShakeNotifyState, EnableLoop) == 0x00004C, "Member 'UEndBattleCameraShakeNotifyState::EnableLoop' has a wrong offset!");

// Class EndGame.EndBTDecorator_Field_IsCharaPopDisableTick
// 0x0000 (0x0068 - 0x0068)
class UEndBTDecorator_Field_IsCharaPopDisableTick final : public UEndBTDecorator_CheckConditionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_Field_IsCharaPopDisableTick">();
	}
	static class UEndBTDecorator_Field_IsCharaPopDisableTick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_Field_IsCharaPopDisableTick>();
	}
};
static_assert(alignof(UEndBTDecorator_Field_IsCharaPopDisableTick) == 0x000008, "Wrong alignment on UEndBTDecorator_Field_IsCharaPopDisableTick");
static_assert(sizeof(UEndBTDecorator_Field_IsCharaPopDisableTick) == 0x000068, "Wrong size on UEndBTDecorator_Field_IsCharaPopDisableTick");

// Class EndGame.EndBattleDamageSourceCollisionCapsuleComponent
// 0x0010 (0x0730 - 0x0720)
class UEndBattleDamageSourceCollisionCapsuleComponent final : public UCapsuleComponent
{
public:
	class FName                                   CategoryID;                                        // 0x0720(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 PossessionActor;                                   // 0x0728(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleDamageSourceCollisionCapsuleComponent">();
	}
	static class UEndBattleDamageSourceCollisionCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleDamageSourceCollisionCapsuleComponent>();
	}
};
static_assert(alignof(UEndBattleDamageSourceCollisionCapsuleComponent) == 0x000010, "Wrong alignment on UEndBattleDamageSourceCollisionCapsuleComponent");
static_assert(sizeof(UEndBattleDamageSourceCollisionCapsuleComponent) == 0x000730, "Wrong size on UEndBattleDamageSourceCollisionCapsuleComponent");
static_assert(offsetof(UEndBattleDamageSourceCollisionCapsuleComponent, CategoryID) == 0x000720, "Member 'UEndBattleDamageSourceCollisionCapsuleComponent::CategoryID' has a wrong offset!");
static_assert(offsetof(UEndBattleDamageSourceCollisionCapsuleComponent, PossessionActor) == 0x000728, "Member 'UEndBattleDamageSourceCollisionCapsuleComponent::PossessionActor' has a wrong offset!");

// Class EndGame.EndMonkeyBarsDebugTextComponent
// 0x00D0 (0x07C0 - 0x06F0)
class UEndMonkeyBarsDebugTextComponent final : public UPrimitiveComponent
{
public:
	uint8                                         Pad_6F0[0xD0];                                     // 0x06F0(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMonkeyBarsDebugTextComponent">();
	}
	static class UEndMonkeyBarsDebugTextComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMonkeyBarsDebugTextComponent>();
	}
};
static_assert(alignof(UEndMonkeyBarsDebugTextComponent) == 0x000010, "Wrong alignment on UEndMonkeyBarsDebugTextComponent");
static_assert(sizeof(UEndMonkeyBarsDebugTextComponent) == 0x0007C0, "Wrong size on UEndMonkeyBarsDebugTextComponent");

// Class EndGame.EndBattleDamageSourceCollisionComponent
// 0x0058 (0x0150 - 0x00F8)
class UEndBattleDamageSourceCollisionComponent final : public UActorComponent
{
public:
	class FName                                   CategoryID;                                        // 0x00F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         GroupNumber;                                       // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEndBattleDamageSourceCollisionDataSphere> Spheres;                                           // 0x0108(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FEndBattleDamageSourceCollisionDataBox> Boxes;                                             // 0x0118(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FEndBattleDamageSourceCollisionDataCapsule> Capsules;                                          // 0x0128(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bStartWithHidden;                                  // 0x0138(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIgnorePlayerDamageSource;                         // 0x0139(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13A[0x6];                                      // 0x013A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AEndEnvironmentPhysicsStaticMeshActor*  OwnerActor;                                        // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 PossessionActor;                                   // 0x0148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleDamageSourceCollisionComponent">();
	}
	static class UEndBattleDamageSourceCollisionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleDamageSourceCollisionComponent>();
	}
};
static_assert(alignof(UEndBattleDamageSourceCollisionComponent) == 0x000008, "Wrong alignment on UEndBattleDamageSourceCollisionComponent");
static_assert(sizeof(UEndBattleDamageSourceCollisionComponent) == 0x000150, "Wrong size on UEndBattleDamageSourceCollisionComponent");
static_assert(offsetof(UEndBattleDamageSourceCollisionComponent, CategoryID) == 0x0000F8, "Member 'UEndBattleDamageSourceCollisionComponent::CategoryID' has a wrong offset!");
static_assert(offsetof(UEndBattleDamageSourceCollisionComponent, GroupNumber) == 0x000100, "Member 'UEndBattleDamageSourceCollisionComponent::GroupNumber' has a wrong offset!");
static_assert(offsetof(UEndBattleDamageSourceCollisionComponent, Spheres) == 0x000108, "Member 'UEndBattleDamageSourceCollisionComponent::Spheres' has a wrong offset!");
static_assert(offsetof(UEndBattleDamageSourceCollisionComponent, Boxes) == 0x000118, "Member 'UEndBattleDamageSourceCollisionComponent::Boxes' has a wrong offset!");
static_assert(offsetof(UEndBattleDamageSourceCollisionComponent, Capsules) == 0x000128, "Member 'UEndBattleDamageSourceCollisionComponent::Capsules' has a wrong offset!");
static_assert(offsetof(UEndBattleDamageSourceCollisionComponent, bStartWithHidden) == 0x000138, "Member 'UEndBattleDamageSourceCollisionComponent::bStartWithHidden' has a wrong offset!");
static_assert(offsetof(UEndBattleDamageSourceCollisionComponent, bIgnorePlayerDamageSource) == 0x000139, "Member 'UEndBattleDamageSourceCollisionComponent::bIgnorePlayerDamageSource' has a wrong offset!");
static_assert(offsetof(UEndBattleDamageSourceCollisionComponent, OwnerActor) == 0x000140, "Member 'UEndBattleDamageSourceCollisionComponent::OwnerActor' has a wrong offset!");
static_assert(offsetof(UEndBattleDamageSourceCollisionComponent, PossessionActor) == 0x000148, "Member 'UEndBattleDamageSourceCollisionComponent::PossessionActor' has a wrong offset!");

// Class EndGame.EndBTDecorator_SetBlackboardFloat
// 0x0030 (0x0098 - 0x0068)
class UEndBTDecorator_SetBlackboardFloat final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 BlackboardKey;                                     // 0x0068(0x0028)(Edit, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_SetBlackboardFloat">();
	}
	static class UEndBTDecorator_SetBlackboardFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_SetBlackboardFloat>();
	}
};
static_assert(alignof(UEndBTDecorator_SetBlackboardFloat) == 0x000008, "Wrong alignment on UEndBTDecorator_SetBlackboardFloat");
static_assert(sizeof(UEndBTDecorator_SetBlackboardFloat) == 0x000098, "Wrong size on UEndBTDecorator_SetBlackboardFloat");
static_assert(offsetof(UEndBTDecorator_SetBlackboardFloat, BlackboardKey) == 0x000068, "Member 'UEndBTDecorator_SetBlackboardFloat::BlackboardKey' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_SetBlackboardFloat, Value) == 0x000090, "Member 'UEndBTDecorator_SetBlackboardFloat::Value' has a wrong offset!");

// Class EndGame.EndSkeletalMeshActor
// 0x0AB8 (0x0EB8 - 0x0400)
#pragma pack(push, 0x1)
class alignas(0x08) AEndSkeletalMeshActor : public ASkeletalMeshActor
{
public:
	uint8                                         Pad_400[0x18];                                     // 0x0400(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UActorComponent*>     ComponentTable;                                    // 0x0418(0x0050)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_468[0x9D8];                                    // 0x0468(0x09D8)(Fixing Size After Last Property [ Dumper-7 ])
	class USQEX_KBD_Component*                    KBD;                                               // 0x0E40(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USQEX_Bonamik_Component*                Bonamik;                                           // 0x0E48(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndEmissiveColorComponent*             EmissiveColorComponent;                            // 0x0E50(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForcedUsePhysicsAssetBounds;                      // 0x0E58(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E59[0x5F];                                     // 0x0E59(0x005F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OverrideDefaultEmissiveColor();
	void PlayEmissiveColorAnimation(class FName RequestID, class FName ColorPaletteId, EEndEmissiveModifierType ModifierType, EEndEmissiveCurveType CurveType, bool bLoop, float Duration, float BlendInTime, float BlendOutTime, float StartOffset, float EndOffset);
	void ResetDirectEmissiveColor();
	void SetDirectEmissiveColor(class FName ColorPaletteId, float IntensityBias);
	void StopEmissiveColorAnimation(class FName RequestID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndSkeletalMeshActor">();
	}
	static class AEndSkeletalMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndSkeletalMeshActor>();
	}
};
#pragma pack(pop)
static_assert(alignof(AEndSkeletalMeshActor) == 0x000008, "Wrong alignment on AEndSkeletalMeshActor");
static_assert(sizeof(AEndSkeletalMeshActor) == 0x000EB8, "Wrong size on AEndSkeletalMeshActor");
static_assert(offsetof(AEndSkeletalMeshActor, ComponentTable) == 0x000418, "Member 'AEndSkeletalMeshActor::ComponentTable' has a wrong offset!");
static_assert(offsetof(AEndSkeletalMeshActor, KBD) == 0x000E40, "Member 'AEndSkeletalMeshActor::KBD' has a wrong offset!");
static_assert(offsetof(AEndSkeletalMeshActor, Bonamik) == 0x000E48, "Member 'AEndSkeletalMeshActor::Bonamik' has a wrong offset!");
static_assert(offsetof(AEndSkeletalMeshActor, EmissiveColorComponent) == 0x000E50, "Member 'AEndSkeletalMeshActor::EmissiveColorComponent' has a wrong offset!");
static_assert(offsetof(AEndSkeletalMeshActor, bForcedUsePhysicsAssetBounds) == 0x000E58, "Member 'AEndSkeletalMeshActor::bForcedUsePhysicsAssetBounds' has a wrong offset!");

// Class EndGame.EndWireReelActor
// 0x0278 (0x1130 - 0x0EB8)
class AEndWireReelActor final : public AEndSkeletalMeshActor
{
public:
	class UEndBoneAttachComponent*                BoneAttach;                                        // 0x0EB8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEndPhysicalConstraintWireEvaluator    PhysicalConstraint;                                // 0x0EC0(0x01E8)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_10A8[0x88];                                    // 0x10A8(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetWireState(EEndWireReelState InState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndWireReelActor">();
	}
	static class AEndWireReelActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndWireReelActor>();
	}
};
static_assert(alignof(AEndWireReelActor) == 0x000008, "Wrong alignment on AEndWireReelActor");
static_assert(sizeof(AEndWireReelActor) == 0x001130, "Wrong size on AEndWireReelActor");
static_assert(offsetof(AEndWireReelActor, BoneAttach) == 0x000EB8, "Member 'AEndWireReelActor::BoneAttach' has a wrong offset!");
static_assert(offsetof(AEndWireReelActor, PhysicalConstraint) == 0x000EC0, "Member 'AEndWireReelActor::PhysicalConstraint' has a wrong offset!");

// Class EndGame.EndBTTask_Field_MoveCancel
// 0x0000 (0x0070 - 0x0070)
class UEndBTTask_Field_MoveCancel final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_Field_MoveCancel">();
	}
	static class UEndBTTask_Field_MoveCancel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_Field_MoveCancel>();
	}
};
static_assert(alignof(UEndBTTask_Field_MoveCancel) == 0x000008, "Wrong alignment on UEndBTTask_Field_MoveCancel");
static_assert(sizeof(UEndBTTask_Field_MoveCancel) == 0x000070, "Wrong size on UEndBTTask_Field_MoveCancel");

// Class EndGame.EndBattleDamageSourceComponentBullet
// 0x0020 (0x0480 - 0x0460)
class UEndBattleDamageSourceComponentBullet final : public UEndBattleDamageSourceComponent
{
public:
	uint8                                         Pad_460[0x20];                                     // 0x0460(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleDamageSourceComponentBullet">();
	}
	static class UEndBattleDamageSourceComponentBullet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleDamageSourceComponentBullet>();
	}
};
static_assert(alignof(UEndBattleDamageSourceComponentBullet) == 0x000008, "Wrong alignment on UEndBattleDamageSourceComponentBullet");
static_assert(sizeof(UEndBattleDamageSourceComponentBullet) == 0x000480, "Wrong size on UEndBattleDamageSourceComponentBullet");

// Class EndGame.EndBattleDamageSourceComponentDisk
// 0x0030 (0x0490 - 0x0460)
class UEndBattleDamageSourceComponentDisk final : public UEndBattleDamageSourceComponent
{
public:
	uint8                                         Pad_460[0x30];                                     // 0x0460(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleDamageSourceComponentDisk">();
	}
	static class UEndBattleDamageSourceComponentDisk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleDamageSourceComponentDisk>();
	}
};
static_assert(alignof(UEndBattleDamageSourceComponentDisk) == 0x000008, "Wrong alignment on UEndBattleDamageSourceComponentDisk");
static_assert(sizeof(UEndBattleDamageSourceComponentDisk) == 0x000490, "Wrong size on UEndBattleDamageSourceComponentDisk");

// Class EndGame.EndFieldActionActorClimb
// 0x0068 (0x0680 - 0x0618)
class AEndFieldActionActorClimb final : public AEndFieldActionActorBase
{
public:
	class UEndFieldActionTriggerComponent*        EnterVolume;                                       // 0x0618(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        ExitVolume;                                        // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0628(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_630[0x50];                                     // 0x0630(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorClimb">();
	}
	static class AEndFieldActionActorClimb* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorClimb>();
	}
};
static_assert(alignof(AEndFieldActionActorClimb) == 0x000008, "Wrong alignment on AEndFieldActionActorClimb");
static_assert(sizeof(AEndFieldActionActorClimb) == 0x000680, "Wrong size on AEndFieldActionActorClimb");
static_assert(offsetof(AEndFieldActionActorClimb, EnterVolume) == 0x000618, "Member 'AEndFieldActionActorClimb::EnterVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorClimb, ExitVolume) == 0x000620, "Member 'AEndFieldActionActorClimb::ExitVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorClimb, ModifierVolume) == 0x000628, "Member 'AEndFieldActionActorClimb::ModifierVolume' has a wrong offset!");

// Class EndGame.EndBTDecorator_SetVisibility
// 0x0008 (0x0070 - 0x0068)
class UEndBTDecorator_SetVisibility final : public UBTDecorator
{
public:
	bool                                          Visibility;                                        // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_SetVisibility">();
	}
	static class UEndBTDecorator_SetVisibility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_SetVisibility>();
	}
};
static_assert(alignof(UEndBTDecorator_SetVisibility) == 0x000008, "Wrong alignment on UEndBTDecorator_SetVisibility");
static_assert(sizeof(UEndBTDecorator_SetVisibility) == 0x000070, "Wrong size on UEndBTDecorator_SetVisibility");
static_assert(offsetof(UEndBTDecorator_SetVisibility, Visibility) == 0x000068, "Member 'UEndBTDecorator_SetVisibility::Visibility' has a wrong offset!");

// Class EndGame.EndBattleDamageSourceComponentDrive
// 0x0060 (0x04C0 - 0x0460)
class UEndBattleDamageSourceComponentDrive final : public UEndBattleDamageSourceComponent
{
public:
	uint8                                         Pad_460[0x60];                                     // 0x0460(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleDamageSourceComponentDrive">();
	}
	static class UEndBattleDamageSourceComponentDrive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleDamageSourceComponentDrive>();
	}
};
static_assert(alignof(UEndBattleDamageSourceComponentDrive) == 0x000008, "Wrong alignment on UEndBattleDamageSourceComponentDrive");
static_assert(sizeof(UEndBattleDamageSourceComponentDrive) == 0x0004C0, "Wrong size on UEndBattleDamageSourceComponentDrive");

// Class EndGame.EndBattleDamageSourceComponentGrenade
// 0x0010 (0x0470 - 0x0460)
class UEndBattleDamageSourceComponentGrenade final : public UEndBattleDamageSourceComponent
{
public:
	uint8                                         Pad_460[0x10];                                     // 0x0460(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleDamageSourceComponentGrenade">();
	}
	static class UEndBattleDamageSourceComponentGrenade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleDamageSourceComponentGrenade>();
	}
};
static_assert(alignof(UEndBattleDamageSourceComponentGrenade) == 0x000008, "Wrong alignment on UEndBattleDamageSourceComponentGrenade");
static_assert(sizeof(UEndBattleDamageSourceComponentGrenade) == 0x000470, "Wrong size on UEndBattleDamageSourceComponentGrenade");

// Class EndGame.EndFieldActionActorFan
// 0x0088 (0x06A0 - 0x0618)
class AEndFieldActionActorFan final : public AEndFieldActionActorBase
{
public:
	class UEndFieldActionSplineComponent*         FanComponent;                                      // 0x0618(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        EnterVolume;                                       // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        ExitVolume;                                        // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndSwitchAreaBoxComponent*             DividedImpassableEnterVolume;                      // 0x0630(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndSwitchAreaBoxComponent*             DividedImpassableExitVolume;                       // 0x0638(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0640(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoBoxRotation;                                   // 0x0648(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_649[0x57];                                     // 0x0649(0x0057)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorFan">();
	}
	static class AEndFieldActionActorFan* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorFan>();
	}
};
static_assert(alignof(AEndFieldActionActorFan) == 0x000008, "Wrong alignment on AEndFieldActionActorFan");
static_assert(sizeof(AEndFieldActionActorFan) == 0x0006A0, "Wrong size on AEndFieldActionActorFan");
static_assert(offsetof(AEndFieldActionActorFan, FanComponent) == 0x000618, "Member 'AEndFieldActionActorFan::FanComponent' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorFan, EnterVolume) == 0x000620, "Member 'AEndFieldActionActorFan::EnterVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorFan, ExitVolume) == 0x000628, "Member 'AEndFieldActionActorFan::ExitVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorFan, DividedImpassableEnterVolume) == 0x000630, "Member 'AEndFieldActionActorFan::DividedImpassableEnterVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorFan, DividedImpassableExitVolume) == 0x000638, "Member 'AEndFieldActionActorFan::DividedImpassableExitVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorFan, ModifierVolume) == 0x000640, "Member 'AEndFieldActionActorFan::ModifierVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorFan, AutoBoxRotation) == 0x000648, "Member 'AEndFieldActionActorFan::AutoBoxRotation' has a wrong offset!");

// Class EndGame.EndBTDecorator_Field_ObjectComparison
// 0x0058 (0x00C0 - 0x0068)
class UEndBTDecorator_Field_ObjectComparison final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 m_SourceA;                                         // 0x0068(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 m_SourceB;                                         // 0x0090(0x0028)(Edit, NativeAccessSpecifierPublic)
	bool                                          m_bNullCheck;                                      // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_Field_ObjectComparison">();
	}
	static class UEndBTDecorator_Field_ObjectComparison* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_Field_ObjectComparison>();
	}
};
static_assert(alignof(UEndBTDecorator_Field_ObjectComparison) == 0x000008, "Wrong alignment on UEndBTDecorator_Field_ObjectComparison");
static_assert(sizeof(UEndBTDecorator_Field_ObjectComparison) == 0x0000C0, "Wrong size on UEndBTDecorator_Field_ObjectComparison");
static_assert(offsetof(UEndBTDecorator_Field_ObjectComparison, m_SourceA) == 0x000068, "Member 'UEndBTDecorator_Field_ObjectComparison::m_SourceA' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_ObjectComparison, m_SourceB) == 0x000090, "Member 'UEndBTDecorator_Field_ObjectComparison::m_SourceB' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_ObjectComparison, m_bNullCheck) == 0x0000B8, "Member 'UEndBTDecorator_Field_ObjectComparison::m_bNullCheck' has a wrong offset!");

// Class EndGame.EndBattleDamageSourceComponentHoming
// 0x00B0 (0x0510 - 0x0460)
class UEndBattleDamageSourceComponentHoming final : public UEndBattleDamageSourceComponent
{
public:
	uint8                                         Pad_460[0xB0];                                     // 0x0460(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleDamageSourceComponentHoming">();
	}
	static class UEndBattleDamageSourceComponentHoming* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleDamageSourceComponentHoming>();
	}
};
static_assert(alignof(UEndBattleDamageSourceComponentHoming) == 0x000008, "Wrong alignment on UEndBattleDamageSourceComponentHoming");
static_assert(sizeof(UEndBattleDamageSourceComponentHoming) == 0x000510, "Wrong size on UEndBattleDamageSourceComponentHoming");

// Class EndGame.EndFieldActionActorPeek
// 0x0030 (0x0648 - 0x0618)
class AEndFieldActionActorPeek final : public AEndFieldActionActorBase
{
public:
	class UEndFieldActionTriggerComponent*        PressVolume;                                       // 0x0618(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        TargetIconComponent;                               // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        CameraComponent;                                   // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CameraTriggerStart;                                // 0x0630(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CameraTriggerEnd;                                  // 0x0638(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0640(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorPeek">();
	}
	static class AEndFieldActionActorPeek* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorPeek>();
	}
};
static_assert(alignof(AEndFieldActionActorPeek) == 0x000008, "Wrong alignment on AEndFieldActionActorPeek");
static_assert(sizeof(AEndFieldActionActorPeek) == 0x000648, "Wrong size on AEndFieldActionActorPeek");
static_assert(offsetof(AEndFieldActionActorPeek, PressVolume) == 0x000618, "Member 'AEndFieldActionActorPeek::PressVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorPeek, TargetIconComponent) == 0x000620, "Member 'AEndFieldActionActorPeek::TargetIconComponent' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorPeek, CameraComponent) == 0x000628, "Member 'AEndFieldActionActorPeek::CameraComponent' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorPeek, CameraTriggerStart) == 0x000630, "Member 'AEndFieldActionActorPeek::CameraTriggerStart' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorPeek, CameraTriggerEnd) == 0x000638, "Member 'AEndFieldActionActorPeek::CameraTriggerEnd' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorPeek, ModifierVolume) == 0x000640, "Member 'AEndFieldActionActorPeek::ModifierVolume' has a wrong offset!");

// Class EndGame.EndBattleDamageSourceComponentLaser
// 0x00D0 (0x0530 - 0x0460)
class UEndBattleDamageSourceComponentLaser final : public UEndBattleDamageSourceComponent
{
public:
	uint8                                         Pad_460[0xD0];                                     // 0x0460(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBindEffectFinished(class UParticleSystemComponent* finishedComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleDamageSourceComponentLaser">();
	}
	static class UEndBattleDamageSourceComponentLaser* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleDamageSourceComponentLaser>();
	}
};
static_assert(alignof(UEndBattleDamageSourceComponentLaser) == 0x000008, "Wrong alignment on UEndBattleDamageSourceComponentLaser");
static_assert(sizeof(UEndBattleDamageSourceComponentLaser) == 0x000530, "Wrong size on UEndBattleDamageSourceComponentLaser");

// Class EndGame.EndBTDecorator_ShouldTeleportCommandExecutePoint
// 0x0000 (0x0068 - 0x0068)
class UEndBTDecorator_ShouldTeleportCommandExecutePoint final : public UEndBTDecorator_CheckConditionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_ShouldTeleportCommandExecutePoint">();
	}
	static class UEndBTDecorator_ShouldTeleportCommandExecutePoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_ShouldTeleportCommandExecutePoint>();
	}
};
static_assert(alignof(UEndBTDecorator_ShouldTeleportCommandExecutePoint) == 0x000008, "Wrong alignment on UEndBTDecorator_ShouldTeleportCommandExecutePoint");
static_assert(sizeof(UEndBTDecorator_ShouldTeleportCommandExecutePoint) == 0x000068, "Wrong size on UEndBTDecorator_ShouldTeleportCommandExecutePoint");

// Class EndGame.EndBattleDamageSourceComponentMcrs
// 0x0120 (0x0580 - 0x0460)
class UEndBattleDamageSourceComponentMcrs final : public UEndBattleDamageSourceComponent
{
public:
	uint8                                         Pad_460[0x120];                                    // 0x0460(0x0120)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleDamageSourceComponentMcrs">();
	}
	static class UEndBattleDamageSourceComponentMcrs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleDamageSourceComponentMcrs>();
	}
};
static_assert(alignof(UEndBattleDamageSourceComponentMcrs) == 0x000008, "Wrong alignment on UEndBattleDamageSourceComponentMcrs");
static_assert(sizeof(UEndBattleDamageSourceComponentMcrs) == 0x000580, "Wrong size on UEndBattleDamageSourceComponentMcrs");

// Class EndGame.VfxDistributionFloatNonUniform
// 0x0010 (0x0070 - 0x0060)
class UVfxDistributionFloatNonUniform final : public UDistributionFloatUniform
{
public:
	struct FVfxNonUniformRandom                   m_NonUniformRandom;                                // 0x0060(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VfxDistributionFloatNonUniform">();
	}
	static class UVfxDistributionFloatNonUniform* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVfxDistributionFloatNonUniform>();
	}
};
static_assert(alignof(UVfxDistributionFloatNonUniform) == 0x000008, "Wrong alignment on UVfxDistributionFloatNonUniform");
static_assert(sizeof(UVfxDistributionFloatNonUniform) == 0x000070, "Wrong size on UVfxDistributionFloatNonUniform");
static_assert(offsetof(UVfxDistributionFloatNonUniform, m_NonUniformRandom) == 0x000060, "Member 'UVfxDistributionFloatNonUniform::m_NonUniformRandom' has a wrong offset!");

// Class EndGame.EndBTDecorator_Field_CheckFollowPositionState
// 0x0010 (0x0078 - 0x0068)
class UEndBTDecorator_Field_CheckFollowPositionState final : public UEndBTDecorator_CheckConditionBase
{
public:
	TArray<EEndFieldAIFollowPositionState>        m_StateTypes;                                      // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_Field_CheckFollowPositionState">();
	}
	static class UEndBTDecorator_Field_CheckFollowPositionState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_Field_CheckFollowPositionState>();
	}
};
static_assert(alignof(UEndBTDecorator_Field_CheckFollowPositionState) == 0x000008, "Wrong alignment on UEndBTDecorator_Field_CheckFollowPositionState");
static_assert(sizeof(UEndBTDecorator_Field_CheckFollowPositionState) == 0x000078, "Wrong size on UEndBTDecorator_Field_CheckFollowPositionState");
static_assert(offsetof(UEndBTDecorator_Field_CheckFollowPositionState, m_StateTypes) == 0x000068, "Member 'UEndBTDecorator_Field_CheckFollowPositionState::m_StateTypes' has a wrong offset!");

// Class EndGame.EndBattleDamageSourceComponentStay
// 0x0000 (0x0460 - 0x0460)
class UEndBattleDamageSourceComponentStay final : public UEndBattleDamageSourceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleDamageSourceComponentStay">();
	}
	static class UEndBattleDamageSourceComponentStay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleDamageSourceComponentStay>();
	}
};
static_assert(alignof(UEndBattleDamageSourceComponentStay) == 0x000008, "Wrong alignment on UEndBattleDamageSourceComponentStay");
static_assert(sizeof(UEndBattleDamageSourceComponentStay) == 0x000460, "Wrong size on UEndBattleDamageSourceComponentStay");

// Class EndGame.EndBattleDamageSourceComponentThrow
// 0x0010 (0x0470 - 0x0460)
class UEndBattleDamageSourceComponentThrow final : public UEndBattleDamageSourceComponent
{
public:
	uint8                                         Pad_460[0x10];                                     // 0x0460(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleDamageSourceComponentThrow">();
	}
	static class UEndBattleDamageSourceComponentThrow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleDamageSourceComponentThrow>();
	}
};
static_assert(alignof(UEndBattleDamageSourceComponentThrow) == 0x000008, "Wrong alignment on UEndBattleDamageSourceComponentThrow");
static_assert(sizeof(UEndBattleDamageSourceComponentThrow) == 0x000470, "Wrong size on UEndBattleDamageSourceComponentThrow");

// Class EndGame.EndFieldActionActorDuctMove
// 0x0028 (0x0640 - 0x0618)
class AEndFieldActionActorDuctMove final : public AEndFieldActionActorBase
{
public:
	class UEndFieldActionTriggerComponent*        EnterVolume;                                       // 0x0618(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndDuctActionSplineComponent*          DuctMoveSplineComponent;                           // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NoPassageTriggerToPlayer;                          // 0x0628(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NoPassageTriggerToParty;                           // 0x0630(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_638[0x8];                                      // 0x0638(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorDuctMove">();
	}
	static class AEndFieldActionActorDuctMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorDuctMove>();
	}
};
static_assert(alignof(AEndFieldActionActorDuctMove) == 0x000008, "Wrong alignment on AEndFieldActionActorDuctMove");
static_assert(sizeof(AEndFieldActionActorDuctMove) == 0x000640, "Wrong size on AEndFieldActionActorDuctMove");
static_assert(offsetof(AEndFieldActionActorDuctMove, EnterVolume) == 0x000618, "Member 'AEndFieldActionActorDuctMove::EnterVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorDuctMove, DuctMoveSplineComponent) == 0x000620, "Member 'AEndFieldActionActorDuctMove::DuctMoveSplineComponent' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorDuctMove, NoPassageTriggerToPlayer) == 0x000628, "Member 'AEndFieldActionActorDuctMove::NoPassageTriggerToPlayer' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorDuctMove, NoPassageTriggerToParty) == 0x000630, "Member 'AEndFieldActionActorDuctMove::NoPassageTriggerToParty' has a wrong offset!");

// Class EndGame.EndBattleEnvironmentResetConditionNotify
// 0x0008 (0x0040 - 0x0038)
class UEndBattleEnvironmentResetConditionNotify final : public UAnimNotify
{
public:
	bool                                          HP;                                                // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleEnvironmentResetConditionNotify">();
	}
	static class UEndBattleEnvironmentResetConditionNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleEnvironmentResetConditionNotify>();
	}
};
static_assert(alignof(UEndBattleEnvironmentResetConditionNotify) == 0x000008, "Wrong alignment on UEndBattleEnvironmentResetConditionNotify");
static_assert(sizeof(UEndBattleEnvironmentResetConditionNotify) == 0x000040, "Wrong size on UEndBattleEnvironmentResetConditionNotify");
static_assert(offsetof(UEndBattleEnvironmentResetConditionNotify, HP) == 0x000038, "Member 'UEndBattleEnvironmentResetConditionNotify::HP' has a wrong offset!");

// Class EndGame.EndBattleHiddenCharacterNotify
// 0x0008 (0x0040 - 0x0038)
class UEndBattleHiddenCharacterNotify final : public UAnimNotify
{
public:
	bool                                          hidden;                                            // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleHiddenCharacterNotify">();
	}
	static class UEndBattleHiddenCharacterNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleHiddenCharacterNotify>();
	}
};
static_assert(alignof(UEndBattleHiddenCharacterNotify) == 0x000008, "Wrong alignment on UEndBattleHiddenCharacterNotify");
static_assert(sizeof(UEndBattleHiddenCharacterNotify) == 0x000040, "Wrong size on UEndBattleHiddenCharacterNotify");
static_assert(offsetof(UEndBattleHiddenCharacterNotify, hidden) == 0x000038, "Member 'UEndBattleHiddenCharacterNotify::hidden' has a wrong offset!");

// Class EndGame.EndCharacterPushCollisionComponent
// 0x0068 (0x0160 - 0x00F8)
class UEndCharacterPushCollisionComponent final : public UActorComponent
{
public:
	struct FEndCharacterPushCollisionData         CoreCollisionData;                                 // 0x00F8(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          EnableCoreCollisionPush;                           // 0x0120(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          EnableWallCollisionData;                           // 0x0121(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_122[0x2];                                      // 0x0122(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEndCharacterPushCollisionData         WallCollisionData;                                 // 0x0124(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEndCharacterPushCollisionData> SubCollisionDataList;                              // 0x0150(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCharacterPushCollisionComponent">();
	}
	static class UEndCharacterPushCollisionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndCharacterPushCollisionComponent>();
	}
};
static_assert(alignof(UEndCharacterPushCollisionComponent) == 0x000008, "Wrong alignment on UEndCharacterPushCollisionComponent");
static_assert(sizeof(UEndCharacterPushCollisionComponent) == 0x000160, "Wrong size on UEndCharacterPushCollisionComponent");
static_assert(offsetof(UEndCharacterPushCollisionComponent, CoreCollisionData) == 0x0000F8, "Member 'UEndCharacterPushCollisionComponent::CoreCollisionData' has a wrong offset!");
static_assert(offsetof(UEndCharacterPushCollisionComponent, EnableCoreCollisionPush) == 0x000120, "Member 'UEndCharacterPushCollisionComponent::EnableCoreCollisionPush' has a wrong offset!");
static_assert(offsetof(UEndCharacterPushCollisionComponent, EnableWallCollisionData) == 0x000121, "Member 'UEndCharacterPushCollisionComponent::EnableWallCollisionData' has a wrong offset!");
static_assert(offsetof(UEndCharacterPushCollisionComponent, WallCollisionData) == 0x000124, "Member 'UEndCharacterPushCollisionComponent::WallCollisionData' has a wrong offset!");
static_assert(offsetof(UEndCharacterPushCollisionComponent, SubCollisionDataList) == 0x000150, "Member 'UEndCharacterPushCollisionComponent::SubCollisionDataList' has a wrong offset!");

// Class EndGame.EndBattleLinkageIcon
// 0x0050 (0x03B0 - 0x0360)
class UEndBattleLinkageIcon : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x1];                                      // 0x0360(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _SetBurstSpace;                                    // 0x0361(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _SetBurstComma;                                    // 0x0362(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_363[0x4D];                                     // 0x0363(0x004D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleLinkageIcon">();
	}
	static class UEndBattleLinkageIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleLinkageIcon>();
	}
};
static_assert(alignof(UEndBattleLinkageIcon) == 0x000008, "Wrong alignment on UEndBattleLinkageIcon");
static_assert(sizeof(UEndBattleLinkageIcon) == 0x0003B0, "Wrong size on UEndBattleLinkageIcon");
static_assert(offsetof(UEndBattleLinkageIcon, _SetBurstSpace) == 0x000361, "Member 'UEndBattleLinkageIcon::_SetBurstSpace' has a wrong offset!");
static_assert(offsetof(UEndBattleLinkageIcon, _SetBurstComma) == 0x000362, "Member 'UEndBattleLinkageIcon::_SetBurstComma' has a wrong offset!");

// Class EndGame.EndCharacterWithDrawPauseHierarchically
// 0x0000 (0x22C0 - 0x22C0)
class AEndCharacterWithDrawPauseHierarchically final : public AEndCharacter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCharacterWithDrawPauseHierarchically">();
	}
	static class AEndCharacterWithDrawPauseHierarchically* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndCharacterWithDrawPauseHierarchically>();
	}
};
static_assert(alignof(AEndCharacterWithDrawPauseHierarchically) == 0x000010, "Wrong alignment on AEndCharacterWithDrawPauseHierarchically");
static_assert(sizeof(AEndCharacterWithDrawPauseHierarchically) == 0x0022C0, "Wrong size on AEndCharacterWithDrawPauseHierarchically");

// Class EndGame.EndBTDecorator_IsExecuteLinkAbilityNearExecutor
// 0x0000 (0x0068 - 0x0068)
class UEndBTDecorator_IsExecuteLinkAbilityNearExecutor final : public UEndBTDecorator_CheckConditionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_IsExecuteLinkAbilityNearExecutor">();
	}
	static class UEndBTDecorator_IsExecuteLinkAbilityNearExecutor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_IsExecuteLinkAbilityNearExecutor>();
	}
};
static_assert(alignof(UEndBTDecorator_IsExecuteLinkAbilityNearExecutor) == 0x000008, "Wrong alignment on UEndBTDecorator_IsExecuteLinkAbilityNearExecutor");
static_assert(sizeof(UEndBTDecorator_IsExecuteLinkAbilityNearExecutor) == 0x000068, "Wrong size on UEndBTDecorator_IsExecuteLinkAbilityNearExecutor");

// Class EndGame.EndBattleMenu
// 0x0120 (0x0480 - 0x0360)
class UEndBattleMenu final : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x120];                                    // 0x0360(0x0120)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCommandCellSetup(class UWidget* ItemWidget, int32 ItemIndex);
	void OnPressedItem(int32 ItemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleMenu">();
	}
	static class UEndBattleMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleMenu>();
	}
};
static_assert(alignof(UEndBattleMenu) == 0x000008, "Wrong alignment on UEndBattleMenu");
static_assert(sizeof(UEndBattleMenu) == 0x000480, "Wrong size on UEndBattleMenu");

// Class EndGame.EndBattleNormalizeAxisState
// 0x0000 (0x0030 - 0x0030)
class UEndBattleNormalizeAxisState final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleNormalizeAxisState">();
	}
	static class UEndBattleNormalizeAxisState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleNormalizeAxisState>();
	}
};
static_assert(alignof(UEndBattleNormalizeAxisState) == 0x000008, "Wrong alignment on UEndBattleNormalizeAxisState");
static_assert(sizeof(UEndBattleNormalizeAxisState) == 0x000030, "Wrong size on UEndBattleNormalizeAxisState");

// Class EndGame.EndCircle
// 0x0100 (0x01F8 - 0x00F8)
class UEndCircle final : public UWidget
{
public:
	struct FSlateBrush                            Brush;                                             // 0x00F8(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TDelegate<void()>                             BrushDelegate;                                     // 0x0170(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorAndOpacity;                                   // 0x0180(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ColorAndOpacityDelegate;                           // 0x0190(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	EBlendMode                                    BlendMode;                                         // 0x01A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x3];                                      // 0x01A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Radius;                                            // 0x01A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             RadiusDelegate;                                    // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         NumSides;                                          // 0x01B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartAngle;                                        // 0x01BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             StartAngleDelegate;                                // 0x01C0(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	float                                         EndAngle;                                          // 0x01D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D4[0x4];                                      // 0x01D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             EndAngleDelegate;                                  // 0x01D8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E8[0x10];                                     // 0x01E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMaterialInstanceDynamic* GetDynamicMaterial();
	void SetBlendMode(EBlendMode InBlendMode);
	void SetBrush(const struct FSlateBrush& InBrush);
	void SetBrushFromAsset(class USlateBrushAsset* Asset);
	void SetBrushFromMaterial(class UMaterialInterface* Material);
	void SetBrushFromTexture(class UTexture2D* Texture, bool bMatchSize);
	void SetBrushFromTextureDynamic(class UTexture2DDynamic* Texture, bool bMatchSize);
	void SetColorAndOpacity(const struct FLinearColor& InColorAndOpacity);
	void SetEndAngle(float InAngle);
	void SetNumSides(int32 InNumSides);
	void SetOpacity(float InOpacity);
	void SetRadius(float InRadius);
	void SetStartAngle(float InAngle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCircle">();
	}
	static class UEndCircle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndCircle>();
	}
};
static_assert(alignof(UEndCircle) == 0x000008, "Wrong alignment on UEndCircle");
static_assert(sizeof(UEndCircle) == 0x0001F8, "Wrong size on UEndCircle");
static_assert(offsetof(UEndCircle, Brush) == 0x0000F8, "Member 'UEndCircle::Brush' has a wrong offset!");
static_assert(offsetof(UEndCircle, BrushDelegate) == 0x000170, "Member 'UEndCircle::BrushDelegate' has a wrong offset!");
static_assert(offsetof(UEndCircle, ColorAndOpacity) == 0x000180, "Member 'UEndCircle::ColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UEndCircle, ColorAndOpacityDelegate) == 0x000190, "Member 'UEndCircle::ColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UEndCircle, BlendMode) == 0x0001A0, "Member 'UEndCircle::BlendMode' has a wrong offset!");
static_assert(offsetof(UEndCircle, Radius) == 0x0001A4, "Member 'UEndCircle::Radius' has a wrong offset!");
static_assert(offsetof(UEndCircle, RadiusDelegate) == 0x0001A8, "Member 'UEndCircle::RadiusDelegate' has a wrong offset!");
static_assert(offsetof(UEndCircle, NumSides) == 0x0001B8, "Member 'UEndCircle::NumSides' has a wrong offset!");
static_assert(offsetof(UEndCircle, StartAngle) == 0x0001BC, "Member 'UEndCircle::StartAngle' has a wrong offset!");
static_assert(offsetof(UEndCircle, StartAngleDelegate) == 0x0001C0, "Member 'UEndCircle::StartAngleDelegate' has a wrong offset!");
static_assert(offsetof(UEndCircle, EndAngle) == 0x0001D0, "Member 'UEndCircle::EndAngle' has a wrong offset!");
static_assert(offsetof(UEndCircle, EndAngleDelegate) == 0x0001D8, "Member 'UEndCircle::EndAngleDelegate' has a wrong offset!");

// Class EndGame.EndStartMenu
// 0x0250 (0x05B0 - 0x0360)
class UEndStartMenu : public UEndUserWidget
{
public:
	TSubclassOf<class UEndUserWidget>             LoadMenuWidgetClass;                               // 0x0360(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEndUserWidget>             OptionsMenuWidgetClass;                            // 0x0368(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEndUserWidget>             DlcWindowWidgetClass;                              // 0x0370(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEndUserWidget>             MembershipWindowWidgetClass;                       // 0x0378(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateSound                            NewGameSound;                                      // 0x0380(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ButtonAnimationStartTime;                          // 0x0398(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ButtonAnimationDelay;                              // 0x039C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A0[0xA8];                                     // 0x03A0(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndUserWidget*                         Throbber;                                          // 0x0448(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndUserWidget*                         CachedLoadMenu;                                    // 0x0450(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndMainMenu*                           MainMenu;                                          // 0x0458(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndNewOptionsMenu*                     OptionsMenu;                                       // 0x0460(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_468[0x148];                                    // 0x0468(0x0148)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnListMenuPressedItem(int32 ItemIndex);
	void OnListMenuSelectedIndexChanged(int32 ItemIndex);
	void OnListMenuSetupItem(class UWidget* ItemWidget, int32 ItemIndex);
	void OnLoadGame();
	void OnLoadLatest();
	void OnMembershipUpdate();
	void OnNewGame();
	void OnOptions();
	void OnQuitGame();
	void OnSaveDataCancelled();
	void OnSaveDataClicked(class UUserWidget* Cell);
	void OnSaveDataPressedItem(int32 ItemIndex);
	void OnSaveDataSelectedIndexChanged(int32 ItemIndex);
	void OnSaveDataSetupItem(class UWidget* ItemWidget, int32 ItemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndStartMenu">();
	}
	static class UEndStartMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndStartMenu>();
	}
};
static_assert(alignof(UEndStartMenu) == 0x000008, "Wrong alignment on UEndStartMenu");
static_assert(sizeof(UEndStartMenu) == 0x0005B0, "Wrong size on UEndStartMenu");
static_assert(offsetof(UEndStartMenu, LoadMenuWidgetClass) == 0x000360, "Member 'UEndStartMenu::LoadMenuWidgetClass' has a wrong offset!");
static_assert(offsetof(UEndStartMenu, OptionsMenuWidgetClass) == 0x000368, "Member 'UEndStartMenu::OptionsMenuWidgetClass' has a wrong offset!");
static_assert(offsetof(UEndStartMenu, DlcWindowWidgetClass) == 0x000370, "Member 'UEndStartMenu::DlcWindowWidgetClass' has a wrong offset!");
static_assert(offsetof(UEndStartMenu, MembershipWindowWidgetClass) == 0x000378, "Member 'UEndStartMenu::MembershipWindowWidgetClass' has a wrong offset!");
static_assert(offsetof(UEndStartMenu, NewGameSound) == 0x000380, "Member 'UEndStartMenu::NewGameSound' has a wrong offset!");
static_assert(offsetof(UEndStartMenu, ButtonAnimationStartTime) == 0x000398, "Member 'UEndStartMenu::ButtonAnimationStartTime' has a wrong offset!");
static_assert(offsetof(UEndStartMenu, ButtonAnimationDelay) == 0x00039C, "Member 'UEndStartMenu::ButtonAnimationDelay' has a wrong offset!");
static_assert(offsetof(UEndStartMenu, Throbber) == 0x000448, "Member 'UEndStartMenu::Throbber' has a wrong offset!");
static_assert(offsetof(UEndStartMenu, CachedLoadMenu) == 0x000450, "Member 'UEndStartMenu::CachedLoadMenu' has a wrong offset!");
static_assert(offsetof(UEndStartMenu, MainMenu) == 0x000458, "Member 'UEndStartMenu::MainMenu' has a wrong offset!");
static_assert(offsetof(UEndStartMenu, OptionsMenu) == 0x000460, "Member 'UEndStartMenu::OptionsMenu' has a wrong offset!");

// Class EndGame.EndBTDecorator_SetBattleParam
// 0x0000 (0x0068 - 0x0068)
class UEndBTDecorator_SetBattleParam final : public UBTDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_SetBattleParam">();
	}
	static class UEndBTDecorator_SetBattleParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_SetBattleParam>();
	}
};
static_assert(alignof(UEndBTDecorator_SetBattleParam) == 0x000008, "Wrong alignment on UEndBTDecorator_SetBattleParam");
static_assert(sizeof(UEndBTDecorator_SetBattleParam) == 0x000068, "Wrong size on UEndBTDecorator_SetBattleParam");

// Class EndGame.EndBTTask_AIPCSearchSafeLocation
// 0x0028 (0x0098 - 0x0070)
class UEndBTTask_AIPCSearchSafeLocation final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 SafeLocationBlackboardKey;                         // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_AIPCSearchSafeLocation">();
	}
	static class UEndBTTask_AIPCSearchSafeLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_AIPCSearchSafeLocation>();
	}
};
static_assert(alignof(UEndBTTask_AIPCSearchSafeLocation) == 0x000008, "Wrong alignment on UEndBTTask_AIPCSearchSafeLocation");
static_assert(sizeof(UEndBTTask_AIPCSearchSafeLocation) == 0x000098, "Wrong size on UEndBTTask_AIPCSearchSafeLocation");
static_assert(offsetof(UEndBTTask_AIPCSearchSafeLocation, SafeLocationBlackboardKey) == 0x000070, "Member 'UEndBTTask_AIPCSearchSafeLocation::SafeLocationBlackboardKey' has a wrong offset!");

// Class EndGame.EndBattleScene_btsc_mako1_110
// 0x00B0 (0x0458 - 0x03A8)
class AEndBattleScene_btsc_mako1_110 final : public AEndBattleSceneBlueprint
{
public:
	class FName                                   GuardScorpionActorName;                            // 0x03A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B0[0xA8];                                     // 0x03B0(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAddMagicThunderHitCountForBarrierGS(class FName CauserCharaName, int32 Count);
	void OnAddNormalAttackHitCountForBarrierGS(class FName CauserCharaName, int32 Count);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleScene_btsc_mako1_110">();
	}
	static class AEndBattleScene_btsc_mako1_110* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleScene_btsc_mako1_110>();
	}
};
static_assert(alignof(AEndBattleScene_btsc_mako1_110) == 0x000008, "Wrong alignment on AEndBattleScene_btsc_mako1_110");
static_assert(sizeof(AEndBattleScene_btsc_mako1_110) == 0x000458, "Wrong size on AEndBattleScene_btsc_mako1_110");
static_assert(offsetof(AEndBattleScene_btsc_mako1_110, GuardScorpionActorName) == 0x0003A8, "Member 'AEndBattleScene_btsc_mako1_110::GuardScorpionActorName' has a wrong offset!");

// Class EndGame.EndDataObjectBikeBattleCutSceneCharacter
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBikeBattleCutSceneCharacter final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBikeBattleCutSceneCharacter">();
	}
	static class UEndDataObjectBikeBattleCutSceneCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBikeBattleCutSceneCharacter>();
	}
};
static_assert(alignof(UEndDataObjectBikeBattleCutSceneCharacter) == 0x000008, "Wrong alignment on UEndDataObjectBikeBattleCutSceneCharacter");
static_assert(sizeof(UEndDataObjectBikeBattleCutSceneCharacter) == 0x000088, "Wrong size on UEndDataObjectBikeBattleCutSceneCharacter");

// Class EndGame.EndFieldActionActorSliding
// 0x0068 (0x0680 - 0x0618)
class AEndFieldActionActorSliding final : public AEndFieldActionActorBase
{
public:
	class UEndFieldActionSplineComponent*         SlidingComponent;                                  // 0x0618(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        EnterVolume;                                       // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        ExitVolume;                                        // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeWidth;                                       // 0x0630(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraFOV;                                         // 0x0634(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CameraLookAtName;                                  // 0x0638(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0640(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_648[0x38];                                     // 0x0648(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorSliding">();
	}
	static class AEndFieldActionActorSliding* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorSliding>();
	}
};
static_assert(alignof(AEndFieldActionActorSliding) == 0x000008, "Wrong alignment on AEndFieldActionActorSliding");
static_assert(sizeof(AEndFieldActionActorSliding) == 0x000680, "Wrong size on AEndFieldActionActorSliding");
static_assert(offsetof(AEndFieldActionActorSliding, SlidingComponent) == 0x000618, "Member 'AEndFieldActionActorSliding::SlidingComponent' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorSliding, EnterVolume) == 0x000620, "Member 'AEndFieldActionActorSliding::EnterVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorSliding, ExitVolume) == 0x000628, "Member 'AEndFieldActionActorSliding::ExitVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorSliding, VolumeWidth) == 0x000630, "Member 'AEndFieldActionActorSliding::VolumeWidth' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorSliding, CameraFOV) == 0x000634, "Member 'AEndFieldActionActorSliding::CameraFOV' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorSliding, CameraLookAtName) == 0x000638, "Member 'AEndFieldActionActorSliding::CameraLookAtName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorSliding, ModifierVolume) == 0x000640, "Member 'AEndFieldActionActorSliding::ModifierVolume' has a wrong offset!");

// Class EndGame.EndBTService_RunEQSWithResult
// 0x00B8 (0x0150 - 0x0098)
class UEndBTService_RunEQSWithResult final : public UBTService_BlackboardBase
{
public:
	struct FEQSParametrizedQueryExecutionRequest  EQSRequest;                                        // 0x0098(0x0048)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 QueryResultBlackboardKey;                          // 0x00E0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_108[0x48];                                     // 0x0108(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTService_RunEQSWithResult">();
	}
	static class UEndBTService_RunEQSWithResult* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTService_RunEQSWithResult>();
	}
};
static_assert(alignof(UEndBTService_RunEQSWithResult) == 0x000008, "Wrong alignment on UEndBTService_RunEQSWithResult");
static_assert(sizeof(UEndBTService_RunEQSWithResult) == 0x000150, "Wrong size on UEndBTService_RunEQSWithResult");
static_assert(offsetof(UEndBTService_RunEQSWithResult, EQSRequest) == 0x000098, "Member 'UEndBTService_RunEQSWithResult::EQSRequest' has a wrong offset!");
static_assert(offsetof(UEndBTService_RunEQSWithResult, QueryResultBlackboardKey) == 0x0000E0, "Member 'UEndBTService_RunEQSWithResult::QueryResultBlackboardKey' has a wrong offset!");

// Class EndGame.EndBattleScene_btsc_mako5_010
// 0x0008 (0x03B0 - 0x03A8)
class AEndBattleScene_btsc_mako5_010 final : public AEndBattleSceneBlueprint
{
public:
	class FName                                   airBusterActorName_;                               // 0x03A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleScene_btsc_mako5_010">();
	}
	static class AEndBattleScene_btsc_mako5_010* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleScene_btsc_mako5_010>();
	}
};
static_assert(alignof(AEndBattleScene_btsc_mako5_010) == 0x000008, "Wrong alignment on AEndBattleScene_btsc_mako5_010");
static_assert(sizeof(AEndBattleScene_btsc_mako5_010) == 0x0003B0, "Wrong size on AEndBattleScene_btsc_mako5_010");
static_assert(offsetof(AEndBattleScene_btsc_mako5_010, airBusterActorName_) == 0x0003A8, "Member 'AEndBattleScene_btsc_mako5_010::airBusterActorName_' has a wrong offset!");

// Class EndGame.EndNavAreaBattle
// 0x0000 (0x0040 - 0x0040)
class UEndNavAreaBattle final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavAreaBattle">();
	}
	static class UEndNavAreaBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavAreaBattle>();
	}
};
static_assert(alignof(UEndNavAreaBattle) == 0x000008, "Wrong alignment on UEndNavAreaBattle");
static_assert(sizeof(UEndNavAreaBattle) == 0x000040, "Wrong size on UEndNavAreaBattle");

// Class EndGame.EndBTTask_CarbuncleRubyHeal
// 0x0078 (0x00E8 - 0x0070)
class UEndBTTask_CarbuncleRubyHeal final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 FromBlackboardKey_AbilityExecuteState;             // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 FromBlackboardKey_InWarp;                          // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)
	class FName                                   AbilityID;                                         // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           BounusAbilityID;                                   // 0x00C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         BonusAbilityRate;                                  // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BonusAbilityInterval;                              // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_CarbuncleRubyHeal">();
	}
	static class UEndBTTask_CarbuncleRubyHeal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_CarbuncleRubyHeal>();
	}
};
static_assert(alignof(UEndBTTask_CarbuncleRubyHeal) == 0x000008, "Wrong alignment on UEndBTTask_CarbuncleRubyHeal");
static_assert(sizeof(UEndBTTask_CarbuncleRubyHeal) == 0x0000E8, "Wrong size on UEndBTTask_CarbuncleRubyHeal");
static_assert(offsetof(UEndBTTask_CarbuncleRubyHeal, FromBlackboardKey_AbilityExecuteState) == 0x000070, "Member 'UEndBTTask_CarbuncleRubyHeal::FromBlackboardKey_AbilityExecuteState' has a wrong offset!");
static_assert(offsetof(UEndBTTask_CarbuncleRubyHeal, FromBlackboardKey_InWarp) == 0x000098, "Member 'UEndBTTask_CarbuncleRubyHeal::FromBlackboardKey_InWarp' has a wrong offset!");
static_assert(offsetof(UEndBTTask_CarbuncleRubyHeal, AbilityID) == 0x0000C0, "Member 'UEndBTTask_CarbuncleRubyHeal::AbilityID' has a wrong offset!");
static_assert(offsetof(UEndBTTask_CarbuncleRubyHeal, BounusAbilityID) == 0x0000C8, "Member 'UEndBTTask_CarbuncleRubyHeal::BounusAbilityID' has a wrong offset!");
static_assert(offsetof(UEndBTTask_CarbuncleRubyHeal, BonusAbilityRate) == 0x0000D8, "Member 'UEndBTTask_CarbuncleRubyHeal::BonusAbilityRate' has a wrong offset!");
static_assert(offsetof(UEndBTTask_CarbuncleRubyHeal, BonusAbilityInterval) == 0x0000DC, "Member 'UEndBTTask_CarbuncleRubyHeal::BonusAbilityInterval' has a wrong offset!");

// Class EndGame.EndBattleScene_btsc_sbil0_90_boss020
// 0x0000 (0x03A8 - 0x03A8)
class AEndBattleScene_btsc_sbil0_90_boss020 final : public AEndBattleSceneBlueprint
{
public:
	static void EndSetPlay();
	static bool IsReadySetPlay();
	static void KeepRelativePositionWarp(class AEndCharacter* BaseCharacter, const struct FVector& BaseLocation, const struct FRotator& BaseRotation, const TArray<class AEndCharacter*>& Characters);
	static void LockSetPlayHeight(float Height);
	static void ResetForceLookAt(class AEndCharacter* Character);
	static void SetBattleAbilityRotateStateLocation(class AEndCharacter* Character, const struct FVector& Location);
	static void SetBattleAbilityRotateStatePointName(class AEndCharacter* Character, class FName RotatePointName);
	static void SetForceLookAt(class AEndCharacter* Character, class AEndCharacter* TargetCharacter);
	static void SetOverrideAerialAttackFallSequence(class AEndCharacter* Character, class FName FallSequeceName, class FName LandSequenceName, class FName MotionOwnerCharaSpecId);
	static void StartSetPlay(const TArray<class AEndCharacter*>& Characters);
	static void StartSetPlayWithErrorCheck(const TArray<class AEndCharacter*>& Characters, ESetPlayStartSetPlay* OutSignal);
	static void SuspendAll(class AEndCharacter* Character);
	static void UnlockSetPlayHeight();

	void AerialAttackJump(class FName StartMotionName, class FName LoopMotionName, class FName NextAbilityID, class AEndCharacter* Executor, class AEndCharacter* Target, float JumpTime, float Timeout, class FName MotionOwnerCharaSpecId, const struct FLatentActionInfo& LatentInfo, ESetPlayAerialAttackJump* OutSignal);
	void FallAction(class AEndCharacter* Character, float GravityScale, class FName FallSequenceName, class FName LandSequenceName, class FName MotionOwnerCharaSpecId, const struct FLatentActionInfo& LatentInfo, ESetPlayFallAction* OutSignal);
	void ForceChangeIdleAction(class AEndCharacter* Character, const struct FLatentActionInfo& LatentInfo, ESetPlayForceChangeIdleAction* OutSignal);
	void GraviticJump(class AEndCharacter* Character, const struct FVector& landingLocation, float Height, float PeakBias, float turningDuration, const struct FVector& LandingForward, class FName BeginSequenceName, class FName LoopSequenceName, class FName EndSequenceName, class FName MotionOwnerCharaSpecId, const struct FLatentActionInfo& LatentInfo, ESetPlayGraviticJump* OutSignal);
	void JumpTo(class AEndCharacter* Character, const struct FVector& TargetLocation, const struct FRotator& TargetRotation, float Duration, class FName StartMotionName, class FName LoopMotionName, class FName OnCompleteMotionName, class FName MotionOwnerCharaSpecId, const struct FLatentActionInfo& LatentInfo, ESetPlayJumpTo* OutSignal);
	void RequestUseAbility(class FName AbilityID, class AEndCharacter* Executor, class AEndCharacter* Target, float Timeout, bool ImmediatelyUseAerial, const struct FLatentActionInfo& LatentInfo, ESetPlayUseAbility* OutSignal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleScene_btsc_sbil0_90_boss020">();
	}
	static class AEndBattleScene_btsc_sbil0_90_boss020* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleScene_btsc_sbil0_90_boss020>();
	}
};
static_assert(alignof(AEndBattleScene_btsc_sbil0_90_boss020) == 0x000008, "Wrong alignment on AEndBattleScene_btsc_sbil0_90_boss020");
static_assert(sizeof(AEndBattleScene_btsc_sbil0_90_boss020) == 0x0003A8, "Wrong size on AEndBattleScene_btsc_sbil0_90_boss020");

// Class EndGame.EndBattleScene_btsc_slu5b_010
// 0x0070 (0x0418 - 0x03A8)
class AEndBattleScene_btsc_slu5b_010 final : public AEndBattleSceneBlueprint
{
public:
	uint8                                         Pad_3A8[0x60];                                     // 0x03A8(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AEndBattleAISlu5bAerithController> GuestAerithBattleAIClass;                          // 0x0408(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AEndBattleAISlu5bAerithController*      AerithAIController;                                // 0x0410(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ConfirmSpark(class AActor* mineActor, int32 sparkID);
	void ReleaseSpark(class AActor* mineActor, int32 sparkID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleScene_btsc_slu5b_010">();
	}
	static class AEndBattleScene_btsc_slu5b_010* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleScene_btsc_slu5b_010>();
	}
};
static_assert(alignof(AEndBattleScene_btsc_slu5b_010) == 0x000008, "Wrong alignment on AEndBattleScene_btsc_slu5b_010");
static_assert(sizeof(AEndBattleScene_btsc_slu5b_010) == 0x000418, "Wrong size on AEndBattleScene_btsc_slu5b_010");
static_assert(offsetof(AEndBattleScene_btsc_slu5b_010, GuestAerithBattleAIClass) == 0x000408, "Member 'AEndBattleScene_btsc_slu5b_010::GuestAerithBattleAIClass' has a wrong offset!");
static_assert(offsetof(AEndBattleScene_btsc_slu5b_010, AerithAIController) == 0x000410, "Member 'AEndBattleScene_btsc_slu5b_010::AerithAIController' has a wrong offset!");

// Class EndGame.EndDataObjectBikeDamageReaction
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBikeDamageReaction final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBikeDamageReaction">();
	}
	static class UEndDataObjectBikeDamageReaction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBikeDamageReaction>();
	}
};
static_assert(alignof(UEndDataObjectBikeDamageReaction) == 0x000008, "Wrong alignment on UEndDataObjectBikeDamageReaction");
static_assert(sizeof(UEndDataObjectBikeDamageReaction) == 0x000088, "Wrong size on UEndDataObjectBikeDamageReaction");

// Class EndGame.EndNavAPI
// 0x0000 (0x0028 - 0x0028)
class UEndNavAPI final : public UObject
{
public:
	static bool FindNearestNavMeshPoint(const struct FVector& TargetLocation, struct FVector* OutLocation, class FName InModifierName, const struct FVector& SearchRange, EEndQueryFilterType FilterType);
	static bool FindNearestNavMeshPointAgent(const struct FVector& TargetLocation, struct FVector* OutLocation, class FName InModifierName, const struct FNavAgentProperties& InAgentProperty, const struct FVector& SearchRange, EEndQueryFilterType FilterType);
	static struct FNavAgentProperties GetAgentPropety(EEndNavLayerType InLayerType);
	static struct FTransform GetNavModifierTransform(const class FName Name_0);
	static bool InvalidateAerialIgnoreVolume(const class FName ActorName);
	static bool InvalidateBlockingModifierVolume(const class FName LevelName, const class FName ActorName);
	static bool InvalidateFieldActionModifierVolume(const class FName ActorName);
	static bool InvalidateNavModifierVolume(const class FName ActorName);
	static bool ValidateAerialIgnoreVolume(const class FName ActorName);
	static bool ValidateBlockingModifierVolume(const class FName LevelName, const class FName ActorName);
	static bool ValidateFieldActionModifierVolume(const class FName ActorName);
	static bool ValidateNavModifierVolume(const class FName ActorName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavAPI">();
	}
	static class UEndNavAPI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavAPI>();
	}
};
static_assert(alignof(UEndNavAPI) == 0x000008, "Wrong alignment on UEndNavAPI");
static_assert(sizeof(UEndNavAPI) == 0x000028, "Wrong size on UEndNavAPI");

// Class EndGame.EndBattleScene_btsc_slum7_025
// 0x0008 (0x03B0 - 0x03A8)
class AEndBattleScene_btsc_slum7_025 final : public AEndBattleSceneBlueprint
{
public:
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleScene_btsc_slum7_025">();
	}
	static class AEndBattleScene_btsc_slum7_025* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleScene_btsc_slum7_025>();
	}
};
static_assert(alignof(AEndBattleScene_btsc_slum7_025) == 0x000008, "Wrong alignment on AEndBattleScene_btsc_slum7_025");
static_assert(sizeof(AEndBattleScene_btsc_slum7_025) == 0x0003B0, "Wrong size on AEndBattleScene_btsc_slum7_025");

// Class EndGame.EndBattleScene_btsc_tnnl4_305
// 0x0008 (0x03B0 - 0x03A8)
class AEndBattleScene_btsc_tnnl4_305 final : public AEndBattleSceneBlueprint
{
public:
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleScene_btsc_tnnl4_305">();
	}
	static class AEndBattleScene_btsc_tnnl4_305* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleScene_btsc_tnnl4_305>();
	}
};
static_assert(alignof(AEndBattleScene_btsc_tnnl4_305) == 0x000008, "Wrong alignment on AEndBattleScene_btsc_tnnl4_305");
static_assert(sizeof(AEndBattleScene_btsc_tnnl4_305) == 0x0003B0, "Wrong size on AEndBattleScene_btsc_tnnl4_305");

// Class EndGame.EndFieldActionActorShinraElevator
// 0x00D0 (0x06E8 - 0x0618)
class AEndFieldActionActorShinraElevator final : public AEndFieldActionActorBase
{
public:
	uint8                                         FloorIndex;                                        // 0x0618(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_619[0x3];                                      // 0x0619(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EnvElevatorActorName;                              // 0x061C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EnvDoorActorName;                                  // 0x0624(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MenuActionName;                                    // 0x062C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_634[0x4];                                      // 0x0634(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int8>                                  FloorIndexList;                                    // 0x0638(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class FName                                   HaveNotCardKeyTrigger;                             // 0x0648(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HaveCardKeyTrigger;                                // 0x0650(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartMovingTrigger;                                // 0x0658(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndMovingTrigger;                                  // 0x0660(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DoorOpenTrigger;                                   // 0x0668(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DoorCloseTrigger;                                  // 0x0670(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MenuOpenStartTrigger;                              // 0x0678(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        PressVolume;                                       // 0x0680(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        TargetIconOutSideVolume;                           // 0x0688(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        TargetIconInSideVolume;                            // 0x0690(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          Party01BoxComponent;                               // 0x0698(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          Party02BoxComponent;                               // 0x06A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x06A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B0[0x38];                                     // 0x06B0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorShinraElevator">();
	}
	static class AEndFieldActionActorShinraElevator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorShinraElevator>();
	}
};
static_assert(alignof(AEndFieldActionActorShinraElevator) == 0x000008, "Wrong alignment on AEndFieldActionActorShinraElevator");
static_assert(sizeof(AEndFieldActionActorShinraElevator) == 0x0006E8, "Wrong size on AEndFieldActionActorShinraElevator");
static_assert(offsetof(AEndFieldActionActorShinraElevator, FloorIndex) == 0x000618, "Member 'AEndFieldActionActorShinraElevator::FloorIndex' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorShinraElevator, EnvElevatorActorName) == 0x00061C, "Member 'AEndFieldActionActorShinraElevator::EnvElevatorActorName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorShinraElevator, EnvDoorActorName) == 0x000624, "Member 'AEndFieldActionActorShinraElevator::EnvDoorActorName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorShinraElevator, MenuActionName) == 0x00062C, "Member 'AEndFieldActionActorShinraElevator::MenuActionName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorShinraElevator, FloorIndexList) == 0x000638, "Member 'AEndFieldActionActorShinraElevator::FloorIndexList' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorShinraElevator, HaveNotCardKeyTrigger) == 0x000648, "Member 'AEndFieldActionActorShinraElevator::HaveNotCardKeyTrigger' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorShinraElevator, HaveCardKeyTrigger) == 0x000650, "Member 'AEndFieldActionActorShinraElevator::HaveCardKeyTrigger' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorShinraElevator, StartMovingTrigger) == 0x000658, "Member 'AEndFieldActionActorShinraElevator::StartMovingTrigger' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorShinraElevator, EndMovingTrigger) == 0x000660, "Member 'AEndFieldActionActorShinraElevator::EndMovingTrigger' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorShinraElevator, DoorOpenTrigger) == 0x000668, "Member 'AEndFieldActionActorShinraElevator::DoorOpenTrigger' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorShinraElevator, DoorCloseTrigger) == 0x000670, "Member 'AEndFieldActionActorShinraElevator::DoorCloseTrigger' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorShinraElevator, MenuOpenStartTrigger) == 0x000678, "Member 'AEndFieldActionActorShinraElevator::MenuOpenStartTrigger' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorShinraElevator, PressVolume) == 0x000680, "Member 'AEndFieldActionActorShinraElevator::PressVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorShinraElevator, TargetIconOutSideVolume) == 0x000688, "Member 'AEndFieldActionActorShinraElevator::TargetIconOutSideVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorShinraElevator, TargetIconInSideVolume) == 0x000690, "Member 'AEndFieldActionActorShinraElevator::TargetIconInSideVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorShinraElevator, Party01BoxComponent) == 0x000698, "Member 'AEndFieldActionActorShinraElevator::Party01BoxComponent' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorShinraElevator, Party02BoxComponent) == 0x0006A0, "Member 'AEndFieldActionActorShinraElevator::Party02BoxComponent' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorShinraElevator, ModifierVolume) == 0x0006A8, "Member 'AEndFieldActionActorShinraElevator::ModifierVolume' has a wrong offset!");

// Class EndGame.EndBattleScene_btsc_tnnl4_400
// 0x0008 (0x03B0 - 0x03A8)
class AEndBattleScene_btsc_tnnl4_400 final : public AEndBattleSceneBlueprint
{
public:
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleScene_btsc_tnnl4_400">();
	}
	static class AEndBattleScene_btsc_tnnl4_400* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleScene_btsc_tnnl4_400>();
	}
};
static_assert(alignof(AEndBattleScene_btsc_tnnl4_400) == 0x000008, "Wrong alignment on AEndBattleScene_btsc_tnnl4_400");
static_assert(sizeof(AEndBattleScene_btsc_tnnl4_400) == 0x0003B0, "Wrong size on AEndBattleScene_btsc_tnnl4_400");

// Class EndGame.EndNavAreaExtendedBattle
// 0x0000 (0x0040 - 0x0040)
class UEndNavAreaExtendedBattle final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavAreaExtendedBattle">();
	}
	static class UEndNavAreaExtendedBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavAreaExtendedBattle>();
	}
};
static_assert(alignof(UEndNavAreaExtendedBattle) == 0x000008, "Wrong alignment on UEndNavAreaExtendedBattle");
static_assert(sizeof(UEndNavAreaExtendedBattle) == 0x000040, "Wrong size on UEndNavAreaExtendedBattle");

// Class EndGame.EndBattleSuperArmorNotify
// 0x0008 (0x0040 - 0x0038)
class UEndBattleSuperArmorNotify final : public UAnimNotify
{
public:
	bool                                          bFlag;                                             // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleSuperArmorNotify">();
	}
	static class UEndBattleSuperArmorNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleSuperArmorNotify>();
	}
};
static_assert(alignof(UEndBattleSuperArmorNotify) == 0x000008, "Wrong alignment on UEndBattleSuperArmorNotify");
static_assert(sizeof(UEndBattleSuperArmorNotify) == 0x000040, "Wrong size on UEndBattleSuperArmorNotify");
static_assert(offsetof(UEndBattleSuperArmorNotify, bFlag) == 0x000038, "Member 'UEndBattleSuperArmorNotify::bFlag' has a wrong offset!");

// Class EndGame.EndBTTask_FindGroundLocation
// 0x0008 (0x0078 - 0x0070)
class UEndBTTask_FindGroundLocation final : public UBTTaskNode
{
public:
	class FName                                   GroundLocationBlackBoardName;                      // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_FindGroundLocation">();
	}
	static class UEndBTTask_FindGroundLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_FindGroundLocation>();
	}
};
static_assert(alignof(UEndBTTask_FindGroundLocation) == 0x000008, "Wrong alignment on UEndBTTask_FindGroundLocation");
static_assert(sizeof(UEndBTTask_FindGroundLocation) == 0x000078, "Wrong size on UEndBTTask_FindGroundLocation");
static_assert(offsetof(UEndBTTask_FindGroundLocation, GroundLocationBlackBoardName) == 0x000070, "Member 'UEndBTTask_FindGroundLocation::GroundLocationBlackBoardName' has a wrong offset!");

// Class EndGame.EndBTDecorator_Field_CheckAngle
// 0x0090 (0x00F8 - 0x0068)
class UEndBTDecorator_Field_CheckAngle final : public UEndBTDecorator_CheckConditionBase
{
public:
	struct FBlackboardKeySelector                 m_Source;                                          // 0x0068(0x0028)(Edit, NativeAccessSpecifierPublic)
	bool                                          m_bUseToSource;                                    // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 m_ToSource;                                        // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 m_Target;                                          // 0x00C0(0x0028)(Edit, NativeAccessSpecifierPublic)
	bool                                          m_bAbs;                                            // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         m_Angle;                                           // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndAiMathCmp                                 m_ArithmeticOperation;                             // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_bCheckYaw;                                       // 0x00F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F2[0x6];                                       // 0x00F2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_Field_CheckAngle">();
	}
	static class UEndBTDecorator_Field_CheckAngle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_Field_CheckAngle>();
	}
};
static_assert(alignof(UEndBTDecorator_Field_CheckAngle) == 0x000008, "Wrong alignment on UEndBTDecorator_Field_CheckAngle");
static_assert(sizeof(UEndBTDecorator_Field_CheckAngle) == 0x0000F8, "Wrong size on UEndBTDecorator_Field_CheckAngle");
static_assert(offsetof(UEndBTDecorator_Field_CheckAngle, m_Source) == 0x000068, "Member 'UEndBTDecorator_Field_CheckAngle::m_Source' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_CheckAngle, m_bUseToSource) == 0x000090, "Member 'UEndBTDecorator_Field_CheckAngle::m_bUseToSource' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_CheckAngle, m_ToSource) == 0x000098, "Member 'UEndBTDecorator_Field_CheckAngle::m_ToSource' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_CheckAngle, m_Target) == 0x0000C0, "Member 'UEndBTDecorator_Field_CheckAngle::m_Target' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_CheckAngle, m_bAbs) == 0x0000E8, "Member 'UEndBTDecorator_Field_CheckAngle::m_bAbs' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_CheckAngle, m_Angle) == 0x0000EC, "Member 'UEndBTDecorator_Field_CheckAngle::m_Angle' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_CheckAngle, m_ArithmeticOperation) == 0x0000F0, "Member 'UEndBTDecorator_Field_CheckAngle::m_ArithmeticOperation' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_CheckAngle, m_bCheckYaw) == 0x0000F1, "Member 'UEndBTDecorator_Field_CheckAngle::m_bCheckYaw' has a wrong offset!");

// Class EndGame.EndBattleTalkCharacterComponent
// 0x0008 (0x0100 - 0x00F8)
class UEndBattleTalkCharacterComponent : public UActorComponent
{
public:
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool OnNotify(const class FName& AnimName, const class FName& SoundName, class AEndCharacter* ownerChara) const;
	bool OnNotifyWithAbility(const class FName& AnimName, const class FName& SoundName, class AEndCharacter* ownerChara, class AEndCharacter* targetChara, const class FName& AbilityID, const struct FEndDataTableBattleAbility& dataTableBattleAbility, bool bFinishBlow) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleTalkCharacterComponent">();
	}
	static class UEndBattleTalkCharacterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBattleTalkCharacterComponent>();
	}
};
static_assert(alignof(UEndBattleTalkCharacterComponent) == 0x000008, "Wrong alignment on UEndBattleTalkCharacterComponent");
static_assert(sizeof(UEndBattleTalkCharacterComponent) == 0x000100, "Wrong size on UEndBattleTalkCharacterComponent");

// Class EndGame.EndBTTask_Field_MoveTo
// 0x0008 (0x00E0 - 0x00D8)
class UEndBTTask_Field_MoveTo : public UEndBTTask_MoveTo
{
public:
	bool                                          m_bRequestOnce;                                    // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFFieldAiType                                 m_AiType;                                          // 0x00D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA[0x2];                                       // 0x00DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         m_BlendTime;                                       // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_Field_MoveTo">();
	}
	static class UEndBTTask_Field_MoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_Field_MoveTo>();
	}
};
static_assert(alignof(UEndBTTask_Field_MoveTo) == 0x000008, "Wrong alignment on UEndBTTask_Field_MoveTo");
static_assert(sizeof(UEndBTTask_Field_MoveTo) == 0x0000E0, "Wrong size on UEndBTTask_Field_MoveTo");
static_assert(offsetof(UEndBTTask_Field_MoveTo, m_bRequestOnce) == 0x0000D8, "Member 'UEndBTTask_Field_MoveTo::m_bRequestOnce' has a wrong offset!");
static_assert(offsetof(UEndBTTask_Field_MoveTo, m_AiType) == 0x0000D9, "Member 'UEndBTTask_Field_MoveTo::m_AiType' has a wrong offset!");
static_assert(offsetof(UEndBTTask_Field_MoveTo, m_BlendTime) == 0x0000DC, "Member 'UEndBTTask_Field_MoveTo::m_BlendTime' has a wrong offset!");

// Class EndGame.EndBattleTalkOnEndBattleActor
// 0x0088 (0x0400 - 0x0378)
class AEndBattleTalkOnEndBattleActor : public AActor
{
public:
	float                                         DelayMinSeconds;                                   // 0x0378(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayMaxSeconds;                                   // 0x037C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_380[0x70];                                     // 0x0380(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEndSoundHandle                        AudioComponent;                                    // 0x03F0(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)

public:
	void OnEndBattle(class FName BattleSceneID, EndBattleExitBattleSceneType BattleExitType);
	void PlayVoice(bool bUnuseDefaultDelay, float OverrideDelayMinSeconds, float OverrideDelayMaxSeconds, class FName VoiceSetId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBattleTalkOnEndBattleActor">();
	}
	static class AEndBattleTalkOnEndBattleActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBattleTalkOnEndBattleActor>();
	}
};
static_assert(alignof(AEndBattleTalkOnEndBattleActor) == 0x000008, "Wrong alignment on AEndBattleTalkOnEndBattleActor");
static_assert(sizeof(AEndBattleTalkOnEndBattleActor) == 0x000400, "Wrong size on AEndBattleTalkOnEndBattleActor");
static_assert(offsetof(AEndBattleTalkOnEndBattleActor, DelayMinSeconds) == 0x000378, "Member 'AEndBattleTalkOnEndBattleActor::DelayMinSeconds' has a wrong offset!");
static_assert(offsetof(AEndBattleTalkOnEndBattleActor, DelayMaxSeconds) == 0x00037C, "Member 'AEndBattleTalkOnEndBattleActor::DelayMaxSeconds' has a wrong offset!");
static_assert(offsetof(AEndBattleTalkOnEndBattleActor, AudioComponent) == 0x0003F0, "Member 'AEndBattleTalkOnEndBattleActor::AudioComponent' has a wrong offset!");

// Class EndGame.EndBTDecorator_Field_CheckLeadState
// 0x0010 (0x0078 - 0x0068)
class UEndBTDecorator_Field_CheckLeadState final : public UEndBTDecorator_CheckConditionBase
{
public:
	TArray<EEndFieldAILeadState>                  m_StateTypes;                                      // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_Field_CheckLeadState">();
	}
	static class UEndBTDecorator_Field_CheckLeadState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_Field_CheckLeadState>();
	}
};
static_assert(alignof(UEndBTDecorator_Field_CheckLeadState) == 0x000008, "Wrong alignment on UEndBTDecorator_Field_CheckLeadState");
static_assert(sizeof(UEndBTDecorator_Field_CheckLeadState) == 0x000078, "Wrong size on UEndBTDecorator_Field_CheckLeadState");
static_assert(offsetof(UEndBTDecorator_Field_CheckLeadState, m_StateTypes) == 0x000068, "Member 'UEndBTDecorator_Field_CheckLeadState::m_StateTypes' has a wrong offset!");

// Class EndGame.EndPolygon
// 0x00E8 (0x01E0 - 0x00F8)
class UEndPolygon final : public UWidget
{
public:
	TArray<struct FEndMenuPolygonVertex>          Vertices;                                          // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 Indices;                                           // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSlateBrush                            Brush;                                             // 0x0118(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TDelegate<void()>                             BrushDelegate;                                     // 0x0190(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorAndOpacity;                                   // 0x01A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ColorAndOpacityDelegate;                           // 0x01B0(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	EBlendMode                                    BlendMode;                                         // 0x01C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x3];                                      // 0x01C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Size;                                              // 0x01C4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CC[0x14];                                     // 0x01CC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMaterialInstanceDynamic* GetDynamicMaterial();
	void SetBlendMode(EBlendMode InBlendMode);
	void SetBrush(const struct FSlateBrush& InBrush);
	void SetBrushFromAsset(class USlateBrushAsset* Asset);
	void SetBrushFromMaterial(class UMaterialInterface* Material);
	void SetBrushFromTexture(class UTexture2D* Texture, bool bMatchSize);
	void SetBrushFromTextureDynamic(class UTexture2DDynamic* Texture, bool bMatchSize);
	void SetColorAndOpacity(const struct FLinearColor& InColorAndOpacity);
	void SetOpacity(float InOpacity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndPolygon">();
	}
	static class UEndPolygon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndPolygon>();
	}
};
static_assert(alignof(UEndPolygon) == 0x000008, "Wrong alignment on UEndPolygon");
static_assert(sizeof(UEndPolygon) == 0x0001E0, "Wrong size on UEndPolygon");
static_assert(offsetof(UEndPolygon, Vertices) == 0x0000F8, "Member 'UEndPolygon::Vertices' has a wrong offset!");
static_assert(offsetof(UEndPolygon, Indices) == 0x000108, "Member 'UEndPolygon::Indices' has a wrong offset!");
static_assert(offsetof(UEndPolygon, Brush) == 0x000118, "Member 'UEndPolygon::Brush' has a wrong offset!");
static_assert(offsetof(UEndPolygon, BrushDelegate) == 0x000190, "Member 'UEndPolygon::BrushDelegate' has a wrong offset!");
static_assert(offsetof(UEndPolygon, ColorAndOpacity) == 0x0001A0, "Member 'UEndPolygon::ColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UEndPolygon, ColorAndOpacityDelegate) == 0x0001B0, "Member 'UEndPolygon::ColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UEndPolygon, BlendMode) == 0x0001C0, "Member 'UEndPolygon::BlendMode' has a wrong offset!");
static_assert(offsetof(UEndPolygon, Size) == 0x0001C4, "Member 'UEndPolygon::Size' has a wrong offset!");

// Class EndGame.EndBTTask_AIPCDodge
// 0x0038 (0x00A8 - 0x0070)
class UEndBTTask_AIPCDodge final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 DodgeLocationBlackboardKey;                        // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	EDodgeDirectionType                           DodgeDirectionType;                                // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartWaitTime;                                     // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInputDirectionDuringDodge;                        // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStyleChange;                                      // 0x00A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_AIPCDodge">();
	}
	static class UEndBTTask_AIPCDodge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_AIPCDodge>();
	}
};
static_assert(alignof(UEndBTTask_AIPCDodge) == 0x000008, "Wrong alignment on UEndBTTask_AIPCDodge");
static_assert(sizeof(UEndBTTask_AIPCDodge) == 0x0000A8, "Wrong size on UEndBTTask_AIPCDodge");
static_assert(offsetof(UEndBTTask_AIPCDodge, DodgeLocationBlackboardKey) == 0x000070, "Member 'UEndBTTask_AIPCDodge::DodgeLocationBlackboardKey' has a wrong offset!");
static_assert(offsetof(UEndBTTask_AIPCDodge, DodgeDirectionType) == 0x000098, "Member 'UEndBTTask_AIPCDodge::DodgeDirectionType' has a wrong offset!");
static_assert(offsetof(UEndBTTask_AIPCDodge, StartWaitTime) == 0x00009C, "Member 'UEndBTTask_AIPCDodge::StartWaitTime' has a wrong offset!");
static_assert(offsetof(UEndBTTask_AIPCDodge, bInputDirectionDuringDodge) == 0x0000A0, "Member 'UEndBTTask_AIPCDodge::bInputDirectionDuringDodge' has a wrong offset!");
static_assert(offsetof(UEndBTTask_AIPCDodge, bStyleChange) == 0x0000A1, "Member 'UEndBTTask_AIPCDodge::bStyleChange' has a wrong offset!");

// Class EndGame.EndBikeAIControllerTrike
// 0x0190 (0x1100 - 0x0F70)
class AEndBikeAIControllerTrike final : public AEndBikeAIControllerAllyBase
{
public:
	float                                         MoveDistanceRange_Min_Enemies_InTruckBattle0;      // 0x0F70(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveDistanceRange_Min_Enemies_InSoldier3rdBattle0; // 0x0F74(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveDistanceRange_Min_Enemies_InSoldier3rdBattle1; // 0x0F78(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F7C[0x4];                                      // 0x0F7C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBikeTrikeStateTriggerData>     StateTriggerList_AttackedBySoldier3rd;             // 0x0F80(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         StateTriggerTime_AttackedBySoldier3rd;             // 0x0F90(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F94[0x4];                                      // 0x0F94(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBikeTrikeStateTriggerData>     StateTriggerList_OnDeadSoldier3rd;                 // 0x0F98(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<EBikeDirection, struct FBikeAllyAbilityList> SpecialAbilitySetting;                             // 0x0FA8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         SpecialAbilityValidMinMileage;                     // 0x0FF8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBikeAIControllerTrikeSpecialAttackParameter mSpecialAttackParameter;                           // 0x0FFC(0x0020)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         SpecialAttackDelay;                                // 0x101C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBikeTrikeRandomIdleGestureParam       mRandomIdleGestureParam;                           // 0x1020(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1040[0xC0];                                    // 0x1040(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikeAIControllerTrike">();
	}
	static class AEndBikeAIControllerTrike* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBikeAIControllerTrike>();
	}
};
static_assert(alignof(AEndBikeAIControllerTrike) == 0x000008, "Wrong alignment on AEndBikeAIControllerTrike");
static_assert(sizeof(AEndBikeAIControllerTrike) == 0x001100, "Wrong size on AEndBikeAIControllerTrike");
static_assert(offsetof(AEndBikeAIControllerTrike, MoveDistanceRange_Min_Enemies_InTruckBattle0) == 0x000F70, "Member 'AEndBikeAIControllerTrike::MoveDistanceRange_Min_Enemies_InTruckBattle0' has a wrong offset!");
static_assert(offsetof(AEndBikeAIControllerTrike, MoveDistanceRange_Min_Enemies_InSoldier3rdBattle0) == 0x000F74, "Member 'AEndBikeAIControllerTrike::MoveDistanceRange_Min_Enemies_InSoldier3rdBattle0' has a wrong offset!");
static_assert(offsetof(AEndBikeAIControllerTrike, MoveDistanceRange_Min_Enemies_InSoldier3rdBattle1) == 0x000F78, "Member 'AEndBikeAIControllerTrike::MoveDistanceRange_Min_Enemies_InSoldier3rdBattle1' has a wrong offset!");
static_assert(offsetof(AEndBikeAIControllerTrike, StateTriggerList_AttackedBySoldier3rd) == 0x000F80, "Member 'AEndBikeAIControllerTrike::StateTriggerList_AttackedBySoldier3rd' has a wrong offset!");
static_assert(offsetof(AEndBikeAIControllerTrike, StateTriggerTime_AttackedBySoldier3rd) == 0x000F90, "Member 'AEndBikeAIControllerTrike::StateTriggerTime_AttackedBySoldier3rd' has a wrong offset!");
static_assert(offsetof(AEndBikeAIControllerTrike, StateTriggerList_OnDeadSoldier3rd) == 0x000F98, "Member 'AEndBikeAIControllerTrike::StateTriggerList_OnDeadSoldier3rd' has a wrong offset!");
static_assert(offsetof(AEndBikeAIControllerTrike, SpecialAbilitySetting) == 0x000FA8, "Member 'AEndBikeAIControllerTrike::SpecialAbilitySetting' has a wrong offset!");
static_assert(offsetof(AEndBikeAIControllerTrike, SpecialAbilityValidMinMileage) == 0x000FF8, "Member 'AEndBikeAIControllerTrike::SpecialAbilityValidMinMileage' has a wrong offset!");
static_assert(offsetof(AEndBikeAIControllerTrike, mSpecialAttackParameter) == 0x000FFC, "Member 'AEndBikeAIControllerTrike::mSpecialAttackParameter' has a wrong offset!");
static_assert(offsetof(AEndBikeAIControllerTrike, SpecialAttackDelay) == 0x00101C, "Member 'AEndBikeAIControllerTrike::SpecialAttackDelay' has a wrong offset!");
static_assert(offsetof(AEndBikeAIControllerTrike, mRandomIdleGestureParam) == 0x001020, "Member 'AEndBikeAIControllerTrike::mRandomIdleGestureParam' has a wrong offset!");

// Class EndGame.EndBTDecorator_Field_IsFieldAIType
// 0x0010 (0x0078 - 0x0068)
class UEndBTDecorator_Field_IsFieldAIType final : public UEndBTDecorator_CheckConditionBase
{
public:
	TArray<EFFieldAiType>                         m_AiTypes;                                         // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_Field_IsFieldAIType">();
	}
	static class UEndBTDecorator_Field_IsFieldAIType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_Field_IsFieldAIType>();
	}
};
static_assert(alignof(UEndBTDecorator_Field_IsFieldAIType) == 0x000008, "Wrong alignment on UEndBTDecorator_Field_IsFieldAIType");
static_assert(sizeof(UEndBTDecorator_Field_IsFieldAIType) == 0x000078, "Wrong size on UEndBTDecorator_Field_IsFieldAIType");
static_assert(offsetof(UEndBTDecorator_Field_IsFieldAIType, m_AiTypes) == 0x000068, "Member 'UEndBTDecorator_Field_IsFieldAIType::m_AiTypes' has a wrong offset!");

// Class EndGame.EndBikeAIDefaultController
// 0x0000 (0x0E60 - 0x0E60)
class AEndBikeAIDefaultController final : public AEndBikeAIController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikeAIDefaultController">();
	}
	static class AEndBikeAIDefaultController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBikeAIDefaultController>();
	}
};
static_assert(alignof(AEndBikeAIDefaultController) == 0x000008, "Wrong alignment on AEndBikeAIDefaultController");
static_assert(sizeof(AEndBikeAIDefaultController) == 0x000E60, "Wrong size on AEndBikeAIDefaultController");

// Class EndGame.EndBikeAIHelicopterController
// 0x05E8 (0x1568 - 0x0F80)
#pragma pack(push, 0x1)
class alignas(0x08) AEndBikeAIHelicopterController : public AEndBikeAIControllerEnemyBase
{
public:
	struct FEndBikeAIHelicopterParameter          mParameter;                                        // 0x0F80(0x00F4)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1074[0x4];                                     // 0x1074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FEndBikeAIHelicopterLockOnInfoList> AbilityIDToLockOnInfo;                             // 0x1078(0x0050)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FEndBikeAIHelicopterMoveParam_MoveAround> MovementParams_MoveAround;                         // 0x10C8(0x0050)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FEndBikeAIHelicopterMoveParam_MoveForward> MovementParams_MoveForward;                        // 0x1118(0x0050)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FEndBikeAIHelicopterMoveParam_MoveBackward> MovementParams_MoveBackward;                       // 0x1168(0x0050)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class FName>                AbilityIDToMovementParams;                         // 0x11B8(0x0050)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FEndBikeAIHelicopterAbilitySet         AbilitySetForPlayer;                               // 0x1208(0x0020)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FEndBikeAIHelicopterAbilitySet         AbilitySetForAlly;                                 // 0x1228(0x0020)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TMap<int32, struct FEndBikeAIHelicopterAbilitySetPhase> AbilitySetForPlayer_Phase;                         // 0x1248(0x0050)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<int32, struct FEndBikeAIHelicopterAbilitySet> AbilitySetForAlly_Phase;                           // 0x1298(0x0050)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   AbilitySetForJumpPoint;                            // 0x12E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FEndBikeAIHelicopterSpecificRoadArea> RightRoadWallAreas;                                // 0x12F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FEndBikeAIHelicopterSpecificRoadArea> LeftRoadWallAreas;                                 // 0x1300(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FEndBikeAIHelicopterSpecificRoadArea> CenterObstacleAreas;                               // 0x1310(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FBikeAIHelicopterSpecialAttackParameter TrikeSpecialAttackParameter;                       // 0x1320(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1358[0x210];                                   // 0x1358(0x0210)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikeAIHelicopterController">();
	}
	static class AEndBikeAIHelicopterController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBikeAIHelicopterController>();
	}
};
#pragma pack(pop)
static_assert(alignof(AEndBikeAIHelicopterController) == 0x000008, "Wrong alignment on AEndBikeAIHelicopterController");
static_assert(sizeof(AEndBikeAIHelicopterController) == 0x001568, "Wrong size on AEndBikeAIHelicopterController");
static_assert(offsetof(AEndBikeAIHelicopterController, mParameter) == 0x000F80, "Member 'AEndBikeAIHelicopterController::mParameter' has a wrong offset!");
static_assert(offsetof(AEndBikeAIHelicopterController, AbilityIDToLockOnInfo) == 0x001078, "Member 'AEndBikeAIHelicopterController::AbilityIDToLockOnInfo' has a wrong offset!");
static_assert(offsetof(AEndBikeAIHelicopterController, MovementParams_MoveAround) == 0x0010C8, "Member 'AEndBikeAIHelicopterController::MovementParams_MoveAround' has a wrong offset!");
static_assert(offsetof(AEndBikeAIHelicopterController, MovementParams_MoveForward) == 0x001118, "Member 'AEndBikeAIHelicopterController::MovementParams_MoveForward' has a wrong offset!");
static_assert(offsetof(AEndBikeAIHelicopterController, MovementParams_MoveBackward) == 0x001168, "Member 'AEndBikeAIHelicopterController::MovementParams_MoveBackward' has a wrong offset!");
static_assert(offsetof(AEndBikeAIHelicopterController, AbilityIDToMovementParams) == 0x0011B8, "Member 'AEndBikeAIHelicopterController::AbilityIDToMovementParams' has a wrong offset!");
static_assert(offsetof(AEndBikeAIHelicopterController, AbilitySetForPlayer) == 0x001208, "Member 'AEndBikeAIHelicopterController::AbilitySetForPlayer' has a wrong offset!");
static_assert(offsetof(AEndBikeAIHelicopterController, AbilitySetForAlly) == 0x001228, "Member 'AEndBikeAIHelicopterController::AbilitySetForAlly' has a wrong offset!");
static_assert(offsetof(AEndBikeAIHelicopterController, AbilitySetForPlayer_Phase) == 0x001248, "Member 'AEndBikeAIHelicopterController::AbilitySetForPlayer_Phase' has a wrong offset!");
static_assert(offsetof(AEndBikeAIHelicopterController, AbilitySetForAlly_Phase) == 0x001298, "Member 'AEndBikeAIHelicopterController::AbilitySetForAlly_Phase' has a wrong offset!");
static_assert(offsetof(AEndBikeAIHelicopterController, AbilitySetForJumpPoint) == 0x0012E8, "Member 'AEndBikeAIHelicopterController::AbilitySetForJumpPoint' has a wrong offset!");
static_assert(offsetof(AEndBikeAIHelicopterController, RightRoadWallAreas) == 0x0012F0, "Member 'AEndBikeAIHelicopterController::RightRoadWallAreas' has a wrong offset!");
static_assert(offsetof(AEndBikeAIHelicopterController, LeftRoadWallAreas) == 0x001300, "Member 'AEndBikeAIHelicopterController::LeftRoadWallAreas' has a wrong offset!");
static_assert(offsetof(AEndBikeAIHelicopterController, CenterObstacleAreas) == 0x001310, "Member 'AEndBikeAIHelicopterController::CenterObstacleAreas' has a wrong offset!");
static_assert(offsetof(AEndBikeAIHelicopterController, TrikeSpecialAttackParameter) == 0x001320, "Member 'AEndBikeAIHelicopterController::TrikeSpecialAttackParameter' has a wrong offset!");

// Class EndGame.EndBikeAIHelicopterEvController
// 0x0018 (0x1580 - 0x1568)
class AEndBikeAIHelicopterEvController final : public AEndBikeAIHelicopterController
{
public:
	bool                                          ExecOnlyFirstAttack;                               // 0x1568(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1569[0x3];                                     // 0x1569(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FirstAttackSplineInputKey;                         // 0x156C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FirstAttackSplineID;                               // 0x1570(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FirstAttackDistance;                               // 0x1578(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_157C[0x4];                                     // 0x157C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikeAIHelicopterEvController">();
	}
	static class AEndBikeAIHelicopterEvController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBikeAIHelicopterEvController>();
	}
};
static_assert(alignof(AEndBikeAIHelicopterEvController) == 0x000008, "Wrong alignment on AEndBikeAIHelicopterEvController");
static_assert(sizeof(AEndBikeAIHelicopterEvController) == 0x001580, "Wrong size on AEndBikeAIHelicopterEvController");
static_assert(offsetof(AEndBikeAIHelicopterEvController, ExecOnlyFirstAttack) == 0x001568, "Member 'AEndBikeAIHelicopterEvController::ExecOnlyFirstAttack' has a wrong offset!");
static_assert(offsetof(AEndBikeAIHelicopterEvController, FirstAttackSplineInputKey) == 0x00156C, "Member 'AEndBikeAIHelicopterEvController::FirstAttackSplineInputKey' has a wrong offset!");
static_assert(offsetof(AEndBikeAIHelicopterEvController, FirstAttackSplineID) == 0x001570, "Member 'AEndBikeAIHelicopterEvController::FirstAttackSplineID' has a wrong offset!");
static_assert(offsetof(AEndBikeAIHelicopterEvController, FirstAttackDistance) == 0x001578, "Member 'AEndBikeAIHelicopterEvController::FirstAttackDistance' has a wrong offset!");

// Class EndGame.EndBTDecorator_Field_IsMove
// 0x0000 (0x0068 - 0x0068)
class UEndBTDecorator_Field_IsMove final : public UEndBTDecorator_CheckConditionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_Field_IsMove">();
	}
	static class UEndBTDecorator_Field_IsMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_Field_IsMove>();
	}
};
static_assert(alignof(UEndBTDecorator_Field_IsMove) == 0x000008, "Wrong alignment on UEndBTDecorator_Field_IsMove");
static_assert(sizeof(UEndBTDecorator_Field_IsMove) == 0x000068, "Wrong size on UEndBTDecorator_Field_IsMove");

// Class EndGame.EndBikeAIMothSlasherController
// 0x0200 (0x1180 - 0x0F80)
class AEndBikeAIMothSlasherController final : public AEndBikeAIControllerEnemyBase
{
public:
	EBikeMothSlasherAttackType                    InitialAttackType;                                 // 0x0F80(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         AbilityCount_DoCharge;                             // 0x0F81(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F82[0x2];                                      // 0x0F82(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AbilitySetID_Charge;                               // 0x0F84(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         ChargeCount_DoDischarge;                           // 0x0F8C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8D[0x3];                                      // 0x0F8D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AbilitySetID_Discharge;                            // 0x0F90(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitPointRate_ChangeToPhase2;                       // 0x0F98(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MotionID_ChangeToPhase2;                           // 0x0F9C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AbilitySetID_Phase2;                               // 0x0FA4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BreakMeshID;                                       // 0x0FAC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BreakMeshStateLabel_After;                         // 0x0FB4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BrokenEffectName;                                  // 0x0FBC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BrokenEffectSocket;                                // 0x0FC4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRunAhead;                                         // 0x0FCC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FCD[0x3];                                      // 0x0FCD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KeepTargetDistance;                                // 0x0FD0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisableArmsPushCollision;                         // 0x0FD4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FD5[0x3];                                      // 0x0FD5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitPointRate_CutterStorm2;                         // 0x0FD8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FDC[0x4];                                      // 0x0FDC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FBikeCutterStormAbilitySetting> CutterStormSettings;                               // 0x0FE0(0x0050)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FBikeCutterStormAbilitySetting> CutterStormSettings2;                              // 0x1030(0x0050)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   DrillAbilityID_Normal;                             // 0x1080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DrillAbilityID_Long;                               // 0x1088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         DrillAbilityCount_ReplaceToLong;                   // 0x1090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1091[0x7];                                     // 0x1091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Unbalance_Abilities;                               // 0x1098(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   MotionID_Unbalance;                                // 0x10A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TalkTriggerSetID_Guarded;                          // 0x10B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, class FName>                MufflerEffectSettings;                             // 0x10B8(0x0050)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1108[0x78];                                    // 0x1108(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikeAIMothSlasherController">();
	}
	static class AEndBikeAIMothSlasherController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBikeAIMothSlasherController>();
	}
};
static_assert(alignof(AEndBikeAIMothSlasherController) == 0x000008, "Wrong alignment on AEndBikeAIMothSlasherController");
static_assert(sizeof(AEndBikeAIMothSlasherController) == 0x001180, "Wrong size on AEndBikeAIMothSlasherController");
static_assert(offsetof(AEndBikeAIMothSlasherController, InitialAttackType) == 0x000F80, "Member 'AEndBikeAIMothSlasherController::InitialAttackType' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMothSlasherController, AbilityCount_DoCharge) == 0x000F81, "Member 'AEndBikeAIMothSlasherController::AbilityCount_DoCharge' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMothSlasherController, AbilitySetID_Charge) == 0x000F84, "Member 'AEndBikeAIMothSlasherController::AbilitySetID_Charge' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMothSlasherController, ChargeCount_DoDischarge) == 0x000F8C, "Member 'AEndBikeAIMothSlasherController::ChargeCount_DoDischarge' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMothSlasherController, AbilitySetID_Discharge) == 0x000F90, "Member 'AEndBikeAIMothSlasherController::AbilitySetID_Discharge' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMothSlasherController, HitPointRate_ChangeToPhase2) == 0x000F98, "Member 'AEndBikeAIMothSlasherController::HitPointRate_ChangeToPhase2' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMothSlasherController, MotionID_ChangeToPhase2) == 0x000F9C, "Member 'AEndBikeAIMothSlasherController::MotionID_ChangeToPhase2' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMothSlasherController, AbilitySetID_Phase2) == 0x000FA4, "Member 'AEndBikeAIMothSlasherController::AbilitySetID_Phase2' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMothSlasherController, BreakMeshID) == 0x000FAC, "Member 'AEndBikeAIMothSlasherController::BreakMeshID' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMothSlasherController, BreakMeshStateLabel_After) == 0x000FB4, "Member 'AEndBikeAIMothSlasherController::BreakMeshStateLabel_After' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMothSlasherController, BrokenEffectName) == 0x000FBC, "Member 'AEndBikeAIMothSlasherController::BrokenEffectName' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMothSlasherController, BrokenEffectSocket) == 0x000FC4, "Member 'AEndBikeAIMothSlasherController::BrokenEffectSocket' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMothSlasherController, bRunAhead) == 0x000FCC, "Member 'AEndBikeAIMothSlasherController::bRunAhead' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMothSlasherController, KeepTargetDistance) == 0x000FD0, "Member 'AEndBikeAIMothSlasherController::KeepTargetDistance' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMothSlasherController, bDisableArmsPushCollision) == 0x000FD4, "Member 'AEndBikeAIMothSlasherController::bDisableArmsPushCollision' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMothSlasherController, HitPointRate_CutterStorm2) == 0x000FD8, "Member 'AEndBikeAIMothSlasherController::HitPointRate_CutterStorm2' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMothSlasherController, CutterStormSettings) == 0x000FE0, "Member 'AEndBikeAIMothSlasherController::CutterStormSettings' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMothSlasherController, CutterStormSettings2) == 0x001030, "Member 'AEndBikeAIMothSlasherController::CutterStormSettings2' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMothSlasherController, DrillAbilityID_Normal) == 0x001080, "Member 'AEndBikeAIMothSlasherController::DrillAbilityID_Normal' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMothSlasherController, DrillAbilityID_Long) == 0x001088, "Member 'AEndBikeAIMothSlasherController::DrillAbilityID_Long' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMothSlasherController, DrillAbilityCount_ReplaceToLong) == 0x001090, "Member 'AEndBikeAIMothSlasherController::DrillAbilityCount_ReplaceToLong' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMothSlasherController, Unbalance_Abilities) == 0x001098, "Member 'AEndBikeAIMothSlasherController::Unbalance_Abilities' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMothSlasherController, MotionID_Unbalance) == 0x0010A8, "Member 'AEndBikeAIMothSlasherController::MotionID_Unbalance' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMothSlasherController, TalkTriggerSetID_Guarded) == 0x0010B0, "Member 'AEndBikeAIMothSlasherController::TalkTriggerSetID_Guarded' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMothSlasherController, MufflerEffectSettings) == 0x0010B8, "Member 'AEndBikeAIMothSlasherController::MufflerEffectSettings' has a wrong offset!");

// Class EndGame.EndBikeAIMotorBallController
// 0x0A90 (0x1A10 - 0x0F80)
class AEndBikeAIMotorBallController final : public AEndBikeAIControllerEnemyBase
{
public:
	uint8                                         Pad_F80[0x8];                                      // 0x0F80(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBikeBreakablePartInfo                 Part_Right_Front;                                  // 0x0F88(0x00E0)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBikeBreakablePartInfo                 Part_Right_Center;                                 // 0x1068(0x00E0)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBikeBreakablePartInfo                 Part_Right_Back;                                   // 0x1148(0x00E0)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBikeBreakablePartInfo                 Part_Left_Front;                                   // 0x1228(0x00E0)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBikeBreakablePartInfo                 Part_Left_Center;                                  // 0x1308(0x00E0)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBikeBreakablePartInfo                 Part_Left_Back;                                    // 0x13E8(0x00E0)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_14C8[0x10];                                    // 0x14C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PenetrateDamageRatio;                              // 0x14D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DownMotionID_Begin;                                // 0x14DC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DownMotionID_Loop;                                 // 0x14E4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DownMotionID_End;                                  // 0x14EC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DownTime;                                          // 0x14F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RelativeSpeedRate_Down;                            // 0x14F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         RepairPartsNum;                                    // 0x14FC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14FD[0x3];                                     // 0x14FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<float, uint8>                            RepairPartsNumSettings;                            // 0x1500(0x0050)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   TalkTriggerSetID_BeginChase;                       // 0x1550(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TalkTriggerSetID_OnBreak;                          // 0x1558(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TalkTriggerSetID_BeginDown;                        // 0x1560(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TalkTriggerSetID_BeginBarrier;                     // 0x1568(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TalkTriggerSetID_BeginRegeneration;                // 0x1570(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TalkTriggerSetID_OnHitBarrier;                     // 0x1578(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Debug_Enable_Draw;                                 // 0x1580(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Debug_Disable_LookAt;                              // 0x1581(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Debug_Disable_Aim;                                 // 0x1582(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BackRun_Start;                                     // 0x1583(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AnimSetID_BackRun;                                 // 0x1584(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_158C[0x4];                                     // 0x158C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<float, uint8>                            TimeAndOdds_ToBackRun;                             // 0x1590(0x0050)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<float, uint8>                            TimeAndOdds_ToForwardRun;                          // 0x15E0(0x0050)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   TurnMotionID_Right;                                // 0x1630(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TurnMotionID_Left;                                 // 0x1638(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Distance_Forward_Limit;                            // 0x1640(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovableArea_Triangle_Top;                          // 0x1644(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovableArea_Triangle_Rate;                         // 0x1648(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlideLimit;                                        // 0x164C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlideSpeed;                                        // 0x1650(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Distance_Right_Threshold_UI;                       // 0x1654(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Opacity_UI;                                        // 0x1658(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitPointRate_Phase1To2;                            // 0x165C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PhaseChangeMotion_Phase1To2;                       // 0x1660(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   StateTriggerID_Phase1To2;                          // 0x1668(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitPointRate_Phase2To3;                            // 0x1670(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PhaseChangeMotion_Phase2To3;                       // 0x1674(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   StateTriggerID_Phase2To3;                          // 0x167C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitPointRate_Phase3To4;                            // 0x1684(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PhaseChangeMotion_Phase3To4;                       // 0x1688(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   StateTriggerID_Phase3To4;                          // 0x1690(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitPointRate_Phase4To5;                            // 0x1698(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PhaseChangeMotion_Phase4To5;                       // 0x169C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   StateTriggerID_Phase4To5;                          // 0x16A4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AbilitySetID_Phase1;                               // 0x16AC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AbilitySetID_Phase1_StandUp;                       // 0x16B4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AbilitySetID_Phase2;                               // 0x16BC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AbilitySetID_Phase2_StandUp;                       // 0x16C4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBikeBarrierPartsSetting               BarrierPartsSetting_Phase2;                        // 0x16CC(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EBikeMotorBallClimaxBehavior                  Behavior_FirstInPhase3;                            // 0x16DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16DD[0x3];                                     // 0x16DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AbilitySetID_Phase3;                               // 0x16E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AbilitySetID_Phase3_StandUp;                       // 0x16E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           AbilitySetIDs_Phase3_Mine;                         // 0x16F0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         MineAbilityNum_Phase3;                             // 0x1700(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1701[0x3];                                     // 0x1701(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AbilitySetID_Phase3_ShockWave;                     // 0x1704(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         ShockWaveAbilityNum_Phase3;                        // 0x170C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_170D[0x3];                                     // 0x170D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AbilitySetID_Phase3_Cannon;                        // 0x1710(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBikeCannonAbilitySetting              CannonAbilitySetting_Phase3;                       // 0x1718(0x002C)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBikeBarrierPartsSetting               BarrierPartsSetting_Phase3;                        // 0x1744(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         Time_ToChase_Phase3;                               // 0x1754(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Distance_Chase_Max_Phase3;                         // 0x1758(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RunSpeed_Chase_Phase3;                             // 0x175C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Distance_EndChase_Phase3;                          // 0x1760(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Time_EndChase_Phase3;                              // 0x1764(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 Times_EndChase_Phase3_Easy;                        // 0x1768(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 Times_EndChase_Phase3_Normal;                      // 0x1778(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   AbilitySetID_Phase4;                               // 0x1788(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AbilitySetID_Phase4_StandUp;                       // 0x1790(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           AbilitySetIDs_Phase4_Mine;                         // 0x1798(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         MineAbilityNum_Phase4;                             // 0x17A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17A9[0x3];                                     // 0x17A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AbilitySetID_Phase4_ShockWave;                     // 0x17AC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         ShockWaveAbilityNum_Phase4;                        // 0x17B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17B5[0x3];                                     // 0x17B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AbilitySetID_Phase4_Cannon;                        // 0x17B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBikeCannonAbilitySetting              CannonAbilitySetting_Phase4;                       // 0x17C0(0x002C)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBikeBarrierPartsSetting               BarrierPartsSetting_Phase4;                        // 0x17EC(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         Time_ToChase_Phase4;                               // 0x17FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Distance_Chase_Max_Phase4;                         // 0x1800(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RunSpeed_Chase_Phase4;                             // 0x1804(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Distance_EndChase_Phase4;                          // 0x1808(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Time_EndChase_Phase4;                              // 0x180C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 Times_EndChase_Phase4_Easy;                        // 0x1810(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 Times_EndChase_Phase4_Normal;                      // 0x1820(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FBikeRegenerationSetting               RegenerationSetting_Phase4;                        // 0x1830(0x0020)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   AbilitySetID_Phase5;                               // 0x1850(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AbilitySetID_Phase5_StandUp;                       // 0x1858(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           AbilitySetIDs_Phase5_Mine;                         // 0x1860(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         MineAbilityNum_Phase5;                             // 0x1870(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1871[0x3];                                     // 0x1871(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AbilitySetID_Phase5_ShockWave;                     // 0x1874(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         ShockWaveAbilityNum_Phase5;                        // 0x187C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_187D[0x3];                                     // 0x187D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AbilitySetID_Phase5_Cannon;                        // 0x1880(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBikeCannonAbilitySetting              CannonAbilitySetting_Phase5;                       // 0x1888(0x002C)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBikeBarrierPartsSetting               BarrierPartsSetting_Phase5;                        // 0x18B4(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         Time_ToChase_Phase5;                               // 0x18C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Distance_Chase_Max_Phase5;                         // 0x18C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RunSpeed_Chase_Phase5;                             // 0x18CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Distance_EndChase_Phase5;                          // 0x18D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Time_EndChase_Phase5;                              // 0x18D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 Times_EndChase_Phase5_Easy;                        // 0x18D8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 Times_EndChase_Phase5_Normal;                      // 0x18E8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FBikeRegenerationSetting               RegenerationSetting_Phase5;                        // 0x18F8(0x0020)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         Distance_RemoteDetonation;                         // 0x1918(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_191C[0x4];                                     // 0x191C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           DamageSourceIDs_RemoteDetonation;                  // 0x1920(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1930[0xE0];                                    // 0x1930(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikeAIMotorBallController">();
	}
	static class AEndBikeAIMotorBallController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBikeAIMotorBallController>();
	}
};
static_assert(alignof(AEndBikeAIMotorBallController) == 0x000008, "Wrong alignment on AEndBikeAIMotorBallController");
static_assert(sizeof(AEndBikeAIMotorBallController) == 0x001A10, "Wrong size on AEndBikeAIMotorBallController");
static_assert(offsetof(AEndBikeAIMotorBallController, Part_Right_Front) == 0x000F88, "Member 'AEndBikeAIMotorBallController::Part_Right_Front' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Part_Right_Center) == 0x001068, "Member 'AEndBikeAIMotorBallController::Part_Right_Center' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Part_Right_Back) == 0x001148, "Member 'AEndBikeAIMotorBallController::Part_Right_Back' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Part_Left_Front) == 0x001228, "Member 'AEndBikeAIMotorBallController::Part_Left_Front' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Part_Left_Center) == 0x001308, "Member 'AEndBikeAIMotorBallController::Part_Left_Center' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Part_Left_Back) == 0x0013E8, "Member 'AEndBikeAIMotorBallController::Part_Left_Back' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, PenetrateDamageRatio) == 0x0014D8, "Member 'AEndBikeAIMotorBallController::PenetrateDamageRatio' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, DownMotionID_Begin) == 0x0014DC, "Member 'AEndBikeAIMotorBallController::DownMotionID_Begin' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, DownMotionID_Loop) == 0x0014E4, "Member 'AEndBikeAIMotorBallController::DownMotionID_Loop' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, DownMotionID_End) == 0x0014EC, "Member 'AEndBikeAIMotorBallController::DownMotionID_End' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, DownTime) == 0x0014F4, "Member 'AEndBikeAIMotorBallController::DownTime' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, RelativeSpeedRate_Down) == 0x0014F8, "Member 'AEndBikeAIMotorBallController::RelativeSpeedRate_Down' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, RepairPartsNum) == 0x0014FC, "Member 'AEndBikeAIMotorBallController::RepairPartsNum' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, RepairPartsNumSettings) == 0x001500, "Member 'AEndBikeAIMotorBallController::RepairPartsNumSettings' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, TalkTriggerSetID_BeginChase) == 0x001550, "Member 'AEndBikeAIMotorBallController::TalkTriggerSetID_BeginChase' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, TalkTriggerSetID_OnBreak) == 0x001558, "Member 'AEndBikeAIMotorBallController::TalkTriggerSetID_OnBreak' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, TalkTriggerSetID_BeginDown) == 0x001560, "Member 'AEndBikeAIMotorBallController::TalkTriggerSetID_BeginDown' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, TalkTriggerSetID_BeginBarrier) == 0x001568, "Member 'AEndBikeAIMotorBallController::TalkTriggerSetID_BeginBarrier' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, TalkTriggerSetID_BeginRegeneration) == 0x001570, "Member 'AEndBikeAIMotorBallController::TalkTriggerSetID_BeginRegeneration' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, TalkTriggerSetID_OnHitBarrier) == 0x001578, "Member 'AEndBikeAIMotorBallController::TalkTriggerSetID_OnHitBarrier' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Debug_Enable_Draw) == 0x001580, "Member 'AEndBikeAIMotorBallController::Debug_Enable_Draw' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Debug_Disable_LookAt) == 0x001581, "Member 'AEndBikeAIMotorBallController::Debug_Disable_LookAt' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Debug_Disable_Aim) == 0x001582, "Member 'AEndBikeAIMotorBallController::Debug_Disable_Aim' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, BackRun_Start) == 0x001583, "Member 'AEndBikeAIMotorBallController::BackRun_Start' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, AnimSetID_BackRun) == 0x001584, "Member 'AEndBikeAIMotorBallController::AnimSetID_BackRun' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, TimeAndOdds_ToBackRun) == 0x001590, "Member 'AEndBikeAIMotorBallController::TimeAndOdds_ToBackRun' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, TimeAndOdds_ToForwardRun) == 0x0015E0, "Member 'AEndBikeAIMotorBallController::TimeAndOdds_ToForwardRun' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, TurnMotionID_Right) == 0x001630, "Member 'AEndBikeAIMotorBallController::TurnMotionID_Right' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, TurnMotionID_Left) == 0x001638, "Member 'AEndBikeAIMotorBallController::TurnMotionID_Left' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Distance_Forward_Limit) == 0x001640, "Member 'AEndBikeAIMotorBallController::Distance_Forward_Limit' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, MovableArea_Triangle_Top) == 0x001644, "Member 'AEndBikeAIMotorBallController::MovableArea_Triangle_Top' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, MovableArea_Triangle_Rate) == 0x001648, "Member 'AEndBikeAIMotorBallController::MovableArea_Triangle_Rate' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, SlideLimit) == 0x00164C, "Member 'AEndBikeAIMotorBallController::SlideLimit' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, SlideSpeed) == 0x001650, "Member 'AEndBikeAIMotorBallController::SlideSpeed' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Distance_Right_Threshold_UI) == 0x001654, "Member 'AEndBikeAIMotorBallController::Distance_Right_Threshold_UI' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Opacity_UI) == 0x001658, "Member 'AEndBikeAIMotorBallController::Opacity_UI' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, HitPointRate_Phase1To2) == 0x00165C, "Member 'AEndBikeAIMotorBallController::HitPointRate_Phase1To2' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, PhaseChangeMotion_Phase1To2) == 0x001660, "Member 'AEndBikeAIMotorBallController::PhaseChangeMotion_Phase1To2' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, StateTriggerID_Phase1To2) == 0x001668, "Member 'AEndBikeAIMotorBallController::StateTriggerID_Phase1To2' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, HitPointRate_Phase2To3) == 0x001670, "Member 'AEndBikeAIMotorBallController::HitPointRate_Phase2To3' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, PhaseChangeMotion_Phase2To3) == 0x001674, "Member 'AEndBikeAIMotorBallController::PhaseChangeMotion_Phase2To3' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, StateTriggerID_Phase2To3) == 0x00167C, "Member 'AEndBikeAIMotorBallController::StateTriggerID_Phase2To3' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, HitPointRate_Phase3To4) == 0x001684, "Member 'AEndBikeAIMotorBallController::HitPointRate_Phase3To4' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, PhaseChangeMotion_Phase3To4) == 0x001688, "Member 'AEndBikeAIMotorBallController::PhaseChangeMotion_Phase3To4' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, StateTriggerID_Phase3To4) == 0x001690, "Member 'AEndBikeAIMotorBallController::StateTriggerID_Phase3To4' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, HitPointRate_Phase4To5) == 0x001698, "Member 'AEndBikeAIMotorBallController::HitPointRate_Phase4To5' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, PhaseChangeMotion_Phase4To5) == 0x00169C, "Member 'AEndBikeAIMotorBallController::PhaseChangeMotion_Phase4To5' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, StateTriggerID_Phase4To5) == 0x0016A4, "Member 'AEndBikeAIMotorBallController::StateTriggerID_Phase4To5' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, AbilitySetID_Phase1) == 0x0016AC, "Member 'AEndBikeAIMotorBallController::AbilitySetID_Phase1' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, AbilitySetID_Phase1_StandUp) == 0x0016B4, "Member 'AEndBikeAIMotorBallController::AbilitySetID_Phase1_StandUp' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, AbilitySetID_Phase2) == 0x0016BC, "Member 'AEndBikeAIMotorBallController::AbilitySetID_Phase2' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, AbilitySetID_Phase2_StandUp) == 0x0016C4, "Member 'AEndBikeAIMotorBallController::AbilitySetID_Phase2_StandUp' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, BarrierPartsSetting_Phase2) == 0x0016CC, "Member 'AEndBikeAIMotorBallController::BarrierPartsSetting_Phase2' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Behavior_FirstInPhase3) == 0x0016DC, "Member 'AEndBikeAIMotorBallController::Behavior_FirstInPhase3' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, AbilitySetID_Phase3) == 0x0016E0, "Member 'AEndBikeAIMotorBallController::AbilitySetID_Phase3' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, AbilitySetID_Phase3_StandUp) == 0x0016E8, "Member 'AEndBikeAIMotorBallController::AbilitySetID_Phase3_StandUp' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, AbilitySetIDs_Phase3_Mine) == 0x0016F0, "Member 'AEndBikeAIMotorBallController::AbilitySetIDs_Phase3_Mine' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, MineAbilityNum_Phase3) == 0x001700, "Member 'AEndBikeAIMotorBallController::MineAbilityNum_Phase3' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, AbilitySetID_Phase3_ShockWave) == 0x001704, "Member 'AEndBikeAIMotorBallController::AbilitySetID_Phase3_ShockWave' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, ShockWaveAbilityNum_Phase3) == 0x00170C, "Member 'AEndBikeAIMotorBallController::ShockWaveAbilityNum_Phase3' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, AbilitySetID_Phase3_Cannon) == 0x001710, "Member 'AEndBikeAIMotorBallController::AbilitySetID_Phase3_Cannon' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, CannonAbilitySetting_Phase3) == 0x001718, "Member 'AEndBikeAIMotorBallController::CannonAbilitySetting_Phase3' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, BarrierPartsSetting_Phase3) == 0x001744, "Member 'AEndBikeAIMotorBallController::BarrierPartsSetting_Phase3' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Time_ToChase_Phase3) == 0x001754, "Member 'AEndBikeAIMotorBallController::Time_ToChase_Phase3' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Distance_Chase_Max_Phase3) == 0x001758, "Member 'AEndBikeAIMotorBallController::Distance_Chase_Max_Phase3' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, RunSpeed_Chase_Phase3) == 0x00175C, "Member 'AEndBikeAIMotorBallController::RunSpeed_Chase_Phase3' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Distance_EndChase_Phase3) == 0x001760, "Member 'AEndBikeAIMotorBallController::Distance_EndChase_Phase3' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Time_EndChase_Phase3) == 0x001764, "Member 'AEndBikeAIMotorBallController::Time_EndChase_Phase3' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Times_EndChase_Phase3_Easy) == 0x001768, "Member 'AEndBikeAIMotorBallController::Times_EndChase_Phase3_Easy' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Times_EndChase_Phase3_Normal) == 0x001778, "Member 'AEndBikeAIMotorBallController::Times_EndChase_Phase3_Normal' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, AbilitySetID_Phase4) == 0x001788, "Member 'AEndBikeAIMotorBallController::AbilitySetID_Phase4' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, AbilitySetID_Phase4_StandUp) == 0x001790, "Member 'AEndBikeAIMotorBallController::AbilitySetID_Phase4_StandUp' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, AbilitySetIDs_Phase4_Mine) == 0x001798, "Member 'AEndBikeAIMotorBallController::AbilitySetIDs_Phase4_Mine' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, MineAbilityNum_Phase4) == 0x0017A8, "Member 'AEndBikeAIMotorBallController::MineAbilityNum_Phase4' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, AbilitySetID_Phase4_ShockWave) == 0x0017AC, "Member 'AEndBikeAIMotorBallController::AbilitySetID_Phase4_ShockWave' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, ShockWaveAbilityNum_Phase4) == 0x0017B4, "Member 'AEndBikeAIMotorBallController::ShockWaveAbilityNum_Phase4' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, AbilitySetID_Phase4_Cannon) == 0x0017B8, "Member 'AEndBikeAIMotorBallController::AbilitySetID_Phase4_Cannon' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, CannonAbilitySetting_Phase4) == 0x0017C0, "Member 'AEndBikeAIMotorBallController::CannonAbilitySetting_Phase4' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, BarrierPartsSetting_Phase4) == 0x0017EC, "Member 'AEndBikeAIMotorBallController::BarrierPartsSetting_Phase4' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Time_ToChase_Phase4) == 0x0017FC, "Member 'AEndBikeAIMotorBallController::Time_ToChase_Phase4' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Distance_Chase_Max_Phase4) == 0x001800, "Member 'AEndBikeAIMotorBallController::Distance_Chase_Max_Phase4' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, RunSpeed_Chase_Phase4) == 0x001804, "Member 'AEndBikeAIMotorBallController::RunSpeed_Chase_Phase4' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Distance_EndChase_Phase4) == 0x001808, "Member 'AEndBikeAIMotorBallController::Distance_EndChase_Phase4' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Time_EndChase_Phase4) == 0x00180C, "Member 'AEndBikeAIMotorBallController::Time_EndChase_Phase4' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Times_EndChase_Phase4_Easy) == 0x001810, "Member 'AEndBikeAIMotorBallController::Times_EndChase_Phase4_Easy' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Times_EndChase_Phase4_Normal) == 0x001820, "Member 'AEndBikeAIMotorBallController::Times_EndChase_Phase4_Normal' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, RegenerationSetting_Phase4) == 0x001830, "Member 'AEndBikeAIMotorBallController::RegenerationSetting_Phase4' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, AbilitySetID_Phase5) == 0x001850, "Member 'AEndBikeAIMotorBallController::AbilitySetID_Phase5' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, AbilitySetID_Phase5_StandUp) == 0x001858, "Member 'AEndBikeAIMotorBallController::AbilitySetID_Phase5_StandUp' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, AbilitySetIDs_Phase5_Mine) == 0x001860, "Member 'AEndBikeAIMotorBallController::AbilitySetIDs_Phase5_Mine' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, MineAbilityNum_Phase5) == 0x001870, "Member 'AEndBikeAIMotorBallController::MineAbilityNum_Phase5' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, AbilitySetID_Phase5_ShockWave) == 0x001874, "Member 'AEndBikeAIMotorBallController::AbilitySetID_Phase5_ShockWave' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, ShockWaveAbilityNum_Phase5) == 0x00187C, "Member 'AEndBikeAIMotorBallController::ShockWaveAbilityNum_Phase5' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, AbilitySetID_Phase5_Cannon) == 0x001880, "Member 'AEndBikeAIMotorBallController::AbilitySetID_Phase5_Cannon' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, CannonAbilitySetting_Phase5) == 0x001888, "Member 'AEndBikeAIMotorBallController::CannonAbilitySetting_Phase5' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, BarrierPartsSetting_Phase5) == 0x0018B4, "Member 'AEndBikeAIMotorBallController::BarrierPartsSetting_Phase5' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Time_ToChase_Phase5) == 0x0018C4, "Member 'AEndBikeAIMotorBallController::Time_ToChase_Phase5' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Distance_Chase_Max_Phase5) == 0x0018C8, "Member 'AEndBikeAIMotorBallController::Distance_Chase_Max_Phase5' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, RunSpeed_Chase_Phase5) == 0x0018CC, "Member 'AEndBikeAIMotorBallController::RunSpeed_Chase_Phase5' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Distance_EndChase_Phase5) == 0x0018D0, "Member 'AEndBikeAIMotorBallController::Distance_EndChase_Phase5' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Time_EndChase_Phase5) == 0x0018D4, "Member 'AEndBikeAIMotorBallController::Time_EndChase_Phase5' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Times_EndChase_Phase5_Easy) == 0x0018D8, "Member 'AEndBikeAIMotorBallController::Times_EndChase_Phase5_Easy' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Times_EndChase_Phase5_Normal) == 0x0018E8, "Member 'AEndBikeAIMotorBallController::Times_EndChase_Phase5_Normal' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, RegenerationSetting_Phase5) == 0x0018F8, "Member 'AEndBikeAIMotorBallController::RegenerationSetting_Phase5' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, Distance_RemoteDetonation) == 0x001918, "Member 'AEndBikeAIMotorBallController::Distance_RemoteDetonation' has a wrong offset!");
static_assert(offsetof(AEndBikeAIMotorBallController, DamageSourceIDs_RemoteDetonation) == 0x001920, "Member 'AEndBikeAIMotorBallController::DamageSourceIDs_RemoteDetonation' has a wrong offset!");

// Class EndGame.EndTrialOrderWindow
// 0x0008 (0x0370 - 0x0368)
class UEndTrialOrderWindow final : public UEndSimpleMenu
{
public:
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BtnDeluxeOnClicked();
	void BtnNormalOnClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndTrialOrderWindow">();
	}
	static class UEndTrialOrderWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndTrialOrderWindow>();
	}
};
static_assert(alignof(UEndTrialOrderWindow) == 0x000008, "Wrong alignment on UEndTrialOrderWindow");
static_assert(sizeof(UEndTrialOrderWindow) == 0x000370, "Wrong size on UEndTrialOrderWindow");

// Class EndGame.EndBTTask_BahamutMoveTo
// 0x0098 (0x0108 - 0x0070)
class UEndBTTask_BahamutMoveTo final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 LocationBlackboardKey;                             // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 LookAtBlackboardKey;                               // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)
	EEndQueryFilterType                           NavQueryFilterType;                                // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ArrivalRadius;                                     // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopMoveWhenFinished;                              // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MoveRequestBlackBoardName;                         // 0x00CC(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightTolerance;                                   // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightAdjustTolerance;                             // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StuckTimeLimit;                                    // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveTimeLimit;                                     // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x18];                                      // 0x00F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_BahamutMoveTo">();
	}
	static class UEndBTTask_BahamutMoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_BahamutMoveTo>();
	}
};
static_assert(alignof(UEndBTTask_BahamutMoveTo) == 0x000008, "Wrong alignment on UEndBTTask_BahamutMoveTo");
static_assert(sizeof(UEndBTTask_BahamutMoveTo) == 0x000108, "Wrong size on UEndBTTask_BahamutMoveTo");
static_assert(offsetof(UEndBTTask_BahamutMoveTo, LocationBlackboardKey) == 0x000070, "Member 'UEndBTTask_BahamutMoveTo::LocationBlackboardKey' has a wrong offset!");
static_assert(offsetof(UEndBTTask_BahamutMoveTo, LookAtBlackboardKey) == 0x000098, "Member 'UEndBTTask_BahamutMoveTo::LookAtBlackboardKey' has a wrong offset!");
static_assert(offsetof(UEndBTTask_BahamutMoveTo, NavQueryFilterType) == 0x0000C0, "Member 'UEndBTTask_BahamutMoveTo::NavQueryFilterType' has a wrong offset!");
static_assert(offsetof(UEndBTTask_BahamutMoveTo, ArrivalRadius) == 0x0000C4, "Member 'UEndBTTask_BahamutMoveTo::ArrivalRadius' has a wrong offset!");
static_assert(offsetof(UEndBTTask_BahamutMoveTo, StopMoveWhenFinished) == 0x0000C8, "Member 'UEndBTTask_BahamutMoveTo::StopMoveWhenFinished' has a wrong offset!");
static_assert(offsetof(UEndBTTask_BahamutMoveTo, MoveRequestBlackBoardName) == 0x0000CC, "Member 'UEndBTTask_BahamutMoveTo::MoveRequestBlackBoardName' has a wrong offset!");
static_assert(offsetof(UEndBTTask_BahamutMoveTo, HeightTolerance) == 0x0000D4, "Member 'UEndBTTask_BahamutMoveTo::HeightTolerance' has a wrong offset!");
static_assert(offsetof(UEndBTTask_BahamutMoveTo, HeightAdjustTolerance) == 0x0000D8, "Member 'UEndBTTask_BahamutMoveTo::HeightAdjustTolerance' has a wrong offset!");
static_assert(offsetof(UEndBTTask_BahamutMoveTo, FilterClass) == 0x0000E0, "Member 'UEndBTTask_BahamutMoveTo::FilterClass' has a wrong offset!");
static_assert(offsetof(UEndBTTask_BahamutMoveTo, StuckTimeLimit) == 0x0000E8, "Member 'UEndBTTask_BahamutMoveTo::StuckTimeLimit' has a wrong offset!");
static_assert(offsetof(UEndBTTask_BahamutMoveTo, MoveTimeLimit) == 0x0000EC, "Member 'UEndBTTask_BahamutMoveTo::MoveTimeLimit' has a wrong offset!");

// Class EndGame.EndBikeAISecuritySoldierController
// 0x0010 (0x0F90 - 0x0F80)
class AEndBikeAISecuritySoldierController final : public AEndBikeAIControllerEnemyBase
{
public:
	uint8                                         Pad_F80[0x10];                                     // 0x0F80(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikeAISecuritySoldierController">();
	}
	static class AEndBikeAISecuritySoldierController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBikeAISecuritySoldierController>();
	}
};
static_assert(alignof(AEndBikeAISecuritySoldierController) == 0x000008, "Wrong alignment on AEndBikeAISecuritySoldierController");
static_assert(sizeof(AEndBikeAISecuritySoldierController) == 0x000F90, "Wrong size on AEndBikeAISecuritySoldierController");

// Class EndGame.EndBikeAISecuritySoldierSeniorController
// 0x0000 (0x0F80 - 0x0F80)
class AEndBikeAISecuritySoldierSeniorController final : public AEndBikeAIControllerEnemyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikeAISecuritySoldierSeniorController">();
	}
	static class AEndBikeAISecuritySoldierSeniorController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBikeAISecuritySoldierSeniorController>();
	}
};
static_assert(alignof(AEndBikeAISecuritySoldierSeniorController) == 0x000008, "Wrong alignment on AEndBikeAISecuritySoldierSeniorController");
static_assert(sizeof(AEndBikeAISecuritySoldierSeniorController) == 0x000F80, "Wrong size on AEndBikeAISecuritySoldierSeniorController");

// Class EndGame.EndFieldActionActorBarCounter
// 0x0098 (0x06B0 - 0x0618)
class AEndFieldActionActorBarCounter final : public AEndFieldActionActorBase
{
public:
	class FName                                   EnvActorName;                                      // 0x0618(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        EnterVolume;                                       // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        ExitVolume;                                        // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndSwitchAreaBoxComponent*             DividedVersatileVolume;                            // 0x0630(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndSwitchAreaBoxComponent*             DividedImpassableVolume;                           // 0x0638(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0640(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_648[0x68];                                     // 0x0648(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorBarCounter">();
	}
	static class AEndFieldActionActorBarCounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorBarCounter>();
	}
};
static_assert(alignof(AEndFieldActionActorBarCounter) == 0x000008, "Wrong alignment on AEndFieldActionActorBarCounter");
static_assert(sizeof(AEndFieldActionActorBarCounter) == 0x0006B0, "Wrong size on AEndFieldActionActorBarCounter");
static_assert(offsetof(AEndFieldActionActorBarCounter, EnvActorName) == 0x000618, "Member 'AEndFieldActionActorBarCounter::EnvActorName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBarCounter, EnterVolume) == 0x000620, "Member 'AEndFieldActionActorBarCounter::EnterVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBarCounter, ExitVolume) == 0x000628, "Member 'AEndFieldActionActorBarCounter::ExitVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBarCounter, DividedVersatileVolume) == 0x000630, "Member 'AEndFieldActionActorBarCounter::DividedVersatileVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBarCounter, DividedImpassableVolume) == 0x000638, "Member 'AEndFieldActionActorBarCounter::DividedImpassableVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBarCounter, ModifierVolume) == 0x000640, "Member 'AEndFieldActionActorBarCounter::ModifierVolume' has a wrong offset!");

// Class EndGame.EndBikeAISoldier3rdController
// 0x0100 (0x1080 - 0x0F80)
class AEndBikeAISoldier3rdController final : public AEndBikeAIControllerEnemyBase
{
public:
	struct FEndBikeAISoldier3rdParameter          mParameter;                                        // 0x0F80(0x0078)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FEndBikeAISoldier3rdAbilitySet         AbilitySetForPlayer;                               // 0x0FF8(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FEndBikeAISoldier3rdAbilitySet         AbilitySetForAlly;                                 // 0x1008(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AEndBikeAISoldier3rdController*> mFriends;                                          // 0x1018(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1028[0x58];                                    // 0x1028(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikeAISoldier3rdController">();
	}
	static class AEndBikeAISoldier3rdController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBikeAISoldier3rdController>();
	}
};
static_assert(alignof(AEndBikeAISoldier3rdController) == 0x000008, "Wrong alignment on AEndBikeAISoldier3rdController");
static_assert(sizeof(AEndBikeAISoldier3rdController) == 0x001080, "Wrong size on AEndBikeAISoldier3rdController");
static_assert(offsetof(AEndBikeAISoldier3rdController, mParameter) == 0x000F80, "Member 'AEndBikeAISoldier3rdController::mParameter' has a wrong offset!");
static_assert(offsetof(AEndBikeAISoldier3rdController, AbilitySetForPlayer) == 0x000FF8, "Member 'AEndBikeAISoldier3rdController::AbilitySetForPlayer' has a wrong offset!");
static_assert(offsetof(AEndBikeAISoldier3rdController, AbilitySetForAlly) == 0x001008, "Member 'AEndBikeAISoldier3rdController::AbilitySetForAlly' has a wrong offset!");
static_assert(offsetof(AEndBikeAISoldier3rdController, mFriends) == 0x001018, "Member 'AEndBikeAISoldier3rdController::mFriends' has a wrong offset!");

// Class EndGame.EndButton
// 0x02F8 (0x0408 - 0x0110)
class UEndButton final : public UContentWidget
{
public:
	struct FButtonStyle                           WidgetStyle;                                       // 0x0110(0x0238)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorAndOpacity;                                   // 0x0348(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BackgroundColor;                                   // 0x0358(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EButtonClickMethod                            ClickMethod;                                       // 0x0368(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EButtonTouchMethod                            TouchMethod;                                       // 0x0369(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EButtonPressMethod                            PressMethod;                                       // 0x036A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFocusable;                                       // 0x036B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsForceHovered;                                    // 0x036C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanPress;                                          // 0x036D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreKeyRepeat;                                   // 0x036E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36F[0x1];                                      // 0x036F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HelpText;                                          // 0x0370(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GuideText;                                         // 0x0380(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateSound                            ErrorSlateSound;                                   // 0x0390(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnClicked;                                         // 0x03A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPressed;                                         // 0x03B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnReleased;                                        // 0x03C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnHovered;                                         // 0x03D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnUnhovered;                                       // 0x03E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F8[0x10];                                     // 0x03F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Press();
	void Release();
	void SetBackgroundColor(const struct FLinearColor& InBackgroundColor);
	void SetCanPress(bool bInCanPress);
	void SetClickMethod(EButtonClickMethod InClickMethod);
	void SetColorAndOpacity(const struct FLinearColor& InColorAndOpacity);
	void SetForceHovered(bool bInHovered);
	void SetGuideText(const class FString& InText);
	void SetHelpText(const class FString& InText);
	void SetIgnoreKeyRepeat(bool bInIgnoreKeyRepeat);
	void SetIsFocusable(bool bInIsFocusable);
	void SetPressMethod(EButtonPressMethod InPressMethod);
	void SetStyle(const struct FButtonStyle& InStyle);
	void SetTouchMethod(EButtonTouchMethod InTouchMethod);

	bool GetCanPress() const;
	bool GetIgnoreKeyRepeat() const;
	bool GetIsFocusable() const;
	bool GetIsForceHovered() const;
	bool IsPressed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndButton">();
	}
	static class UEndButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndButton>();
	}
};
static_assert(alignof(UEndButton) == 0x000008, "Wrong alignment on UEndButton");
static_assert(sizeof(UEndButton) == 0x000408, "Wrong size on UEndButton");
static_assert(offsetof(UEndButton, WidgetStyle) == 0x000110, "Member 'UEndButton::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UEndButton, ColorAndOpacity) == 0x000348, "Member 'UEndButton::ColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UEndButton, BackgroundColor) == 0x000358, "Member 'UEndButton::BackgroundColor' has a wrong offset!");
static_assert(offsetof(UEndButton, ClickMethod) == 0x000368, "Member 'UEndButton::ClickMethod' has a wrong offset!");
static_assert(offsetof(UEndButton, TouchMethod) == 0x000369, "Member 'UEndButton::TouchMethod' has a wrong offset!");
static_assert(offsetof(UEndButton, PressMethod) == 0x00036A, "Member 'UEndButton::PressMethod' has a wrong offset!");
static_assert(offsetof(UEndButton, IsFocusable) == 0x00036B, "Member 'UEndButton::IsFocusable' has a wrong offset!");
static_assert(offsetof(UEndButton, IsForceHovered) == 0x00036C, "Member 'UEndButton::IsForceHovered' has a wrong offset!");
static_assert(offsetof(UEndButton, CanPress) == 0x00036D, "Member 'UEndButton::CanPress' has a wrong offset!");
static_assert(offsetof(UEndButton, IgnoreKeyRepeat) == 0x00036E, "Member 'UEndButton::IgnoreKeyRepeat' has a wrong offset!");
static_assert(offsetof(UEndButton, HelpText) == 0x000370, "Member 'UEndButton::HelpText' has a wrong offset!");
static_assert(offsetof(UEndButton, GuideText) == 0x000380, "Member 'UEndButton::GuideText' has a wrong offset!");
static_assert(offsetof(UEndButton, ErrorSlateSound) == 0x000390, "Member 'UEndButton::ErrorSlateSound' has a wrong offset!");
static_assert(offsetof(UEndButton, OnClicked) == 0x0003A8, "Member 'UEndButton::OnClicked' has a wrong offset!");
static_assert(offsetof(UEndButton, OnPressed) == 0x0003B8, "Member 'UEndButton::OnPressed' has a wrong offset!");
static_assert(offsetof(UEndButton, OnReleased) == 0x0003C8, "Member 'UEndButton::OnReleased' has a wrong offset!");
static_assert(offsetof(UEndButton, OnHovered) == 0x0003D8, "Member 'UEndButton::OnHovered' has a wrong offset!");
static_assert(offsetof(UEndButton, OnUnhovered) == 0x0003E8, "Member 'UEndButton::OnUnhovered' has a wrong offset!");

// Class EndGame.EndBikeAIStunRayMothController
// 0x0018 (0x1030 - 0x1018)
class AEndBikeAIStunRayMothController final : public AEndBikeAIStunRayController
{
public:
	class AEndBikeAIMothSlasherController*        mMothSlasherAI;                                    // 0x1018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1020[0x10];                                    // 0x1020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikeAIStunRayMothController">();
	}
	static class AEndBikeAIStunRayMothController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBikeAIStunRayMothController>();
	}
};
static_assert(alignof(AEndBikeAIStunRayMothController) == 0x000008, "Wrong alignment on AEndBikeAIStunRayMothController");
static_assert(sizeof(AEndBikeAIStunRayMothController) == 0x001030, "Wrong size on AEndBikeAIStunRayMothController");
static_assert(offsetof(AEndBikeAIStunRayMothController, mMothSlasherAI) == 0x001018, "Member 'AEndBikeAIStunRayMothController::mMothSlasherAI' has a wrong offset!");

// Class EndGame.EndBikeAIStunRayTaserGunController
// 0x0038 (0x1050 - 0x1018)
class AEndBikeAIStunRayTaserGunController final : public AEndBikeAIStunRayController
{
public:
	struct FEndBikeAIFunnelMoveParameter          FunnelMovementParam;                               // 0x1018(0x0028)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1040[0x10];                                    // 0x1040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikeAIStunRayTaserGunController">();
	}
	static class AEndBikeAIStunRayTaserGunController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBikeAIStunRayTaserGunController>();
	}
};
static_assert(alignof(AEndBikeAIStunRayTaserGunController) == 0x000008, "Wrong alignment on AEndBikeAIStunRayTaserGunController");
static_assert(sizeof(AEndBikeAIStunRayTaserGunController) == 0x001050, "Wrong size on AEndBikeAIStunRayTaserGunController");
static_assert(offsetof(AEndBikeAIStunRayTaserGunController, FunnelMovementParam) == 0x001018, "Member 'AEndBikeAIStunRayTaserGunController::FunnelMovementParam' has a wrong offset!");

// Class EndGame.EndBikeAITruckController
// 0x0220 (0x11A0 - 0x0F80)
class AEndBikeAITruckController final : public AEndBikeAIControllerEnemyBase
{
public:
	struct FEndBikeAITruckParameter               mParameter;                                        // 0x0F80(0x00D8)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TArray<struct FEndBikeAITruckDamageLoopEffectParam> DamageLoopEffectParamList;                         // 0x1058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         CutSceneLength;                                    // 0x1068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_106C[0x134];                                   // 0x106C(0x0134)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikeAITruckController">();
	}
	static class AEndBikeAITruckController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBikeAITruckController>();
	}
};
static_assert(alignof(AEndBikeAITruckController) == 0x000008, "Wrong alignment on AEndBikeAITruckController");
static_assert(sizeof(AEndBikeAITruckController) == 0x0011A0, "Wrong size on AEndBikeAITruckController");
static_assert(offsetof(AEndBikeAITruckController, mParameter) == 0x000F80, "Member 'AEndBikeAITruckController::mParameter' has a wrong offset!");
static_assert(offsetof(AEndBikeAITruckController, DamageLoopEffectParamList) == 0x001058, "Member 'AEndBikeAITruckController::DamageLoopEffectParamList' has a wrong offset!");
static_assert(offsetof(AEndBikeAITruckController, CutSceneLength) == 0x001068, "Member 'AEndBikeAITruckController::CutSceneLength' has a wrong offset!");

// Class EndGame.EndCameraLockNotify
// 0x0008 (0x0040 - 0x0038)
class UEndCameraLockNotify final : public UAnimNotify
{
public:
	float                                         LockTime;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCameraLockNotify">();
	}
	static class UEndCameraLockNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndCameraLockNotify>();
	}
};
static_assert(alignof(UEndCameraLockNotify) == 0x000008, "Wrong alignment on UEndCameraLockNotify");
static_assert(sizeof(UEndCameraLockNotify) == 0x000040, "Wrong size on UEndCameraLockNotify");
static_assert(offsetof(UEndCameraLockNotify, LockTime) == 0x000038, "Member 'UEndCameraLockNotify::LockTime' has a wrong offset!");

// Class EndGame.EndBikeEndlessPopupComponent
// 0x0140 (0x0238 - 0x00F8)
class UEndBikeEndlessPopupComponent final : public UActorComponent
{
public:
	uint8                                         Pad_F8[0x130];                                     // 0x00F8(0x0130)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndBikePopupComponent*                 pPopupComponent;                                   // 0x0228(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikeEndlessPopupComponent">();
	}
	static class UEndBikeEndlessPopupComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBikeEndlessPopupComponent>();
	}
};
static_assert(alignof(UEndBikeEndlessPopupComponent) == 0x000008, "Wrong alignment on UEndBikeEndlessPopupComponent");
static_assert(sizeof(UEndBikeEndlessPopupComponent) == 0x000238, "Wrong size on UEndBikeEndlessPopupComponent");
static_assert(offsetof(UEndBikeEndlessPopupComponent, pPopupComponent) == 0x000228, "Member 'UEndBikeEndlessPopupComponent::pPopupComponent' has a wrong offset!");

// Class EndGame.EndBikeNormalPopupComponent
// 0x0228 (0x0320 - 0x00F8)
class UEndBikeNormalPopupComponent final : public UActorComponent
{
public:
	uint8                                         Pad_F8[0x218];                                     // 0x00F8(0x0218)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndBikePopupComponent*                 pPopupComponent;                                   // 0x0310(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikeNormalPopupComponent">();
	}
	static class UEndBikeNormalPopupComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBikeNormalPopupComponent>();
	}
};
static_assert(alignof(UEndBikeNormalPopupComponent) == 0x000008, "Wrong alignment on UEndBikeNormalPopupComponent");
static_assert(sizeof(UEndBikeNormalPopupComponent) == 0x000320, "Wrong size on UEndBikeNormalPopupComponent");
static_assert(offsetof(UEndBikeNormalPopupComponent, pPopupComponent) == 0x000310, "Member 'UEndBikeNormalPopupComponent::pPopupComponent' has a wrong offset!");

// Class EndGame.EndBikePopupComponent
// 0x0138 (0x0230 - 0x00F8)
class UEndBikePopupComponent final : public UActorComponent
{
public:
	uint8                                         Pad_F8[0x138];                                     // 0x00F8(0x0138)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikePopupComponent">();
	}
	static class UEndBikePopupComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBikePopupComponent>();
	}
};
static_assert(alignof(UEndBikePopupComponent) == 0x000008, "Wrong alignment on UEndBikePopupComponent");
static_assert(sizeof(UEndBikePopupComponent) == 0x000230, "Wrong size on UEndBikePopupComponent");

// Class EndGame.EndBikeSpline
// 0x0010 (0x0388 - 0x0378)
class AEndBikeSpline final : public AActor
{
public:
	class UEndBikeSplineComponent*                mSplineComponent;                                  // 0x0378(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsLoop;                                            // 0x0380(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_381[0x7];                                      // 0x0381(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikeSpline">();
	}
	static class AEndBikeSpline* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBikeSpline>();
	}
};
static_assert(alignof(AEndBikeSpline) == 0x000008, "Wrong alignment on AEndBikeSpline");
static_assert(sizeof(AEndBikeSpline) == 0x000388, "Wrong size on AEndBikeSpline");
static_assert(offsetof(AEndBikeSpline, mSplineComponent) == 0x000378, "Member 'AEndBikeSpline::mSplineComponent' has a wrong offset!");
static_assert(offsetof(AEndBikeSpline, IsLoop) == 0x000380, "Member 'AEndBikeSpline::IsLoop' has a wrong offset!");

// Class EndGame.EndCapsuleOverlapComponent
// 0x0150 (0x0248 - 0x00F8)
class UEndCapsuleOverlapComponent final : public UActorComponent
{
public:
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x0100(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x140];                                    // 0x0108(0x0140)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCapsuleOverlapComponent">();
	}
	static class UEndCapsuleOverlapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndCapsuleOverlapComponent>();
	}
};
static_assert(alignof(UEndCapsuleOverlapComponent) == 0x000008, "Wrong alignment on UEndCapsuleOverlapComponent");
static_assert(sizeof(UEndCapsuleOverlapComponent) == 0x000248, "Wrong size on UEndCapsuleOverlapComponent");
static_assert(offsetof(UEndCapsuleOverlapComponent, CapsuleComponent) == 0x000100, "Member 'UEndCapsuleOverlapComponent::CapsuleComponent' has a wrong offset!");

// Class EndGame.EndBikeSplineComponent
// 0x0030 (0x0810 - 0x07E0)
class UEndBikeSplineComponent final : public USplineComponent
{
public:
	TArray<struct FEndBikeSplineMetaData>         SplineMetaData;                                    // 0x07E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FEndBikeSplineJumpAreaData>     SplineJumpAreaData;                                // 0x07F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class FName                                   NextSplineID;                                      // 0x0800(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_808[0x8];                                      // 0x0808(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikeSplineComponent">();
	}
	static class UEndBikeSplineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBikeSplineComponent>();
	}
};
static_assert(alignof(UEndBikeSplineComponent) == 0x000010, "Wrong alignment on UEndBikeSplineComponent");
static_assert(sizeof(UEndBikeSplineComponent) == 0x000810, "Wrong size on UEndBikeSplineComponent");
static_assert(offsetof(UEndBikeSplineComponent, SplineMetaData) == 0x0007E0, "Member 'UEndBikeSplineComponent::SplineMetaData' has a wrong offset!");
static_assert(offsetof(UEndBikeSplineComponent, SplineJumpAreaData) == 0x0007F0, "Member 'UEndBikeSplineComponent::SplineJumpAreaData' has a wrong offset!");
static_assert(offsetof(UEndBikeSplineComponent, NextSplineID) == 0x000800, "Member 'UEndBikeSplineComponent::NextSplineID' has a wrong offset!");

// Class EndGame.EndBikeTriggerBoxLoccheBreakBridge
// 0x0008 (0x0388 - 0x0380)
class AEndBikeTriggerBoxLoccheBreakBridge final : public ATriggerBox
{
public:
	class AEndCharacter*                          mTarget;                                           // 0x0380(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikeTriggerBoxLoccheBreakBridge">();
	}
	static class AEndBikeTriggerBoxLoccheBreakBridge* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBikeTriggerBoxLoccheBreakBridge>();
	}
};
static_assert(alignof(AEndBikeTriggerBoxLoccheBreakBridge) == 0x000008, "Wrong alignment on AEndBikeTriggerBoxLoccheBreakBridge");
static_assert(sizeof(AEndBikeTriggerBoxLoccheBreakBridge) == 0x000388, "Wrong size on AEndBikeTriggerBoxLoccheBreakBridge");
static_assert(offsetof(AEndBikeTriggerBoxLoccheBreakBridge, mTarget) == 0x000380, "Member 'AEndBikeTriggerBoxLoccheBreakBridge::mTarget' has a wrong offset!");

// Class EndGame.EndDataObjectBattleAICharaSpec
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleAICharaSpec final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleAICharaSpec">();
	}
	static class UEndDataObjectBattleAICharaSpec* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleAICharaSpec>();
	}
};
static_assert(alignof(UEndDataObjectBattleAICharaSpec) == 0x000008, "Wrong alignment on UEndDataObjectBattleAICharaSpec");
static_assert(sizeof(UEndDataObjectBattleAICharaSpec) == 0x000088, "Wrong size on UEndDataObjectBattleAICharaSpec");

// Class EndGame.EndBikeTriggerBoxSavePhysActor
// 0x0068 (0x03E8 - 0x0380)
class AEndBikeTriggerBoxSavePhysActor final : public ATriggerBox
{
public:
	class AEndCharacter*                          mTriggerTarget;                                    // 0x0380(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           TargetLevels;                                      // 0x0388(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	uint8                                         Pad_398[0x50];                                     // 0x0398(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikeTriggerBoxSavePhysActor">();
	}
	static class AEndBikeTriggerBoxSavePhysActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBikeTriggerBoxSavePhysActor>();
	}
};
static_assert(alignof(AEndBikeTriggerBoxSavePhysActor) == 0x000008, "Wrong alignment on AEndBikeTriggerBoxSavePhysActor");
static_assert(sizeof(AEndBikeTriggerBoxSavePhysActor) == 0x0003E8, "Wrong size on AEndBikeTriggerBoxSavePhysActor");
static_assert(offsetof(AEndBikeTriggerBoxSavePhysActor, mTriggerTarget) == 0x000380, "Member 'AEndBikeTriggerBoxSavePhysActor::mTriggerTarget' has a wrong offset!");
static_assert(offsetof(AEndBikeTriggerBoxSavePhysActor, TargetLevels) == 0x000388, "Member 'AEndBikeTriggerBoxSavePhysActor::TargetLevels' has a wrong offset!");

// Class EndGame.EndBikeZeroOneSeComponent
// 0x0400 (0x04F8 - 0x00F8)
class UEndBikeZeroOneSeComponent final : public UActorComponent
{
public:
	struct FBikeSeAsset                           Engine;                                            // 0x00F8(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBikeSeAsset                           Accel;                                             // 0x0140(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBikeSeAsset                           AccelOff;                                          // 0x0188(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBikeSeAsset                           Traveling;                                         // 0x01D0(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBikeSeAsset                           Landing;                                           // 0x0218(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBikeSeAsset                           Body;                                              // 0x0260(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBikeSeAsset                           HitWall;                                           // 0x02A8(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBikeSeAsset                           HitObject;                                         // 0x02F0(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         VelocityZeroOneFadeTime;                           // 0x0338(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAccelModifier                         EngineModifier;                                    // 0x033C(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FAccelModifier                         ExhaustionModifier;                                // 0x039C(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         BodyRoughnessThreshold;                            // 0x03FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomPitchRange;                                  // 0x0400(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_404[0xF4];                                     // 0x0404(0x00F4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBikeZeroOneSeComponent">();
	}
	static class UEndBikeZeroOneSeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBikeZeroOneSeComponent>();
	}
};
static_assert(alignof(UEndBikeZeroOneSeComponent) == 0x000008, "Wrong alignment on UEndBikeZeroOneSeComponent");
static_assert(sizeof(UEndBikeZeroOneSeComponent) == 0x0004F8, "Wrong size on UEndBikeZeroOneSeComponent");
static_assert(offsetof(UEndBikeZeroOneSeComponent, Engine) == 0x0000F8, "Member 'UEndBikeZeroOneSeComponent::Engine' has a wrong offset!");
static_assert(offsetof(UEndBikeZeroOneSeComponent, Accel) == 0x000140, "Member 'UEndBikeZeroOneSeComponent::Accel' has a wrong offset!");
static_assert(offsetof(UEndBikeZeroOneSeComponent, AccelOff) == 0x000188, "Member 'UEndBikeZeroOneSeComponent::AccelOff' has a wrong offset!");
static_assert(offsetof(UEndBikeZeroOneSeComponent, Traveling) == 0x0001D0, "Member 'UEndBikeZeroOneSeComponent::Traveling' has a wrong offset!");
static_assert(offsetof(UEndBikeZeroOneSeComponent, Landing) == 0x000218, "Member 'UEndBikeZeroOneSeComponent::Landing' has a wrong offset!");
static_assert(offsetof(UEndBikeZeroOneSeComponent, Body) == 0x000260, "Member 'UEndBikeZeroOneSeComponent::Body' has a wrong offset!");
static_assert(offsetof(UEndBikeZeroOneSeComponent, HitWall) == 0x0002A8, "Member 'UEndBikeZeroOneSeComponent::HitWall' has a wrong offset!");
static_assert(offsetof(UEndBikeZeroOneSeComponent, HitObject) == 0x0002F0, "Member 'UEndBikeZeroOneSeComponent::HitObject' has a wrong offset!");
static_assert(offsetof(UEndBikeZeroOneSeComponent, VelocityZeroOneFadeTime) == 0x000338, "Member 'UEndBikeZeroOneSeComponent::VelocityZeroOneFadeTime' has a wrong offset!");
static_assert(offsetof(UEndBikeZeroOneSeComponent, EngineModifier) == 0x00033C, "Member 'UEndBikeZeroOneSeComponent::EngineModifier' has a wrong offset!");
static_assert(offsetof(UEndBikeZeroOneSeComponent, ExhaustionModifier) == 0x00039C, "Member 'UEndBikeZeroOneSeComponent::ExhaustionModifier' has a wrong offset!");
static_assert(offsetof(UEndBikeZeroOneSeComponent, BodyRoughnessThreshold) == 0x0003FC, "Member 'UEndBikeZeroOneSeComponent::BodyRoughnessThreshold' has a wrong offset!");
static_assert(offsetof(UEndBikeZeroOneSeComponent, RandomPitchRange) == 0x000400, "Member 'UEndBikeZeroOneSeComponent::RandomPitchRange' has a wrong offset!");

// Class EndGame.EndBillboard
// 0x01C0 (0x02B8 - 0x00F8)
class UEndBillboard final : public UWidget
{
public:
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ImagePath;                                         // 0x0100(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ImageSize;                                         // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            TintColor;                                         // 0x0120(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	ESlateBrushDrawType                           DrawAs;                                            // 0x0148(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateBrushTileType                           Tiling;                                            // 0x0149(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14A[0x2];                                      // 0x014A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ColorAndOpacity;                                   // 0x014C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             ColorAndOpacityDelegate;                           // 0x0160(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	EBlendMode                                    BlendMode;                                         // 0x0170(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(const struct FGeometry& MyGeometry, struct FPointerEvent& MouseEvent)> OnMouseButtonDownEvent;                            // 0x0178(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_188[0xA8];                                     // 0x0188(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Brush;                                             // 0x0230(0x0078)(Transient, Protected, NativeAccessSpecifierProtected)
	class UEndUserWidget*                         Throbber;                                          // 0x02A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBlendMode(EBlendMode InBlendMode);
	void SetColorAndOpacity(const struct FLinearColor& InColorAndOpacity);
	void SetImagePath(const struct FSoftObjectPath& InImagePath, bool bInRewind);
	void SetOpacity(float InOpacity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBillboard">();
	}
	static class UEndBillboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBillboard>();
	}
};
static_assert(alignof(UEndBillboard) == 0x000008, "Wrong alignment on UEndBillboard");
static_assert(sizeof(UEndBillboard) == 0x0002B8, "Wrong size on UEndBillboard");
static_assert(offsetof(UEndBillboard, ImagePath) == 0x000100, "Member 'UEndBillboard::ImagePath' has a wrong offset!");
static_assert(offsetof(UEndBillboard, ImageSize) == 0x000118, "Member 'UEndBillboard::ImageSize' has a wrong offset!");
static_assert(offsetof(UEndBillboard, TintColor) == 0x000120, "Member 'UEndBillboard::TintColor' has a wrong offset!");
static_assert(offsetof(UEndBillboard, DrawAs) == 0x000148, "Member 'UEndBillboard::DrawAs' has a wrong offset!");
static_assert(offsetof(UEndBillboard, Tiling) == 0x000149, "Member 'UEndBillboard::Tiling' has a wrong offset!");
static_assert(offsetof(UEndBillboard, ColorAndOpacity) == 0x00014C, "Member 'UEndBillboard::ColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UEndBillboard, ColorAndOpacityDelegate) == 0x000160, "Member 'UEndBillboard::ColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UEndBillboard, BlendMode) == 0x000170, "Member 'UEndBillboard::BlendMode' has a wrong offset!");
static_assert(offsetof(UEndBillboard, OnMouseButtonDownEvent) == 0x000178, "Member 'UEndBillboard::OnMouseButtonDownEvent' has a wrong offset!");
static_assert(offsetof(UEndBillboard, Brush) == 0x000230, "Member 'UEndBillboard::Brush' has a wrong offset!");
static_assert(offsetof(UEndBillboard, Throbber) == 0x0002A8, "Member 'UEndBillboard::Throbber' has a wrong offset!");

// Class EndGame.EndDataObjectBattleCameraSequence
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleCameraSequence final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleCameraSequence">();
	}
	static class UEndDataObjectBattleCameraSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleCameraSequence>();
	}
};
static_assert(alignof(UEndDataObjectBattleCameraSequence) == 0x000008, "Wrong alignment on UEndDataObjectBattleCameraSequence");
static_assert(sizeof(UEndDataObjectBattleCameraSequence) == 0x000088, "Wrong size on UEndDataObjectBattleCameraSequence");

// Class EndGame.EndBonamikBoxScaleGroupParamsActor
// 0x0078 (0x0428 - 0x03B0)
class AEndBonamikBoxScaleGroupParamsActor final : public AVolume
{
public:
	TArray<class FString>                         m_Groups;                                          // 0x03B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          m_ChangeInnerCone;                                 // 0x03C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C1[0x3];                                      // 0x03C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         m_InnerConeScale;                                  // 0x03C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_ChangeOuterCone;                                 // 0x03C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C9[0x3];                                      // 0x03C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         m_OuterConeScale;                                  // 0x03CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_ChangeLocalForce;                                // 0x03D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D1[0x3];                                      // 0x03D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         m_LocalForceScale;                                 // 0x03D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_ChangeWindScale;                                 // 0x03D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D9[0x3];                                      // 0x03D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         m_GroupWindScale;                                  // 0x03DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_ChangeCharaWindScale;                            // 0x03E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E1[0x3];                                      // 0x03E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         m_GroupCharaWindScale;                             // 0x03E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_ChangeMassScale;                                 // 0x03E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E9[0x3];                                      // 0x03E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         m_GroupMassScale;                                  // 0x03EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_ApplyToAttachments;                              // 0x03F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F1[0x37];                                     // 0x03F1(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBonamikBoxScaleGroupParamsActor">();
	}
	static class AEndBonamikBoxScaleGroupParamsActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBonamikBoxScaleGroupParamsActor>();
	}
};
static_assert(alignof(AEndBonamikBoxScaleGroupParamsActor) == 0x000008, "Wrong alignment on AEndBonamikBoxScaleGroupParamsActor");
static_assert(sizeof(AEndBonamikBoxScaleGroupParamsActor) == 0x000428, "Wrong size on AEndBonamikBoxScaleGroupParamsActor");
static_assert(offsetof(AEndBonamikBoxScaleGroupParamsActor, m_Groups) == 0x0003B0, "Member 'AEndBonamikBoxScaleGroupParamsActor::m_Groups' has a wrong offset!");
static_assert(offsetof(AEndBonamikBoxScaleGroupParamsActor, m_ChangeInnerCone) == 0x0003C0, "Member 'AEndBonamikBoxScaleGroupParamsActor::m_ChangeInnerCone' has a wrong offset!");
static_assert(offsetof(AEndBonamikBoxScaleGroupParamsActor, m_InnerConeScale) == 0x0003C4, "Member 'AEndBonamikBoxScaleGroupParamsActor::m_InnerConeScale' has a wrong offset!");
static_assert(offsetof(AEndBonamikBoxScaleGroupParamsActor, m_ChangeOuterCone) == 0x0003C8, "Member 'AEndBonamikBoxScaleGroupParamsActor::m_ChangeOuterCone' has a wrong offset!");
static_assert(offsetof(AEndBonamikBoxScaleGroupParamsActor, m_OuterConeScale) == 0x0003CC, "Member 'AEndBonamikBoxScaleGroupParamsActor::m_OuterConeScale' has a wrong offset!");
static_assert(offsetof(AEndBonamikBoxScaleGroupParamsActor, m_ChangeLocalForce) == 0x0003D0, "Member 'AEndBonamikBoxScaleGroupParamsActor::m_ChangeLocalForce' has a wrong offset!");
static_assert(offsetof(AEndBonamikBoxScaleGroupParamsActor, m_LocalForceScale) == 0x0003D4, "Member 'AEndBonamikBoxScaleGroupParamsActor::m_LocalForceScale' has a wrong offset!");
static_assert(offsetof(AEndBonamikBoxScaleGroupParamsActor, m_ChangeWindScale) == 0x0003D8, "Member 'AEndBonamikBoxScaleGroupParamsActor::m_ChangeWindScale' has a wrong offset!");
static_assert(offsetof(AEndBonamikBoxScaleGroupParamsActor, m_GroupWindScale) == 0x0003DC, "Member 'AEndBonamikBoxScaleGroupParamsActor::m_GroupWindScale' has a wrong offset!");
static_assert(offsetof(AEndBonamikBoxScaleGroupParamsActor, m_ChangeCharaWindScale) == 0x0003E0, "Member 'AEndBonamikBoxScaleGroupParamsActor::m_ChangeCharaWindScale' has a wrong offset!");
static_assert(offsetof(AEndBonamikBoxScaleGroupParamsActor, m_GroupCharaWindScale) == 0x0003E4, "Member 'AEndBonamikBoxScaleGroupParamsActor::m_GroupCharaWindScale' has a wrong offset!");
static_assert(offsetof(AEndBonamikBoxScaleGroupParamsActor, m_ChangeMassScale) == 0x0003E8, "Member 'AEndBonamikBoxScaleGroupParamsActor::m_ChangeMassScale' has a wrong offset!");
static_assert(offsetof(AEndBonamikBoxScaleGroupParamsActor, m_GroupMassScale) == 0x0003EC, "Member 'AEndBonamikBoxScaleGroupParamsActor::m_GroupMassScale' has a wrong offset!");
static_assert(offsetof(AEndBonamikBoxScaleGroupParamsActor, m_ApplyToAttachments) == 0x0003F0, "Member 'AEndBonamikBoxScaleGroupParamsActor::m_ApplyToAttachments' has a wrong offset!");

// Class EndGame.EndDataObjectBattleCharaLevel
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleCharaLevel final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleCharaLevel">();
	}
	static class UEndDataObjectBattleCharaLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleCharaLevel>();
	}
};
static_assert(alignof(UEndDataObjectBattleCharaLevel) == 0x000008, "Wrong alignment on UEndDataObjectBattleCharaLevel");
static_assert(sizeof(UEndDataObjectBattleCharaLevel) == 0x000088, "Wrong size on UEndDataObjectBattleCharaLevel");

// Class EndGame.EndBonamikBoxWindActor
// 0x0020 (0x03D0 - 0x03B0)
class AEndBonamikBoxWindActor final : public AVolume
{
public:
	class UEndBonamikWindData*                    WindData;                                          // 0x03B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x03B8(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C4[0x4];                                      // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USQEX_BonamikWind*                      BonamikWind;                                       // 0x03C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Activate();
	void Deactivate();

	bool IsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBonamikBoxWindActor">();
	}
	static class AEndBonamikBoxWindActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndBonamikBoxWindActor>();
	}
};
static_assert(alignof(AEndBonamikBoxWindActor) == 0x000008, "Wrong alignment on AEndBonamikBoxWindActor");
static_assert(sizeof(AEndBonamikBoxWindActor) == 0x0003D0, "Wrong size on AEndBonamikBoxWindActor");
static_assert(offsetof(AEndBonamikBoxWindActor, WindData) == 0x0003B0, "Member 'AEndBonamikBoxWindActor::WindData' has a wrong offset!");
static_assert(offsetof(AEndBonamikBoxWindActor, Direction) == 0x0003B8, "Member 'AEndBonamikBoxWindActor::Direction' has a wrong offset!");
static_assert(offsetof(AEndBonamikBoxWindActor, BonamikWind) == 0x0003C8, "Member 'AEndBonamikBoxWindActor::BonamikWind' has a wrong offset!");

// Class EndGame.EndBonamikBoxWindComponent
// 0x00B0 (0x07D0 - 0x0720)
class UEndBonamikBoxWindComponent final : public UBoxComponent
{
public:
	struct FBonamikBoxWindData                    WindData;                                          // 0x0720(0x0064)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0784(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AreaMargin;                                        // 0x0790(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_794[0x4];                                      // 0x0794(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USQEX_BonamikWind*                      BonamikWind;                                       // 0x0798(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7A0[0x30];                                     // 0x07A0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBonamikBoxWindComponent">();
	}
	static class UEndBonamikBoxWindComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBonamikBoxWindComponent>();
	}
};
static_assert(alignof(UEndBonamikBoxWindComponent) == 0x000010, "Wrong alignment on UEndBonamikBoxWindComponent");
static_assert(sizeof(UEndBonamikBoxWindComponent) == 0x0007D0, "Wrong size on UEndBonamikBoxWindComponent");
static_assert(offsetof(UEndBonamikBoxWindComponent, WindData) == 0x000720, "Member 'UEndBonamikBoxWindComponent::WindData' has a wrong offset!");
static_assert(offsetof(UEndBonamikBoxWindComponent, Direction) == 0x000784, "Member 'UEndBonamikBoxWindComponent::Direction' has a wrong offset!");
static_assert(offsetof(UEndBonamikBoxWindComponent, AreaMargin) == 0x000790, "Member 'UEndBonamikBoxWindComponent::AreaMargin' has a wrong offset!");
static_assert(offsetof(UEndBonamikBoxWindComponent, BonamikWind) == 0x000798, "Member 'UEndBonamikBoxWindComponent::BonamikWind' has a wrong offset!");

// Class EndGame.EndBonamikHelicopterWindComponent
// 0x0030 (0x02E0 - 0x02B0)
class UEndBonamikHelicopterWindComponent final : public USceneComponent
{
public:
	struct FBonamikHelicopterWindData             WindData;                                          // 0x02B0(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightMargin;                                      // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OuterPitchBottom;                                  // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightMarginStrengthScale;                         // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusMargin;                                      // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsWindActive;                                     // 0x02D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D5[0xB];                                      // 0x02D5(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBonamikHelicopterWindComponent">();
	}
	static class UEndBonamikHelicopterWindComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBonamikHelicopterWindComponent>();
	}
};
static_assert(alignof(UEndBonamikHelicopterWindComponent) == 0x000008, "Wrong alignment on UEndBonamikHelicopterWindComponent");
static_assert(sizeof(UEndBonamikHelicopterWindComponent) == 0x0002E0, "Wrong size on UEndBonamikHelicopterWindComponent");
static_assert(offsetof(UEndBonamikHelicopterWindComponent, WindData) == 0x0002B0, "Member 'UEndBonamikHelicopterWindComponent::WindData' has a wrong offset!");
static_assert(offsetof(UEndBonamikHelicopterWindComponent, HalfHeight) == 0x0002BC, "Member 'UEndBonamikHelicopterWindComponent::HalfHeight' has a wrong offset!");
static_assert(offsetof(UEndBonamikHelicopterWindComponent, HeightMargin) == 0x0002C0, "Member 'UEndBonamikHelicopterWindComponent::HeightMargin' has a wrong offset!");
static_assert(offsetof(UEndBonamikHelicopterWindComponent, OuterPitchBottom) == 0x0002C4, "Member 'UEndBonamikHelicopterWindComponent::OuterPitchBottom' has a wrong offset!");
static_assert(offsetof(UEndBonamikHelicopterWindComponent, HeightMarginStrengthScale) == 0x0002C8, "Member 'UEndBonamikHelicopterWindComponent::HeightMarginStrengthScale' has a wrong offset!");
static_assert(offsetof(UEndBonamikHelicopterWindComponent, Radius) == 0x0002CC, "Member 'UEndBonamikHelicopterWindComponent::Radius' has a wrong offset!");
static_assert(offsetof(UEndBonamikHelicopterWindComponent, RadiusMargin) == 0x0002D0, "Member 'UEndBonamikHelicopterWindComponent::RadiusMargin' has a wrong offset!");
static_assert(offsetof(UEndBonamikHelicopterWindComponent, bIsWindActive) == 0x0002D4, "Member 'UEndBonamikHelicopterWindComponent::bIsWindActive' has a wrong offset!");

// Class EndGame.EndDataObjectBattleCommandLinkage
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleCommandLinkage final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleCommandLinkage">();
	}
	static class UEndDataObjectBattleCommandLinkage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleCommandLinkage>();
	}
};
static_assert(alignof(UEndDataObjectBattleCommandLinkage) == 0x000008, "Wrong alignment on UEndDataObjectBattleCommandLinkage");
static_assert(sizeof(UEndDataObjectBattleCommandLinkage) == 0x000088, "Wrong size on UEndDataObjectBattleCommandLinkage");

// Class EndGame.EndBoneAttachComponent
// 0x00A8 (0x01A0 - 0x00F8)
class UEndBoneAttachComponent final : public UActorComponent
{
public:
	class USkeletalMeshComponent*                 OwnerMesh;                                         // 0x00F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachBoneName;                                    // 0x0100(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndBoneAttachTarget                          AttachTarget;                                      // 0x0108(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 AttachTargetMesh;                                  // 0x0110(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachTargetBoneName;                              // 0x0118(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             AttachTargetTransform;                             // 0x0120(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   PreAttachOrientBoneName;                           // 0x0150(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PreAttachOrientBoneForwardVector;                  // 0x0158(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x3C];                                     // 0x0164(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBoneAttachComponent">();
	}
	static class UEndBoneAttachComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBoneAttachComponent>();
	}
};
static_assert(alignof(UEndBoneAttachComponent) == 0x000010, "Wrong alignment on UEndBoneAttachComponent");
static_assert(sizeof(UEndBoneAttachComponent) == 0x0001A0, "Wrong size on UEndBoneAttachComponent");
static_assert(offsetof(UEndBoneAttachComponent, OwnerMesh) == 0x0000F8, "Member 'UEndBoneAttachComponent::OwnerMesh' has a wrong offset!");
static_assert(offsetof(UEndBoneAttachComponent, AttachBoneName) == 0x000100, "Member 'UEndBoneAttachComponent::AttachBoneName' has a wrong offset!");
static_assert(offsetof(UEndBoneAttachComponent, AttachTarget) == 0x000108, "Member 'UEndBoneAttachComponent::AttachTarget' has a wrong offset!");
static_assert(offsetof(UEndBoneAttachComponent, AttachTargetMesh) == 0x000110, "Member 'UEndBoneAttachComponent::AttachTargetMesh' has a wrong offset!");
static_assert(offsetof(UEndBoneAttachComponent, AttachTargetBoneName) == 0x000118, "Member 'UEndBoneAttachComponent::AttachTargetBoneName' has a wrong offset!");
static_assert(offsetof(UEndBoneAttachComponent, AttachTargetTransform) == 0x000120, "Member 'UEndBoneAttachComponent::AttachTargetTransform' has a wrong offset!");
static_assert(offsetof(UEndBoneAttachComponent, PreAttachOrientBoneName) == 0x000150, "Member 'UEndBoneAttachComponent::PreAttachOrientBoneName' has a wrong offset!");
static_assert(offsetof(UEndBoneAttachComponent, PreAttachOrientBoneForwardVector) == 0x000158, "Member 'UEndBoneAttachComponent::PreAttachOrientBoneForwardVector' has a wrong offset!");

// Class EndGame.EndSwitchableMeshCharacter
// 0x0000 (0x22C0 - 0x22C0)
class AEndSwitchableMeshCharacter final : public AEndCharacter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndSwitchableMeshCharacter">();
	}
	static class AEndSwitchableMeshCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndSwitchableMeshCharacter>();
	}
};
static_assert(alignof(AEndSwitchableMeshCharacter) == 0x000010, "Wrong alignment on AEndSwitchableMeshCharacter");
static_assert(sizeof(AEndSwitchableMeshCharacter) == 0x0022C0, "Wrong size on AEndSwitchableMeshCharacter");

// Class EndGame.EndBTDecorator_IsIdleState
// 0x0000 (0x0068 - 0x0068)
class UEndBTDecorator_IsIdleState final : public UEndBTDecorator_CheckConditionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_IsIdleState">();
	}
	static class UEndBTDecorator_IsIdleState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_IsIdleState>();
	}
};
static_assert(alignof(UEndBTDecorator_IsIdleState) == 0x000008, "Wrong alignment on UEndBTDecorator_IsIdleState");
static_assert(sizeof(UEndBTDecorator_IsIdleState) == 0x000068, "Wrong size on UEndBTDecorator_IsIdleState");

// Class EndGame.EndBTComposite_Custom
// 0x0008 (0x00D0 - 0x00C8)
class UEndBTComposite_Custom final : public UBTCompositeNode
{
public:
	EEndCustomCompositeReturnCondition            ReturnCondition;                                   // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTComposite_Custom">();
	}
	static class UEndBTComposite_Custom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTComposite_Custom>();
	}
};
static_assert(alignof(UEndBTComposite_Custom) == 0x000008, "Wrong alignment on UEndBTComposite_Custom");
static_assert(sizeof(UEndBTComposite_Custom) == 0x0000D0, "Wrong size on UEndBTComposite_Custom");
static_assert(offsetof(UEndBTComposite_Custom, ReturnCondition) == 0x0000C8, "Member 'UEndBTComposite_Custom::ReturnCondition' has a wrong offset!");

// Class EndGame.EndBTD_IsSummonCommandStackEmpty
// 0x0000 (0x0068 - 0x0068)
class UEndBTD_IsSummonCommandStackEmpty final : public UEndBTDecorator_CheckConditionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTD_IsSummonCommandStackEmpty">();
	}
	static class UEndBTD_IsSummonCommandStackEmpty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTD_IsSummonCommandStackEmpty>();
	}
};
static_assert(alignof(UEndBTD_IsSummonCommandStackEmpty) == 0x000008, "Wrong alignment on UEndBTD_IsSummonCommandStackEmpty");
static_assert(sizeof(UEndBTD_IsSummonCommandStackEmpty) == 0x000068, "Wrong size on UEndBTD_IsSummonCommandStackEmpty");

// Class EndGame.EndBTD_NeedGoThroughTarget
// 0x0050 (0x00B8 - 0x0068)
class UEndBTD_NeedGoThroughTarget final : public UEndBTDecorator_CheckConditionBase
{
public:
	struct FBlackboardKeySelector                 FromBlackboardKey_Target;                          // 0x0068(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 FromBlackboardKey_MoveTo;                          // 0x0090(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTD_NeedGoThroughTarget">();
	}
	static class UEndBTD_NeedGoThroughTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTD_NeedGoThroughTarget>();
	}
};
static_assert(alignof(UEndBTD_NeedGoThroughTarget) == 0x000008, "Wrong alignment on UEndBTD_NeedGoThroughTarget");
static_assert(sizeof(UEndBTD_NeedGoThroughTarget) == 0x0000B8, "Wrong size on UEndBTD_NeedGoThroughTarget");
static_assert(offsetof(UEndBTD_NeedGoThroughTarget, FromBlackboardKey_Target) == 0x000068, "Member 'UEndBTD_NeedGoThroughTarget::FromBlackboardKey_Target' has a wrong offset!");
static_assert(offsetof(UEndBTD_NeedGoThroughTarget, FromBlackboardKey_MoveTo) == 0x000090, "Member 'UEndBTD_NeedGoThroughTarget::FromBlackboardKey_MoveTo' has a wrong offset!");

// Class EndGame.EndCondorFortMiniGameGameUnit
// 0x00D0 (0x0430 - 0x0360)
class UEndCondorFortMiniGameGameUnit final : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0xD0];                                     // 0x0360(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCondorFortMiniGameGameUnit">();
	}
	static class UEndCondorFortMiniGameGameUnit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndCondorFortMiniGameGameUnit>();
	}
};
static_assert(alignof(UEndCondorFortMiniGameGameUnit) == 0x000008, "Wrong alignment on UEndCondorFortMiniGameGameUnit");
static_assert(sizeof(UEndCondorFortMiniGameGameUnit) == 0x000430, "Wrong size on UEndCondorFortMiniGameGameUnit");

// Class EndGame.EndBTD_SummonEndPreciseAttack
// 0x0000 (0x0068 - 0x0068)
class UEndBTD_SummonEndPreciseAttack final : public UBTDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTD_SummonEndPreciseAttack">();
	}
	static class UEndBTD_SummonEndPreciseAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTD_SummonEndPreciseAttack>();
	}
};
static_assert(alignof(UEndBTD_SummonEndPreciseAttack) == 0x000008, "Wrong alignment on UEndBTD_SummonEndPreciseAttack");
static_assert(sizeof(UEndBTD_SummonEndPreciseAttack) == 0x000068, "Wrong size on UEndBTD_SummonEndPreciseAttack");

// Class EndGame.EndBTD_SummonSetBattleBehavior
// 0x0030 (0x0098 - 0x0068)
class UEndBTD_SummonSetBattleBehavior final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 ToBlackboardKey_BattleBehavior;                    // 0x0068(0x0028)(Edit, NativeAccessSpecifierPublic)
	ESummonBattleBehavior                         NewBattleBehavior;                                 // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTD_SummonSetBattleBehavior">();
	}
	static class UEndBTD_SummonSetBattleBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTD_SummonSetBattleBehavior>();
	}
};
static_assert(alignof(UEndBTD_SummonSetBattleBehavior) == 0x000008, "Wrong alignment on UEndBTD_SummonSetBattleBehavior");
static_assert(sizeof(UEndBTD_SummonSetBattleBehavior) == 0x000098, "Wrong size on UEndBTD_SummonSetBattleBehavior");
static_assert(offsetof(UEndBTD_SummonSetBattleBehavior, ToBlackboardKey_BattleBehavior) == 0x000068, "Member 'UEndBTD_SummonSetBattleBehavior::ToBlackboardKey_BattleBehavior' has a wrong offset!");
static_assert(offsetof(UEndBTD_SummonSetBattleBehavior, NewBattleBehavior) == 0x000090, "Member 'UEndBTD_SummonSetBattleBehavior::NewBattleBehavior' has a wrong offset!");

// Class EndGame.EndBTTask_OverwriteWarpLocation
// 0x0028 (0x0098 - 0x0070)
class UEndBTTask_OverwriteWarpLocation final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 LocationBlackboardKey;                             // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_OverwriteWarpLocation">();
	}
	static class UEndBTTask_OverwriteWarpLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_OverwriteWarpLocation>();
	}
};
static_assert(alignof(UEndBTTask_OverwriteWarpLocation) == 0x000008, "Wrong alignment on UEndBTTask_OverwriteWarpLocation");
static_assert(sizeof(UEndBTTask_OverwriteWarpLocation) == 0x000098, "Wrong size on UEndBTTask_OverwriteWarpLocation");
static_assert(offsetof(UEndBTTask_OverwriteWarpLocation, LocationBlackboardKey) == 0x000070, "Member 'UEndBTTask_OverwriteWarpLocation::LocationBlackboardKey' has a wrong offset!");

// Class EndGame.EndBTD_SummonSetConfrontDistance
// 0x0028 (0x0090 - 0x0068)
class UEndBTD_SummonSetConfrontDistance final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 FromBlackboardKey_Base;                            // 0x0068(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTD_SummonSetConfrontDistance">();
	}
	static class UEndBTD_SummonSetConfrontDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTD_SummonSetConfrontDistance>();
	}
};
static_assert(alignof(UEndBTD_SummonSetConfrontDistance) == 0x000008, "Wrong alignment on UEndBTD_SummonSetConfrontDistance");
static_assert(sizeof(UEndBTD_SummonSetConfrontDistance) == 0x000090, "Wrong size on UEndBTD_SummonSetConfrontDistance");
static_assert(offsetof(UEndBTD_SummonSetConfrontDistance, FromBlackboardKey_Base) == 0x000068, "Member 'UEndBTD_SummonSetConfrontDistance::FromBlackboardKey_Base' has a wrong offset!");

// Class EndGame.EndFieldActionActorWireMeshMoveChild
// 0x0098 (0x06B0 - 0x0618)
class AEndFieldActionActorWireMeshMoveChild final : public AEndFieldActionActorBase
{
public:
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0618(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_620[0x90];                                     // 0x0620(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorWireMeshMoveChild">();
	}
	static class AEndFieldActionActorWireMeshMoveChild* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorWireMeshMoveChild>();
	}
};
static_assert(alignof(AEndFieldActionActorWireMeshMoveChild) == 0x000008, "Wrong alignment on AEndFieldActionActorWireMeshMoveChild");
static_assert(sizeof(AEndFieldActionActorWireMeshMoveChild) == 0x0006B0, "Wrong size on AEndFieldActionActorWireMeshMoveChild");
static_assert(offsetof(AEndFieldActionActorWireMeshMoveChild, ModifierVolume) == 0x000618, "Member 'AEndFieldActionActorWireMeshMoveChild::ModifierVolume' has a wrong offset!");

// Class EndGame.EndBTDecorator_AIPCCalcCautionTime
// 0x0028 (0x0090 - 0x0068)
class UEndBTDecorator_AIPCCalcCautionTime final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 CautionTimeBlackboardKey;                          // 0x0068(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_AIPCCalcCautionTime">();
	}
	static class UEndBTDecorator_AIPCCalcCautionTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_AIPCCalcCautionTime>();
	}
};
static_assert(alignof(UEndBTDecorator_AIPCCalcCautionTime) == 0x000008, "Wrong alignment on UEndBTDecorator_AIPCCalcCautionTime");
static_assert(sizeof(UEndBTDecorator_AIPCCalcCautionTime) == 0x000090, "Wrong size on UEndBTDecorator_AIPCCalcCautionTime");
static_assert(offsetof(UEndBTDecorator_AIPCCalcCautionTime, CautionTimeBlackboardKey) == 0x000068, "Member 'UEndBTDecorator_AIPCCalcCautionTime::CautionTimeBlackboardKey' has a wrong offset!");

// Class EndGame.EndBTDecorator_AIPCDurationCover
// 0x0000 (0x0068 - 0x0068)
class UEndBTDecorator_AIPCDurationCover final : public UBTDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_AIPCDurationCover">();
	}
	static class UEndBTDecorator_AIPCDurationCover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_AIPCDurationCover>();
	}
};
static_assert(alignof(UEndBTDecorator_AIPCDurationCover) == 0x000008, "Wrong alignment on UEndBTDecorator_AIPCDurationCover");
static_assert(sizeof(UEndBTDecorator_AIPCDurationCover) == 0x000068, "Wrong size on UEndBTDecorator_AIPCDurationCover");

// Class EndGame.EndBTTask_SearchCutSceneTarget
// 0x0008 (0x0078 - 0x0070)
class UEndBTTask_SearchCutSceneTarget final : public UBTTaskNode
{
public:
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_SearchCutSceneTarget">();
	}
	static class UEndBTTask_SearchCutSceneTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_SearchCutSceneTarget>();
	}
};
static_assert(alignof(UEndBTTask_SearchCutSceneTarget) == 0x000008, "Wrong alignment on UEndBTTask_SearchCutSceneTarget");
static_assert(sizeof(UEndBTTask_SearchCutSceneTarget) == 0x000078, "Wrong size on UEndBTTask_SearchCutSceneTarget");

// Class EndGame.EndBTDecorator_AIPCDurationSetDefenceTarget
// 0x0030 (0x0098 - 0x0068)
class UEndBTDecorator_AIPCDurationSetDefenceTarget final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 TargetBlackboardKey;                               // 0x0068(0x0028)(Edit, NativeAccessSpecifierPublic)
	float                                         BestDsitance;                                      // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDisntance;                                      // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_AIPCDurationSetDefenceTarget">();
	}
	static class UEndBTDecorator_AIPCDurationSetDefenceTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_AIPCDurationSetDefenceTarget>();
	}
};
static_assert(alignof(UEndBTDecorator_AIPCDurationSetDefenceTarget) == 0x000008, "Wrong alignment on UEndBTDecorator_AIPCDurationSetDefenceTarget");
static_assert(sizeof(UEndBTDecorator_AIPCDurationSetDefenceTarget) == 0x000098, "Wrong size on UEndBTDecorator_AIPCDurationSetDefenceTarget");
static_assert(offsetof(UEndBTDecorator_AIPCDurationSetDefenceTarget, TargetBlackboardKey) == 0x000068, "Member 'UEndBTDecorator_AIPCDurationSetDefenceTarget::TargetBlackboardKey' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_AIPCDurationSetDefenceTarget, BestDsitance) == 0x000090, "Member 'UEndBTDecorator_AIPCDurationSetDefenceTarget::BestDsitance' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_AIPCDurationSetDefenceTarget, MaxDisntance) == 0x000094, "Member 'UEndBTDecorator_AIPCDurationSetDefenceTarget::MaxDisntance' has a wrong offset!");

// Class EndGame.EndBTDecorator_AIPCHasDefenceTarget
// 0x0000 (0x0068 - 0x0068)
class UEndBTDecorator_AIPCHasDefenceTarget final : public UEndBTDecorator_CheckConditionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_AIPCHasDefenceTarget">();
	}
	static class UEndBTDecorator_AIPCHasDefenceTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_AIPCHasDefenceTarget>();
	}
};
static_assert(alignof(UEndBTDecorator_AIPCHasDefenceTarget) == 0x000008, "Wrong alignment on UEndBTDecorator_AIPCHasDefenceTarget");
static_assert(sizeof(UEndBTDecorator_AIPCHasDefenceTarget) == 0x000068, "Wrong size on UEndBTDecorator_AIPCHasDefenceTarget");

// Class EndGame.EndWireMeshMoveTriggerComponent
// 0x0010 (0x0750 - 0x0740)
class UEndWireMeshMoveTriggerComponent final : public UEndFieldActionTriggerComponent
{
public:
	bool                                          NotCreateEffect;                                   // 0x0740(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_741[0xF];                                      // 0x0741(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndWireMeshMoveTriggerComponent">();
	}
	static class UEndWireMeshMoveTriggerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndWireMeshMoveTriggerComponent>();
	}
};
static_assert(alignof(UEndWireMeshMoveTriggerComponent) == 0x000010, "Wrong alignment on UEndWireMeshMoveTriggerComponent");
static_assert(sizeof(UEndWireMeshMoveTriggerComponent) == 0x000750, "Wrong size on UEndWireMeshMoveTriggerComponent");
static_assert(offsetof(UEndWireMeshMoveTriggerComponent, NotCreateEffect) == 0x000740, "Member 'UEndWireMeshMoveTriggerComponent::NotCreateEffect' has a wrong offset!");

// Class EndGame.EndBTDecorator_AIPCHasTargetParts
// 0x0000 (0x0068 - 0x0068)
class UEndBTDecorator_AIPCHasTargetParts final : public UEndBTDecorator_CheckConditionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_AIPCHasTargetParts">();
	}
	static class UEndBTDecorator_AIPCHasTargetParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_AIPCHasTargetParts>();
	}
};
static_assert(alignof(UEndBTDecorator_AIPCHasTargetParts) == 0x000008, "Wrong alignment on UEndBTDecorator_AIPCHasTargetParts");
static_assert(sizeof(UEndBTDecorator_AIPCHasTargetParts) == 0x000068, "Wrong size on UEndBTDecorator_AIPCHasTargetParts");

// Class EndGame.EndBTTask_SummonExecuteCommand
// 0x0108 (0x0178 - 0x0070)
class UEndBTTask_SummonExecuteCommand final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 FromBlackboardKey_AbilityID;                       // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 FromBlackboardKey_IgnoreAbilityRange;              // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 FromBlackboardKey_AbilityRange;                    // 0x00C0(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 FromBlackboardKey_AbilityExecuteState;             // 0x00E8(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 FromBlackboardKey_Target;                          // 0x0110(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 FromBlackboardKey_InWarp;                          // 0x0138(0x0028)(Edit, NativeAccessSpecifierPublic)
	float                                         TimeLimit;                                         // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NeedApproachTargetBlackBoardName;                  // 0x0164(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0xC];                                      // 0x016C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_SummonExecuteCommand">();
	}
	static class UEndBTTask_SummonExecuteCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_SummonExecuteCommand>();
	}
};
static_assert(alignof(UEndBTTask_SummonExecuteCommand) == 0x000008, "Wrong alignment on UEndBTTask_SummonExecuteCommand");
static_assert(sizeof(UEndBTTask_SummonExecuteCommand) == 0x000178, "Wrong size on UEndBTTask_SummonExecuteCommand");
static_assert(offsetof(UEndBTTask_SummonExecuteCommand, FromBlackboardKey_AbilityID) == 0x000070, "Member 'UEndBTTask_SummonExecuteCommand::FromBlackboardKey_AbilityID' has a wrong offset!");
static_assert(offsetof(UEndBTTask_SummonExecuteCommand, FromBlackboardKey_IgnoreAbilityRange) == 0x000098, "Member 'UEndBTTask_SummonExecuteCommand::FromBlackboardKey_IgnoreAbilityRange' has a wrong offset!");
static_assert(offsetof(UEndBTTask_SummonExecuteCommand, FromBlackboardKey_AbilityRange) == 0x0000C0, "Member 'UEndBTTask_SummonExecuteCommand::FromBlackboardKey_AbilityRange' has a wrong offset!");
static_assert(offsetof(UEndBTTask_SummonExecuteCommand, FromBlackboardKey_AbilityExecuteState) == 0x0000E8, "Member 'UEndBTTask_SummonExecuteCommand::FromBlackboardKey_AbilityExecuteState' has a wrong offset!");
static_assert(offsetof(UEndBTTask_SummonExecuteCommand, FromBlackboardKey_Target) == 0x000110, "Member 'UEndBTTask_SummonExecuteCommand::FromBlackboardKey_Target' has a wrong offset!");
static_assert(offsetof(UEndBTTask_SummonExecuteCommand, FromBlackboardKey_InWarp) == 0x000138, "Member 'UEndBTTask_SummonExecuteCommand::FromBlackboardKey_InWarp' has a wrong offset!");
static_assert(offsetof(UEndBTTask_SummonExecuteCommand, TimeLimit) == 0x000160, "Member 'UEndBTTask_SummonExecuteCommand::TimeLimit' has a wrong offset!");
static_assert(offsetof(UEndBTTask_SummonExecuteCommand, NeedApproachTargetBlackBoardName) == 0x000164, "Member 'UEndBTTask_SummonExecuteCommand::NeedApproachTargetBlackBoardName' has a wrong offset!");

// Class EndGame.EndBTDecorator_AIPCSetConfrontDistance
// 0x0010 (0x0078 - 0x0068)
class UEndBTDecorator_AIPCSetConfrontDistance final : public UBTDecorator
{
public:
	EConfrontType                                 ConfrontType;                                      // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDistance;                                       // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Offset;                                            // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_AIPCSetConfrontDistance">();
	}
	static class UEndBTDecorator_AIPCSetConfrontDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_AIPCSetConfrontDistance>();
	}
};
static_assert(alignof(UEndBTDecorator_AIPCSetConfrontDistance) == 0x000008, "Wrong alignment on UEndBTDecorator_AIPCSetConfrontDistance");
static_assert(sizeof(UEndBTDecorator_AIPCSetConfrontDistance) == 0x000078, "Wrong size on UEndBTDecorator_AIPCSetConfrontDistance");
static_assert(offsetof(UEndBTDecorator_AIPCSetConfrontDistance, ConfrontType) == 0x000068, "Member 'UEndBTDecorator_AIPCSetConfrontDistance::ConfrontType' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_AIPCSetConfrontDistance, MinDistance) == 0x00006C, "Member 'UEndBTDecorator_AIPCSetConfrontDistance::MinDistance' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_AIPCSetConfrontDistance, MaxDistance) == 0x000070, "Member 'UEndBTDecorator_AIPCSetConfrontDistance::MaxDistance' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_AIPCSetConfrontDistance, Offset) == 0x000074, "Member 'UEndBTDecorator_AIPCSetConfrontDistance::Offset' has a wrong offset!");

// Class EndGame.EndBTDecorator_CheckTargetAngle
// 0x0010 (0x0078 - 0x0068)
class UEndBTDecorator_CheckTargetAngle final : public UEndBTDecorator_CheckConditionBase
{
public:
	EAngleCheckType                               CheckType;                                         // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndAiMathCmp                                 Operator;                                          // 0x006C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CheckTargetAngle;                                  // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_CheckTargetAngle">();
	}
	static class UEndBTDecorator_CheckTargetAngle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_CheckTargetAngle>();
	}
};
static_assert(alignof(UEndBTDecorator_CheckTargetAngle) == 0x000008, "Wrong alignment on UEndBTDecorator_CheckTargetAngle");
static_assert(sizeof(UEndBTDecorator_CheckTargetAngle) == 0x000078, "Wrong size on UEndBTDecorator_CheckTargetAngle");
static_assert(offsetof(UEndBTDecorator_CheckTargetAngle, CheckType) == 0x000068, "Member 'UEndBTDecorator_CheckTargetAngle::CheckType' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_CheckTargetAngle, Operator) == 0x00006C, "Member 'UEndBTDecorator_CheckTargetAngle::Operator' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_CheckTargetAngle, CheckTargetAngle) == 0x000070, "Member 'UEndBTDecorator_CheckTargetAngle::CheckTargetAngle' has a wrong offset!");

// Class EndGame.EndBTTask_SyncAbility
// 0x00B0 (0x0120 - 0x0070)
class UEndBTTask_SyncAbility final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 AbilityNameBlackboardKey;                          // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 AbilityTargetBlackboardKey;                        // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 LinkAbilityTypeBlackboardKey;                      // 0x00C0(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 AbilityHandleIdBlackboardKey;                      // 0x00E8(0x0028)(Edit, NativeAccessSpecifierPublic)
	class FName                                   SkipAbilityDistanceCheckBBKey;                     // 0x0110(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartWaitTime;                                     // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_SyncAbility">();
	}
	static class UEndBTTask_SyncAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_SyncAbility>();
	}
};
static_assert(alignof(UEndBTTask_SyncAbility) == 0x000008, "Wrong alignment on UEndBTTask_SyncAbility");
static_assert(sizeof(UEndBTTask_SyncAbility) == 0x000120, "Wrong size on UEndBTTask_SyncAbility");
static_assert(offsetof(UEndBTTask_SyncAbility, AbilityNameBlackboardKey) == 0x000070, "Member 'UEndBTTask_SyncAbility::AbilityNameBlackboardKey' has a wrong offset!");
static_assert(offsetof(UEndBTTask_SyncAbility, AbilityTargetBlackboardKey) == 0x000098, "Member 'UEndBTTask_SyncAbility::AbilityTargetBlackboardKey' has a wrong offset!");
static_assert(offsetof(UEndBTTask_SyncAbility, LinkAbilityTypeBlackboardKey) == 0x0000C0, "Member 'UEndBTTask_SyncAbility::LinkAbilityTypeBlackboardKey' has a wrong offset!");
static_assert(offsetof(UEndBTTask_SyncAbility, AbilityHandleIdBlackboardKey) == 0x0000E8, "Member 'UEndBTTask_SyncAbility::AbilityHandleIdBlackboardKey' has a wrong offset!");
static_assert(offsetof(UEndBTTask_SyncAbility, SkipAbilityDistanceCheckBBKey) == 0x000110, "Member 'UEndBTTask_SyncAbility::SkipAbilityDistanceCheckBBKey' has a wrong offset!");
static_assert(offsetof(UEndBTTask_SyncAbility, StartWaitTime) == 0x000118, "Member 'UEndBTTask_SyncAbility::StartWaitTime' has a wrong offset!");

// Class EndGame.EndBTDecorator_ClearInputBuffer
// 0x0000 (0x0068 - 0x0068)
class UEndBTDecorator_ClearInputBuffer final : public UBTDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_ClearInputBuffer">();
	}
	static class UEndBTDecorator_ClearInputBuffer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_ClearInputBuffer>();
	}
};
static_assert(alignof(UEndBTDecorator_ClearInputBuffer) == 0x000008, "Wrong alignment on UEndBTDecorator_ClearInputBuffer");
static_assert(sizeof(UEndBTDecorator_ClearInputBuffer) == 0x000068, "Wrong size on UEndBTDecorator_ClearInputBuffer");

// Class EndGame.EndBTDecorator_Field_ArithmeticComparison
// 0x0080 (0x00E8 - 0x0068)
class UEndBTDecorator_Field_ArithmeticComparison final : public UEndBTDecorator_CheckConditionBase
{
public:
	EBTDecorator_Field_ArithmeticComparisonSource ValueTypeA;                                        // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUseBlackboardA : 1;                               // 0x006C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsePropertyOrFunctionA : 1;                       // 0x006C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseLiteralA : 1;                                  // 0x006C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BlackboardKeyA;                                    // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	class FName                                   PropertyNameA;                                     // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LiteralValueA;                                     // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndAiMathCmp                                 ArithmeticOperation;                               // 0x00A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBTDecorator_Field_ArithmeticComparisonSource ValueTypeB;                                        // 0x00A5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A6[0x2];                                       // 0x00A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUseBlackboardB : 1;                               // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsePropertyOrFunctionB : 1;                       // 0x00A8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseLiteralB : 1;                                  // 0x00A8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BlackboardKeyB;                                    // 0x00B0(0x0028)(Edit, NativeAccessSpecifierPublic)
	class FName                                   PropertyNameB;                                     // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LiteralValueB;                                     // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_Field_ArithmeticComparison">();
	}
	static class UEndBTDecorator_Field_ArithmeticComparison* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_Field_ArithmeticComparison>();
	}
};
static_assert(alignof(UEndBTDecorator_Field_ArithmeticComparison) == 0x000008, "Wrong alignment on UEndBTDecorator_Field_ArithmeticComparison");
static_assert(sizeof(UEndBTDecorator_Field_ArithmeticComparison) == 0x0000E8, "Wrong size on UEndBTDecorator_Field_ArithmeticComparison");
static_assert(offsetof(UEndBTDecorator_Field_ArithmeticComparison, ValueTypeA) == 0x000068, "Member 'UEndBTDecorator_Field_ArithmeticComparison::ValueTypeA' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_ArithmeticComparison, BlackboardKeyA) == 0x000070, "Member 'UEndBTDecorator_Field_ArithmeticComparison::BlackboardKeyA' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_ArithmeticComparison, PropertyNameA) == 0x000098, "Member 'UEndBTDecorator_Field_ArithmeticComparison::PropertyNameA' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_ArithmeticComparison, LiteralValueA) == 0x0000A0, "Member 'UEndBTDecorator_Field_ArithmeticComparison::LiteralValueA' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_ArithmeticComparison, ArithmeticOperation) == 0x0000A4, "Member 'UEndBTDecorator_Field_ArithmeticComparison::ArithmeticOperation' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_ArithmeticComparison, ValueTypeB) == 0x0000A5, "Member 'UEndBTDecorator_Field_ArithmeticComparison::ValueTypeB' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_ArithmeticComparison, BlackboardKeyB) == 0x0000B0, "Member 'UEndBTDecorator_Field_ArithmeticComparison::BlackboardKeyB' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_ArithmeticComparison, PropertyNameB) == 0x0000D8, "Member 'UEndBTDecorator_Field_ArithmeticComparison::PropertyNameB' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_ArithmeticComparison, LiteralValueB) == 0x0000E0, "Member 'UEndBTDecorator_Field_ArithmeticComparison::LiteralValueB' has a wrong offset!");

// Class EndGame.EndBTDecorator_Field_CheckDistance
// 0x0008 (0x00D0 - 0x00C8)
class UEndBTDecorator_Field_CheckDistance final : public UEndBTDecorator_CheckDistance
{
public:
	EBTDecorator_Field_CheckDistanceMode          m_DistanceMode;                                    // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_bUseBodyRadius_From;                             // 0x00C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_bUseBodyRadius_To;                               // 0x00CA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CB[0x5];                                       // 0x00CB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_Field_CheckDistance">();
	}
	static class UEndBTDecorator_Field_CheckDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_Field_CheckDistance>();
	}
};
static_assert(alignof(UEndBTDecorator_Field_CheckDistance) == 0x000008, "Wrong alignment on UEndBTDecorator_Field_CheckDistance");
static_assert(sizeof(UEndBTDecorator_Field_CheckDistance) == 0x0000D0, "Wrong size on UEndBTDecorator_Field_CheckDistance");
static_assert(offsetof(UEndBTDecorator_Field_CheckDistance, m_DistanceMode) == 0x0000C8, "Member 'UEndBTDecorator_Field_CheckDistance::m_DistanceMode' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_CheckDistance, m_bUseBodyRadius_From) == 0x0000C9, "Member 'UEndBTDecorator_Field_CheckDistance::m_bUseBodyRadius_From' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_CheckDistance, m_bUseBodyRadius_To) == 0x0000CA, "Member 'UEndBTDecorator_Field_CheckDistance::m_bUseBodyRadius_To' has a wrong offset!");

// Class EndGame.EndBTDecorator_Field_CheckLeadMoveType
// 0x0010 (0x0078 - 0x0068)
class UEndBTDecorator_Field_CheckLeadMoveType final : public UEndBTDecorator_CheckConditionBase
{
public:
	TArray<EEndAiMoveType>                        m_MoveTypes;                                       // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_Field_CheckLeadMoveType">();
	}
	static class UEndBTDecorator_Field_CheckLeadMoveType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_Field_CheckLeadMoveType>();
	}
};
static_assert(alignof(UEndBTDecorator_Field_CheckLeadMoveType) == 0x000008, "Wrong alignment on UEndBTDecorator_Field_CheckLeadMoveType");
static_assert(sizeof(UEndBTDecorator_Field_CheckLeadMoveType) == 0x000078, "Wrong size on UEndBTDecorator_Field_CheckLeadMoveType");
static_assert(offsetof(UEndBTDecorator_Field_CheckLeadMoveType, m_MoveTypes) == 0x000068, "Member 'UEndBTDecorator_Field_CheckLeadMoveType::m_MoveTypes' has a wrong offset!");

// Class EndGame.EndBTDecorator_Field_IsCameraFlavor
// 0x0008 (0x0070 - 0x0068)
class UEndBTDecorator_Field_IsCameraFlavor final : public UEndBTDecorator_CheckConditionBase
{
public:
	EEndFieldCameraOperatorFlavorType             m_CameraFlavorType;                                // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_Field_IsCameraFlavor">();
	}
	static class UEndBTDecorator_Field_IsCameraFlavor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_Field_IsCameraFlavor>();
	}
};
static_assert(alignof(UEndBTDecorator_Field_IsCameraFlavor) == 0x000008, "Wrong alignment on UEndBTDecorator_Field_IsCameraFlavor");
static_assert(sizeof(UEndBTDecorator_Field_IsCameraFlavor) == 0x000070, "Wrong size on UEndBTDecorator_Field_IsCameraFlavor");
static_assert(offsetof(UEndBTDecorator_Field_IsCameraFlavor, m_CameraFlavorType) == 0x000068, "Member 'UEndBTDecorator_Field_IsCameraFlavor::m_CameraFlavorType' has a wrong offset!");

// Class EndGame.EndBTDecorator_Field_IsExclusionMask
// 0x0000 (0x0068 - 0x0068)
class UEndBTDecorator_Field_IsExclusionMask final : public UEndBTDecorator_CheckConditionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_Field_IsExclusionMask">();
	}
	static class UEndBTDecorator_Field_IsExclusionMask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_Field_IsExclusionMask>();
	}
};
static_assert(alignof(UEndBTDecorator_Field_IsExclusionMask) == 0x000008, "Wrong alignment on UEndBTDecorator_Field_IsExclusionMask");
static_assert(sizeof(UEndBTDecorator_Field_IsExclusionMask) == 0x000068, "Wrong size on UEndBTDecorator_Field_IsExclusionMask");

// Class EndGame.EndBTDecorator_Field_IsInFollowViewArea
// 0x0030 (0x0098 - 0x0068)
class UEndBTDecorator_Field_IsInFollowViewArea final : public UEndBTDecorator_CheckConditionBase
{
public:
	struct FBlackboardKeySelector                 m_Source;                                          // 0x0068(0x0028)(Edit, NativeAccessSpecifierPublic)
	float                                         m_Angle;                                           // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_AreaSize;                                        // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_Field_IsInFollowViewArea">();
	}
	static class UEndBTDecorator_Field_IsInFollowViewArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_Field_IsInFollowViewArea>();
	}
};
static_assert(alignof(UEndBTDecorator_Field_IsInFollowViewArea) == 0x000008, "Wrong alignment on UEndBTDecorator_Field_IsInFollowViewArea");
static_assert(sizeof(UEndBTDecorator_Field_IsInFollowViewArea) == 0x000098, "Wrong size on UEndBTDecorator_Field_IsInFollowViewArea");
static_assert(offsetof(UEndBTDecorator_Field_IsInFollowViewArea, m_Source) == 0x000068, "Member 'UEndBTDecorator_Field_IsInFollowViewArea::m_Source' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_IsInFollowViewArea, m_Angle) == 0x000090, "Member 'UEndBTDecorator_Field_IsInFollowViewArea::m_Angle' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_IsInFollowViewArea, m_AreaSize) == 0x000094, "Member 'UEndBTDecorator_Field_IsInFollowViewArea::m_AreaSize' has a wrong offset!");

// Class EndGame.VfxParticleModuleEventTrigger
// 0x0010 (0x0048 - 0x0038)
class UVfxParticleModuleEventTrigger final : public UParticleModuleEventBase
{
public:
	EVfxParticleEventTriggerType                  m_TriggerType;                                     // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         m_TriggerTime;                                     // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         m_TriggerParam;                                    // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         m_bRepeatTrigger : 1;                              // 0x0044(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VfxParticleModuleEventTrigger">();
	}
	static class UVfxParticleModuleEventTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVfxParticleModuleEventTrigger>();
	}
};
static_assert(alignof(UVfxParticleModuleEventTrigger) == 0x000008, "Wrong alignment on UVfxParticleModuleEventTrigger");
static_assert(sizeof(UVfxParticleModuleEventTrigger) == 0x000048, "Wrong size on UVfxParticleModuleEventTrigger");
static_assert(offsetof(UVfxParticleModuleEventTrigger, m_TriggerType) == 0x000038, "Member 'UVfxParticleModuleEventTrigger::m_TriggerType' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleEventTrigger, m_TriggerTime) == 0x00003C, "Member 'UVfxParticleModuleEventTrigger::m_TriggerTime' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleEventTrigger, m_TriggerParam) == 0x000040, "Member 'UVfxParticleModuleEventTrigger::m_TriggerParam' has a wrong offset!");

// Class EndGame.EndBTDecorator_Field_IsInViewLine
// 0x0030 (0x0098 - 0x0068)
class UEndBTDecorator_Field_IsInViewLine final : public UEndBTDecorator_CheckConditionBase
{
public:
	struct FBlackboardKeySelector                 m_Source;                                          // 0x0068(0x0028)(Edit, NativeAccessSpecifierPublic)
	float                                         m_Width;                                           // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_Length;                                          // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_Field_IsInViewLine">();
	}
	static class UEndBTDecorator_Field_IsInViewLine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_Field_IsInViewLine>();
	}
};
static_assert(alignof(UEndBTDecorator_Field_IsInViewLine) == 0x000008, "Wrong alignment on UEndBTDecorator_Field_IsInViewLine");
static_assert(sizeof(UEndBTDecorator_Field_IsInViewLine) == 0x000098, "Wrong size on UEndBTDecorator_Field_IsInViewLine");
static_assert(offsetof(UEndBTDecorator_Field_IsInViewLine, m_Source) == 0x000068, "Member 'UEndBTDecorator_Field_IsInViewLine::m_Source' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_IsInViewLine, m_Width) == 0x000090, "Member 'UEndBTDecorator_Field_IsInViewLine::m_Width' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_IsInViewLine, m_Length) == 0x000094, "Member 'UEndBTDecorator_Field_IsInViewLine::m_Length' has a wrong offset!");

// Class EndGame.EndBTDecorator_Field_IsLocomotionState
// 0x0038 (0x00A0 - 0x0068)
class UEndBTDecorator_Field_IsLocomotionState final : public UEndBTDecorator_CheckConditionBase
{
public:
	struct FBlackboardKeySelector                 m_Source;                                          // 0x0068(0x0028)(Edit, NativeAccessSpecifierPublic)
	TArray<EEndLocomotionState>                   m_LocomotionStates;                                // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_Field_IsLocomotionState">();
	}
	static class UEndBTDecorator_Field_IsLocomotionState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_Field_IsLocomotionState>();
	}
};
static_assert(alignof(UEndBTDecorator_Field_IsLocomotionState) == 0x000008, "Wrong alignment on UEndBTDecorator_Field_IsLocomotionState");
static_assert(sizeof(UEndBTDecorator_Field_IsLocomotionState) == 0x0000A0, "Wrong size on UEndBTDecorator_Field_IsLocomotionState");
static_assert(offsetof(UEndBTDecorator_Field_IsLocomotionState, m_Source) == 0x000068, "Member 'UEndBTDecorator_Field_IsLocomotionState::m_Source' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_IsLocomotionState, m_LocomotionStates) == 0x000090, "Member 'UEndBTDecorator_Field_IsLocomotionState::m_LocomotionStates' has a wrong offset!");

// Class EndGame.EndBTDecorator_Field_IsOnSkeletal
// 0x0030 (0x0098 - 0x0068)
class UEndBTDecorator_Field_IsOnSkeletal final : public UEndBTDecorator_CheckConditionBase
{
public:
	struct FBlackboardKeySelector                 m_Source;                                          // 0x0068(0x0028)(Edit, NativeAccessSpecifierPublic)
	bool                                          m_bEscalator;                                      // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_Field_IsOnSkeletal">();
	}
	static class UEndBTDecorator_Field_IsOnSkeletal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_Field_IsOnSkeletal>();
	}
};
static_assert(alignof(UEndBTDecorator_Field_IsOnSkeletal) == 0x000008, "Wrong alignment on UEndBTDecorator_Field_IsOnSkeletal");
static_assert(sizeof(UEndBTDecorator_Field_IsOnSkeletal) == 0x000098, "Wrong size on UEndBTDecorator_Field_IsOnSkeletal");
static_assert(offsetof(UEndBTDecorator_Field_IsOnSkeletal, m_Source) == 0x000068, "Member 'UEndBTDecorator_Field_IsOnSkeletal::m_Source' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_IsOnSkeletal, m_bEscalator) == 0x000090, "Member 'UEndBTDecorator_Field_IsOnSkeletal::m_bEscalator' has a wrong offset!");

// Class EndGame.EndBTDecorator_Field_SensingMember
// 0x0070 (0x00D8 - 0x0068)
class UEndBTDecorator_Field_SensingMember final : public UEndBTDecorator_CheckConditionBase
{
public:
	struct FBlackboardKeySelector                 m_Source;                                          // 0x0068(0x0028)(Edit, NativeAccessSpecifierPublic)
	bool                                          m_bUseSourceToTarget;                              // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 m_SourceToTarget;                                  // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)
	float                                         m_Distance;                                        // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndAiMathCmp                                 m_ArithmeticOperation_Distance;                    // 0x00C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_bUseBodyRadius;                                  // 0x00C5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C6[0x2];                                       // 0x00C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         m_Angle;                                           // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndAiMathCmp                                 m_ArithmeticOperation_Angle;                       // 0x00CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_bAbs_Angle;                                      // 0x00CD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_bIgnoreLeader;                                   // 0x00CE(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_bLeaderOnly;                                     // 0x00CF(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_bCheckHeight;                                    // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         m_Height;                                          // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_Field_SensingMember">();
	}
	static class UEndBTDecorator_Field_SensingMember* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_Field_SensingMember>();
	}
};
static_assert(alignof(UEndBTDecorator_Field_SensingMember) == 0x000008, "Wrong alignment on UEndBTDecorator_Field_SensingMember");
static_assert(sizeof(UEndBTDecorator_Field_SensingMember) == 0x0000D8, "Wrong size on UEndBTDecorator_Field_SensingMember");
static_assert(offsetof(UEndBTDecorator_Field_SensingMember, m_Source) == 0x000068, "Member 'UEndBTDecorator_Field_SensingMember::m_Source' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_SensingMember, m_bUseSourceToTarget) == 0x000090, "Member 'UEndBTDecorator_Field_SensingMember::m_bUseSourceToTarget' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_SensingMember, m_SourceToTarget) == 0x000098, "Member 'UEndBTDecorator_Field_SensingMember::m_SourceToTarget' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_SensingMember, m_Distance) == 0x0000C0, "Member 'UEndBTDecorator_Field_SensingMember::m_Distance' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_SensingMember, m_ArithmeticOperation_Distance) == 0x0000C4, "Member 'UEndBTDecorator_Field_SensingMember::m_ArithmeticOperation_Distance' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_SensingMember, m_bUseBodyRadius) == 0x0000C5, "Member 'UEndBTDecorator_Field_SensingMember::m_bUseBodyRadius' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_SensingMember, m_Angle) == 0x0000C8, "Member 'UEndBTDecorator_Field_SensingMember::m_Angle' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_SensingMember, m_ArithmeticOperation_Angle) == 0x0000CC, "Member 'UEndBTDecorator_Field_SensingMember::m_ArithmeticOperation_Angle' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_SensingMember, m_bAbs_Angle) == 0x0000CD, "Member 'UEndBTDecorator_Field_SensingMember::m_bAbs_Angle' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_SensingMember, m_bIgnoreLeader) == 0x0000CE, "Member 'UEndBTDecorator_Field_SensingMember::m_bIgnoreLeader' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_SensingMember, m_bLeaderOnly) == 0x0000CF, "Member 'UEndBTDecorator_Field_SensingMember::m_bLeaderOnly' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_SensingMember, m_bCheckHeight) == 0x0000D0, "Member 'UEndBTDecorator_Field_SensingMember::m_bCheckHeight' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_Field_SensingMember, m_Height) == 0x0000D4, "Member 'UEndBTDecorator_Field_SensingMember::m_Height' has a wrong offset!");

// Class EndGame.EndBTDecorator_IsPathExist
// 0x0058 (0x00C0 - 0x0068)
class UEndBTDecorator_IsPathExist final : public UEndBTDecorator_CheckConditionBase
{
public:
	struct FBlackboardKeySelector                 FromBlackboardKey;                                 // 0x0068(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 ToBlackboardKey;                                   // 0x0090(0x0028)(Edit, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_IsPathExist">();
	}
	static class UEndBTDecorator_IsPathExist* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_IsPathExist>();
	}
};
static_assert(alignof(UEndBTDecorator_IsPathExist) == 0x000008, "Wrong alignment on UEndBTDecorator_IsPathExist");
static_assert(sizeof(UEndBTDecorator_IsPathExist) == 0x0000C0, "Wrong size on UEndBTDecorator_IsPathExist");
static_assert(offsetof(UEndBTDecorator_IsPathExist, FromBlackboardKey) == 0x000068, "Member 'UEndBTDecorator_IsPathExist::FromBlackboardKey' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_IsPathExist, ToBlackboardKey) == 0x000090, "Member 'UEndBTDecorator_IsPathExist::ToBlackboardKey' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_IsPathExist, FilterClass) == 0x0000B8, "Member 'UEndBTDecorator_IsPathExist::FilterClass' has a wrong offset!");

// Class EndGame.EndBTDecorator_SetBlackboardBool
// 0x0030 (0x0098 - 0x0068)
class UEndBTDecorator_SetBlackboardBool final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 BlackboardKey;                                     // 0x0068(0x0028)(Edit, NativeAccessSpecifierPublic)
	bool                                          Value;                                             // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_SetBlackboardBool">();
	}
	static class UEndBTDecorator_SetBlackboardBool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_SetBlackboardBool>();
	}
};
static_assert(alignof(UEndBTDecorator_SetBlackboardBool) == 0x000008, "Wrong alignment on UEndBTDecorator_SetBlackboardBool");
static_assert(sizeof(UEndBTDecorator_SetBlackboardBool) == 0x000098, "Wrong size on UEndBTDecorator_SetBlackboardBool");
static_assert(offsetof(UEndBTDecorator_SetBlackboardBool, BlackboardKey) == 0x000068, "Member 'UEndBTDecorator_SetBlackboardBool::BlackboardKey' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_SetBlackboardBool, Value) == 0x000090, "Member 'UEndBTDecorator_SetBlackboardBool::Value' has a wrong offset!");

// Class EndGame.EndBTDecorator_SetFlagOnDeactivate
// 0x0010 (0x0078 - 0x0068)
class UEndBTDecorator_SetFlagOnDeactivate final : public UBTDecorator
{
public:
	class FName                                   KeyName;                                           // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bValue;                                            // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_SetFlagOnDeactivate">();
	}
	static class UEndBTDecorator_SetFlagOnDeactivate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_SetFlagOnDeactivate>();
	}
};
static_assert(alignof(UEndBTDecorator_SetFlagOnDeactivate) == 0x000008, "Wrong alignment on UEndBTDecorator_SetFlagOnDeactivate");
static_assert(sizeof(UEndBTDecorator_SetFlagOnDeactivate) == 0x000078, "Wrong size on UEndBTDecorator_SetFlagOnDeactivate");
static_assert(offsetof(UEndBTDecorator_SetFlagOnDeactivate, KeyName) == 0x000068, "Member 'UEndBTDecorator_SetFlagOnDeactivate::KeyName' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_SetFlagOnDeactivate, bValue) == 0x000070, "Member 'UEndBTDecorator_SetFlagOnDeactivate::bValue' has a wrong offset!");

// Class EndGame.EndBTDecorator_SetTarget
// 0x0030 (0x0098 - 0x0068)
class UEndBTDecorator_SetTarget final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 FromBlackboardKey;                                 // 0x0068(0x0028)(Edit, NativeAccessSpecifierPublic)
	bool                                          SkipWhenNull;                                      // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_SetTarget">();
	}
	static class UEndBTDecorator_SetTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_SetTarget>();
	}
};
static_assert(alignof(UEndBTDecorator_SetTarget) == 0x000008, "Wrong alignment on UEndBTDecorator_SetTarget");
static_assert(sizeof(UEndBTDecorator_SetTarget) == 0x000098, "Wrong size on UEndBTDecorator_SetTarget");
static_assert(offsetof(UEndBTDecorator_SetTarget, FromBlackboardKey) == 0x000068, "Member 'UEndBTDecorator_SetTarget::FromBlackboardKey' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_SetTarget, SkipWhenNull) == 0x000090, "Member 'UEndBTDecorator_SetTarget::SkipWhenNull' has a wrong offset!");

// Class EndGame.EndBTDecorator_AIPCSyncLeaderTarget
// 0x0000 (0x0068 - 0x0068)
class UEndBTDecorator_AIPCSyncLeaderTarget final : public UBTDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_AIPCSyncLeaderTarget">();
	}
	static class UEndBTDecorator_AIPCSyncLeaderTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_AIPCSyncLeaderTarget>();
	}
};
static_assert(alignof(UEndBTDecorator_AIPCSyncLeaderTarget) == 0x000008, "Wrong alignment on UEndBTDecorator_AIPCSyncLeaderTarget");
static_assert(sizeof(UEndBTDecorator_AIPCSyncLeaderTarget) == 0x000068, "Wrong size on UEndBTDecorator_AIPCSyncLeaderTarget");

// Class EndGame.EndBTDecorator_ShouldTeleport
// 0x0078 (0x00E0 - 0x0068)
class UEndBTDecorator_ShouldTeleport final : public UEndBTDecorator_CheckConditionBase
{
public:
	struct FBlackboardKeySelector                 FromBBKey;                                         // 0x0068(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 ToBBKey;                                           // 0x0090(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 DoTeleportDistanceBBKey;                           // 0x00B8(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_ShouldTeleport">();
	}
	static class UEndBTDecorator_ShouldTeleport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_ShouldTeleport>();
	}
};
static_assert(alignof(UEndBTDecorator_ShouldTeleport) == 0x000008, "Wrong alignment on UEndBTDecorator_ShouldTeleport");
static_assert(sizeof(UEndBTDecorator_ShouldTeleport) == 0x0000E0, "Wrong size on UEndBTDecorator_ShouldTeleport");
static_assert(offsetof(UEndBTDecorator_ShouldTeleport, FromBBKey) == 0x000068, "Member 'UEndBTDecorator_ShouldTeleport::FromBBKey' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_ShouldTeleport, ToBBKey) == 0x000090, "Member 'UEndBTDecorator_ShouldTeleport::ToBBKey' has a wrong offset!");
static_assert(offsetof(UEndBTDecorator_ShouldTeleport, DoTeleportDistanceBBKey) == 0x0000B8, "Member 'UEndBTDecorator_ShouldTeleport::DoTeleportDistanceBBKey' has a wrong offset!");

// Class EndGame.EndBTDecorator_IsFinishedCommandInitCheck
// 0x0000 (0x0068 - 0x0068)
class UEndBTDecorator_IsFinishedCommandInitCheck final : public UEndBTDecorator_CheckConditionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_IsFinishedCommandInitCheck">();
	}
	static class UEndBTDecorator_IsFinishedCommandInitCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_IsFinishedCommandInitCheck>();
	}
};
static_assert(alignof(UEndBTDecorator_IsFinishedCommandInitCheck) == 0x000008, "Wrong alignment on UEndBTDecorator_IsFinishedCommandInitCheck");
static_assert(sizeof(UEndBTDecorator_IsFinishedCommandInitCheck) == 0x000068, "Wrong size on UEndBTDecorator_IsFinishedCommandInitCheck");

// Class EndGame.EndBTDecorator_CanSononEscortTeleport
// 0x0000 (0x0068 - 0x0068)
class UEndBTDecorator_CanSononEscortTeleport final : public UEndBTDecorator_CheckConditionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTDecorator_CanSononEscortTeleport">();
	}
	static class UEndBTDecorator_CanSononEscortTeleport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTDecorator_CanSononEscortTeleport>();
	}
};
static_assert(alignof(UEndBTDecorator_CanSononEscortTeleport) == 0x000008, "Wrong alignment on UEndBTDecorator_CanSononEscortTeleport");
static_assert(sizeof(UEndBTDecorator_CanSononEscortTeleport) == 0x000068, "Wrong size on UEndBTDecorator_CanSononEscortTeleport");

// Class EndGame.EndPlat4CraneRailActor
// 0x0030 (0x03A8 - 0x0378)
class AEndPlat4CraneRailActor final : public AActor
{
public:
	int32                                         UniqueIndex;                                       // 0x0378(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ForwardLength;                                     // 0x037C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BackwardLength;                                    // 0x0380(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlaySeconds;                                       // 0x0384(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentPositionInSeconds;                          // 0x0388(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38C[0x1C];                                     // 0x038C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndPlat4CraneRailActor">();
	}
	static class AEndPlat4CraneRailActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndPlat4CraneRailActor>();
	}
};
static_assert(alignof(AEndPlat4CraneRailActor) == 0x000008, "Wrong alignment on AEndPlat4CraneRailActor");
static_assert(sizeof(AEndPlat4CraneRailActor) == 0x0003A8, "Wrong size on AEndPlat4CraneRailActor");
static_assert(offsetof(AEndPlat4CraneRailActor, UniqueIndex) == 0x000378, "Member 'AEndPlat4CraneRailActor::UniqueIndex' has a wrong offset!");
static_assert(offsetof(AEndPlat4CraneRailActor, ForwardLength) == 0x00037C, "Member 'AEndPlat4CraneRailActor::ForwardLength' has a wrong offset!");
static_assert(offsetof(AEndPlat4CraneRailActor, BackwardLength) == 0x000380, "Member 'AEndPlat4CraneRailActor::BackwardLength' has a wrong offset!");
static_assert(offsetof(AEndPlat4CraneRailActor, PlaySeconds) == 0x000384, "Member 'AEndPlat4CraneRailActor::PlaySeconds' has a wrong offset!");
static_assert(offsetof(AEndPlat4CraneRailActor, CurrentPositionInSeconds) == 0x000388, "Member 'AEndPlat4CraneRailActor::CurrentPositionInSeconds' has a wrong offset!");

// Class EndGame.EndBTService_AIPCSearchTarget
// 0x0050 (0x00C0 - 0x0070)
class UEndBTService_AIPCSearchTarget final : public UBTService
{
public:
	bool                                          IgnoreAutoPlayUCPC;                                // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x4F];                                      // 0x0071(0x004F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTService_AIPCSearchTarget">();
	}
	static class UEndBTService_AIPCSearchTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTService_AIPCSearchTarget>();
	}
};
static_assert(alignof(UEndBTService_AIPCSearchTarget) == 0x000008, "Wrong alignment on UEndBTService_AIPCSearchTarget");
static_assert(sizeof(UEndBTService_AIPCSearchTarget) == 0x0000C0, "Wrong size on UEndBTService_AIPCSearchTarget");
static_assert(offsetof(UEndBTService_AIPCSearchTarget, IgnoreAutoPlayUCPC) == 0x000070, "Member 'UEndBTService_AIPCSearchTarget::IgnoreAutoPlayUCPC' has a wrong offset!");

// Class EndGame.EndBTTask_AIPCContinuousAttack
// 0x0030 (0x00A0 - 0x0070)
class UEndBTTask_AIPCContinuousAttack final : public UBTTaskNode
{
public:
	float                                         CombatDisntaceOffset;                              // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 CombatRangeCoefficientBlackboardKey;               // 0x0078(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_AIPCContinuousAttack">();
	}
	static class UEndBTTask_AIPCContinuousAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_AIPCContinuousAttack>();
	}
};
static_assert(alignof(UEndBTTask_AIPCContinuousAttack) == 0x000008, "Wrong alignment on UEndBTTask_AIPCContinuousAttack");
static_assert(sizeof(UEndBTTask_AIPCContinuousAttack) == 0x0000A0, "Wrong size on UEndBTTask_AIPCContinuousAttack");
static_assert(offsetof(UEndBTTask_AIPCContinuousAttack, CombatDisntaceOffset) == 0x000070, "Member 'UEndBTTask_AIPCContinuousAttack::CombatDisntaceOffset' has a wrong offset!");
static_assert(offsetof(UEndBTTask_AIPCContinuousAttack, CombatRangeCoefficientBlackboardKey) == 0x000078, "Member 'UEndBTTask_AIPCContinuousAttack::CombatRangeCoefficientBlackboardKey' has a wrong offset!");

// Class EndGame.EndBTTask_AIPCExecuteAbility
// 0x00C8 (0x0138 - 0x0070)
class UEndBTTask_AIPCExecuteAbility final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 AbilityNameBlackboardKey;                          // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 AbilityTargetBlackboardKey;                        // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 IsExecuteWitoutTargetBlackboardKey;                // 0x00C0(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 AbilityHandleIdBlackboardKey;                      // 0x00E8(0x0028)(Edit, NativeAccessSpecifierPublic)
	float                                         StartWaitTime;                                     // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkipAbilityDistanceCheckBBKey;                     // 0x0114(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InstanceExecuteAbilityBBKey;                       // 0x011C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ExecutingAbility;                                  // 0x0124(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TeleportWaitBlackboardKey;                         // 0x012C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_AIPCExecuteAbility">();
	}
	static class UEndBTTask_AIPCExecuteAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_AIPCExecuteAbility>();
	}
};
static_assert(alignof(UEndBTTask_AIPCExecuteAbility) == 0x000008, "Wrong alignment on UEndBTTask_AIPCExecuteAbility");
static_assert(sizeof(UEndBTTask_AIPCExecuteAbility) == 0x000138, "Wrong size on UEndBTTask_AIPCExecuteAbility");
static_assert(offsetof(UEndBTTask_AIPCExecuteAbility, AbilityNameBlackboardKey) == 0x000070, "Member 'UEndBTTask_AIPCExecuteAbility::AbilityNameBlackboardKey' has a wrong offset!");
static_assert(offsetof(UEndBTTask_AIPCExecuteAbility, AbilityTargetBlackboardKey) == 0x000098, "Member 'UEndBTTask_AIPCExecuteAbility::AbilityTargetBlackboardKey' has a wrong offset!");
static_assert(offsetof(UEndBTTask_AIPCExecuteAbility, IsExecuteWitoutTargetBlackboardKey) == 0x0000C0, "Member 'UEndBTTask_AIPCExecuteAbility::IsExecuteWitoutTargetBlackboardKey' has a wrong offset!");
static_assert(offsetof(UEndBTTask_AIPCExecuteAbility, AbilityHandleIdBlackboardKey) == 0x0000E8, "Member 'UEndBTTask_AIPCExecuteAbility::AbilityHandleIdBlackboardKey' has a wrong offset!");
static_assert(offsetof(UEndBTTask_AIPCExecuteAbility, StartWaitTime) == 0x000110, "Member 'UEndBTTask_AIPCExecuteAbility::StartWaitTime' has a wrong offset!");
static_assert(offsetof(UEndBTTask_AIPCExecuteAbility, SkipAbilityDistanceCheckBBKey) == 0x000114, "Member 'UEndBTTask_AIPCExecuteAbility::SkipAbilityDistanceCheckBBKey' has a wrong offset!");
static_assert(offsetof(UEndBTTask_AIPCExecuteAbility, InstanceExecuteAbilityBBKey) == 0x00011C, "Member 'UEndBTTask_AIPCExecuteAbility::InstanceExecuteAbilityBBKey' has a wrong offset!");
static_assert(offsetof(UEndBTTask_AIPCExecuteAbility, ExecutingAbility) == 0x000124, "Member 'UEndBTTask_AIPCExecuteAbility::ExecutingAbility' has a wrong offset!");
static_assert(offsetof(UEndBTTask_AIPCExecuteAbility, TeleportWaitBlackboardKey) == 0x00012C, "Member 'UEndBTTask_AIPCExecuteAbility::TeleportWaitBlackboardKey' has a wrong offset!");

// Class EndGame.EndMenuTextureRenderTarget2D
// 0x0000 (0x0100 - 0x0100)
class UEndMenuTextureRenderTarget2D final : public UTextureRenderTarget2D
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMenuTextureRenderTarget2D">();
	}
	static class UEndMenuTextureRenderTarget2D* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMenuTextureRenderTarget2D>();
	}
};
static_assert(alignof(UEndMenuTextureRenderTarget2D) == 0x000008, "Wrong alignment on UEndMenuTextureRenderTarget2D");
static_assert(sizeof(UEndMenuTextureRenderTarget2D) == 0x000100, "Wrong size on UEndMenuTextureRenderTarget2D");

// Class EndGame.EndBTTask_AIPCMoveTo
// 0x0028 (0x0100 - 0x00D8)
class UEndBTTask_AIPCMoveTo final : public UEndBTTask_MoveTo
{
public:
	struct FBlackboardKeySelector                 MoveTargetBlackBoardKey;                           // 0x00D8(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_AIPCMoveTo">();
	}
	static class UEndBTTask_AIPCMoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_AIPCMoveTo>();
	}
};
static_assert(alignof(UEndBTTask_AIPCMoveTo) == 0x000008, "Wrong alignment on UEndBTTask_AIPCMoveTo");
static_assert(sizeof(UEndBTTask_AIPCMoveTo) == 0x000100, "Wrong size on UEndBTTask_AIPCMoveTo");
static_assert(offsetof(UEndBTTask_AIPCMoveTo, MoveTargetBlackBoardKey) == 0x0000D8, "Member 'UEndBTTask_AIPCMoveTo::MoveTargetBlackBoardKey' has a wrong offset!");

// Class EndGame.EndBTTask_AIPCSearchCombatArea
// 0x0028 (0x0098 - 0x0070)
class UEndBTTask_AIPCSearchCombatArea final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 CombatAreaBlackboardKey;                           // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_AIPCSearchCombatArea">();
	}
	static class UEndBTTask_AIPCSearchCombatArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_AIPCSearchCombatArea>();
	}
};
static_assert(alignof(UEndBTTask_AIPCSearchCombatArea) == 0x000008, "Wrong alignment on UEndBTTask_AIPCSearchCombatArea");
static_assert(sizeof(UEndBTTask_AIPCSearchCombatArea) == 0x000098, "Wrong size on UEndBTTask_AIPCSearchCombatArea");
static_assert(offsetof(UEndBTTask_AIPCSearchCombatArea, CombatAreaBlackboardKey) == 0x000070, "Member 'UEndBTTask_AIPCSearchCombatArea::CombatAreaBlackboardKey' has a wrong offset!");

// Class EndGame.EndBTTask_AIPCSearchCoverLocation
// 0x0028 (0x0098 - 0x0070)
class UEndBTTask_AIPCSearchCoverLocation final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 CoverLocationBlackboardKey;                        // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_AIPCSearchCoverLocation">();
	}
	static class UEndBTTask_AIPCSearchCoverLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_AIPCSearchCoverLocation>();
	}
};
static_assert(alignof(UEndBTTask_AIPCSearchCoverLocation) == 0x000008, "Wrong alignment on UEndBTTask_AIPCSearchCoverLocation");
static_assert(sizeof(UEndBTTask_AIPCSearchCoverLocation) == 0x000098, "Wrong size on UEndBTTask_AIPCSearchCoverLocation");
static_assert(offsetof(UEndBTTask_AIPCSearchCoverLocation, CoverLocationBlackboardKey) == 0x000070, "Member 'UEndBTTask_AIPCSearchCoverLocation::CoverLocationBlackboardKey' has a wrong offset!");

// Class EndGame.EndBTTask_AIPCSearchTarget
// 0x0040 (0x00B0 - 0x0070)
class UEndBTTask_AIPCSearchTarget final : public UBTTaskNode
{
public:
	uint8                                         Pad_70[0x40];                                      // 0x0070(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_AIPCSearchTarget">();
	}
	static class UEndBTTask_AIPCSearchTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_AIPCSearchTarget>();
	}
};
static_assert(alignof(UEndBTTask_AIPCSearchTarget) == 0x000008, "Wrong alignment on UEndBTTask_AIPCSearchTarget");
static_assert(sizeof(UEndBTTask_AIPCSearchTarget) == 0x0000B0, "Wrong size on UEndBTTask_AIPCSearchTarget");

// Class EndGame.EndBTTask_CactuarHundredNeedles
// 0x0058 (0x00C8 - 0x0070)
class UEndBTTask_CactuarHundredNeedles final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 FromBlackboardKey_AbilityExecuteState;             // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 FromBlackboardKey_InWarp;                          // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)
	class FName                                   AbilityID;                                         // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_CactuarHundredNeedles">();
	}
	static class UEndBTTask_CactuarHundredNeedles* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_CactuarHundredNeedles>();
	}
};
static_assert(alignof(UEndBTTask_CactuarHundredNeedles) == 0x000008, "Wrong alignment on UEndBTTask_CactuarHundredNeedles");
static_assert(sizeof(UEndBTTask_CactuarHundredNeedles) == 0x0000C8, "Wrong size on UEndBTTask_CactuarHundredNeedles");
static_assert(offsetof(UEndBTTask_CactuarHundredNeedles, FromBlackboardKey_AbilityExecuteState) == 0x000070, "Member 'UEndBTTask_CactuarHundredNeedles::FromBlackboardKey_AbilityExecuteState' has a wrong offset!");
static_assert(offsetof(UEndBTTask_CactuarHundredNeedles, FromBlackboardKey_InWarp) == 0x000098, "Member 'UEndBTTask_CactuarHundredNeedles::FromBlackboardKey_InWarp' has a wrong offset!");
static_assert(offsetof(UEndBTTask_CactuarHundredNeedles, AbilityID) == 0x0000C0, "Member 'UEndBTTask_CactuarHundredNeedles::AbilityID' has a wrong offset!");

// Class EndGame.EndNavActorInterface
// 0x0000 (0x0028 - 0x0028)
class IEndNavActorInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavActorInterface">();
	}
	static class IEndNavActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEndNavActorInterface>();
	}
};
static_assert(alignof(IEndNavActorInterface) == 0x000008, "Wrong alignment on IEndNavActorInterface");
static_assert(sizeof(IEndNavActorInterface) == 0x000028, "Wrong size on IEndNavActorInterface");

// Class EndGame.EndBTTask_DoNothing
// 0x0008 (0x0078 - 0x0070)
class UEndBTTask_DoNothing final : public UBTTaskNode
{
public:
	EBTNodeResult                                 m_SelectionType;                                   // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_DoNothing">();
	}
	static class UEndBTTask_DoNothing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_DoNothing>();
	}
};
static_assert(alignof(UEndBTTask_DoNothing) == 0x000008, "Wrong alignment on UEndBTTask_DoNothing");
static_assert(sizeof(UEndBTTask_DoNothing) == 0x000078, "Wrong size on UEndBTTask_DoNothing");
static_assert(offsetof(UEndBTTask_DoNothing, m_SelectionType) == 0x000070, "Member 'UEndBTTask_DoNothing::m_SelectionType' has a wrong offset!");

// Class EndGame.EndBTTask_Field_Lead_MoveTo
// 0x0000 (0x00E0 - 0x00E0)
class UEndBTTask_Field_Lead_MoveTo final : public UEndBTTask_Field_MoveTo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_Field_Lead_MoveTo">();
	}
	static class UEndBTTask_Field_Lead_MoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_Field_Lead_MoveTo>();
	}
};
static_assert(alignof(UEndBTTask_Field_Lead_MoveTo) == 0x000008, "Wrong alignment on UEndBTTask_Field_Lead_MoveTo");
static_assert(sizeof(UEndBTTask_Field_Lead_MoveTo) == 0x0000E0, "Wrong size on UEndBTTask_Field_Lead_MoveTo");

// Class EndGame.EndBTTask_Field_LookAtTarget
// 0x0010 (0x00A8 - 0x0098)
class UEndBTTask_Field_LookAtTarget final : public UBTTask_BlackboardBase
{
public:
	bool                                          m_bActive;                                         // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_bForce;                                          // 0x0099(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x2];                                       // 0x009A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         m_LookAtInterval;                                  // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_LookAtIntervalRand;                              // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_LookAtDisableInterval;                           // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_Field_LookAtTarget">();
	}
	static class UEndBTTask_Field_LookAtTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_Field_LookAtTarget>();
	}
};
static_assert(alignof(UEndBTTask_Field_LookAtTarget) == 0x000008, "Wrong alignment on UEndBTTask_Field_LookAtTarget");
static_assert(sizeof(UEndBTTask_Field_LookAtTarget) == 0x0000A8, "Wrong size on UEndBTTask_Field_LookAtTarget");
static_assert(offsetof(UEndBTTask_Field_LookAtTarget, m_bActive) == 0x000098, "Member 'UEndBTTask_Field_LookAtTarget::m_bActive' has a wrong offset!");
static_assert(offsetof(UEndBTTask_Field_LookAtTarget, m_bForce) == 0x000099, "Member 'UEndBTTask_Field_LookAtTarget::m_bForce' has a wrong offset!");
static_assert(offsetof(UEndBTTask_Field_LookAtTarget, m_LookAtInterval) == 0x00009C, "Member 'UEndBTTask_Field_LookAtTarget::m_LookAtInterval' has a wrong offset!");
static_assert(offsetof(UEndBTTask_Field_LookAtTarget, m_LookAtIntervalRand) == 0x0000A0, "Member 'UEndBTTask_Field_LookAtTarget::m_LookAtIntervalRand' has a wrong offset!");
static_assert(offsetof(UEndBTTask_Field_LookAtTarget, m_LookAtDisableInterval) == 0x0000A4, "Member 'UEndBTTask_Field_LookAtTarget::m_LookAtDisableInterval' has a wrong offset!");

// Class EndGame.EndBTTask_Field_TurnTo
// 0x0010 (0x00A8 - 0x0098)
class UEndBTTask_Field_TurnTo final : public UBTTask_BlackboardBase
{
public:
	float                                         m_Tolerance;                                       // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_Offset;                                          // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_bTurnContextRotation;                            // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_bRequestOnce;                                    // 0x00A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_Field_TurnTo">();
	}
	static class UEndBTTask_Field_TurnTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_Field_TurnTo>();
	}
};
static_assert(alignof(UEndBTTask_Field_TurnTo) == 0x000008, "Wrong alignment on UEndBTTask_Field_TurnTo");
static_assert(sizeof(UEndBTTask_Field_TurnTo) == 0x0000A8, "Wrong size on UEndBTTask_Field_TurnTo");
static_assert(offsetof(UEndBTTask_Field_TurnTo, m_Tolerance) == 0x000098, "Member 'UEndBTTask_Field_TurnTo::m_Tolerance' has a wrong offset!");
static_assert(offsetof(UEndBTTask_Field_TurnTo, m_Offset) == 0x00009C, "Member 'UEndBTTask_Field_TurnTo::m_Offset' has a wrong offset!");
static_assert(offsetof(UEndBTTask_Field_TurnTo, m_bTurnContextRotation) == 0x0000A0, "Member 'UEndBTTask_Field_TurnTo::m_bTurnContextRotation' has a wrong offset!");
static_assert(offsetof(UEndBTTask_Field_TurnTo, m_bRequestOnce) == 0x0000A1, "Member 'UEndBTTask_Field_TurnTo::m_bRequestOnce' has a wrong offset!");

// Class EndGame.EndNavAreaCation
// 0x0000 (0x0040 - 0x0040)
class UEndNavAreaCation final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavAreaCation">();
	}
	static class UEndNavAreaCation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavAreaCation>();
	}
};
static_assert(alignof(UEndNavAreaCation) == 0x000008, "Wrong alignment on UEndNavAreaCation");
static_assert(sizeof(UEndNavAreaCation) == 0x000040, "Wrong size on UEndNavAreaCation");

// Class EndGame.EndBTTask_HinachocoboMagic
// 0x0028 (0x0098 - 0x0070)
class UEndBTTask_HinachocoboMagic final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 FromBlackboardKey_InWarp;                          // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_HinachocoboMagic">();
	}
	static class UEndBTTask_HinachocoboMagic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_HinachocoboMagic>();
	}
};
static_assert(alignof(UEndBTTask_HinachocoboMagic) == 0x000008, "Wrong alignment on UEndBTTask_HinachocoboMagic");
static_assert(sizeof(UEndBTTask_HinachocoboMagic) == 0x000098, "Wrong size on UEndBTTask_HinachocoboMagic");
static_assert(offsetof(UEndBTTask_HinachocoboMagic, FromBlackboardKey_InWarp) == 0x000070, "Member 'UEndBTTask_HinachocoboMagic::FromBlackboardKey_InWarp' has a wrong offset!");

// Class EndGame.EndBTTask_IfritDropPunch
// 0x0098 (0x0108 - 0x0070)
class UEndBTTask_IfritDropPunch final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 FromBlackboardKey_AbilityID;                       // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 FromBlackboardKey_Location;                        // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 FromBlackboardKey_AbilityExecuteState;             // 0x00C0(0x0028)(Edit, NativeAccessSpecifierPublic)
	class FName                                   WarpMotion_Start;                                  // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeleportingTime;                                   // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IgnoreAbilityRangeBlackBoardName;                  // 0x00F4(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0xC];                                       // 0x00FC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_IfritDropPunch">();
	}
	static class UEndBTTask_IfritDropPunch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_IfritDropPunch>();
	}
};
static_assert(alignof(UEndBTTask_IfritDropPunch) == 0x000008, "Wrong alignment on UEndBTTask_IfritDropPunch");
static_assert(sizeof(UEndBTTask_IfritDropPunch) == 0x000108, "Wrong size on UEndBTTask_IfritDropPunch");
static_assert(offsetof(UEndBTTask_IfritDropPunch, FromBlackboardKey_AbilityID) == 0x000070, "Member 'UEndBTTask_IfritDropPunch::FromBlackboardKey_AbilityID' has a wrong offset!");
static_assert(offsetof(UEndBTTask_IfritDropPunch, FromBlackboardKey_Location) == 0x000098, "Member 'UEndBTTask_IfritDropPunch::FromBlackboardKey_Location' has a wrong offset!");
static_assert(offsetof(UEndBTTask_IfritDropPunch, FromBlackboardKey_AbilityExecuteState) == 0x0000C0, "Member 'UEndBTTask_IfritDropPunch::FromBlackboardKey_AbilityExecuteState' has a wrong offset!");
static_assert(offsetof(UEndBTTask_IfritDropPunch, WarpMotion_Start) == 0x0000E8, "Member 'UEndBTTask_IfritDropPunch::WarpMotion_Start' has a wrong offset!");
static_assert(offsetof(UEndBTTask_IfritDropPunch, TeleportingTime) == 0x0000F0, "Member 'UEndBTTask_IfritDropPunch::TeleportingTime' has a wrong offset!");
static_assert(offsetof(UEndBTTask_IfritDropPunch, IgnoreAbilityRangeBlackBoardName) == 0x0000F4, "Member 'UEndBTTask_IfritDropPunch::IgnoreAbilityRangeBlackBoardName' has a wrong offset!");

// Class EndGame.EndBTTask_JumpTo
// 0x0040 (0x00B0 - 0x0070)
class UEndBTTask_JumpTo final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 FromBlackboardKey_Location;                        // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	class FName                                   JumpMotion_Start;                                  // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   JumpMotion_Loop;                                   // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   JumpMotion_End;                                    // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_JumpTo">();
	}
	static class UEndBTTask_JumpTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_JumpTo>();
	}
};
static_assert(alignof(UEndBTTask_JumpTo) == 0x000008, "Wrong alignment on UEndBTTask_JumpTo");
static_assert(sizeof(UEndBTTask_JumpTo) == 0x0000B0, "Wrong size on UEndBTTask_JumpTo");
static_assert(offsetof(UEndBTTask_JumpTo, FromBlackboardKey_Location) == 0x000070, "Member 'UEndBTTask_JumpTo::FromBlackboardKey_Location' has a wrong offset!");
static_assert(offsetof(UEndBTTask_JumpTo, JumpMotion_Start) == 0x000098, "Member 'UEndBTTask_JumpTo::JumpMotion_Start' has a wrong offset!");
static_assert(offsetof(UEndBTTask_JumpTo, JumpMotion_Loop) == 0x0000A0, "Member 'UEndBTTask_JumpTo::JumpMotion_Loop' has a wrong offset!");
static_assert(offsetof(UEndBTTask_JumpTo, JumpMotion_End) == 0x0000A8, "Member 'UEndBTTask_JumpTo::JumpMotion_End' has a wrong offset!");

// Class EndGame.EndBTTask_PlayerExtraAction
// 0x0010 (0x0080 - 0x0070)
class UEndBTTask_PlayerExtraAction final : public UBTTaskNode
{
public:
	class FName                                   ExtraActionName;                                   // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_PlayerExtraAction">();
	}
	static class UEndBTTask_PlayerExtraAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_PlayerExtraAction>();
	}
};
static_assert(alignof(UEndBTTask_PlayerExtraAction) == 0x000008, "Wrong alignment on UEndBTTask_PlayerExtraAction");
static_assert(sizeof(UEndBTTask_PlayerExtraAction) == 0x000080, "Wrong size on UEndBTTask_PlayerExtraAction");
static_assert(offsetof(UEndBTTask_PlayerExtraAction, ExtraActionName) == 0x000070, "Member 'UEndBTTask_PlayerExtraAction::ExtraActionName' has a wrong offset!");

// Class EndGame.EndBTTask_RunEQS
// 0x0000 (0x0180 - 0x0180)
class UEndBTTask_RunEQS final : public UBTTask_RunEQSQuery
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_RunEQS">();
	}
	static class UEndBTTask_RunEQS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_RunEQS>();
	}
};
static_assert(alignof(UEndBTTask_RunEQS) == 0x000008, "Wrong alignment on UEndBTTask_RunEQS");
static_assert(sizeof(UEndBTTask_RunEQS) == 0x000180, "Wrong size on UEndBTTask_RunEQS");

// Class EndGame.EndBTTask_SononTeleport
// 0x0080 (0x00F0 - 0x0070)
class UEndBTTask_SononTeleport final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 LocationBlackboardKey;                             // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 TargetBlackboardKey;                               // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 TeleportingBlackboardKey;                          // 0x00C0(0x0028)(Edit, NativeAccessSpecifierPublic)
	bool                                          bCheckAbilityCancel;                               // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_SononTeleport">();
	}
	static class UEndBTTask_SononTeleport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_SononTeleport>();
	}
};
static_assert(alignof(UEndBTTask_SononTeleport) == 0x000008, "Wrong alignment on UEndBTTask_SononTeleport");
static_assert(sizeof(UEndBTTask_SononTeleport) == 0x0000F0, "Wrong size on UEndBTTask_SononTeleport");
static_assert(offsetof(UEndBTTask_SononTeleport, LocationBlackboardKey) == 0x000070, "Member 'UEndBTTask_SononTeleport::LocationBlackboardKey' has a wrong offset!");
static_assert(offsetof(UEndBTTask_SononTeleport, TargetBlackboardKey) == 0x000098, "Member 'UEndBTTask_SononTeleport::TargetBlackboardKey' has a wrong offset!");
static_assert(offsetof(UEndBTTask_SononTeleport, TeleportingBlackboardKey) == 0x0000C0, "Member 'UEndBTTask_SononTeleport::TeleportingBlackboardKey' has a wrong offset!");
static_assert(offsetof(UEndBTTask_SononTeleport, bCheckAbilityCancel) == 0x0000E8, "Member 'UEndBTTask_SononTeleport::bCheckAbilityCancel' has a wrong offset!");

// Class EndGame.EndBTTask_SummonChooseAbility
// 0x0040 (0x00B0 - 0x0070)
class UEndBTTask_SummonChooseAbility final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 FromBlackboardKey_Target;                          // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	class FName                                   RequestAbilityIDBlackBoardName;                    // 0x0098(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IgnoreAbilityRangeBlackBoardName;                  // 0x00A0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AbilityRangeBlackBoardName;                        // 0x00A8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_SummonChooseAbility">();
	}
	static class UEndBTTask_SummonChooseAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_SummonChooseAbility>();
	}
};
static_assert(alignof(UEndBTTask_SummonChooseAbility) == 0x000008, "Wrong alignment on UEndBTTask_SummonChooseAbility");
static_assert(sizeof(UEndBTTask_SummonChooseAbility) == 0x0000B0, "Wrong size on UEndBTTask_SummonChooseAbility");
static_assert(offsetof(UEndBTTask_SummonChooseAbility, FromBlackboardKey_Target) == 0x000070, "Member 'UEndBTTask_SummonChooseAbility::FromBlackboardKey_Target' has a wrong offset!");
static_assert(offsetof(UEndBTTask_SummonChooseAbility, RequestAbilityIDBlackBoardName) == 0x000098, "Member 'UEndBTTask_SummonChooseAbility::RequestAbilityIDBlackBoardName' has a wrong offset!");
static_assert(offsetof(UEndBTTask_SummonChooseAbility, IgnoreAbilityRangeBlackBoardName) == 0x0000A0, "Member 'UEndBTTask_SummonChooseAbility::IgnoreAbilityRangeBlackBoardName' has a wrong offset!");
static_assert(offsetof(UEndBTTask_SummonChooseAbility, AbilityRangeBlackBoardName) == 0x0000A8, "Member 'UEndBTTask_SummonChooseAbility::AbilityRangeBlackBoardName' has a wrong offset!");

// Class EndGame.EndBTTask_SummonExecuteAbility
// 0x0108 (0x0178 - 0x0070)
class UEndBTTask_SummonExecuteAbility final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 FromBlackboardKey_AbilityID;                       // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 FromBlackboardKey_IgnoreAbilityRange;              // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 FromBlackboardKey_AbilityRange;                    // 0x00C0(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 FromBlackboardKey_AbilityExecuteState;             // 0x00E8(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 FromBlackboardKey_Target;                          // 0x0110(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 FromBlackboardKey_InWarp;                          // 0x0138(0x0028)(Edit, NativeAccessSpecifierPublic)
	class FName                                   NeedApproachTargetBlackBoardName;                  // 0x0160(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ComboCountBlackBoardName;                          // 0x0168(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_170[0x8];                                      // 0x0170(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_SummonExecuteAbility">();
	}
	static class UEndBTTask_SummonExecuteAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_SummonExecuteAbility>();
	}
};
static_assert(alignof(UEndBTTask_SummonExecuteAbility) == 0x000008, "Wrong alignment on UEndBTTask_SummonExecuteAbility");
static_assert(sizeof(UEndBTTask_SummonExecuteAbility) == 0x000178, "Wrong size on UEndBTTask_SummonExecuteAbility");
static_assert(offsetof(UEndBTTask_SummonExecuteAbility, FromBlackboardKey_AbilityID) == 0x000070, "Member 'UEndBTTask_SummonExecuteAbility::FromBlackboardKey_AbilityID' has a wrong offset!");
static_assert(offsetof(UEndBTTask_SummonExecuteAbility, FromBlackboardKey_IgnoreAbilityRange) == 0x000098, "Member 'UEndBTTask_SummonExecuteAbility::FromBlackboardKey_IgnoreAbilityRange' has a wrong offset!");
static_assert(offsetof(UEndBTTask_SummonExecuteAbility, FromBlackboardKey_AbilityRange) == 0x0000C0, "Member 'UEndBTTask_SummonExecuteAbility::FromBlackboardKey_AbilityRange' has a wrong offset!");
static_assert(offsetof(UEndBTTask_SummonExecuteAbility, FromBlackboardKey_AbilityExecuteState) == 0x0000E8, "Member 'UEndBTTask_SummonExecuteAbility::FromBlackboardKey_AbilityExecuteState' has a wrong offset!");
static_assert(offsetof(UEndBTTask_SummonExecuteAbility, FromBlackboardKey_Target) == 0x000110, "Member 'UEndBTTask_SummonExecuteAbility::FromBlackboardKey_Target' has a wrong offset!");
static_assert(offsetof(UEndBTTask_SummonExecuteAbility, FromBlackboardKey_InWarp) == 0x000138, "Member 'UEndBTTask_SummonExecuteAbility::FromBlackboardKey_InWarp' has a wrong offset!");
static_assert(offsetof(UEndBTTask_SummonExecuteAbility, NeedApproachTargetBlackBoardName) == 0x000160, "Member 'UEndBTTask_SummonExecuteAbility::NeedApproachTargetBlackBoardName' has a wrong offset!");
static_assert(offsetof(UEndBTTask_SummonExecuteAbility, ComboCountBlackBoardName) == 0x000168, "Member 'UEndBTTask_SummonExecuteAbility::ComboCountBlackBoardName' has a wrong offset!");

// Class EndGame.EndBTTask_SummonMoveTo
// 0x0020 (0x00F8 - 0x00D8)
class UEndBTTask_SummonMoveTo final : public UEndBTTask_MoveTo
{
public:
	float                                         StuckTimeLimit;                                    // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveTimeLimit;                                     // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x18];                                      // 0x00E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_SummonMoveTo">();
	}
	static class UEndBTTask_SummonMoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_SummonMoveTo>();
	}
};
static_assert(alignof(UEndBTTask_SummonMoveTo) == 0x000008, "Wrong alignment on UEndBTTask_SummonMoveTo");
static_assert(sizeof(UEndBTTask_SummonMoveTo) == 0x0000F8, "Wrong size on UEndBTTask_SummonMoveTo");
static_assert(offsetof(UEndBTTask_SummonMoveTo, StuckTimeLimit) == 0x0000D8, "Member 'UEndBTTask_SummonMoveTo::StuckTimeLimit' has a wrong offset!");
static_assert(offsetof(UEndBTTask_SummonMoveTo, MoveTimeLimit) == 0x0000DC, "Member 'UEndBTTask_SummonMoveTo::MoveTimeLimit' has a wrong offset!");

// Class EndGame.EndBTTask_SummonSearchTarget
// 0x0008 (0x0078 - 0x0070)
class UEndBTTask_SummonSearchTarget final : public UBTTaskNode
{
public:
	bool                                          bBossFirst;                                        // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_SummonSearchTarget">();
	}
	static class UEndBTTask_SummonSearchTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_SummonSearchTarget>();
	}
};
static_assert(alignof(UEndBTTask_SummonSearchTarget) == 0x000008, "Wrong alignment on UEndBTTask_SummonSearchTarget");
static_assert(sizeof(UEndBTTask_SummonSearchTarget) == 0x000078, "Wrong size on UEndBTTask_SummonSearchTarget");
static_assert(offsetof(UEndBTTask_SummonSearchTarget, bBossFirst) == 0x000070, "Member 'UEndBTTask_SummonSearchTarget::bBossFirst' has a wrong offset!");

// Class EndGame.EndBTTask_SummonUltimateMagic
// 0x0050 (0x00C0 - 0x0070)
class UEndBTTask_SummonUltimateMagic final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 FromBlackboardKey_Target;                          // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 FromBlackboardKey_AbilityExecuteState;             // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_SummonUltimateMagic">();
	}
	static class UEndBTTask_SummonUltimateMagic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_SummonUltimateMagic>();
	}
};
static_assert(alignof(UEndBTTask_SummonUltimateMagic) == 0x000008, "Wrong alignment on UEndBTTask_SummonUltimateMagic");
static_assert(sizeof(UEndBTTask_SummonUltimateMagic) == 0x0000C0, "Wrong size on UEndBTTask_SummonUltimateMagic");
static_assert(offsetof(UEndBTTask_SummonUltimateMagic, FromBlackboardKey_Target) == 0x000070, "Member 'UEndBTTask_SummonUltimateMagic::FromBlackboardKey_Target' has a wrong offset!");
static_assert(offsetof(UEndBTTask_SummonUltimateMagic, FromBlackboardKey_AbilityExecuteState) == 0x000098, "Member 'UEndBTTask_SummonUltimateMagic::FromBlackboardKey_AbilityExecuteState' has a wrong offset!");

// Class EndGame.EndBTTask_WarpIn
// 0x0030 (0x00A0 - 0x0070)
class UEndBTTask_WarpIn final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 FromBlackboardKey_InWarp;                          // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_WarpIn">();
	}
	static class UEndBTTask_WarpIn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_WarpIn>();
	}
};
static_assert(alignof(UEndBTTask_WarpIn) == 0x000008, "Wrong alignment on UEndBTTask_WarpIn");
static_assert(sizeof(UEndBTTask_WarpIn) == 0x0000A0, "Wrong size on UEndBTTask_WarpIn");
static_assert(offsetof(UEndBTTask_WarpIn, FromBlackboardKey_InWarp) == 0x000070, "Member 'UEndBTTask_WarpIn::FromBlackboardKey_InWarp' has a wrong offset!");

// Class EndGame.EndBTTask_WarpOut
// 0x0058 (0x00C8 - 0x0070)
class UEndBTTask_WarpOut final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 LocationBlackboardKey;                             // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 FromBlackboardKey_InWarp;                          // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndBTTask_WarpOut">();
	}
	static class UEndBTTask_WarpOut* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndBTTask_WarpOut>();
	}
};
static_assert(alignof(UEndBTTask_WarpOut) == 0x000008, "Wrong alignment on UEndBTTask_WarpOut");
static_assert(sizeof(UEndBTTask_WarpOut) == 0x0000C8, "Wrong size on UEndBTTask_WarpOut");
static_assert(offsetof(UEndBTTask_WarpOut, LocationBlackboardKey) == 0x000070, "Member 'UEndBTTask_WarpOut::LocationBlackboardKey' has a wrong offset!");
static_assert(offsetof(UEndBTTask_WarpOut, FromBlackboardKey_InWarp) == 0x000098, "Member 'UEndBTTask_WarpOut::FromBlackboardKey_InWarp' has a wrong offset!");

// Class EndGame.EndButtonSlot
// 0x0028 (0x0060 - 0x0038)
class UEndButtonSlot final : public UPanelSlot
{
public:
	struct FMargin                                Padding;                                           // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0049(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x16];                                      // 0x004A(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment);
	void SetPadding(const struct FMargin& InPadding);
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndButtonSlot">();
	}
	static class UEndButtonSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndButtonSlot>();
	}
};
static_assert(alignof(UEndButtonSlot) == 0x000008, "Wrong alignment on UEndButtonSlot");
static_assert(sizeof(UEndButtonSlot) == 0x000060, "Wrong size on UEndButtonSlot");
static_assert(offsetof(UEndButtonSlot, Padding) == 0x000038, "Member 'UEndButtonSlot::Padding' has a wrong offset!");
static_assert(offsetof(UEndButtonSlot, HorizontalAlignment) == 0x000048, "Member 'UEndButtonSlot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UEndButtonSlot, VerticalAlignment) == 0x000049, "Member 'UEndButtonSlot::VerticalAlignment' has a wrong offset!");

// Class EndGame.EndCameraModeMenu
// 0x0150 (0x04B0 - 0x0360)
class UEndCameraModeMenu : public UEndUserWidget
{
public:
	TArray<struct FEndMenuColorCorrectionSelection> ColorCorrectionSelections;                         // 0x0360(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_370[0x128];                                    // 0x0370(0x0128)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndTextBlock*                          KeyGuideTextBlock;                                 // 0x0498(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A0[0x10];                                     // 0x04A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCameraModeMenu">();
	}
	static class UEndCameraModeMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndCameraModeMenu>();
	}
};
static_assert(alignof(UEndCameraModeMenu) == 0x000008, "Wrong alignment on UEndCameraModeMenu");
static_assert(sizeof(UEndCameraModeMenu) == 0x0004B0, "Wrong size on UEndCameraModeMenu");
static_assert(offsetof(UEndCameraModeMenu, ColorCorrectionSelections) == 0x000360, "Member 'UEndCameraModeMenu::ColorCorrectionSelections' has a wrong offset!");
static_assert(offsetof(UEndCameraModeMenu, KeyGuideTextBlock) == 0x000498, "Member 'UEndCameraModeMenu::KeyGuideTextBlock' has a wrong offset!");

// Class EndGame.EndCameraOnlyRail
// 0x00D8 (0x0550 - 0x0478)
class AEndCameraOnlyRail final : public AEndCameraRail
{
public:
	float                                         AimOffset;                                         // 0x0478(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraOffset;                                      // 0x047C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AimSocketName;                                     // 0x0480(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentCameraWeight;                               // 0x0488(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowCameraPosition;                                // 0x048C(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48D[0x3];                                      // 0x048D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartPointMargin;                                  // 0x0490(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndPointMargin;                                    // 0x0494(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraMoveThreshold;                               // 0x0498(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49C[0x4];                                      // 0x049C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 AimOffsets;                                        // 0x04A0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<float>                                 CameraOffsets;                                     // 0x04B0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<float>                                 CollisionIgnoreAngles;                             // 0x04C0(0x0010)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<float>                                 MoveDistanceForBlends;                             // 0x04D0(0x0010)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<float>                                 OrerrideFOVs;                                      // 0x04E0(0x0010)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          UseCollisionCheck;                                 // 0x04F0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseForceConnect;                                   // 0x04F1(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopControl;                                       // 0x04F2(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StartEndPointOnly;                                 // 0x04F3(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BoostAimFollow;                                    // 0x04F4(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceCutBlend;                                     // 0x04F5(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F6[0x5A];                                     // 0x04F6(0x005A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCameraOnlyRail">();
	}
	static class AEndCameraOnlyRail* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndCameraOnlyRail>();
	}
};
static_assert(alignof(AEndCameraOnlyRail) == 0x000008, "Wrong alignment on AEndCameraOnlyRail");
static_assert(sizeof(AEndCameraOnlyRail) == 0x000550, "Wrong size on AEndCameraOnlyRail");
static_assert(offsetof(AEndCameraOnlyRail, AimOffset) == 0x000478, "Member 'AEndCameraOnlyRail::AimOffset' has a wrong offset!");
static_assert(offsetof(AEndCameraOnlyRail, CameraOffset) == 0x00047C, "Member 'AEndCameraOnlyRail::CameraOffset' has a wrong offset!");
static_assert(offsetof(AEndCameraOnlyRail, AimSocketName) == 0x000480, "Member 'AEndCameraOnlyRail::AimSocketName' has a wrong offset!");
static_assert(offsetof(AEndCameraOnlyRail, CurrentCameraWeight) == 0x000488, "Member 'AEndCameraOnlyRail::CurrentCameraWeight' has a wrong offset!");
static_assert(offsetof(AEndCameraOnlyRail, ShowCameraPosition) == 0x00048C, "Member 'AEndCameraOnlyRail::ShowCameraPosition' has a wrong offset!");
static_assert(offsetof(AEndCameraOnlyRail, StartPointMargin) == 0x000490, "Member 'AEndCameraOnlyRail::StartPointMargin' has a wrong offset!");
static_assert(offsetof(AEndCameraOnlyRail, EndPointMargin) == 0x000494, "Member 'AEndCameraOnlyRail::EndPointMargin' has a wrong offset!");
static_assert(offsetof(AEndCameraOnlyRail, CameraMoveThreshold) == 0x000498, "Member 'AEndCameraOnlyRail::CameraMoveThreshold' has a wrong offset!");
static_assert(offsetof(AEndCameraOnlyRail, AimOffsets) == 0x0004A0, "Member 'AEndCameraOnlyRail::AimOffsets' has a wrong offset!");
static_assert(offsetof(AEndCameraOnlyRail, CameraOffsets) == 0x0004B0, "Member 'AEndCameraOnlyRail::CameraOffsets' has a wrong offset!");
static_assert(offsetof(AEndCameraOnlyRail, CollisionIgnoreAngles) == 0x0004C0, "Member 'AEndCameraOnlyRail::CollisionIgnoreAngles' has a wrong offset!");
static_assert(offsetof(AEndCameraOnlyRail, MoveDistanceForBlends) == 0x0004D0, "Member 'AEndCameraOnlyRail::MoveDistanceForBlends' has a wrong offset!");
static_assert(offsetof(AEndCameraOnlyRail, OrerrideFOVs) == 0x0004E0, "Member 'AEndCameraOnlyRail::OrerrideFOVs' has a wrong offset!");
static_assert(offsetof(AEndCameraOnlyRail, UseCollisionCheck) == 0x0004F0, "Member 'AEndCameraOnlyRail::UseCollisionCheck' has a wrong offset!");
static_assert(offsetof(AEndCameraOnlyRail, UseForceConnect) == 0x0004F1, "Member 'AEndCameraOnlyRail::UseForceConnect' has a wrong offset!");
static_assert(offsetof(AEndCameraOnlyRail, StopControl) == 0x0004F2, "Member 'AEndCameraOnlyRail::StopControl' has a wrong offset!");
static_assert(offsetof(AEndCameraOnlyRail, StartEndPointOnly) == 0x0004F3, "Member 'AEndCameraOnlyRail::StartEndPointOnly' has a wrong offset!");
static_assert(offsetof(AEndCameraOnlyRail, BoostAimFollow) == 0x0004F4, "Member 'AEndCameraOnlyRail::BoostAimFollow' has a wrong offset!");
static_assert(offsetof(AEndCameraOnlyRail, ForceCutBlend) == 0x0004F5, "Member 'AEndCameraOnlyRail::ForceCutBlend' has a wrong offset!");

// Class EndGame.EndParticleModuleCollision
// 0x0008 (0x0200 - 0x01F8)
class UEndParticleModuleCollision final : public UParticleModuleCollision
{
public:
	float                                         m_HitOffsetNormalScale;                            // 0x01F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_FreezeTranslationVelocityLength;                 // 0x01FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndParticleModuleCollision">();
	}
	static class UEndParticleModuleCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndParticleModuleCollision>();
	}
};
static_assert(alignof(UEndParticleModuleCollision) == 0x000008, "Wrong alignment on UEndParticleModuleCollision");
static_assert(sizeof(UEndParticleModuleCollision) == 0x000200, "Wrong size on UEndParticleModuleCollision");
static_assert(offsetof(UEndParticleModuleCollision, m_HitOffsetNormalScale) == 0x0001F8, "Member 'UEndParticleModuleCollision::m_HitOffsetNormalScale' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleCollision, m_FreezeTranslationVelocityLength) == 0x0001FC, "Member 'UEndParticleModuleCollision::m_FreezeTranslationVelocityLength' has a wrong offset!");

// Class EndGame.EndCameraShakeDefault
// 0x0010 (0x0170 - 0x0160)
class UEndCameraShakeDefault final : public UCameraShake
{
public:
	uint8                                         Pad_160[0x10];                                     // 0x0160(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCameraShakeDefault">();
	}
	static class UEndCameraShakeDefault* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndCameraShakeDefault>();
	}
};
static_assert(alignof(UEndCameraShakeDefault) == 0x000008, "Wrong alignment on UEndCameraShakeDefault");
static_assert(sizeof(UEndCameraShakeDefault) == 0x000170, "Wrong size on UEndCameraShakeDefault");

// Class EndGame.EndCanvasPanel
// 0x0038 (0x0148 - 0x0110)
class UEndCanvasPanel final : public UPanelWidget
{
public:
	struct FLinearColor                           ContentColorAndOpacity;                            // 0x0110(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ContentColorAndOpacityDelegate;                    // 0x0120(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bExplicitChildZOrder;                              // 0x0130(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraProjectionMode                         ProjectionMode;                                    // 0x0131(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_132[0x2];                                      // 0x0132(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FieldOfView;                                       // 0x0134(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0x10];                                     // 0x0138(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UEndCanvasPanelSlot* AddChildToCanvas(class UWidget* Content);
	void SetContentColorAndOpacity(const struct FLinearColor& InContentColorAndOpacity);
	void SetExplicitChildZOrder(bool bInExplicitChildZOrder);
	void SetFieldOfView(float InFieldOfView);
	void SetProjectionMode(ECameraProjectionMode InProjectionMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCanvasPanel">();
	}
	static class UEndCanvasPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndCanvasPanel>();
	}
};
static_assert(alignof(UEndCanvasPanel) == 0x000008, "Wrong alignment on UEndCanvasPanel");
static_assert(sizeof(UEndCanvasPanel) == 0x000148, "Wrong size on UEndCanvasPanel");
static_assert(offsetof(UEndCanvasPanel, ContentColorAndOpacity) == 0x000110, "Member 'UEndCanvasPanel::ContentColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UEndCanvasPanel, ContentColorAndOpacityDelegate) == 0x000120, "Member 'UEndCanvasPanel::ContentColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UEndCanvasPanel, bExplicitChildZOrder) == 0x000130, "Member 'UEndCanvasPanel::bExplicitChildZOrder' has a wrong offset!");
static_assert(offsetof(UEndCanvasPanel, ProjectionMode) == 0x000131, "Member 'UEndCanvasPanel::ProjectionMode' has a wrong offset!");
static_assert(offsetof(UEndCanvasPanel, FieldOfView) == 0x000134, "Member 'UEndCanvasPanel::FieldOfView' has a wrong offset!");

// Class EndGame.EndCategoryVolumeControlActor
// 0x0008 (0x0380 - 0x0378)
class AEndCategoryVolumeControlActor final : public AActor
{
public:
	class UEndCategoryVolumeControlComponent*     ControllerComponent;                               // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void UpdateCategoryVolumeComponent();

	class UEndCategoryVolumeControlComponent* GetControllerComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCategoryVolumeControlActor">();
	}
	static class AEndCategoryVolumeControlActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndCategoryVolumeControlActor>();
	}
};
static_assert(alignof(AEndCategoryVolumeControlActor) == 0x000008, "Wrong alignment on AEndCategoryVolumeControlActor");
static_assert(sizeof(AEndCategoryVolumeControlActor) == 0x000380, "Wrong size on AEndCategoryVolumeControlActor");
static_assert(offsetof(AEndCategoryVolumeControlActor, ControllerComponent) == 0x000378, "Member 'AEndCategoryVolumeControlActor::ControllerComponent' has a wrong offset!");

// Class EndGame.EndCategoryVolumeControlComponent
// 0x0020 (0x02D0 - 0x02B0)
class UEndCategoryVolumeControlComponent final : public USceneComponent
{
public:
	float                                         Volume_Backup;                                     // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Volume;                                            // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeTime;                                          // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CategoryName;                                      // 0x02BC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4[0xC];                                      // 0x02C4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeCategoryVolume(const class FName& TargetName);
	void TerminateCategoryVolume();
	void UpdateCategoryVolume();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCategoryVolumeControlComponent">();
	}
	static class UEndCategoryVolumeControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndCategoryVolumeControlComponent>();
	}
};
static_assert(alignof(UEndCategoryVolumeControlComponent) == 0x000008, "Wrong alignment on UEndCategoryVolumeControlComponent");
static_assert(sizeof(UEndCategoryVolumeControlComponent) == 0x0002D0, "Wrong size on UEndCategoryVolumeControlComponent");
static_assert(offsetof(UEndCategoryVolumeControlComponent, Volume_Backup) == 0x0002B0, "Member 'UEndCategoryVolumeControlComponent::Volume_Backup' has a wrong offset!");
static_assert(offsetof(UEndCategoryVolumeControlComponent, Volume) == 0x0002B4, "Member 'UEndCategoryVolumeControlComponent::Volume' has a wrong offset!");
static_assert(offsetof(UEndCategoryVolumeControlComponent, FadeTime) == 0x0002B8, "Member 'UEndCategoryVolumeControlComponent::FadeTime' has a wrong offset!");
static_assert(offsetof(UEndCategoryVolumeControlComponent, CategoryName) == 0x0002BC, "Member 'UEndCategoryVolumeControlComponent::CategoryName' has a wrong offset!");

// Class EndGame.EndChapterSelectMenu
// 0x0130 (0x0490 - 0x0360)
class UEndChapterSelectMenu : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0xC0];                                     // 0x0360(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSoftObjectPath>                _BillboardImagePaths;                              // 0x0420(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSoftObjectPath>                _PlusBillboardImagePaths;                          // 0x0430(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSoftObjectPath>                _CellBillboardPaths;                               // 0x0440(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSoftObjectPath>                _PlusCellBillboardPaths;                           // 0x0450(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FString>                         _ChapterInfos;                                     // 0x0460(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FString>                         _PlusChapterInfos;                                 // 0x0470(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class UEndUserWidget*                         Throbber;                                          // 0x0480(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_488[0x8];                                      // 0x0488(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChapterListPressedItem(int32 CellIndex);
	void OnChapterListSelectedIndexChanged(int32 CellIndex);
	void OnChapterListSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void SetCellImage(class UEndImage* Widget, class UPaperSprite* Sprite);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndChapterSelectMenu">();
	}
	static class UEndChapterSelectMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndChapterSelectMenu>();
	}
};
static_assert(alignof(UEndChapterSelectMenu) == 0x000008, "Wrong alignment on UEndChapterSelectMenu");
static_assert(sizeof(UEndChapterSelectMenu) == 0x000490, "Wrong size on UEndChapterSelectMenu");
static_assert(offsetof(UEndChapterSelectMenu, _BillboardImagePaths) == 0x000420, "Member 'UEndChapterSelectMenu::_BillboardImagePaths' has a wrong offset!");
static_assert(offsetof(UEndChapterSelectMenu, _PlusBillboardImagePaths) == 0x000430, "Member 'UEndChapterSelectMenu::_PlusBillboardImagePaths' has a wrong offset!");
static_assert(offsetof(UEndChapterSelectMenu, _CellBillboardPaths) == 0x000440, "Member 'UEndChapterSelectMenu::_CellBillboardPaths' has a wrong offset!");
static_assert(offsetof(UEndChapterSelectMenu, _PlusCellBillboardPaths) == 0x000450, "Member 'UEndChapterSelectMenu::_PlusCellBillboardPaths' has a wrong offset!");
static_assert(offsetof(UEndChapterSelectMenu, _ChapterInfos) == 0x000460, "Member 'UEndChapterSelectMenu::_ChapterInfos' has a wrong offset!");
static_assert(offsetof(UEndChapterSelectMenu, _PlusChapterInfos) == 0x000470, "Member 'UEndChapterSelectMenu::_PlusChapterInfos' has a wrong offset!");
static_assert(offsetof(UEndChapterSelectMenu, Throbber) == 0x000480, "Member 'UEndChapterSelectMenu::Throbber' has a wrong offset!");

// Class EndGame.EndTarzanSuccessIcon
// 0x0008 (0x0370 - 0x0368)
class UEndTarzanSuccessIcon final : public UEndSimpleMenu
{
public:
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndTarzanSuccessIcon">();
	}
	static class UEndTarzanSuccessIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndTarzanSuccessIcon>();
	}
};
static_assert(alignof(UEndTarzanSuccessIcon) == 0x000008, "Wrong alignment on UEndTarzanSuccessIcon");
static_assert(sizeof(UEndTarzanSuccessIcon) == 0x000370, "Wrong size on UEndTarzanSuccessIcon");

// Class EndGame.EndCharacterMovementActor
// 0x0060 (0x03D8 - 0x0378)
class AEndCharacterMovementActor final : public AActor
{
public:
	class UEndDuringCharacterMovementComponent*   DuringCharacterMovementComponentList[0xC];         // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCharacterMovementActor">();
	}
	static class AEndCharacterMovementActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndCharacterMovementActor>();
	}
};
static_assert(alignof(AEndCharacterMovementActor) == 0x000008, "Wrong alignment on AEndCharacterMovementActor");
static_assert(sizeof(AEndCharacterMovementActor) == 0x0003D8, "Wrong size on AEndCharacterMovementActor");
static_assert(offsetof(AEndCharacterMovementActor, DuringCharacterMovementComponentList) == 0x000378, "Member 'AEndCharacterMovementActor::DuringCharacterMovementComponentList' has a wrong offset!");

// Class EndGame.EndCharacterWhizSeComponent
// 0x0038 (0x0330 - 0x02F8)
class UEndCharacterWhizSeComponent final : public USQEXSEADWhizSeComponent
{
public:
	TSoftObjectPtr<class USoundBase>              SoundRef;                                          // 0x02F8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SoundName;                                         // 0x0320(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCharacterWhizSeComponent">();
	}
	static class UEndCharacterWhizSeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndCharacterWhizSeComponent>();
	}
};
static_assert(alignof(UEndCharacterWhizSeComponent) == 0x000008, "Wrong alignment on UEndCharacterWhizSeComponent");
static_assert(sizeof(UEndCharacterWhizSeComponent) == 0x000330, "Wrong size on UEndCharacterWhizSeComponent");
static_assert(offsetof(UEndCharacterWhizSeComponent, SoundRef) == 0x0002F8, "Member 'UEndCharacterWhizSeComponent::SoundRef' has a wrong offset!");
static_assert(offsetof(UEndCharacterWhizSeComponent, SoundName) == 0x000320, "Member 'UEndCharacterWhizSeComponent::SoundName' has a wrong offset!");

// Class EndGame.EndCharacterZeroOneSeComponent
// 0x0068 (0x0160 - 0x00F8)
class UEndCharacterZeroOneSeComponent final : public UActorComponent
{
public:
	TSoftObjectPtr<class USoundBase>              SoundRef;                                          // 0x00F8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SoundName;                                         // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PropertyValueMax;                                  // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInTime;                                        // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTime;                                       // 0x0130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttatch;                                          // 0x0134(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefaultEnable;                                    // 0x0135(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_136[0x2];                                      // 0x0136(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachPointName;                                   // 0x0138(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSlot0;                                      // 0x0140(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndCharacterZeroOneSeProperties              Slot0Property;                                     // 0x0141(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSlot1;                                      // 0x0142(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndCharacterZeroOneSeProperties              Slot1Property;                                     // 0x0143(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x1C];                                     // 0x0144(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCharacterZeroOneSeComponent">();
	}
	static class UEndCharacterZeroOneSeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndCharacterZeroOneSeComponent>();
	}
};
static_assert(alignof(UEndCharacterZeroOneSeComponent) == 0x000008, "Wrong alignment on UEndCharacterZeroOneSeComponent");
static_assert(sizeof(UEndCharacterZeroOneSeComponent) == 0x000160, "Wrong size on UEndCharacterZeroOneSeComponent");
static_assert(offsetof(UEndCharacterZeroOneSeComponent, SoundRef) == 0x0000F8, "Member 'UEndCharacterZeroOneSeComponent::SoundRef' has a wrong offset!");
static_assert(offsetof(UEndCharacterZeroOneSeComponent, SoundName) == 0x000120, "Member 'UEndCharacterZeroOneSeComponent::SoundName' has a wrong offset!");
static_assert(offsetof(UEndCharacterZeroOneSeComponent, PropertyValueMax) == 0x000128, "Member 'UEndCharacterZeroOneSeComponent::PropertyValueMax' has a wrong offset!");
static_assert(offsetof(UEndCharacterZeroOneSeComponent, FadeInTime) == 0x00012C, "Member 'UEndCharacterZeroOneSeComponent::FadeInTime' has a wrong offset!");
static_assert(offsetof(UEndCharacterZeroOneSeComponent, FadeOutTime) == 0x000130, "Member 'UEndCharacterZeroOneSeComponent::FadeOutTime' has a wrong offset!");
static_assert(offsetof(UEndCharacterZeroOneSeComponent, bAttatch) == 0x000134, "Member 'UEndCharacterZeroOneSeComponent::bAttatch' has a wrong offset!");
static_assert(offsetof(UEndCharacterZeroOneSeComponent, bDefaultEnable) == 0x000135, "Member 'UEndCharacterZeroOneSeComponent::bDefaultEnable' has a wrong offset!");
static_assert(offsetof(UEndCharacterZeroOneSeComponent, AttachPointName) == 0x000138, "Member 'UEndCharacterZeroOneSeComponent::AttachPointName' has a wrong offset!");
static_assert(offsetof(UEndCharacterZeroOneSeComponent, bEnableSlot0) == 0x000140, "Member 'UEndCharacterZeroOneSeComponent::bEnableSlot0' has a wrong offset!");
static_assert(offsetof(UEndCharacterZeroOneSeComponent, Slot0Property) == 0x000141, "Member 'UEndCharacterZeroOneSeComponent::Slot0Property' has a wrong offset!");
static_assert(offsetof(UEndCharacterZeroOneSeComponent, bEnableSlot1) == 0x000142, "Member 'UEndCharacterZeroOneSeComponent::bEnableSlot1' has a wrong offset!");
static_assert(offsetof(UEndCharacterZeroOneSeComponent, Slot1Property) == 0x000143, "Member 'UEndCharacterZeroOneSeComponent::Slot1Property' has a wrong offset!");

// Class EndGame.EndTextRenderActor
// 0x0000 (0x0380 - 0x0380)
class AEndTextRenderActor final : public ATextRenderActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndTextRenderActor">();
	}
	static class AEndTextRenderActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndTextRenderActor>();
	}
};
static_assert(alignof(AEndTextRenderActor) == 0x000008, "Wrong alignment on AEndTextRenderActor");
static_assert(sizeof(AEndTextRenderActor) == 0x000380, "Wrong size on AEndTextRenderActor");

// Class EndGame.EndChocoboFastTravelMenu
// 0x0180 (0x04E0 - 0x0360)
class UEndChocoboFastTravelMenu : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0xC0];                                     // 0x0360(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       PlayingAnimation;                                  // 0x0420(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_428[0xB8];                                     // 0x0428(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPointsListIndexChanged(int32 ItemIndex);
	void OnPointsListPressedItem(int32 ItemIndex);
	void OnPointsListSetupItem(class UWidget* ItemWidget, int32 ItemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndChocoboFastTravelMenu">();
	}
	static class UEndChocoboFastTravelMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndChocoboFastTravelMenu>();
	}
};
static_assert(alignof(UEndChocoboFastTravelMenu) == 0x000008, "Wrong alignment on UEndChocoboFastTravelMenu");
static_assert(sizeof(UEndChocoboFastTravelMenu) == 0x0004E0, "Wrong size on UEndChocoboFastTravelMenu");
static_assert(offsetof(UEndChocoboFastTravelMenu, PlayingAnimation) == 0x000420, "Member 'UEndChocoboFastTravelMenu::PlayingAnimation' has a wrong offset!");

// Class EndGame.EndCinemaButton
// 0x00C0 (0x0420 - 0x0360)
class UEndCinemaButton : public UEndUserWidget
{
public:
	float                                         SkipWaitTime;                                      // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MenuWaitTime;                                      // 0x0364(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MenuOutTime;                                       // 0x0368(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36C[0xB4];                                     // 0x036C(0x00B4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCinemaButton">();
	}
	static class UEndCinemaButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndCinemaButton>();
	}
};
static_assert(alignof(UEndCinemaButton) == 0x000008, "Wrong alignment on UEndCinemaButton");
static_assert(sizeof(UEndCinemaButton) == 0x000420, "Wrong size on UEndCinemaButton");
static_assert(offsetof(UEndCinemaButton, SkipWaitTime) == 0x000360, "Member 'UEndCinemaButton::SkipWaitTime' has a wrong offset!");
static_assert(offsetof(UEndCinemaButton, MenuWaitTime) == 0x000364, "Member 'UEndCinemaButton::MenuWaitTime' has a wrong offset!");
static_assert(offsetof(UEndCinemaButton, MenuOutTime) == 0x000368, "Member 'UEndCinemaButton::MenuOutTime' has a wrong offset!");

// Class EndGame.EndCmdShortcutCell
// 0x0038 (0x0398 - 0x0360)
class UEndCmdShortcutCell : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x38];                                     // 0x0360(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCmdShortcutCell">();
	}
	static class UEndCmdShortcutCell* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndCmdShortcutCell>();
	}
};
static_assert(alignof(UEndCmdShortcutCell) == 0x000008, "Wrong alignment on UEndCmdShortcutCell");
static_assert(sizeof(UEndCmdShortcutCell) == 0x000398, "Wrong size on UEndCmdShortcutCell");

// Class EndGame.EndCollisionActor
// 0x07C8 (0x0B40 - 0x0378)
class AEndCollisionActor final : public AActor
{
public:
	uint8                                         Pad_378[0x7C8];                                    // 0x0378(0x07C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCollisionActor">();
	}
	static class AEndCollisionActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndCollisionActor>();
	}
};
static_assert(alignof(AEndCollisionActor) == 0x000008, "Wrong alignment on AEndCollisionActor");
static_assert(sizeof(AEndCollisionActor) == 0x000B40, "Wrong size on AEndCollisionActor");

// Class EndGame.EndColorPalette
// 0x0058 (0x0080 - 0x0028)
class UEndColorPalette final : public UObject
{
public:
	TMap<class FName, struct FEndColorPaletteMaterial> Materials;                                         // 0x0028(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EEndEmissiveCurveType                         DefaultCurve;                                      // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultDuration;                                   // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndColorPalette">();
	}
	static class UEndColorPalette* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndColorPalette>();
	}
};
static_assert(alignof(UEndColorPalette) == 0x000008, "Wrong alignment on UEndColorPalette");
static_assert(sizeof(UEndColorPalette) == 0x000080, "Wrong size on UEndColorPalette");
static_assert(offsetof(UEndColorPalette, Materials) == 0x000028, "Member 'UEndColorPalette::Materials' has a wrong offset!");
static_assert(offsetof(UEndColorPalette, DefaultCurve) == 0x000078, "Member 'UEndColorPalette::DefaultCurve' has a wrong offset!");
static_assert(offsetof(UEndColorPalette, DefaultDuration) == 0x00007C, "Member 'UEndColorPalette::DefaultDuration' has a wrong offset!");

// Class EndGame.EndColosseumMenuWindow
// 0x00E0 (0x0440 - 0x0360)
class UEndColosseumMenuWindow : public UEndUserWidget
{
public:
	class UEndMenuColosseumPrototypeData*         PrototypeData;                                     // 0x0360(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_368[0xD8];                                     // 0x0368(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndColosseumMenuWindow">();
	}
	static class UEndColosseumMenuWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndColosseumMenuWindow>();
	}
};
static_assert(alignof(UEndColosseumMenuWindow) == 0x000008, "Wrong alignment on UEndColosseumMenuWindow");
static_assert(sizeof(UEndColosseumMenuWindow) == 0x000440, "Wrong size on UEndColosseumMenuWindow");
static_assert(offsetof(UEndColosseumMenuWindow, PrototypeData) == 0x000360, "Member 'UEndColosseumMenuWindow::PrototypeData' has a wrong offset!");

// Class EndGame.EndColosseumBattleSelectWindow
// 0x0030 (0x0470 - 0x0440)
class UEndColosseumBattleSelectWindow final : public UEndColosseumMenuWindow
{
public:
	uint8                                         Pad_440[0x30];                                     // 0x0440(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBattleListPressedItem(int32 ItemIndex);
	void OnBattleListSetupItem(class UWidget* ItemWidget, int32 ItemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndColosseumBattleSelectWindow">();
	}
	static class UEndColosseumBattleSelectWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndColosseumBattleSelectWindow>();
	}
};
static_assert(alignof(UEndColosseumBattleSelectWindow) == 0x000008, "Wrong alignment on UEndColosseumBattleSelectWindow");
static_assert(sizeof(UEndColosseumBattleSelectWindow) == 0x000470, "Wrong size on UEndColosseumBattleSelectWindow");

// Class EndGame.EndColosseumConfirmWindow
// 0x00A0 (0x0400 - 0x0360)
class UEndColosseumConfirmWindow final : public UEndUserWidget
{
public:
	class UEndTextBlock*                          Txt_NewRecord;                                     // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Turn;                                          // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Info;                                          // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Pnl_Win;                                           // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Pnl_Chara1;                                        // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Name1;                                         // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Pnl_Chara2;                                        // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Name2;                                         // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Pnl_Chara3;                                        // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Name3;                                         // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Pnl_Fee;                                           // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_TitleFee;                                      // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Fee;                                           // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Pnl_Gil;                                           // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_TitleGil;                                      // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_GIL;                                           // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVerticalBox*                           Nut_Btn;                                           // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndUserWidget*                         Btn_00;                                            // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndUserWidget*                         Btn_01;                                            // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F8[0x8];                                      // 0x03F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCancelNextBattleClicked();
	void OnConfirmNextBattleClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndColosseumConfirmWindow">();
	}
	static class UEndColosseumConfirmWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndColosseumConfirmWindow>();
	}
};
static_assert(alignof(UEndColosseumConfirmWindow) == 0x000008, "Wrong alignment on UEndColosseumConfirmWindow");
static_assert(sizeof(UEndColosseumConfirmWindow) == 0x000400, "Wrong size on UEndColosseumConfirmWindow");
static_assert(offsetof(UEndColosseumConfirmWindow, Txt_NewRecord) == 0x000360, "Member 'UEndColosseumConfirmWindow::Txt_NewRecord' has a wrong offset!");
static_assert(offsetof(UEndColosseumConfirmWindow, Txt_Turn) == 0x000368, "Member 'UEndColosseumConfirmWindow::Txt_Turn' has a wrong offset!");
static_assert(offsetof(UEndColosseumConfirmWindow, Txt_Info) == 0x000370, "Member 'UEndColosseumConfirmWindow::Txt_Info' has a wrong offset!");
static_assert(offsetof(UEndColosseumConfirmWindow, Pnl_Win) == 0x000378, "Member 'UEndColosseumConfirmWindow::Pnl_Win' has a wrong offset!");
static_assert(offsetof(UEndColosseumConfirmWindow, Pnl_Chara1) == 0x000380, "Member 'UEndColosseumConfirmWindow::Pnl_Chara1' has a wrong offset!");
static_assert(offsetof(UEndColosseumConfirmWindow, Txt_Name1) == 0x000388, "Member 'UEndColosseumConfirmWindow::Txt_Name1' has a wrong offset!");
static_assert(offsetof(UEndColosseumConfirmWindow, Pnl_Chara2) == 0x000390, "Member 'UEndColosseumConfirmWindow::Pnl_Chara2' has a wrong offset!");
static_assert(offsetof(UEndColosseumConfirmWindow, Txt_Name2) == 0x000398, "Member 'UEndColosseumConfirmWindow::Txt_Name2' has a wrong offset!");
static_assert(offsetof(UEndColosseumConfirmWindow, Pnl_Chara3) == 0x0003A0, "Member 'UEndColosseumConfirmWindow::Pnl_Chara3' has a wrong offset!");
static_assert(offsetof(UEndColosseumConfirmWindow, Txt_Name3) == 0x0003A8, "Member 'UEndColosseumConfirmWindow::Txt_Name3' has a wrong offset!");
static_assert(offsetof(UEndColosseumConfirmWindow, Pnl_Fee) == 0x0003B0, "Member 'UEndColosseumConfirmWindow::Pnl_Fee' has a wrong offset!");
static_assert(offsetof(UEndColosseumConfirmWindow, Txt_TitleFee) == 0x0003B8, "Member 'UEndColosseumConfirmWindow::Txt_TitleFee' has a wrong offset!");
static_assert(offsetof(UEndColosseumConfirmWindow, Txt_Fee) == 0x0003C0, "Member 'UEndColosseumConfirmWindow::Txt_Fee' has a wrong offset!");
static_assert(offsetof(UEndColosseumConfirmWindow, Pnl_Gil) == 0x0003C8, "Member 'UEndColosseumConfirmWindow::Pnl_Gil' has a wrong offset!");
static_assert(offsetof(UEndColosseumConfirmWindow, Txt_TitleGil) == 0x0003D0, "Member 'UEndColosseumConfirmWindow::Txt_TitleGil' has a wrong offset!");
static_assert(offsetof(UEndColosseumConfirmWindow, Txt_GIL) == 0x0003D8, "Member 'UEndColosseumConfirmWindow::Txt_GIL' has a wrong offset!");
static_assert(offsetof(UEndColosseumConfirmWindow, Nut_Btn) == 0x0003E0, "Member 'UEndColosseumConfirmWindow::Nut_Btn' has a wrong offset!");
static_assert(offsetof(UEndColosseumConfirmWindow, Btn_00) == 0x0003E8, "Member 'UEndColosseumConfirmWindow::Btn_00' has a wrong offset!");
static_assert(offsetof(UEndColosseumConfirmWindow, Btn_01) == 0x0003F0, "Member 'UEndColosseumConfirmWindow::Btn_01' has a wrong offset!");

// Class EndGame.EndColosseumInfoWindow
// 0x00B8 (0x0418 - 0x0360)
class UEndColosseumInfoWindow final : public UEndUserWidget
{
public:
	class UEndTextBlock*                          Txt_Difficulty;                                    // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_CourseTitle;                                   // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndVirtualScrollBox*                   Info2_ScrollList;                                  // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_TitleTurn;                                     // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_TitleMemberNum;                                // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_TitleFee;                                      // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_DifficultyTitle;                               // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Turn;                                          // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_MemberNum;                                     // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Fee;                                           // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_TitleTime;                                     // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_TitleParty;                                    // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Time;                                          // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Member1;                                       // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Member2;                                       // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Member3;                                       // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Info;                                          // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Btn;                                           // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Clear;                                         // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndImageSet*                           Icon_Clear;                                        // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Prize_Group1;                                      // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_ItemName_G1;                                   // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_ItemNum_G1;                                    // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndColosseumInfoWindow">();
	}
	static class UEndColosseumInfoWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndColosseumInfoWindow>();
	}
};
static_assert(alignof(UEndColosseumInfoWindow) == 0x000008, "Wrong alignment on UEndColosseumInfoWindow");
static_assert(sizeof(UEndColosseumInfoWindow) == 0x000418, "Wrong size on UEndColosseumInfoWindow");
static_assert(offsetof(UEndColosseumInfoWindow, Txt_Difficulty) == 0x000360, "Member 'UEndColosseumInfoWindow::Txt_Difficulty' has a wrong offset!");
static_assert(offsetof(UEndColosseumInfoWindow, Txt_CourseTitle) == 0x000368, "Member 'UEndColosseumInfoWindow::Txt_CourseTitle' has a wrong offset!");
static_assert(offsetof(UEndColosseumInfoWindow, Info2_ScrollList) == 0x000370, "Member 'UEndColosseumInfoWindow::Info2_ScrollList' has a wrong offset!");
static_assert(offsetof(UEndColosseumInfoWindow, Txt_TitleTurn) == 0x000378, "Member 'UEndColosseumInfoWindow::Txt_TitleTurn' has a wrong offset!");
static_assert(offsetof(UEndColosseumInfoWindow, Txt_TitleMemberNum) == 0x000380, "Member 'UEndColosseumInfoWindow::Txt_TitleMemberNum' has a wrong offset!");
static_assert(offsetof(UEndColosseumInfoWindow, Txt_TitleFee) == 0x000388, "Member 'UEndColosseumInfoWindow::Txt_TitleFee' has a wrong offset!");
static_assert(offsetof(UEndColosseumInfoWindow, Txt_DifficultyTitle) == 0x000390, "Member 'UEndColosseumInfoWindow::Txt_DifficultyTitle' has a wrong offset!");
static_assert(offsetof(UEndColosseumInfoWindow, Txt_Turn) == 0x000398, "Member 'UEndColosseumInfoWindow::Txt_Turn' has a wrong offset!");
static_assert(offsetof(UEndColosseumInfoWindow, Txt_MemberNum) == 0x0003A0, "Member 'UEndColosseumInfoWindow::Txt_MemberNum' has a wrong offset!");
static_assert(offsetof(UEndColosseumInfoWindow, Txt_Fee) == 0x0003A8, "Member 'UEndColosseumInfoWindow::Txt_Fee' has a wrong offset!");
static_assert(offsetof(UEndColosseumInfoWindow, Txt_TitleTime) == 0x0003B0, "Member 'UEndColosseumInfoWindow::Txt_TitleTime' has a wrong offset!");
static_assert(offsetof(UEndColosseumInfoWindow, Txt_TitleParty) == 0x0003B8, "Member 'UEndColosseumInfoWindow::Txt_TitleParty' has a wrong offset!");
static_assert(offsetof(UEndColosseumInfoWindow, Txt_Time) == 0x0003C0, "Member 'UEndColosseumInfoWindow::Txt_Time' has a wrong offset!");
static_assert(offsetof(UEndColosseumInfoWindow, Txt_Member1) == 0x0003C8, "Member 'UEndColosseumInfoWindow::Txt_Member1' has a wrong offset!");
static_assert(offsetof(UEndColosseumInfoWindow, Txt_Member2) == 0x0003D0, "Member 'UEndColosseumInfoWindow::Txt_Member2' has a wrong offset!");
static_assert(offsetof(UEndColosseumInfoWindow, Txt_Member3) == 0x0003D8, "Member 'UEndColosseumInfoWindow::Txt_Member3' has a wrong offset!");
static_assert(offsetof(UEndColosseumInfoWindow, Txt_Info) == 0x0003E0, "Member 'UEndColosseumInfoWindow::Txt_Info' has a wrong offset!");
static_assert(offsetof(UEndColosseumInfoWindow, Txt_Btn) == 0x0003E8, "Member 'UEndColosseumInfoWindow::Txt_Btn' has a wrong offset!");
static_assert(offsetof(UEndColosseumInfoWindow, Txt_Clear) == 0x0003F0, "Member 'UEndColosseumInfoWindow::Txt_Clear' has a wrong offset!");
static_assert(offsetof(UEndColosseumInfoWindow, Icon_Clear) == 0x0003F8, "Member 'UEndColosseumInfoWindow::Icon_Clear' has a wrong offset!");
static_assert(offsetof(UEndColosseumInfoWindow, Prize_Group1) == 0x000400, "Member 'UEndColosseumInfoWindow::Prize_Group1' has a wrong offset!");
static_assert(offsetof(UEndColosseumInfoWindow, Txt_ItemName_G1) == 0x000408, "Member 'UEndColosseumInfoWindow::Txt_ItemName_G1' has a wrong offset!");
static_assert(offsetof(UEndColosseumInfoWindow, Txt_ItemNum_G1) == 0x000410, "Member 'UEndColosseumInfoWindow::Txt_ItemNum_G1' has a wrong offset!");

// Class EndGame.EndColosseumMenu
// 0x0280 (0x05E0 - 0x0360)
class UEndColosseumMenu final : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x1A0];                                    // 0x0360(0x01A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndTextBlock*                          Txt_Btn;                                           // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndImage*                              Icon_Giru;                                         // 0x0508(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Giru;                                          // 0x0510(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_ListTitle1;                                    // 0x0518(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_ListTitle2;                                    // 0x0520(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_ListTitle3;                                    // 0x0528(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndVirtualScrollBox*                   Info2_ScrollList;                                  // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_TitleColiseum;                                 // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_TitleCourse;                                   // 0x0540(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Difficulty;                                    // 0x0548(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_SelectInfo1;                                   // 0x0550(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_SelectInfo2;                                   // 0x0558(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndVirtualScrollBox*                   LeftMenu_ScrollBox;                                // 0x0560(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndPlayerStatusPanel*                  Chara1;                                            // 0x0568(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndPlayerStatusPanel*                  Chara2;                                            // 0x0570(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndPlayerStatusPanel*                  Chara3;                                            // 0x0578(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Pnl_Leader;                                        // 0x0580(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_BattleLeader;                                  // 0x0588(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Pnl_CharaList;                                     // 0x0590(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        CharaNum1;                                         // 0x0598(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        CharaNum2;                                         // 0x05A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        CharaNum3;                                         // 0x05A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndImage*                              LightB1;                                           // 0x05B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndImage*                              LightB2;                                           // 0x05B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndImage*                              LightB3;                                           // 0x05C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndColosseumConfirmWindow*             ConfirmWindow;                                     // 0x05C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndColosseumInfoWindow*                InfoWindow;                                        // 0x05D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndUserWidget*                         DifficultyWindow;                                  // 0x05D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	struct FVector2D OnBattleInfoWindowMeasureItem(int32 ItemIndex);
	void OnBattleInfoWindowSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnCharaSelectMenuPressedItem(int32 CellIndex);
	void OnCharaSelectMenuSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnCourseMenuPressedItem(int32 CellIndex);
	void OnCourseMenuSelectedIndexChanged(int32 CellIndex);
	void OnCourseMenuSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnDifficultySelectMenuPressedItem(int32 CellIndex);
	void OnDifficultySelectMenuSelectedIndexChanged(int32 CellIndex);
	void OnDifficultySelectMenuSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnNoButtonPressed();
	void OnYesButtonPressed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndColosseumMenu">();
	}
	static class UEndColosseumMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndColosseumMenu>();
	}
};
static_assert(alignof(UEndColosseumMenu) == 0x000008, "Wrong alignment on UEndColosseumMenu");
static_assert(sizeof(UEndColosseumMenu) == 0x0005E0, "Wrong size on UEndColosseumMenu");
static_assert(offsetof(UEndColosseumMenu, Txt_Btn) == 0x000500, "Member 'UEndColosseumMenu::Txt_Btn' has a wrong offset!");
static_assert(offsetof(UEndColosseumMenu, Icon_Giru) == 0x000508, "Member 'UEndColosseumMenu::Icon_Giru' has a wrong offset!");
static_assert(offsetof(UEndColosseumMenu, Txt_Giru) == 0x000510, "Member 'UEndColosseumMenu::Txt_Giru' has a wrong offset!");
static_assert(offsetof(UEndColosseumMenu, Txt_ListTitle1) == 0x000518, "Member 'UEndColosseumMenu::Txt_ListTitle1' has a wrong offset!");
static_assert(offsetof(UEndColosseumMenu, Txt_ListTitle2) == 0x000520, "Member 'UEndColosseumMenu::Txt_ListTitle2' has a wrong offset!");
static_assert(offsetof(UEndColosseumMenu, Txt_ListTitle3) == 0x000528, "Member 'UEndColosseumMenu::Txt_ListTitle3' has a wrong offset!");
static_assert(offsetof(UEndColosseumMenu, Info2_ScrollList) == 0x000530, "Member 'UEndColosseumMenu::Info2_ScrollList' has a wrong offset!");
static_assert(offsetof(UEndColosseumMenu, Txt_TitleColiseum) == 0x000538, "Member 'UEndColosseumMenu::Txt_TitleColiseum' has a wrong offset!");
static_assert(offsetof(UEndColosseumMenu, Txt_TitleCourse) == 0x000540, "Member 'UEndColosseumMenu::Txt_TitleCourse' has a wrong offset!");
static_assert(offsetof(UEndColosseumMenu, Txt_Difficulty) == 0x000548, "Member 'UEndColosseumMenu::Txt_Difficulty' has a wrong offset!");
static_assert(offsetof(UEndColosseumMenu, Txt_SelectInfo1) == 0x000550, "Member 'UEndColosseumMenu::Txt_SelectInfo1' has a wrong offset!");
static_assert(offsetof(UEndColosseumMenu, Txt_SelectInfo2) == 0x000558, "Member 'UEndColosseumMenu::Txt_SelectInfo2' has a wrong offset!");
static_assert(offsetof(UEndColosseumMenu, LeftMenu_ScrollBox) == 0x000560, "Member 'UEndColosseumMenu::LeftMenu_ScrollBox' has a wrong offset!");
static_assert(offsetof(UEndColosseumMenu, Chara1) == 0x000568, "Member 'UEndColosseumMenu::Chara1' has a wrong offset!");
static_assert(offsetof(UEndColosseumMenu, Chara2) == 0x000570, "Member 'UEndColosseumMenu::Chara2' has a wrong offset!");
static_assert(offsetof(UEndColosseumMenu, Chara3) == 0x000578, "Member 'UEndColosseumMenu::Chara3' has a wrong offset!");
static_assert(offsetof(UEndColosseumMenu, Pnl_Leader) == 0x000580, "Member 'UEndColosseumMenu::Pnl_Leader' has a wrong offset!");
static_assert(offsetof(UEndColosseumMenu, Txt_BattleLeader) == 0x000588, "Member 'UEndColosseumMenu::Txt_BattleLeader' has a wrong offset!");
static_assert(offsetof(UEndColosseumMenu, Pnl_CharaList) == 0x000590, "Member 'UEndColosseumMenu::Pnl_CharaList' has a wrong offset!");
static_assert(offsetof(UEndColosseumMenu, CharaNum1) == 0x000598, "Member 'UEndColosseumMenu::CharaNum1' has a wrong offset!");
static_assert(offsetof(UEndColosseumMenu, CharaNum2) == 0x0005A0, "Member 'UEndColosseumMenu::CharaNum2' has a wrong offset!");
static_assert(offsetof(UEndColosseumMenu, CharaNum3) == 0x0005A8, "Member 'UEndColosseumMenu::CharaNum3' has a wrong offset!");
static_assert(offsetof(UEndColosseumMenu, LightB1) == 0x0005B0, "Member 'UEndColosseumMenu::LightB1' has a wrong offset!");
static_assert(offsetof(UEndColosseumMenu, LightB2) == 0x0005B8, "Member 'UEndColosseumMenu::LightB2' has a wrong offset!");
static_assert(offsetof(UEndColosseumMenu, LightB3) == 0x0005C0, "Member 'UEndColosseumMenu::LightB3' has a wrong offset!");
static_assert(offsetof(UEndColosseumMenu, ConfirmWindow) == 0x0005C8, "Member 'UEndColosseumMenu::ConfirmWindow' has a wrong offset!");
static_assert(offsetof(UEndColosseumMenu, InfoWindow) == 0x0005D0, "Member 'UEndColosseumMenu::InfoWindow' has a wrong offset!");
static_assert(offsetof(UEndColosseumMenu, DifficultyWindow) == 0x0005D8, "Member 'UEndColosseumMenu::DifficultyWindow' has a wrong offset!");

// Class EndGame.EndColosseumModeSelectWindow
// 0x0010 (0x0450 - 0x0440)
class UEndColosseumModeSelectWindow final : public UEndColosseumMenuWindow
{
public:
	uint8                                         Pad_440[0x10];                                     // 0x0440(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnModeListPressedItem(int32 ItemIndex);
	void OnModeListSetupItem(class UWidget* ItemWidget, int32 ItemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndColosseumModeSelectWindow">();
	}
	static class UEndColosseumModeSelectWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndColosseumModeSelectWindow>();
	}
};
static_assert(alignof(UEndColosseumModeSelectWindow) == 0x000008, "Wrong alignment on UEndColosseumModeSelectWindow");
static_assert(sizeof(UEndColosseumModeSelectWindow) == 0x000450, "Wrong size on UEndColosseumModeSelectWindow");

// Class EndGame.EndColosseumResultMenu
// 0x00E0 (0x0440 - 0x0360)
class UEndColosseumResultMenu final : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x48];                                     // 0x0360(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndTextBlock*                          Txt_Difficulty;                                    // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_CourseTitle;                                   // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_DifficultyTitle;                               // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Time;                                          // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Turn;                                          // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_FailedTime;                                    // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_NewRecord;                                     // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_ItemName_G1;                                   // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_ItemName_G2;                                   // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_ItemName_G3;                                   // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_ItemNum_G1;                                    // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_ItemNum_G2;                                    // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_ItemNum_G3;                                    // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Pnl_NewRecord;                                     // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Prize_Group1;                                      // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Prize_Group2;                                      // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Prize_Group3;                                      // 0x0428(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndButton*                             Focus_Button;                                      // 0x0430(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndColosseumConfirmWindow*             ConfirmWindow;                                     // 0x0438(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnNoButtonPressed();
	void OnYesButtonPressed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndColosseumResultMenu">();
	}
	static class UEndColosseumResultMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndColosseumResultMenu>();
	}
};
static_assert(alignof(UEndColosseumResultMenu) == 0x000008, "Wrong alignment on UEndColosseumResultMenu");
static_assert(sizeof(UEndColosseumResultMenu) == 0x000440, "Wrong size on UEndColosseumResultMenu");
static_assert(offsetof(UEndColosseumResultMenu, Txt_Difficulty) == 0x0003A8, "Member 'UEndColosseumResultMenu::Txt_Difficulty' has a wrong offset!");
static_assert(offsetof(UEndColosseumResultMenu, Txt_CourseTitle) == 0x0003B0, "Member 'UEndColosseumResultMenu::Txt_CourseTitle' has a wrong offset!");
static_assert(offsetof(UEndColosseumResultMenu, Txt_DifficultyTitle) == 0x0003B8, "Member 'UEndColosseumResultMenu::Txt_DifficultyTitle' has a wrong offset!");
static_assert(offsetof(UEndColosseumResultMenu, Txt_Time) == 0x0003C0, "Member 'UEndColosseumResultMenu::Txt_Time' has a wrong offset!");
static_assert(offsetof(UEndColosseumResultMenu, Txt_Turn) == 0x0003C8, "Member 'UEndColosseumResultMenu::Txt_Turn' has a wrong offset!");
static_assert(offsetof(UEndColosseumResultMenu, Txt_FailedTime) == 0x0003D0, "Member 'UEndColosseumResultMenu::Txt_FailedTime' has a wrong offset!");
static_assert(offsetof(UEndColosseumResultMenu, Txt_NewRecord) == 0x0003D8, "Member 'UEndColosseumResultMenu::Txt_NewRecord' has a wrong offset!");
static_assert(offsetof(UEndColosseumResultMenu, Txt_ItemName_G1) == 0x0003E0, "Member 'UEndColosseumResultMenu::Txt_ItemName_G1' has a wrong offset!");
static_assert(offsetof(UEndColosseumResultMenu, Txt_ItemName_G2) == 0x0003E8, "Member 'UEndColosseumResultMenu::Txt_ItemName_G2' has a wrong offset!");
static_assert(offsetof(UEndColosseumResultMenu, Txt_ItemName_G3) == 0x0003F0, "Member 'UEndColosseumResultMenu::Txt_ItemName_G3' has a wrong offset!");
static_assert(offsetof(UEndColosseumResultMenu, Txt_ItemNum_G1) == 0x0003F8, "Member 'UEndColosseumResultMenu::Txt_ItemNum_G1' has a wrong offset!");
static_assert(offsetof(UEndColosseumResultMenu, Txt_ItemNum_G2) == 0x000400, "Member 'UEndColosseumResultMenu::Txt_ItemNum_G2' has a wrong offset!");
static_assert(offsetof(UEndColosseumResultMenu, Txt_ItemNum_G3) == 0x000408, "Member 'UEndColosseumResultMenu::Txt_ItemNum_G3' has a wrong offset!");
static_assert(offsetof(UEndColosseumResultMenu, Pnl_NewRecord) == 0x000410, "Member 'UEndColosseumResultMenu::Pnl_NewRecord' has a wrong offset!");
static_assert(offsetof(UEndColosseumResultMenu, Prize_Group1) == 0x000418, "Member 'UEndColosseumResultMenu::Prize_Group1' has a wrong offset!");
static_assert(offsetof(UEndColosseumResultMenu, Prize_Group2) == 0x000420, "Member 'UEndColosseumResultMenu::Prize_Group2' has a wrong offset!");
static_assert(offsetof(UEndColosseumResultMenu, Prize_Group3) == 0x000428, "Member 'UEndColosseumResultMenu::Prize_Group3' has a wrong offset!");
static_assert(offsetof(UEndColosseumResultMenu, Focus_Button) == 0x000430, "Member 'UEndColosseumResultMenu::Focus_Button' has a wrong offset!");
static_assert(offsetof(UEndColosseumResultMenu, ConfirmWindow) == 0x000438, "Member 'UEndColosseumResultMenu::ConfirmWindow' has a wrong offset!");

// Class EndGame.EndColosseumSupplyHandicapWindow
// 0x0020 (0x0460 - 0x0440)
class UEndColosseumSupplyHandicapWindow final : public UEndColosseumMenuWindow
{
public:
	uint8                                         Pad_440[0x20];                                     // 0x0440(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCommandListPressedItem(int32 ItemIndex);
	void OnCommandListSetupItem(class UWidget* ItemWidget, int32 ItemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndColosseumSupplyHandicapWindow">();
	}
	static class UEndColosseumSupplyHandicapWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndColosseumSupplyHandicapWindow>();
	}
};
static_assert(alignof(UEndColosseumSupplyHandicapWindow) == 0x000008, "Wrong alignment on UEndColosseumSupplyHandicapWindow");
static_assert(sizeof(UEndColosseumSupplyHandicapWindow) == 0x000460, "Wrong size on UEndColosseumSupplyHandicapWindow");

// Class EndGame.EndCommonAPI
// 0x0000 (0x0028 - 0x0028)
class UEndCommonAPI final : public UObject
{
public:
	static float RandomFloatInRange(float Min, float Max);
	static int32 RandomIntegerInRange(int32 Min, int32 Max);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCommonAPI">();
	}
	static class UEndCommonAPI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndCommonAPI>();
	}
};
static_assert(alignof(UEndCommonAPI) == 0x000008, "Wrong alignment on UEndCommonAPI");
static_assert(sizeof(UEndCommonAPI) == 0x000028, "Wrong size on UEndCommonAPI");

// Class EndGame.EndCompassWindow
// 0x0010 (0x0370 - 0x0360)
class UEndCompassWindow : public UEndUserWidget
{
public:
	float                                         CompassMarginX;                                    // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEndUserWidget>             AreaEffectWidgetClass;                             // 0x0368(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCompassWindow">();
	}
	static class UEndCompassWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndCompassWindow>();
	}
};
static_assert(alignof(UEndCompassWindow) == 0x000008, "Wrong alignment on UEndCompassWindow");
static_assert(sizeof(UEndCompassWindow) == 0x000370, "Wrong size on UEndCompassWindow");
static_assert(offsetof(UEndCompassWindow, CompassMarginX) == 0x000360, "Member 'UEndCompassWindow::CompassMarginX' has a wrong offset!");
static_assert(offsetof(UEndCompassWindow, AreaEffectWidgetClass) == 0x000368, "Member 'UEndCompassWindow::AreaEffectWidgetClass' has a wrong offset!");

// Class EndGame.EndCondorFortMiniGameBoardSelectWindow
// 0x0080 (0x03E0 - 0x0360)
class UEndCondorFortMiniGameBoardSelectWindow final : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x80];                                     // 0x0360(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector2D OnMeasureItem_Guage(int32 ItemIndex);
	void OnPressedItem_BoardList(int32 ItemIndex);
	void OnSetupItem_BoardList(class UWidget* ItemWidget, int32 ItemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCondorFortMiniGameBoardSelectWindow">();
	}
	static class UEndCondorFortMiniGameBoardSelectWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndCondorFortMiniGameBoardSelectWindow>();
	}
};
static_assert(alignof(UEndCondorFortMiniGameBoardSelectWindow) == 0x000008, "Wrong alignment on UEndCondorFortMiniGameBoardSelectWindow");
static_assert(sizeof(UEndCondorFortMiniGameBoardSelectWindow) == 0x0003E0, "Wrong size on UEndCondorFortMiniGameBoardSelectWindow");

// Class EndGame.EndCondorFortMinigameEditMenu
// 0x00E0 (0x0440 - 0x0360)
class UEndCondorFortMinigameEditMenu final : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0xE0];                                     // 0x0360(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClicked_Board(class FName BoardID);
	void OnClicked_UnitSelect(class UEndCondorFortMiniGameUnitItem* UnitItem);
	void OnClicked_UnitSwap(class UEndCondorFortMiniGameUnitItem* UnitItem);
	void OnSetup_UnitListCell(class UWidget* ItemWidget, int32 ItemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCondorFortMinigameEditMenu">();
	}
	static class UEndCondorFortMinigameEditMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndCondorFortMinigameEditMenu>();
	}
};
static_assert(alignof(UEndCondorFortMinigameEditMenu) == 0x000008, "Wrong alignment on UEndCondorFortMinigameEditMenu");
static_assert(sizeof(UEndCondorFortMinigameEditMenu) == 0x000440, "Wrong size on UEndCondorFortMinigameEditMenu");

// Class EndGame.EndCondorFortMiniGameInfoWindow
// 0x0088 (0x03E8 - 0x0360)
class UEndCondorFortMiniGameInfoWindow final : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x88];                                     // 0x0360(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector2D OnMeasureItem_Guage(int32 ItemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCondorFortMiniGameInfoWindow">();
	}
	static class UEndCondorFortMiniGameInfoWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndCondorFortMiniGameInfoWindow>();
	}
};
static_assert(alignof(UEndCondorFortMiniGameInfoWindow) == 0x000008, "Wrong alignment on UEndCondorFortMiniGameInfoWindow");
static_assert(sizeof(UEndCondorFortMiniGameInfoWindow) == 0x0003E8, "Wrong size on UEndCondorFortMiniGameInfoWindow");

// Class EndGame.EndCondorFortMiniGameMagicCursor
// 0x0028 (0x0388 - 0x0360)
class UEndCondorFortMiniGameMagicCursor final : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x28];                                     // 0x0360(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCondorFortMiniGameMagicCursor">();
	}
	static class UEndCondorFortMiniGameMagicCursor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndCondorFortMiniGameMagicCursor>();
	}
};
static_assert(alignof(UEndCondorFortMiniGameMagicCursor) == 0x000008, "Wrong alignment on UEndCondorFortMiniGameMagicCursor");
static_assert(sizeof(UEndCondorFortMiniGameMagicCursor) == 0x000388, "Wrong size on UEndCondorFortMiniGameMagicCursor");

// Class EndGame.EndCondorFortMiniGameMateriaInfoItem
// 0x0028 (0x0388 - 0x0360)
class UEndCondorFortMiniGameMateriaInfoItem final : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x28];                                     // 0x0360(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCondorFortMiniGameMateriaInfoItem">();
	}
	static class UEndCondorFortMiniGameMateriaInfoItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndCondorFortMiniGameMateriaInfoItem>();
	}
};
static_assert(alignof(UEndCondorFortMiniGameMateriaInfoItem) == 0x000008, "Wrong alignment on UEndCondorFortMiniGameMateriaInfoItem");
static_assert(sizeof(UEndCondorFortMiniGameMateriaInfoItem) == 0x000388, "Wrong size on UEndCondorFortMiniGameMateriaInfoItem");

// Class EndGame.EndNavModifierFootBGMVolume
// 0x0008 (0x0430 - 0x0428)
class AEndNavModifierFootBGMVolume final : public AEndNavModifierVolumeBase
{
public:
	class FName                                   _footBGMSetID;                                     // 0x0428(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavModifierFootBGMVolume">();
	}
	static class AEndNavModifierFootBGMVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndNavModifierFootBGMVolume>();
	}
};
static_assert(alignof(AEndNavModifierFootBGMVolume) == 0x000008, "Wrong alignment on AEndNavModifierFootBGMVolume");
static_assert(sizeof(AEndNavModifierFootBGMVolume) == 0x000430, "Wrong size on AEndNavModifierFootBGMVolume");
static_assert(offsetof(AEndNavModifierFootBGMVolume, _footBGMSetID) == 0x000428, "Member 'AEndNavModifierFootBGMVolume::_footBGMSetID' has a wrong offset!");

// Class EndGame.EndCondorFortMiniGamePrepareWindow
// 0x0068 (0x03C8 - 0x0360)
class UEndCondorFortMiniGamePrepareWindow final : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x68];                                     // 0x0360(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClicked_Board(class FName BoardID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCondorFortMiniGamePrepareWindow">();
	}
	static class UEndCondorFortMiniGamePrepareWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndCondorFortMiniGamePrepareWindow>();
	}
};
static_assert(alignof(UEndCondorFortMiniGamePrepareWindow) == 0x000008, "Wrong alignment on UEndCondorFortMiniGamePrepareWindow");
static_assert(sizeof(UEndCondorFortMiniGamePrepareWindow) == 0x0003C8, "Wrong size on UEndCondorFortMiniGamePrepareWindow");

// Class EndGame.EndCondorFortMiniGameResultWindow
// 0x0000 (0x0360 - 0x0360)
class UEndCondorFortMiniGameResultWindow final : public UEndUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCondorFortMiniGameResultWindow">();
	}
	static class UEndCondorFortMiniGameResultWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndCondorFortMiniGameResultWindow>();
	}
};
static_assert(alignof(UEndCondorFortMiniGameResultWindow) == 0x000008, "Wrong alignment on UEndCondorFortMiniGameResultWindow");
static_assert(sizeof(UEndCondorFortMiniGameResultWindow) == 0x000360, "Wrong size on UEndCondorFortMiniGameResultWindow");

// Class EndGame.EndCondorFortMiniGameUnitItem
// 0x00D0 (0x0430 - 0x0360)
class UEndCondorFortMiniGameUnitItem final : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0xD0];                                     // 0x0360(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnButtonClicked();
	void OnButtonHovered();
	void OnButtonUnhovered();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCondorFortMiniGameUnitItem">();
	}
	static class UEndCondorFortMiniGameUnitItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndCondorFortMiniGameUnitItem>();
	}
};
static_assert(alignof(UEndCondorFortMiniGameUnitItem) == 0x000008, "Wrong alignment on UEndCondorFortMiniGameUnitItem");
static_assert(sizeof(UEndCondorFortMiniGameUnitItem) == 0x000430, "Wrong size on UEndCondorFortMiniGameUnitItem");

// Class EndGame.EndCondorUnitController
// 0x00A0 (0x0E30 - 0x0D90)
class AEndCondorUnitController final : public AEndAIController
{
public:
	uint8                                         Pad_D90[0xA0];                                     // 0x0D90(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCondorUnitController">();
	}
	static class AEndCondorUnitController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndCondorUnitController>();
	}
};
static_assert(alignof(AEndCondorUnitController) == 0x000008, "Wrong alignment on AEndCondorUnitController");
static_assert(sizeof(AEndCondorUnitController) == 0x000E30, "Wrong size on AEndCondorUnitController");

// Class EndGame.EndCrossSaveManager
// 0x0060 (0x0088 - 0x0028)
class UEndCrossSaveManager final : public UObject
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            MessageWidget;                                     // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x30];                                      // 0x0058(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCrossSaveManager">();
	}
	static class UEndCrossSaveManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndCrossSaveManager>();
	}
};
static_assert(alignof(UEndCrossSaveManager) == 0x000008, "Wrong alignment on UEndCrossSaveManager");
static_assert(sizeof(UEndCrossSaveManager) == 0x000088, "Wrong size on UEndCrossSaveManager");
static_assert(offsetof(UEndCrossSaveManager, MessageWidget) == 0x000050, "Member 'UEndCrossSaveManager::MessageWidget' has a wrong offset!");

// Class EndGame.EndDamageSubText
// 0x0090 (0x03F0 - 0x0360)
class UEndDamageSubText : public UEndUserWidget
{
public:
	struct FEndPopupMessageColors                 NormalColors;                                      // 0x0360(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndPopupMessageColors                 ExtraBonusColors;                                  // 0x03A0(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E0[0x10];                                     // 0x03E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDamageSubText">();
	}
	static class UEndDamageSubText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDamageSubText>();
	}
};
static_assert(alignof(UEndDamageSubText) == 0x000008, "Wrong alignment on UEndDamageSubText");
static_assert(sizeof(UEndDamageSubText) == 0x0003F0, "Wrong size on UEndDamageSubText");
static_assert(offsetof(UEndDamageSubText, NormalColors) == 0x000360, "Member 'UEndDamageSubText::NormalColors' has a wrong offset!");
static_assert(offsetof(UEndDamageSubText, ExtraBonusColors) == 0x0003A0, "Member 'UEndDamageSubText::ExtraBonusColors' has a wrong offset!");

// Class EndGame.EndNavNoCinemaObstacleQueryFilter
// 0x0000 (0x0048 - 0x0048)
class UEndNavNoCinemaObstacleQueryFilter final : public UEndNavQueryFilterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavNoCinemaObstacleQueryFilter">();
	}
	static class UEndNavNoCinemaObstacleQueryFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavNoCinemaObstacleQueryFilter>();
	}
};
static_assert(alignof(UEndNavNoCinemaObstacleQueryFilter) == 0x000008, "Wrong alignment on UEndNavNoCinemaObstacleQueryFilter");
static_assert(sizeof(UEndNavNoCinemaObstacleQueryFilter) == 0x000048, "Wrong size on UEndNavNoCinemaObstacleQueryFilter");

// Class EndGame.EndDataBaseAPI
// 0x0008 (0x0030 - 0x0028)
class UEndDataBaseAPI final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void CheckExistSaveCommon();
	static void CheckExistSaveData(int32 Slot);
	static void ClearGameScenarioType();
	static void ClearPlayerCharaSpecListBP();
	static TMap<class FString, int32> DebugButtonList(int32 Type);
	static TArray<class FString> DebugButtonList2(int32 Type);
	static void DebugSetGameScenarioType(EEndGameScenarioType Type);
	static void EnemyBook_IncrementKillCount_BP(class FName enemyBookTableId);
	static void GatherExistSaveData();
	static int32 GetCurrentDataSlot();
	static void GetCurrentPlayerCharaSpecList(EEquipmentType equipment, EPlayerType Type, TArray<class FName>* outNameList);
	static int32 GetDataSlotFromDataName(const class FString& Name_0);
	static EPlayerType GetDefaultBattleLeaderTypeBP();
	static EPlayerType GetDefaultPartyLeaderTypeBP();
	static int32 GetEmptyDataSlot(const TArray<class FString>& saves);
	static EEndGameScenarioType GetGameScenarioType();
	static EGameDataResult GetIOSaveLoadDataResult();
	static int32 GetItemNumBP(int32 UniqueID);
	static int32 GetLastSelectDataSlot();
	static float GetLocationWorkFloat(class FName locationWorkId);
	static int32 GetLocationWorkInteger(class FName locationWorkId);
	static class FName GetPlayerLevelName(EEquipmentType equipment, EPlayerType Type);
	static TArray<class FName> GetPlayerLevelNames(EEquipmentType equipment, EPlayerType Type);
	static struct FVector GetPlayerPosition(EPlayerType Type);
	static struct FRotator GetPlayerRotation(EPlayerType Type);
	static void GetPrevCharaSpecList(EEquipmentType equipment, EPlayerType Type, TArray<class FName>* outNameList);
	static float GetResidentWorkFloat(const class FName& residentWorkId);
	static int32 GetResidentWorkInteger(const class FName& residentWorkId);
	static TArray<class FString> GetSaveDataList();
	static EGameDataResult GetSaveLoadResult(EIOGameDataRequestLayer InLayer);
	static const class FName GetTestPlayModeTableID();
	static bool GetUpdatePlayTimeFlag();
	static bool HasBackUpData();
	static void Hoge00();
	static void Hoge01();
	static void Hoge02();
	static void Hoge03();
	static void Hoge04();
	static void Hoge05();
	static void Hoge06();
	static void Hoge07();
	static void Hoge08();
	static void Hoge09();
	static bool IsClassic();
	static bool IsDataBaseFlagBP(int32 BitFlag);
	static bool IsDifficulty(EDifficultyType Difficulty);
	static bool IsFinishStreamMateriaModel();
	static bool IsIOSaveLoadData();
	static bool IsMakeCommonSaveData();
	static bool IsMakeLocationSaveData();
	static bool IsSaveLoadExecuting(EIOGameDataRequestLayer InLayer, int32 InRequestID);
	static bool IsStoryFlag(const class FName& StoryFlagID);
	static void MakeCommonSaveData();
	static void MakeLocationSaveData();
	static void MakeResidentSaveData();
	static void ReflectionCommonSaveData();
	static void ReflectionLocationSaveData(bool snap);
	static void ReflectionPointSaveToAutoSave(class FName Level, const class FString& Name_0, const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	static void ReflectionResidentSaveData(bool snap, bool backup);
	static int32 RequestAutoSave(EIOGameDataRequestLayer InLayer, bool override_position, const struct FVector& pos, const struct FRotator& rot);
	static int32 RequestBackUpAutoSave(EIOGameDataRequestLayer InLayer, bool override_position, const struct FVector& pos, const struct FRotator& rot);
	static int32 RequestBackUpLoad(EIOGameDataRequestLayer InLayer);
	static int32 RequestCheckExistSaveCommon(EIOGameDataRequestLayer InLayer);
	static int32 RequestCheckExistSaveData(EIOGameDataRequestLayer InLayer, int32 Slot);
	static int32 RequestGatherExistSaveData(EIOGameDataRequestLayer InLayer);
	static int32 RequestGatherExistSaveDataAtSaving(EIOGameDataRequestLayer InLayer);
	static int32 RequestLoadCommon(EIOGameDataRequestLayer InLayer);
	static int32 RequestLoadData(EIOGameDataRequestLayer InLayer, bool isCarryOverPlayerParameter);
	static int32 RequestLoadLocation(EIOGameDataRequestLayer InLayer);
	static int32 RequestResetBackUpAutoSave(EIOGameDataRequestLayer InLayer, bool override_position, const struct FVector& pos, const struct FRotator& rot);
	static int32 RequestSaveCommon(EIOGameDataRequestLayer InLayer);
	static int32 RequestSaveData(EIOGameDataRequestLayer InLayer, bool ignorePreUpdateLocation, bool ignoreLocationSave);
	static void RequestSnapLoad();
	static void ResetLocationSaveData();
	static void ResetResidentSaveData();
	static void ResetSnapSave();
	static void SetCurrentDataSlot(int32 Slot);
	static void SetCurrentPlayerCharaSpecList(EEquipmentType equipment, EPlayerType Type);
	static void SetDataBaseFlagBP(int32 BitFlag, bool Flag);
	static void SetDefaultBattleLeaderTypeBP(EPlayerType Type);
	static void SetDefaultPartyLeaderTypeBP(EPlayerType Type);
	static void SetLocationWorkFloat(class FName locationWorkId, float Value);
	static void SetLocationWorkInteger(class FName locationWorkId, int32 Value);
	static void SetPrevCharaSpecList(EEquipmentType equipment, EPlayerType Type, const TArray<class FName>& nameList);
	static void SetResidentWorkFloat(const class FName& residentWorkId, float Value);
	static void SetResidentWorkInteger(const class FName& residentWorkId, int32 Value);
	static void SetStoryFlagBP(const class FName& StoryFlagID, bool Value);
	static void SetTestPlayModeTableID(class FName setTableID);
	static void SetupInitialParameter(class FName debugPartyListDataTableId);
	static void SetupSaveDataCommonDefaultParameter();
	static void StartAutoSave(bool override_position, const struct FVector& pos, const struct FRotator& rot);
	static void StartAutoSaveForInitializedLocationData(bool override_position, const struct FVector& pos, const struct FRotator& rot);
	static void StartBackUpAutoSave(bool override_position, const struct FVector& pos, const struct FRotator& rot);
	static void StartBackUpLoad();
	static void StartLoadCommon();
	static void StartLoadData(bool isCarryOverPlayerParameter);
	static void StartLoadLocation();
	static void StartPlayTime();
	static void StartResetBackUpAutoSave(bool override_position, const struct FVector& pos, const struct FRotator& rot);
	static void StartSaveCommon();
	static void StartSaveData(bool ignorePreUpdateLocation, bool ignoreLocationSave);
	static void StartSnapLoad();
	static void StartSnapSave(bool override_position, const struct FVector& pos, const struct FRotator& rot);
	static void StartStreamMateriaModel();
	static void StopPlayTime();
	static void WaitIOSaveLoadData(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataBaseAPI">();
	}
	static class UEndDataBaseAPI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataBaseAPI>();
	}
};
static_assert(alignof(UEndDataBaseAPI) == 0x000008, "Wrong alignment on UEndDataBaseAPI");
static_assert(sizeof(UEndDataBaseAPI) == 0x000030, "Wrong size on UEndDataBaseAPI");

// Class EndGame.EndDataObjectActionGroup
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectActionGroup final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectActionGroup">();
	}
	static class UEndDataObjectActionGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectActionGroup>();
	}
};
static_assert(alignof(UEndDataObjectActionGroup) == 0x000008, "Wrong alignment on UEndDataObjectActionGroup");
static_assert(sizeof(UEndDataObjectActionGroup) == 0x000088, "Wrong size on UEndDataObjectActionGroup");

// Class EndGame.EndDataObjectActorGroup
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectActorGroup final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectActorGroup">();
	}
	static class UEndDataObjectActorGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectActorGroup>();
	}
};
static_assert(alignof(UEndDataObjectActorGroup) == 0x000008, "Wrong alignment on UEndDataObjectActorGroup");
static_assert(sizeof(UEndDataObjectActorGroup) == 0x000088, "Wrong size on UEndDataObjectActorGroup");

// Class EndGame.EndDataObjectAIParameter
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectAIParameter final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectAIParameter">();
	}
	static class UEndDataObjectAIParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectAIParameter>();
	}
};
static_assert(alignof(UEndDataObjectAIParameter) == 0x000008, "Wrong alignment on UEndDataObjectAIParameter");
static_assert(sizeof(UEndDataObjectAIParameter) == 0x000088, "Wrong size on UEndDataObjectAIParameter");

// Class EndGame.EndDataObjectAppContent
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectAppContent final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectAppContent">();
	}
	static class UEndDataObjectAppContent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectAppContent>();
	}
};
static_assert(alignof(UEndDataObjectAppContent) == 0x000008, "Wrong alignment on UEndDataObjectAppContent");
static_assert(sizeof(UEndDataObjectAppContent) == 0x000088, "Wrong size on UEndDataObjectAppContent");

// Class EndGame.EndRCSActor
// 0x00E8 (0x0560 - 0x0478)
class AEndRCSActor final : public AEndCameraRail
{
public:
	float                                         StartBlendTime;                                    // 0x0478(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndBlendTime;                                      // 0x047C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControllLimit;                                     // 0x0480(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsrRollCorrection;                                 // 0x0484(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_485[0x3];                                      // 0x0485(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RollCorrectionMax;                                 // 0x0488(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchCorrectionMax;                                // 0x048C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Intensity;                                         // 0x0490(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DependentTime;                                     // 0x0494(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCenterLocation;                                 // 0x0495(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_496[0x2];                                      // 0x0496(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ObeserveObjectName;                                // 0x0498(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      HeliClampWeight;                                   // 0x04A0(0x0050)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         BlendWeightBasedDist;                              // 0x04F0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F4[0x6C];                                     // 0x04F4(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndRCSActor">();
	}
	static class AEndRCSActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndRCSActor>();
	}
};
static_assert(alignof(AEndRCSActor) == 0x000008, "Wrong alignment on AEndRCSActor");
static_assert(sizeof(AEndRCSActor) == 0x000560, "Wrong size on AEndRCSActor");
static_assert(offsetof(AEndRCSActor, StartBlendTime) == 0x000478, "Member 'AEndRCSActor::StartBlendTime' has a wrong offset!");
static_assert(offsetof(AEndRCSActor, EndBlendTime) == 0x00047C, "Member 'AEndRCSActor::EndBlendTime' has a wrong offset!");
static_assert(offsetof(AEndRCSActor, ControllLimit) == 0x000480, "Member 'AEndRCSActor::ControllLimit' has a wrong offset!");
static_assert(offsetof(AEndRCSActor, UsrRollCorrection) == 0x000484, "Member 'AEndRCSActor::UsrRollCorrection' has a wrong offset!");
static_assert(offsetof(AEndRCSActor, RollCorrectionMax) == 0x000488, "Member 'AEndRCSActor::RollCorrectionMax' has a wrong offset!");
static_assert(offsetof(AEndRCSActor, PitchCorrectionMax) == 0x00048C, "Member 'AEndRCSActor::PitchCorrectionMax' has a wrong offset!");
static_assert(offsetof(AEndRCSActor, Intensity) == 0x000490, "Member 'AEndRCSActor::Intensity' has a wrong offset!");
static_assert(offsetof(AEndRCSActor, DependentTime) == 0x000494, "Member 'AEndRCSActor::DependentTime' has a wrong offset!");
static_assert(offsetof(AEndRCSActor, UseCenterLocation) == 0x000495, "Member 'AEndRCSActor::UseCenterLocation' has a wrong offset!");
static_assert(offsetof(AEndRCSActor, ObeserveObjectName) == 0x000498, "Member 'AEndRCSActor::ObeserveObjectName' has a wrong offset!");
static_assert(offsetof(AEndRCSActor, HeliClampWeight) == 0x0004A0, "Member 'AEndRCSActor::HeliClampWeight' has a wrong offset!");
static_assert(offsetof(AEndRCSActor, BlendWeightBasedDist) == 0x0004F0, "Member 'AEndRCSActor::BlendWeightBasedDist' has a wrong offset!");

// Class EndGame.EndDataObjectArmMiniGameTriggerInfo
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectArmMiniGameTriggerInfo final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectArmMiniGameTriggerInfo">();
	}
	static class UEndDataObjectArmMiniGameTriggerInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectArmMiniGameTriggerInfo>();
	}
};
static_assert(alignof(UEndDataObjectArmMiniGameTriggerInfo) == 0x000008, "Wrong alignment on UEndDataObjectArmMiniGameTriggerInfo");
static_assert(sizeof(UEndDataObjectArmMiniGameTriggerInfo) == 0x000088, "Wrong size on UEndDataObjectArmMiniGameTriggerInfo");

// Class EndGame.EndDataObjectAutoCameraGroup
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectAutoCameraGroup final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectAutoCameraGroup">();
	}
	static class UEndDataObjectAutoCameraGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectAutoCameraGroup>();
	}
};
static_assert(alignof(UEndDataObjectAutoCameraGroup) == 0x000008, "Wrong alignment on UEndDataObjectAutoCameraGroup");
static_assert(sizeof(UEndDataObjectAutoCameraGroup) == 0x000088, "Wrong size on UEndDataObjectAutoCameraGroup");

// Class EndGame.EndDataObjectAutoCameraLightGroup
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectAutoCameraLightGroup final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectAutoCameraLightGroup">();
	}
	static class UEndDataObjectAutoCameraLightGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectAutoCameraLightGroup>();
	}
};
static_assert(alignof(UEndDataObjectAutoCameraLightGroup) == 0x000008, "Wrong alignment on UEndDataObjectAutoCameraLightGroup");
static_assert(sizeof(UEndDataObjectAutoCameraLightGroup) == 0x000088, "Wrong size on UEndDataObjectAutoCameraLightGroup");

// Class EndGame.EndDataObjectAutoCameraLightInfo
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectAutoCameraLightInfo final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectAutoCameraLightInfo">();
	}
	static class UEndDataObjectAutoCameraLightInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectAutoCameraLightInfo>();
	}
};
static_assert(alignof(UEndDataObjectAutoCameraLightInfo) == 0x000008, "Wrong alignment on UEndDataObjectAutoCameraLightInfo");
static_assert(sizeof(UEndDataObjectAutoCameraLightInfo) == 0x000088, "Wrong size on UEndDataObjectAutoCameraLightInfo");

// Class EndGame.EndDataObjectAutoCameraPositionInfo
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectAutoCameraPositionInfo final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectAutoCameraPositionInfo">();
	}
	static class UEndDataObjectAutoCameraPositionInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectAutoCameraPositionInfo>();
	}
};
static_assert(alignof(UEndDataObjectAutoCameraPositionInfo) == 0x000008, "Wrong alignment on UEndDataObjectAutoCameraPositionInfo");
static_assert(sizeof(UEndDataObjectAutoCameraPositionInfo) == 0x000088, "Wrong size on UEndDataObjectAutoCameraPositionInfo");

// Class EndGame.EndDataObjectAutoCameraShotInfo
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectAutoCameraShotInfo final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectAutoCameraShotInfo">();
	}
	static class UEndDataObjectAutoCameraShotInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectAutoCameraShotInfo>();
	}
};
static_assert(alignof(UEndDataObjectAutoCameraShotInfo) == 0x000008, "Wrong alignment on UEndDataObjectAutoCameraShotInfo");
static_assert(sizeof(UEndDataObjectAutoCameraShotInfo) == 0x000088, "Wrong size on UEndDataObjectAutoCameraShotInfo");

// Class EndGame.EndDataObjectAutoCameraShotLogic
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectAutoCameraShotLogic final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectAutoCameraShotLogic">();
	}
	static class UEndDataObjectAutoCameraShotLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectAutoCameraShotLogic>();
	}
};
static_assert(alignof(UEndDataObjectAutoCameraShotLogic) == 0x000008, "Wrong alignment on UEndDataObjectAutoCameraShotLogic");
static_assert(sizeof(UEndDataObjectAutoCameraShotLogic) == 0x000088, "Wrong size on UEndDataObjectAutoCameraShotLogic");

// Class EndGame.EndDataObjectBattleAbility
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleAbility final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleAbility">();
	}
	static class UEndDataObjectBattleAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleAbility>();
	}
};
static_assert(alignof(UEndDataObjectBattleAbility) == 0x000008, "Wrong alignment on UEndDataObjectBattleAbility");
static_assert(sizeof(UEndDataObjectBattleAbility) == 0x000088, "Wrong size on UEndDataObjectBattleAbility");

// Class EndGame.EndDataObjectBattleAbilityResource
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleAbilityResource final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleAbilityResource">();
	}
	static class UEndDataObjectBattleAbilityResource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleAbilityResource>();
	}
};
static_assert(alignof(UEndDataObjectBattleAbilityResource) == 0x000008, "Wrong alignment on UEndDataObjectBattleAbilityResource");
static_assert(sizeof(UEndDataObjectBattleAbilityResource) == 0x000088, "Wrong size on UEndDataObjectBattleAbilityResource");

// Class EndGame.EndDataObjectBattleAIActionAbility
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleAIActionAbility final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleAIActionAbility">();
	}
	static class UEndDataObjectBattleAIActionAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleAIActionAbility>();
	}
};
static_assert(alignof(UEndDataObjectBattleAIActionAbility) == 0x000008, "Wrong alignment on UEndDataObjectBattleAIActionAbility");
static_assert(sizeof(UEndDataObjectBattleAIActionAbility) == 0x000088, "Wrong size on UEndDataObjectBattleAIActionAbility");

// Class EndGame.EndDataObjectBattleAIActionCombo
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleAIActionCombo final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleAIActionCombo">();
	}
	static class UEndDataObjectBattleAIActionCombo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleAIActionCombo>();
	}
};
static_assert(alignof(UEndDataObjectBattleAIActionCombo) == 0x000008, "Wrong alignment on UEndDataObjectBattleAIActionCombo");
static_assert(sizeof(UEndDataObjectBattleAIActionCombo) == 0x000088, "Wrong size on UEndDataObjectBattleAIActionCombo");

// Class EndGame.EndParticleModuleLoopTime
// 0x0010 (0x0048 - 0x0038)
class UEndParticleModuleLoopTime final : public UEndParticleModuleBase
{
public:
	float                                         m_fBeginLoop;                                      // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_fEndLoop;                                        // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         m_PerParticleLoop : 1;                             // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndParticleModuleLoopTime">();
	}
	static class UEndParticleModuleLoopTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndParticleModuleLoopTime>();
	}
};
static_assert(alignof(UEndParticleModuleLoopTime) == 0x000008, "Wrong alignment on UEndParticleModuleLoopTime");
static_assert(sizeof(UEndParticleModuleLoopTime) == 0x000048, "Wrong size on UEndParticleModuleLoopTime");
static_assert(offsetof(UEndParticleModuleLoopTime, m_fBeginLoop) == 0x000038, "Member 'UEndParticleModuleLoopTime::m_fBeginLoop' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleLoopTime, m_fEndLoop) == 0x00003C, "Member 'UEndParticleModuleLoopTime::m_fEndLoop' has a wrong offset!");

// Class EndGame.EndDataObjectBattleAIOverrideAnim
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleAIOverrideAnim final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleAIOverrideAnim">();
	}
	static class UEndDataObjectBattleAIOverrideAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleAIOverrideAnim>();
	}
};
static_assert(alignof(UEndDataObjectBattleAIOverrideAnim) == 0x000008, "Wrong alignment on UEndDataObjectBattleAIOverrideAnim");
static_assert(sizeof(UEndDataObjectBattleAIOverrideAnim) == 0x000088, "Wrong size on UEndDataObjectBattleAIOverrideAnim");

// Class EndGame.EndDataObjectBattleAIPCSceneSetting
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleAIPCSceneSetting final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleAIPCSceneSetting">();
	}
	static class UEndDataObjectBattleAIPCSceneSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleAIPCSceneSetting>();
	}
};
static_assert(alignof(UEndDataObjectBattleAIPCSceneSetting) == 0x000008, "Wrong alignment on UEndDataObjectBattleAIPCSceneSetting");
static_assert(sizeof(UEndDataObjectBattleAIPCSceneSetting) == 0x000088, "Wrong size on UEndDataObjectBattleAIPCSceneSetting");

// Class EndGame.EndDataObjectBattleCharaAttach
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleCharaAttach final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleCharaAttach">();
	}
	static class UEndDataObjectBattleCharaAttach* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleCharaAttach>();
	}
};
static_assert(alignof(UEndDataObjectBattleCharaAttach) == 0x000008, "Wrong alignment on UEndDataObjectBattleCharaAttach");
static_assert(sizeof(UEndDataObjectBattleCharaAttach) == 0x000088, "Wrong size on UEndDataObjectBattleCharaAttach");

// Class EndGame.EndDataObjectBattleCharaCameraFlavor
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleCharaCameraFlavor final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleCharaCameraFlavor">();
	}
	static class UEndDataObjectBattleCharaCameraFlavor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleCharaCameraFlavor>();
	}
};
static_assert(alignof(UEndDataObjectBattleCharaCameraFlavor) == 0x000008, "Wrong alignment on UEndDataObjectBattleCharaCameraFlavor");
static_assert(sizeof(UEndDataObjectBattleCharaCameraFlavor) == 0x000088, "Wrong size on UEndDataObjectBattleCharaCameraFlavor");

// Class EndGame.EndParticleModuleTypeDataEmitter
// 0x0020 (0x0058 - 0x0038)
class UEndParticleModuleTypeDataEmitter final : public UParticleModuleTypeDataBase
{
public:
	class FName                                   m_SourceEmitterName;                               // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         m_DisableSourceEmitterInstance : 1;                // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         m_SpawnWorldSpace : 1;                             // 0x0040(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         m_bSyncParticle : 1;                               // 0x0040(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x17];                                      // 0x0041(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndParticleModuleTypeDataEmitter">();
	}
	static class UEndParticleModuleTypeDataEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndParticleModuleTypeDataEmitter>();
	}
};
static_assert(alignof(UEndParticleModuleTypeDataEmitter) == 0x000008, "Wrong alignment on UEndParticleModuleTypeDataEmitter");
static_assert(sizeof(UEndParticleModuleTypeDataEmitter) == 0x000058, "Wrong size on UEndParticleModuleTypeDataEmitter");
static_assert(offsetof(UEndParticleModuleTypeDataEmitter, m_SourceEmitterName) == 0x000038, "Member 'UEndParticleModuleTypeDataEmitter::m_SourceEmitterName' has a wrong offset!");

// Class EndGame.EndDataObjectBattleCharaPartsSpec
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleCharaPartsSpec final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleCharaPartsSpec">();
	}
	static class UEndDataObjectBattleCharaPartsSpec* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleCharaPartsSpec>();
	}
};
static_assert(alignof(UEndDataObjectBattleCharaPartsSpec) == 0x000008, "Wrong alignment on UEndDataObjectBattleCharaPartsSpec");
static_assert(sizeof(UEndDataObjectBattleCharaPartsSpec) == 0x000088, "Wrong size on UEndDataObjectBattleCharaPartsSpec");

// Class EndGame.EndDataObjectBattleCharaSpec
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleCharaSpec final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleCharaSpec">();
	}
	static class UEndDataObjectBattleCharaSpec* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleCharaSpec>();
	}
};
static_assert(alignof(UEndDataObjectBattleCharaSpec) == 0x000008, "Wrong alignment on UEndDataObjectBattleCharaSpec");
static_assert(sizeof(UEndDataObjectBattleCharaSpec) == 0x000088, "Wrong size on UEndDataObjectBattleCharaSpec");

// Class EndGame.EndDataObjectBattleConditionTrigger
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleConditionTrigger final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleConditionTrigger">();
	}
	static class UEndDataObjectBattleConditionTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleConditionTrigger>();
	}
};
static_assert(alignof(UEndDataObjectBattleConditionTrigger) == 0x000008, "Wrong alignment on UEndDataObjectBattleConditionTrigger");
static_assert(sizeof(UEndDataObjectBattleConditionTrigger) == 0x000088, "Wrong size on UEndDataObjectBattleConditionTrigger");

// Class EndGame.EndDataObjectBattleConditionTriggerEasyCondition
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleConditionTriggerEasyCondition final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleConditionTriggerEasyCondition">();
	}
	static class UEndDataObjectBattleConditionTriggerEasyCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleConditionTriggerEasyCondition>();
	}
};
static_assert(alignof(UEndDataObjectBattleConditionTriggerEasyCondition) == 0x000008, "Wrong alignment on UEndDataObjectBattleConditionTriggerEasyCondition");
static_assert(sizeof(UEndDataObjectBattleConditionTriggerEasyCondition) == 0x000088, "Wrong size on UEndDataObjectBattleConditionTriggerEasyCondition");

// Class EndGame.EndDataObjectBattleDamageReaction
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleDamageReaction final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleDamageReaction">();
	}
	static class UEndDataObjectBattleDamageReaction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleDamageReaction>();
	}
};
static_assert(alignof(UEndDataObjectBattleDamageReaction) == 0x000008, "Wrong alignment on UEndDataObjectBattleDamageReaction");
static_assert(sizeof(UEndDataObjectBattleDamageReaction) == 0x000088, "Wrong size on UEndDataObjectBattleDamageReaction");

// Class EndGame.EndNaviMapPrototypeData
// 0x0050 (0x0078 - 0x0028)
class UEndNaviMapPrototypeData final : public UObject
{
public:
	TMap<class FName, struct FEndNaviMapLocationPrototypeData> Locations;                                         // 0x0028(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNaviMapPrototypeData">();
	}
	static class UEndNaviMapPrototypeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNaviMapPrototypeData>();
	}
};
static_assert(alignof(UEndNaviMapPrototypeData) == 0x000008, "Wrong alignment on UEndNaviMapPrototypeData");
static_assert(sizeof(UEndNaviMapPrototypeData) == 0x000078, "Wrong size on UEndNaviMapPrototypeData");
static_assert(offsetof(UEndNaviMapPrototypeData, Locations) == 0x000028, "Member 'UEndNaviMapPrototypeData::Locations' has a wrong offset!");

// Class EndGame.EndDataObjectBattleDamageSource
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleDamageSource final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleDamageSource">();
	}
	static class UEndDataObjectBattleDamageSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleDamageSource>();
	}
};
static_assert(alignof(UEndDataObjectBattleDamageSource) == 0x000008, "Wrong alignment on UEndDataObjectBattleDamageSource");
static_assert(sizeof(UEndDataObjectBattleDamageSource) == 0x000088, "Wrong size on UEndDataObjectBattleDamageSource");

// Class EndGame.EndDataObjectBattleDamageSourceHitReaction
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleDamageSourceHitReaction final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleDamageSourceHitReaction">();
	}
	static class UEndDataObjectBattleDamageSourceHitReaction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleDamageSourceHitReaction>();
	}
};
static_assert(alignof(UEndDataObjectBattleDamageSourceHitReaction) == 0x000008, "Wrong alignment on UEndDataObjectBattleDamageSourceHitReaction");
static_assert(sizeof(UEndDataObjectBattleDamageSourceHitReaction) == 0x000088, "Wrong size on UEndDataObjectBattleDamageSourceHitReaction");

// Class EndGame.EndDataObjectBattleEnemyIconUI
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleEnemyIconUI final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleEnemyIconUI">();
	}
	static class UEndDataObjectBattleEnemyIconUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleEnemyIconUI>();
	}
};
static_assert(alignof(UEndDataObjectBattleEnemyIconUI) == 0x000008, "Wrong alignment on UEndDataObjectBattleEnemyIconUI");
static_assert(sizeof(UEndDataObjectBattleEnemyIconUI) == 0x000088, "Wrong size on UEndDataObjectBattleEnemyIconUI");

// Class EndGame.EndDataObjectBattleHitSlow
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleHitSlow final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleHitSlow">();
	}
	static class UEndDataObjectBattleHitSlow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleHitSlow>();
	}
};
static_assert(alignof(UEndDataObjectBattleHitSlow) == 0x000008, "Wrong alignment on UEndDataObjectBattleHitSlow");
static_assert(sizeof(UEndDataObjectBattleHitSlow) == 0x000088, "Wrong size on UEndDataObjectBattleHitSlow");

// Class EndGame.EndDataObjectBattleItemPossession
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleItemPossession final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleItemPossession">();
	}
	static class UEndDataObjectBattleItemPossession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleItemPossession>();
	}
};
static_assert(alignof(UEndDataObjectBattleItemPossession) == 0x000008, "Wrong alignment on UEndDataObjectBattleItemPossession");
static_assert(sizeof(UEndDataObjectBattleItemPossession) == 0x000088, "Wrong size on UEndDataObjectBattleItemPossession");

// Class EndGame.EndDataObjectBattlePointLinkData
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattlePointLinkData final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattlePointLinkData">();
	}
	static class UEndDataObjectBattlePointLinkData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattlePointLinkData>();
	}
};
static_assert(alignof(UEndDataObjectBattlePointLinkData) == 0x000008, "Wrong alignment on UEndDataObjectBattlePointLinkData");
static_assert(sizeof(UEndDataObjectBattlePointLinkData) == 0x000088, "Wrong size on UEndDataObjectBattlePointLinkData");

// Class EndGame.EndNavModifierAddAttributeVolume
// 0x0000 (0x0428 - 0x0428)
class AEndNavModifierAddAttributeVolume final : public AEndNavModifierVolumeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavModifierAddAttributeVolume">();
	}
	static class AEndNavModifierAddAttributeVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndNavModifierAddAttributeVolume>();
	}
};
static_assert(alignof(AEndNavModifierAddAttributeVolume) == 0x000008, "Wrong alignment on AEndNavModifierAddAttributeVolume");
static_assert(sizeof(AEndNavModifierAddAttributeVolume) == 0x000428, "Wrong size on AEndNavModifierAddAttributeVolume");

// Class EndGame.EndDataObjectBattleReport
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleReport final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleReport">();
	}
	static class UEndDataObjectBattleReport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleReport>();
	}
};
static_assert(alignof(UEndDataObjectBattleReport) == 0x000008, "Wrong alignment on UEndDataObjectBattleReport");
static_assert(sizeof(UEndDataObjectBattleReport) == 0x000088, "Wrong size on UEndDataObjectBattleReport");

// Class EndGame.EndDataObjectBattleReportCondition
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleReportCondition final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleReportCondition">();
	}
	static class UEndDataObjectBattleReportCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleReportCondition>();
	}
};
static_assert(alignof(UEndDataObjectBattleReportCondition) == 0x000008, "Wrong alignment on UEndDataObjectBattleReportCondition");
static_assert(sizeof(UEndDataObjectBattleReportCondition) == 0x000088, "Wrong size on UEndDataObjectBattleReportCondition");

// Class EndGame.EndDataObjectBattleScene
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleScene final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleScene">();
	}
	static class UEndDataObjectBattleScene* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleScene>();
	}
};
static_assert(alignof(UEndDataObjectBattleScene) == 0x000008, "Wrong alignment on UEndDataObjectBattleScene");
static_assert(sizeof(UEndDataObjectBattleScene) == 0x000088, "Wrong size on UEndDataObjectBattleScene");

// Class EndGame.EndDataObjectBattleSceneLevel
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleSceneLevel final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleSceneLevel">();
	}
	static class UEndDataObjectBattleSceneLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleSceneLevel>();
	}
};
static_assert(alignof(UEndDataObjectBattleSceneLevel) == 0x000008, "Wrong alignment on UEndDataObjectBattleSceneLevel");
static_assert(sizeof(UEndDataObjectBattleSceneLevel) == 0x000088, "Wrong size on UEndDataObjectBattleSceneLevel");

// Class EndGame.EndDataObjectBattleScenePopGroup
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleScenePopGroup final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleScenePopGroup">();
	}
	static class UEndDataObjectBattleScenePopGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleScenePopGroup>();
	}
};
static_assert(alignof(UEndDataObjectBattleScenePopGroup) == 0x000008, "Wrong alignment on UEndDataObjectBattleScenePopGroup");
static_assert(sizeof(UEndDataObjectBattleScenePopGroup) == 0x000088, "Wrong size on UEndDataObjectBattleScenePopGroup");

// Class EndGame.EndDataObjectBattleSceneSituation
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleSceneSituation final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleSceneSituation">();
	}
	static class UEndDataObjectBattleSceneSituation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleSceneSituation>();
	}
};
static_assert(alignof(UEndDataObjectBattleSceneSituation) == 0x000008, "Wrong alignment on UEndDataObjectBattleSceneSituation");
static_assert(sizeof(UEndDataObjectBattleSceneSituation) == 0x000088, "Wrong size on UEndDataObjectBattleSceneSituation");

// Class EndGame.EndPlayBlendSpaceActionActorInterface
// 0x0000 (0x0028 - 0x0028)
class IEndPlayBlendSpaceActionActorInterface final : public IInterface
{
public:
	float OnGetCurrentBlendSpaceInput();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndPlayBlendSpaceActionActorInterface">();
	}
	static class IEndPlayBlendSpaceActionActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEndPlayBlendSpaceActionActorInterface>();
	}
};
static_assert(alignof(IEndPlayBlendSpaceActionActorInterface) == 0x000008, "Wrong alignment on IEndPlayBlendSpaceActionActorInterface");
static_assert(sizeof(IEndPlayBlendSpaceActionActorInterface) == 0x000028, "Wrong size on IEndPlayBlendSpaceActionActorInterface");

// Class EndGame.EndDataObjectBattleShield
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleShield final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleShield">();
	}
	static class UEndDataObjectBattleShield* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleShield>();
	}
};
static_assert(alignof(UEndDataObjectBattleShield) == 0x000008, "Wrong alignment on UEndDataObjectBattleShield");
static_assert(sizeof(UEndDataObjectBattleShield) == 0x000088, "Wrong size on UEndDataObjectBattleShield");

// Class EndGame.EndDataObjectBattleSpecialStateEffect
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleSpecialStateEffect final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleSpecialStateEffect">();
	}
	static class UEndDataObjectBattleSpecialStateEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleSpecialStateEffect>();
	}
};
static_assert(alignof(UEndDataObjectBattleSpecialStateEffect) == 0x000008, "Wrong alignment on UEndDataObjectBattleSpecialStateEffect");
static_assert(sizeof(UEndDataObjectBattleSpecialStateEffect) == 0x000088, "Wrong size on UEndDataObjectBattleSpecialStateEffect");

// Class EndGame.EndDataObjectBattleStatusChange
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleStatusChange final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleStatusChange">();
	}
	static class UEndDataObjectBattleStatusChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleStatusChange>();
	}
};
static_assert(alignof(UEndDataObjectBattleStatusChange) == 0x000008, "Wrong alignment on UEndDataObjectBattleStatusChange");
static_assert(sizeof(UEndDataObjectBattleStatusChange) == 0x000088, "Wrong size on UEndDataObjectBattleStatusChange");

// Class EndGame.EndDataObjectBattleStunInformation
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleStunInformation final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleStunInformation">();
	}
	static class UEndDataObjectBattleStunInformation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleStunInformation>();
	}
};
static_assert(alignof(UEndDataObjectBattleStunInformation) == 0x000008, "Wrong alignment on UEndDataObjectBattleStunInformation");
static_assert(sizeof(UEndDataObjectBattleStunInformation) == 0x000088, "Wrong size on UEndDataObjectBattleStunInformation");

// Class EndGame.EndDataObjectBattleSummonAbilityChoice
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleSummonAbilityChoice final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleSummonAbilityChoice">();
	}
	static class UEndDataObjectBattleSummonAbilityChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleSummonAbilityChoice>();
	}
};
static_assert(alignof(UEndDataObjectBattleSummonAbilityChoice) == 0x000008, "Wrong alignment on UEndDataObjectBattleSummonAbilityChoice");
static_assert(sizeof(UEndDataObjectBattleSummonAbilityChoice) == 0x000088, "Wrong size on UEndDataObjectBattleSummonAbilityChoice");

// Class EndGame.EndFieldActionActorJump
// 0x0098 (0x06B0 - 0x0618)
class AEndFieldActionActorJump final : public AEndFieldActionActorBase
{
public:
	class UEndFieldActionTriggerComponent*        EnterVolume;                                       // 0x0618(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        ExitVolume;                                        // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0628(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENavLinkDirection                             JumpDirection;                                     // 0x0630(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_631[0x3];                                      // 0x0631(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpDistance;                                      // 0x0634(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJumpType                                     JumpType;                                          // 0x0638(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJumpStartType                                StartJumpType;                                     // 0x0639(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HiddenEffect;                                      // 0x063A(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NotUpdateVolume;                                   // 0x063B(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StraddleExtensions;                                // 0x063C(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_63D[0x3];                                      // 0x063D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpAngleToLeft;                                   // 0x0640(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlightDurationToLeft;                              // 0x0644(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DrawRightToLeft;                                   // 0x0648(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_649[0x3];                                      // 0x0649(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpAngleToRight;                                  // 0x064C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlightDurationToRight;                             // 0x0650(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DrawLeftToRight;                                   // 0x0654(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_655[0x3];                                      // 0x0655(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ToRightOverrideVelocity;                           // 0x0658(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ToLeftOverrideVelocity;                            // 0x065C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideHeight;                                    // 0x0660(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableConnectJump;                                 // 0x0664(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_665[0x4B];                                     // 0x0665(0x004B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorJump">();
	}
	static class AEndFieldActionActorJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorJump>();
	}
};
static_assert(alignof(AEndFieldActionActorJump) == 0x000008, "Wrong alignment on AEndFieldActionActorJump");
static_assert(sizeof(AEndFieldActionActorJump) == 0x0006B0, "Wrong size on AEndFieldActionActorJump");
static_assert(offsetof(AEndFieldActionActorJump, EnterVolume) == 0x000618, "Member 'AEndFieldActionActorJump::EnterVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorJump, ExitVolume) == 0x000620, "Member 'AEndFieldActionActorJump::ExitVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorJump, ModifierVolume) == 0x000628, "Member 'AEndFieldActionActorJump::ModifierVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorJump, JumpDirection) == 0x000630, "Member 'AEndFieldActionActorJump::JumpDirection' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorJump, JumpDistance) == 0x000634, "Member 'AEndFieldActionActorJump::JumpDistance' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorJump, JumpType) == 0x000638, "Member 'AEndFieldActionActorJump::JumpType' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorJump, StartJumpType) == 0x000639, "Member 'AEndFieldActionActorJump::StartJumpType' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorJump, HiddenEffect) == 0x00063A, "Member 'AEndFieldActionActorJump::HiddenEffect' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorJump, NotUpdateVolume) == 0x00063B, "Member 'AEndFieldActionActorJump::NotUpdateVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorJump, StraddleExtensions) == 0x00063C, "Member 'AEndFieldActionActorJump::StraddleExtensions' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorJump, JumpAngleToLeft) == 0x000640, "Member 'AEndFieldActionActorJump::JumpAngleToLeft' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorJump, FlightDurationToLeft) == 0x000644, "Member 'AEndFieldActionActorJump::FlightDurationToLeft' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorJump, DrawRightToLeft) == 0x000648, "Member 'AEndFieldActionActorJump::DrawRightToLeft' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorJump, JumpAngleToRight) == 0x00064C, "Member 'AEndFieldActionActorJump::JumpAngleToRight' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorJump, FlightDurationToRight) == 0x000650, "Member 'AEndFieldActionActorJump::FlightDurationToRight' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorJump, DrawLeftToRight) == 0x000654, "Member 'AEndFieldActionActorJump::DrawLeftToRight' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorJump, ToRightOverrideVelocity) == 0x000658, "Member 'AEndFieldActionActorJump::ToRightOverrideVelocity' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorJump, ToLeftOverrideVelocity) == 0x00065C, "Member 'AEndFieldActionActorJump::ToLeftOverrideVelocity' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorJump, OverrideHeight) == 0x000660, "Member 'AEndFieldActionActorJump::OverrideHeight' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorJump, EnableConnectJump) == 0x000664, "Member 'AEndFieldActionActorJump::EnableConnectJump' has a wrong offset!");

// Class EndGame.EndDataObjectBattleSummonSpec
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleSummonSpec final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleSummonSpec">();
	}
	static class UEndDataObjectBattleSummonSpec* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleSummonSpec>();
	}
};
static_assert(alignof(UEndDataObjectBattleSummonSpec) == 0x000008, "Wrong alignment on UEndDataObjectBattleSummonSpec");
static_assert(sizeof(UEndDataObjectBattleSummonSpec) == 0x000088, "Wrong size on UEndDataObjectBattleSummonSpec");

// Class EndGame.EndPopupMessage
// 0x03A0 (0x0700 - 0x0360)
class UEndPopupMessage : public UEndUserWidget
{
public:
	struct FEndPopupMessageColors                 DamageColors;                                      // 0x0360(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndPopupMessageColors                 ReducedDamageColors;                               // 0x03A0(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndPopupMessageColors                 HealColors;                                        // 0x03E0(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndPopupMessageColors                 PartyDamageColors;                                 // 0x0420(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndPopupMessageColors                 ReducedPartyDamageColors;                          // 0x0460(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndPopupMessageColors                 MpDamageColors;                                    // 0x04A0(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndPopupMessageColors                 MpHealColors;                                      // 0x04E0(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndPopupMessageColors                 LinkageLowColors;                                  // 0x0520(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndPopupMessageColors                 LinkageHighColors;                                 // 0x0560(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndPopupMessageColors                 NoDamageColors;                                    // 0x05A0(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndPopupMessageColors                 DamageOverTimeColors;                              // 0x05E0(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndPopupMessageColors                 PartyDamageOverTimeColors;                         // 0x0620(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndPopupMessageColors                 HealOverTimeColors;                                // 0x0660(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndPopupMessageColors                 BurstColors;                                       // 0x06A0(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinLinkageScale;                                   // 0x06E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLinkageScale;                                   // 0x06E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubTextOffset;                                     // 0x06E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubTextInterval;                                   // 0x06EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DangerLoopCount;                                   // 0x06F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6F4[0xC];                                      // 0x06F4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndPopupMessage">();
	}
	static class UEndPopupMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndPopupMessage>();
	}
};
static_assert(alignof(UEndPopupMessage) == 0x000008, "Wrong alignment on UEndPopupMessage");
static_assert(sizeof(UEndPopupMessage) == 0x000700, "Wrong size on UEndPopupMessage");
static_assert(offsetof(UEndPopupMessage, DamageColors) == 0x000360, "Member 'UEndPopupMessage::DamageColors' has a wrong offset!");
static_assert(offsetof(UEndPopupMessage, ReducedDamageColors) == 0x0003A0, "Member 'UEndPopupMessage::ReducedDamageColors' has a wrong offset!");
static_assert(offsetof(UEndPopupMessage, HealColors) == 0x0003E0, "Member 'UEndPopupMessage::HealColors' has a wrong offset!");
static_assert(offsetof(UEndPopupMessage, PartyDamageColors) == 0x000420, "Member 'UEndPopupMessage::PartyDamageColors' has a wrong offset!");
static_assert(offsetof(UEndPopupMessage, ReducedPartyDamageColors) == 0x000460, "Member 'UEndPopupMessage::ReducedPartyDamageColors' has a wrong offset!");
static_assert(offsetof(UEndPopupMessage, MpDamageColors) == 0x0004A0, "Member 'UEndPopupMessage::MpDamageColors' has a wrong offset!");
static_assert(offsetof(UEndPopupMessage, MpHealColors) == 0x0004E0, "Member 'UEndPopupMessage::MpHealColors' has a wrong offset!");
static_assert(offsetof(UEndPopupMessage, LinkageLowColors) == 0x000520, "Member 'UEndPopupMessage::LinkageLowColors' has a wrong offset!");
static_assert(offsetof(UEndPopupMessage, LinkageHighColors) == 0x000560, "Member 'UEndPopupMessage::LinkageHighColors' has a wrong offset!");
static_assert(offsetof(UEndPopupMessage, NoDamageColors) == 0x0005A0, "Member 'UEndPopupMessage::NoDamageColors' has a wrong offset!");
static_assert(offsetof(UEndPopupMessage, DamageOverTimeColors) == 0x0005E0, "Member 'UEndPopupMessage::DamageOverTimeColors' has a wrong offset!");
static_assert(offsetof(UEndPopupMessage, PartyDamageOverTimeColors) == 0x000620, "Member 'UEndPopupMessage::PartyDamageOverTimeColors' has a wrong offset!");
static_assert(offsetof(UEndPopupMessage, HealOverTimeColors) == 0x000660, "Member 'UEndPopupMessage::HealOverTimeColors' has a wrong offset!");
static_assert(offsetof(UEndPopupMessage, BurstColors) == 0x0006A0, "Member 'UEndPopupMessage::BurstColors' has a wrong offset!");
static_assert(offsetof(UEndPopupMessage, MinLinkageScale) == 0x0006E0, "Member 'UEndPopupMessage::MinLinkageScale' has a wrong offset!");
static_assert(offsetof(UEndPopupMessage, MaxLinkageScale) == 0x0006E4, "Member 'UEndPopupMessage::MaxLinkageScale' has a wrong offset!");
static_assert(offsetof(UEndPopupMessage, SubTextOffset) == 0x0006E8, "Member 'UEndPopupMessage::SubTextOffset' has a wrong offset!");
static_assert(offsetof(UEndPopupMessage, SubTextInterval) == 0x0006EC, "Member 'UEndPopupMessage::SubTextInterval' has a wrong offset!");
static_assert(offsetof(UEndPopupMessage, DangerLoopCount) == 0x0006F0, "Member 'UEndPopupMessage::DangerLoopCount' has a wrong offset!");

// Class EndGame.EndDataObjectBattleSyncAction
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBattleSyncAction final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBattleSyncAction">();
	}
	static class UEndDataObjectBattleSyncAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBattleSyncAction>();
	}
};
static_assert(alignof(UEndDataObjectBattleSyncAction) == 0x000008, "Wrong alignment on UEndDataObjectBattleSyncAction");
static_assert(sizeof(UEndDataObjectBattleSyncAction) == 0x000088, "Wrong size on UEndDataObjectBattleSyncAction");

// Class EndGame.EndDataObjectBGMList
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBGMList final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBGMList">();
	}
	static class UEndDataObjectBGMList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBGMList>();
	}
};
static_assert(alignof(UEndDataObjectBGMList) == 0x000008, "Wrong alignment on UEndDataObjectBGMList");
static_assert(sizeof(UEndDataObjectBGMList) == 0x000088, "Wrong size on UEndDataObjectBGMList");

// Class EndGame.EndDataObjectBikeAIAbilitySet
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBikeAIAbilitySet final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBikeAIAbilitySet">();
	}
	static class UEndDataObjectBikeAIAbilitySet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBikeAIAbilitySet>();
	}
};
static_assert(alignof(UEndDataObjectBikeAIAbilitySet) == 0x000008, "Wrong alignment on UEndDataObjectBikeAIAbilitySet");
static_assert(sizeof(UEndDataObjectBikeAIAbilitySet) == 0x000088, "Wrong size on UEndDataObjectBikeAIAbilitySet");

// Class EndGame.EndDataObjectBikeAngleRange
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBikeAngleRange final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBikeAngleRange">();
	}
	static class UEndDataObjectBikeAngleRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBikeAngleRange>();
	}
};
static_assert(alignof(UEndDataObjectBikeAngleRange) == 0x000008, "Wrong alignment on UEndDataObjectBikeAngleRange");
static_assert(sizeof(UEndDataObjectBikeAngleRange) == 0x000088, "Wrong size on UEndDataObjectBikeAngleRange");

// Class EndGame.EndDataObjectBikeBattle
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBikeBattle final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBikeBattle">();
	}
	static class UEndDataObjectBikeBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBikeBattle>();
	}
};
static_assert(alignof(UEndDataObjectBikeBattle) == 0x000008, "Wrong alignment on UEndDataObjectBikeBattle");
static_assert(sizeof(UEndDataObjectBikeBattle) == 0x000088, "Wrong size on UEndDataObjectBikeBattle");

// Class EndGame.EndFieldActionActorParkourJump
// 0x0068 (0x0680 - 0x0618)
class AEndFieldActionActorParkourJump final : public AEndFieldActionActorBase
{
public:
	class UEndFieldActionTriggerComponent*        EnterVolume;                                       // 0x0618(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        ExitVolume;                                        // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParkourJumpType                              ParkourJumpType;                                   // 0x0628(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParkourJumpLandingType                       ParkourJumpLandingType;                            // 0x0629(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62A[0x2];                                      // 0x062A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpAngle;                                         // 0x062C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlightDuration;                                    // 0x0630(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraFOV;                                         // 0x0634(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CameraLookAtName;                                  // 0x0638(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0640(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_648[0x38];                                     // 0x0648(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorParkourJump">();
	}
	static class AEndFieldActionActorParkourJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorParkourJump>();
	}
};
static_assert(alignof(AEndFieldActionActorParkourJump) == 0x000008, "Wrong alignment on AEndFieldActionActorParkourJump");
static_assert(sizeof(AEndFieldActionActorParkourJump) == 0x000680, "Wrong size on AEndFieldActionActorParkourJump");
static_assert(offsetof(AEndFieldActionActorParkourJump, EnterVolume) == 0x000618, "Member 'AEndFieldActionActorParkourJump::EnterVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorParkourJump, ExitVolume) == 0x000620, "Member 'AEndFieldActionActorParkourJump::ExitVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorParkourJump, ParkourJumpType) == 0x000628, "Member 'AEndFieldActionActorParkourJump::ParkourJumpType' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorParkourJump, ParkourJumpLandingType) == 0x000629, "Member 'AEndFieldActionActorParkourJump::ParkourJumpLandingType' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorParkourJump, JumpAngle) == 0x00062C, "Member 'AEndFieldActionActorParkourJump::JumpAngle' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorParkourJump, FlightDuration) == 0x000630, "Member 'AEndFieldActionActorParkourJump::FlightDuration' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorParkourJump, CameraFOV) == 0x000634, "Member 'AEndFieldActionActorParkourJump::CameraFOV' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorParkourJump, CameraLookAtName) == 0x000638, "Member 'AEndFieldActionActorParkourJump::CameraLookAtName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorParkourJump, ModifierVolume) == 0x000640, "Member 'AEndFieldActionActorParkourJump::ModifierVolume' has a wrong offset!");

// Class EndGame.EndDataObjectBikeCharaSpec
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBikeCharaSpec final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBikeCharaSpec">();
	}
	static class UEndDataObjectBikeCharaSpec* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBikeCharaSpec>();
	}
};
static_assert(alignof(UEndDataObjectBikeCharaSpec) == 0x000008, "Wrong alignment on UEndDataObjectBikeCharaSpec");
static_assert(sizeof(UEndDataObjectBikeCharaSpec) == 0x000088, "Wrong size on UEndDataObjectBikeCharaSpec");

// Class EndGame.EndTurnBackBox
// 0x0020 (0x03A8 - 0x0388)
class AEndTurnBackBox final : public AEndTriggerBox
{
public:
	class AEndTriggerBox*                         m_pTurnBackTriggerBox;                             // 0x0388(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AEndTriggerBox*                         m_pFollowDiscardTriggerBox;                        // 0x0390(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          m_pBlockWall;                                      // 0x0398(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          EnableBlockWall;                                   // 0x03A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A1[0x7];                                      // 0x03A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndTurnBackBox">();
	}
	static class AEndTurnBackBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndTurnBackBox>();
	}
};
static_assert(alignof(AEndTurnBackBox) == 0x000008, "Wrong alignment on AEndTurnBackBox");
static_assert(sizeof(AEndTurnBackBox) == 0x0003A8, "Wrong size on AEndTurnBackBox");
static_assert(offsetof(AEndTurnBackBox, m_pTurnBackTriggerBox) == 0x000388, "Member 'AEndTurnBackBox::m_pTurnBackTriggerBox' has a wrong offset!");
static_assert(offsetof(AEndTurnBackBox, m_pFollowDiscardTriggerBox) == 0x000390, "Member 'AEndTurnBackBox::m_pFollowDiscardTriggerBox' has a wrong offset!");
static_assert(offsetof(AEndTurnBackBox, m_pBlockWall) == 0x000398, "Member 'AEndTurnBackBox::m_pBlockWall' has a wrong offset!");
static_assert(offsetof(AEndTurnBackBox, EnableBlockWall) == 0x0003A0, "Member 'AEndTurnBackBox::EnableBlockWall' has a wrong offset!");

// Class EndGame.EndDataObjectBikeCombo
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBikeCombo final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBikeCombo">();
	}
	static class UEndDataObjectBikeCombo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBikeCombo>();
	}
};
static_assert(alignof(UEndDataObjectBikeCombo) == 0x000008, "Wrong alignment on UEndDataObjectBikeCombo");
static_assert(sizeof(UEndDataObjectBikeCombo) == 0x000088, "Wrong size on UEndDataObjectBikeCombo");

// Class EndGame.EndDataObjectBikeCommonParameter
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBikeCommonParameter final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBikeCommonParameter">();
	}
	static class UEndDataObjectBikeCommonParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBikeCommonParameter>();
	}
};
static_assert(alignof(UEndDataObjectBikeCommonParameter) == 0x000008, "Wrong alignment on UEndDataObjectBikeCommonParameter");
static_assert(sizeof(UEndDataObjectBikeCommonParameter) == 0x000088, "Wrong size on UEndDataObjectBikeCommonParameter");

// Class EndGame.EndDataObjectBikeDamageSource
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBikeDamageSource final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBikeDamageSource">();
	}
	static class UEndDataObjectBikeDamageSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBikeDamageSource>();
	}
};
static_assert(alignof(UEndDataObjectBikeDamageSource) == 0x000008, "Wrong alignment on UEndDataObjectBikeDamageSource");
static_assert(sizeof(UEndDataObjectBikeDamageSource) == 0x000088, "Wrong size on UEndDataObjectBikeDamageSource");

// Class EndGame.EndDataObjectBikeInterruptAction
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBikeInterruptAction final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBikeInterruptAction">();
	}
	static class UEndDataObjectBikeInterruptAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBikeInterruptAction>();
	}
};
static_assert(alignof(UEndDataObjectBikeInterruptAction) == 0x000008, "Wrong alignment on UEndDataObjectBikeInterruptAction");
static_assert(sizeof(UEndDataObjectBikeInterruptAction) == 0x000088, "Wrong size on UEndDataObjectBikeInterruptAction");

// Class EndGame.EndDataObjectBikeLocation
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBikeLocation final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBikeLocation">();
	}
	static class UEndDataObjectBikeLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBikeLocation>();
	}
};
static_assert(alignof(UEndDataObjectBikeLocation) == 0x000008, "Wrong alignment on UEndDataObjectBikeLocation");
static_assert(sizeof(UEndDataObjectBikeLocation) == 0x000088, "Wrong size on UEndDataObjectBikeLocation");

// Class EndGame.EndFieldActionActorSlideDown
// 0x0068 (0x0680 - 0x0618)
class AEndFieldActionActorSlideDown final : public AEndFieldActionActorBase
{
public:
	class UEndFieldActionSplineComponent*         SlideDownComponent;                                // 0x0618(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        EnterVolume;                                       // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        ExitVolume;                                        // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeWidth;                                       // 0x0630(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraFOV;                                         // 0x0634(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CameraLookAtName;                                  // 0x0638(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0640(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_648[0x38];                                     // 0x0648(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorSlideDown">();
	}
	static class AEndFieldActionActorSlideDown* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorSlideDown>();
	}
};
static_assert(alignof(AEndFieldActionActorSlideDown) == 0x000008, "Wrong alignment on AEndFieldActionActorSlideDown");
static_assert(sizeof(AEndFieldActionActorSlideDown) == 0x000680, "Wrong size on AEndFieldActionActorSlideDown");
static_assert(offsetof(AEndFieldActionActorSlideDown, SlideDownComponent) == 0x000618, "Member 'AEndFieldActionActorSlideDown::SlideDownComponent' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorSlideDown, EnterVolume) == 0x000620, "Member 'AEndFieldActionActorSlideDown::EnterVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorSlideDown, ExitVolume) == 0x000628, "Member 'AEndFieldActionActorSlideDown::ExitVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorSlideDown, VolumeWidth) == 0x000630, "Member 'AEndFieldActionActorSlideDown::VolumeWidth' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorSlideDown, CameraFOV) == 0x000634, "Member 'AEndFieldActionActorSlideDown::CameraFOV' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorSlideDown, CameraLookAtName) == 0x000638, "Member 'AEndFieldActionActorSlideDown::CameraLookAtName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorSlideDown, ModifierVolume) == 0x000640, "Member 'AEndFieldActionActorSlideDown::ModifierVolume' has a wrong offset!");

// Class EndGame.EndDataObjectBikePhaseEnemyParameter
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBikePhaseEnemyParameter final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBikePhaseEnemyParameter">();
	}
	static class UEndDataObjectBikePhaseEnemyParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBikePhaseEnemyParameter>();
	}
};
static_assert(alignof(UEndDataObjectBikePhaseEnemyParameter) == 0x000008, "Wrong alignment on UEndDataObjectBikePhaseEnemyParameter");
static_assert(sizeof(UEndDataObjectBikePhaseEnemyParameter) == 0x000088, "Wrong size on UEndDataObjectBikePhaseEnemyParameter");

// Class EndGame.FA0122_AnimInstance
// 0x01A8 (0x05D0 - 0x0428)
class UFA0122_AnimInstance final : public UAnimInstance
{
public:
	struct FBoneReference                         BasementBone;                                      // 0x0428(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         HandBone;                                          // 0x043C(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FBoneReference>                 ArmBones;                                          // 0x0450(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBoneReference>                 TransformCacheBones;                               // 0x0460(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAnimSequence*                          PoseReferenceAnimation;                            // 0x0470(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EFA0122_PoseReference, int32>            PoseReferenceFrames;                               // 0x0478(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         PoseReferenceAnimationFrameRate;                   // 0x04C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFA0122_ArmState                              CurrentArmState;                                   // 0x04CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4CD[0x3];                                      // 0x04CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RequestedBasementAngle;                            // 0x04D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentBasementAngle;                              // 0x04D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BasementAngleSpeed;                                // 0x04D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RequestedArmHeightRate;                            // 0x04DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentArmHeightRate;                              // 0x04E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmHeightRateSpeed;                                // 0x04E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinArmHeight;                                      // 0x04E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxArmHeight;                                      // 0x04EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFA0122_ArmHeightAndRate>       ArmHeightAndRates;                                 // 0x04F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         RequestedHandGrabRate;                             // 0x0500(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentHandGrabRate;                               // 0x0504(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HandGrabRateSpeed;                                 // 0x0508(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50C[0xC4];                                     // 0x050C(0x00C4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RequestArmHeightRate(float Rate);
	void RequestBasementAngle(float Angle);

	float GetArmHeightRateFromHeight(float Height) const;
	float GetCurrentArmHeightRate() const;
	float GetCurrentBasementAngle() const;
	float GetMaxArmHeight() const;
	float GetMinArmHeight() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FA0122_AnimInstance">();
	}
	static class UFA0122_AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFA0122_AnimInstance>();
	}
};
static_assert(alignof(UFA0122_AnimInstance) == 0x000008, "Wrong alignment on UFA0122_AnimInstance");
static_assert(sizeof(UFA0122_AnimInstance) == 0x0005D0, "Wrong size on UFA0122_AnimInstance");
static_assert(offsetof(UFA0122_AnimInstance, BasementBone) == 0x000428, "Member 'UFA0122_AnimInstance::BasementBone' has a wrong offset!");
static_assert(offsetof(UFA0122_AnimInstance, HandBone) == 0x00043C, "Member 'UFA0122_AnimInstance::HandBone' has a wrong offset!");
static_assert(offsetof(UFA0122_AnimInstance, ArmBones) == 0x000450, "Member 'UFA0122_AnimInstance::ArmBones' has a wrong offset!");
static_assert(offsetof(UFA0122_AnimInstance, TransformCacheBones) == 0x000460, "Member 'UFA0122_AnimInstance::TransformCacheBones' has a wrong offset!");
static_assert(offsetof(UFA0122_AnimInstance, PoseReferenceAnimation) == 0x000470, "Member 'UFA0122_AnimInstance::PoseReferenceAnimation' has a wrong offset!");
static_assert(offsetof(UFA0122_AnimInstance, PoseReferenceFrames) == 0x000478, "Member 'UFA0122_AnimInstance::PoseReferenceFrames' has a wrong offset!");
static_assert(offsetof(UFA0122_AnimInstance, PoseReferenceAnimationFrameRate) == 0x0004C8, "Member 'UFA0122_AnimInstance::PoseReferenceAnimationFrameRate' has a wrong offset!");
static_assert(offsetof(UFA0122_AnimInstance, CurrentArmState) == 0x0004CC, "Member 'UFA0122_AnimInstance::CurrentArmState' has a wrong offset!");
static_assert(offsetof(UFA0122_AnimInstance, RequestedBasementAngle) == 0x0004D0, "Member 'UFA0122_AnimInstance::RequestedBasementAngle' has a wrong offset!");
static_assert(offsetof(UFA0122_AnimInstance, CurrentBasementAngle) == 0x0004D4, "Member 'UFA0122_AnimInstance::CurrentBasementAngle' has a wrong offset!");
static_assert(offsetof(UFA0122_AnimInstance, BasementAngleSpeed) == 0x0004D8, "Member 'UFA0122_AnimInstance::BasementAngleSpeed' has a wrong offset!");
static_assert(offsetof(UFA0122_AnimInstance, RequestedArmHeightRate) == 0x0004DC, "Member 'UFA0122_AnimInstance::RequestedArmHeightRate' has a wrong offset!");
static_assert(offsetof(UFA0122_AnimInstance, CurrentArmHeightRate) == 0x0004E0, "Member 'UFA0122_AnimInstance::CurrentArmHeightRate' has a wrong offset!");
static_assert(offsetof(UFA0122_AnimInstance, ArmHeightRateSpeed) == 0x0004E4, "Member 'UFA0122_AnimInstance::ArmHeightRateSpeed' has a wrong offset!");
static_assert(offsetof(UFA0122_AnimInstance, MinArmHeight) == 0x0004E8, "Member 'UFA0122_AnimInstance::MinArmHeight' has a wrong offset!");
static_assert(offsetof(UFA0122_AnimInstance, MaxArmHeight) == 0x0004EC, "Member 'UFA0122_AnimInstance::MaxArmHeight' has a wrong offset!");
static_assert(offsetof(UFA0122_AnimInstance, ArmHeightAndRates) == 0x0004F0, "Member 'UFA0122_AnimInstance::ArmHeightAndRates' has a wrong offset!");
static_assert(offsetof(UFA0122_AnimInstance, RequestedHandGrabRate) == 0x000500, "Member 'UFA0122_AnimInstance::RequestedHandGrabRate' has a wrong offset!");
static_assert(offsetof(UFA0122_AnimInstance, CurrentHandGrabRate) == 0x000504, "Member 'UFA0122_AnimInstance::CurrentHandGrabRate' has a wrong offset!");
static_assert(offsetof(UFA0122_AnimInstance, HandGrabRateSpeed) == 0x000508, "Member 'UFA0122_AnimInstance::HandGrabRateSpeed' has a wrong offset!");

// Class EndGame.EndDataObjectBikePhaseParameter
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBikePhaseParameter final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBikePhaseParameter">();
	}
	static class UEndDataObjectBikePhaseParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBikePhaseParameter>();
	}
};
static_assert(alignof(UEndDataObjectBikePhaseParameter) == 0x000008, "Wrong alignment on UEndDataObjectBikePhaseParameter");
static_assert(sizeof(UEndDataObjectBikePhaseParameter) == 0x000088, "Wrong size on UEndDataObjectBikePhaseParameter");

// Class EndGame.EndDataObjectBikePlayerCharaSpec
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBikePlayerCharaSpec final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBikePlayerCharaSpec">();
	}
	static class UEndDataObjectBikePlayerCharaSpec* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBikePlayerCharaSpec>();
	}
};
static_assert(alignof(UEndDataObjectBikePlayerCharaSpec) == 0x000008, "Wrong alignment on UEndDataObjectBikePlayerCharaSpec");
static_assert(sizeof(UEndDataObjectBikePlayerCharaSpec) == 0x000088, "Wrong size on UEndDataObjectBikePlayerCharaSpec");

// Class EndGame.EndDataObjectBikePlayerFeedback
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBikePlayerFeedback final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBikePlayerFeedback">();
	}
	static class UEndDataObjectBikePlayerFeedback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBikePlayerFeedback>();
	}
};
static_assert(alignof(UEndDataObjectBikePlayerFeedback) == 0x000008, "Wrong alignment on UEndDataObjectBikePlayerFeedback");
static_assert(sizeof(UEndDataObjectBikePlayerFeedback) == 0x000088, "Wrong size on UEndDataObjectBikePlayerFeedback");

// Class EndGame.EndDataObjectBikeSequence
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBikeSequence final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBikeSequence">();
	}
	static class UEndDataObjectBikeSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBikeSequence>();
	}
};
static_assert(alignof(UEndDataObjectBikeSequence) == 0x000008, "Wrong alignment on UEndDataObjectBikeSequence");
static_assert(sizeof(UEndDataObjectBikeSequence) == 0x000088, "Wrong size on UEndDataObjectBikeSequence");

// Class EndGame.EndDataObjectBikeSequenceAction
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBikeSequenceAction final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBikeSequenceAction">();
	}
	static class UEndDataObjectBikeSequenceAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBikeSequenceAction>();
	}
};
static_assert(alignof(UEndDataObjectBikeSequenceAction) == 0x000008, "Wrong alignment on UEndDataObjectBikeSequenceAction");
static_assert(sizeof(UEndDataObjectBikeSequenceAction) == 0x000088, "Wrong size on UEndDataObjectBikeSequenceAction");

// Class EndGame.EndDataObjectBikeSequenceJump
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBikeSequenceJump final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBikeSequenceJump">();
	}
	static class UEndDataObjectBikeSequenceJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBikeSequenceJump>();
	}
};
static_assert(alignof(UEndDataObjectBikeSequenceJump) == 0x000008, "Wrong alignment on UEndDataObjectBikeSequenceJump");
static_assert(sizeof(UEndDataObjectBikeSequenceJump) == 0x000088, "Wrong size on UEndDataObjectBikeSequenceJump");

// Class EndGame.EndNavTarzanRopeTerrainVolume
// 0x0000 (0x0450 - 0x0450)
class AEndNavTarzanRopeTerrainVolume final : public AEndNavSimpleTerrainVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavTarzanRopeTerrainVolume">();
	}
	static class AEndNavTarzanRopeTerrainVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndNavTarzanRopeTerrainVolume>();
	}
};
static_assert(alignof(AEndNavTarzanRopeTerrainVolume) == 0x000008, "Wrong alignment on AEndNavTarzanRopeTerrainVolume");
static_assert(sizeof(AEndNavTarzanRopeTerrainVolume) == 0x000450, "Wrong size on AEndNavTarzanRopeTerrainVolume");

// Class EndGame.EndDataObjectBikeTalkCondition
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBikeTalkCondition final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBikeTalkCondition">();
	}
	static class UEndDataObjectBikeTalkCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBikeTalkCondition>();
	}
};
static_assert(alignof(UEndDataObjectBikeTalkCondition) == 0x000008, "Wrong alignment on UEndDataObjectBikeTalkCondition");
static_assert(sizeof(UEndDataObjectBikeTalkCondition) == 0x000088, "Wrong size on UEndDataObjectBikeTalkCondition");

// Class EndGame.EndDataObjectBikeTalkTriggerSet
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBikeTalkTriggerSet final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBikeTalkTriggerSet">();
	}
	static class UEndDataObjectBikeTalkTriggerSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBikeTalkTriggerSet>();
	}
};
static_assert(alignof(UEndDataObjectBikeTalkTriggerSet) == 0x000008, "Wrong alignment on UEndDataObjectBikeTalkTriggerSet");
static_assert(sizeof(UEndDataObjectBikeTalkTriggerSet) == 0x000088, "Wrong size on UEndDataObjectBikeTalkTriggerSet");

// Class EndGame.EndDataObjectBikeTriggerEffectSetting
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectBikeTriggerEffectSetting final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectBikeTriggerEffectSetting">();
	}
	static class UEndDataObjectBikeTriggerEffectSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectBikeTriggerEffectSetting>();
	}
};
static_assert(alignof(UEndDataObjectBikeTriggerEffectSetting) == 0x000008, "Wrong alignment on UEndDataObjectBikeTriggerEffectSetting");
static_assert(sizeof(UEndDataObjectBikeTriggerEffectSetting) == 0x000088, "Wrong size on UEndDataObjectBikeTriggerEffectSetting");

// Class EndGame.EndDataObjectCameraSequence
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectCameraSequence final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectCameraSequence">();
	}
	static class UEndDataObjectCameraSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectCameraSequence>();
	}
};
static_assert(alignof(UEndDataObjectCameraSequence) == 0x000008, "Wrong alignment on UEndDataObjectCameraSequence");
static_assert(sizeof(UEndDataObjectCameraSequence) == 0x000088, "Wrong size on UEndDataObjectCameraSequence");

// Class EndGame.EndDataObjectCameraSetting
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectCameraSetting final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectCameraSetting">();
	}
	static class UEndDataObjectCameraSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectCameraSetting>();
	}
};
static_assert(alignof(UEndDataObjectCameraSetting) == 0x000008, "Wrong alignment on UEndDataObjectCameraSetting");
static_assert(sizeof(UEndDataObjectCameraSetting) == 0x000088, "Wrong size on UEndDataObjectCameraSetting");

// Class EndGame.EndDataObjectCameraShake
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectCameraShake final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectCameraShake">();
	}
	static class UEndDataObjectCameraShake* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectCameraShake>();
	}
};
static_assert(alignof(UEndDataObjectCameraShake) == 0x000008, "Wrong alignment on UEndDataObjectCameraShake");
static_assert(sizeof(UEndDataObjectCameraShake) == 0x000088, "Wrong size on UEndDataObjectCameraShake");

// Class EndGame.EndDataObjectChapter
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectChapter final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectChapter">();
	}
	static class UEndDataObjectChapter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectChapter>();
	}
};
static_assert(alignof(UEndDataObjectChapter) == 0x000008, "Wrong alignment on UEndDataObjectChapter");
static_assert(sizeof(UEndDataObjectChapter) == 0x000088, "Wrong size on UEndDataObjectChapter");

// Class EndGame.EndSortWindow
// 0x0080 (0x03E0 - 0x0360)
class UEndSortWindow : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x60];                                     // 0x0360(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndVirtualScrollBox*                   Options;                                           // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Btn;                                           // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndBorder*                             Sort_EquipMark;                                    // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSortListPressedItem(int32 CellIndex);
	void OnSortListSetupItem(class UWidget* ItemWidget, int32 CellIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndSortWindow">();
	}
	static class UEndSortWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndSortWindow>();
	}
};
static_assert(alignof(UEndSortWindow) == 0x000008, "Wrong alignment on UEndSortWindow");
static_assert(sizeof(UEndSortWindow) == 0x0003E0, "Wrong size on UEndSortWindow");
static_assert(offsetof(UEndSortWindow, Options) == 0x0003C0, "Member 'UEndSortWindow::Options' has a wrong offset!");
static_assert(offsetof(UEndSortWindow, Txt_Btn) == 0x0003C8, "Member 'UEndSortWindow::Txt_Btn' has a wrong offset!");
static_assert(offsetof(UEndSortWindow, Sort_EquipMark) == 0x0003D0, "Member 'UEndSortWindow::Sort_EquipMark' has a wrong offset!");

// Class EndGame.EndDataObjectCharaActionTable
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectCharaActionTable final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectCharaActionTable">();
	}
	static class UEndDataObjectCharaActionTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectCharaActionTable>();
	}
};
static_assert(alignof(UEndDataObjectCharaActionTable) == 0x000008, "Wrong alignment on UEndDataObjectCharaActionTable");
static_assert(sizeof(UEndDataObjectCharaActionTable) == 0x000088, "Wrong size on UEndDataObjectCharaActionTable");

// Class EndGame.EndDataObjectCharaExchangeTable
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectCharaExchangeTable final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectCharaExchangeTable">();
	}
	static class UEndDataObjectCharaExchangeTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectCharaExchangeTable>();
	}
};
static_assert(alignof(UEndDataObjectCharaExchangeTable) == 0x000008, "Wrong alignment on UEndDataObjectCharaExchangeTable");
static_assert(sizeof(UEndDataObjectCharaExchangeTable) == 0x000088, "Wrong size on UEndDataObjectCharaExchangeTable");

// Class EndGame.EndDataObjectCharaPopAsset
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectCharaPopAsset final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectCharaPopAsset">();
	}
	static class UEndDataObjectCharaPopAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectCharaPopAsset>();
	}
};
static_assert(alignof(UEndDataObjectCharaPopAsset) == 0x000008, "Wrong alignment on UEndDataObjectCharaPopAsset");
static_assert(sizeof(UEndDataObjectCharaPopAsset) == 0x000088, "Wrong size on UEndDataObjectCharaPopAsset");

// Class EndGame.EndDataObjectCharaPopPack
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectCharaPopPack final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectCharaPopPack">();
	}
	static class UEndDataObjectCharaPopPack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectCharaPopPack>();
	}
};
static_assert(alignof(UEndDataObjectCharaPopPack) == 0x000008, "Wrong alignment on UEndDataObjectCharaPopPack");
static_assert(sizeof(UEndDataObjectCharaPopPack) == 0x000088, "Wrong size on UEndDataObjectCharaPopPack");

// Class EndGame.EndDataObjectCharaSpec
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectCharaSpec final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectCharaSpec">();
	}
	static class UEndDataObjectCharaSpec* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectCharaSpec>();
	}
};
static_assert(alignof(UEndDataObjectCharaSpec) == 0x000008, "Wrong alignment on UEndDataObjectCharaSpec");
static_assert(sizeof(UEndDataObjectCharaSpec) == 0x000088, "Wrong size on UEndDataObjectCharaSpec");

// Class EndGame.EndDataObjectCharaSpecSoundCategory
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectCharaSpecSoundCategory final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectCharaSpecSoundCategory">();
	}
	static class UEndDataObjectCharaSpecSoundCategory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectCharaSpecSoundCategory>();
	}
};
static_assert(alignof(UEndDataObjectCharaSpecSoundCategory) == 0x000008, "Wrong alignment on UEndDataObjectCharaSpecSoundCategory");
static_assert(sizeof(UEndDataObjectCharaSpecSoundCategory) == 0x000088, "Wrong size on UEndDataObjectCharaSpecSoundCategory");

// Class EndGame.EndDataObjectColosseum
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectColosseum final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectColosseum">();
	}
	static class UEndDataObjectColosseum* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectColosseum>();
	}
};
static_assert(alignof(UEndDataObjectColosseum) == 0x000008, "Wrong alignment on UEndDataObjectColosseum");
static_assert(sizeof(UEndDataObjectColosseum) == 0x000088, "Wrong size on UEndDataObjectColosseum");

// Class EndGame.EndParticleModuleWeaponUpgrade
// 0x0688 (0x06C0 - 0x0038)
class UEndParticleModuleWeaponUpgrade final : public UEndParticleModuleBase
{
public:
	int32                                         m_DebugMainCoreResource;                           // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         m_DebugSubCoreResource;                            // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         m_DebugSkillResource;                              // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         m_DebugSubCoreCount;                               // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         m_DebugMainSkillCount;                             // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         m_DebugSubSkillCount;                              // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         m_DebugUpgradeCount;                               // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         m_DebugPlayStageEffects : 1;                       // 0x0054(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         m_DebugPlayStageEffectsActive : 1;                 // 0x0054(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         m_DebugTravelCore : 1;                             // 0x0054(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         m_DebugTravelTimer;                                // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEndWeaponUpgradeCircle                m_CircleCore;                                      // 0x0060(0x0200)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FEndWeaponUpgradeCircle                m_CircleSkill;                                     // 0x0260(0x0200)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FEndWeaponUpgradeCircle                m_CircleUpgrade;                                   // 0x0460(0x0200)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         m_UpgradeScale;                                    // 0x0660(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_WaitCameraMoveTime;                              // 0x0664(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_WaitStageEffectsTime;                            // 0x0668(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_WaitCoreStageEffectsTime;                        // 0x066C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_CoreStageEffectsFirstDelayTime;                  // 0x0670(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_CoreStageEffectsDelayTime;                       // 0x0674(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_678[0x48];                                     // 0x0678(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndParticleModuleWeaponUpgrade">();
	}
	static class UEndParticleModuleWeaponUpgrade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndParticleModuleWeaponUpgrade>();
	}
};
static_assert(alignof(UEndParticleModuleWeaponUpgrade) == 0x000008, "Wrong alignment on UEndParticleModuleWeaponUpgrade");
static_assert(sizeof(UEndParticleModuleWeaponUpgrade) == 0x0006C0, "Wrong size on UEndParticleModuleWeaponUpgrade");
static_assert(offsetof(UEndParticleModuleWeaponUpgrade, m_DebugMainCoreResource) == 0x000038, "Member 'UEndParticleModuleWeaponUpgrade::m_DebugMainCoreResource' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleWeaponUpgrade, m_DebugSubCoreResource) == 0x00003C, "Member 'UEndParticleModuleWeaponUpgrade::m_DebugSubCoreResource' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleWeaponUpgrade, m_DebugSkillResource) == 0x000040, "Member 'UEndParticleModuleWeaponUpgrade::m_DebugSkillResource' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleWeaponUpgrade, m_DebugSubCoreCount) == 0x000044, "Member 'UEndParticleModuleWeaponUpgrade::m_DebugSubCoreCount' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleWeaponUpgrade, m_DebugMainSkillCount) == 0x000048, "Member 'UEndParticleModuleWeaponUpgrade::m_DebugMainSkillCount' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleWeaponUpgrade, m_DebugSubSkillCount) == 0x00004C, "Member 'UEndParticleModuleWeaponUpgrade::m_DebugSubSkillCount' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleWeaponUpgrade, m_DebugUpgradeCount) == 0x000050, "Member 'UEndParticleModuleWeaponUpgrade::m_DebugUpgradeCount' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleWeaponUpgrade, m_DebugTravelTimer) == 0x000058, "Member 'UEndParticleModuleWeaponUpgrade::m_DebugTravelTimer' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleWeaponUpgrade, m_CircleCore) == 0x000060, "Member 'UEndParticleModuleWeaponUpgrade::m_CircleCore' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleWeaponUpgrade, m_CircleSkill) == 0x000260, "Member 'UEndParticleModuleWeaponUpgrade::m_CircleSkill' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleWeaponUpgrade, m_CircleUpgrade) == 0x000460, "Member 'UEndParticleModuleWeaponUpgrade::m_CircleUpgrade' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleWeaponUpgrade, m_UpgradeScale) == 0x000660, "Member 'UEndParticleModuleWeaponUpgrade::m_UpgradeScale' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleWeaponUpgrade, m_WaitCameraMoveTime) == 0x000664, "Member 'UEndParticleModuleWeaponUpgrade::m_WaitCameraMoveTime' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleWeaponUpgrade, m_WaitStageEffectsTime) == 0x000668, "Member 'UEndParticleModuleWeaponUpgrade::m_WaitStageEffectsTime' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleWeaponUpgrade, m_WaitCoreStageEffectsTime) == 0x00066C, "Member 'UEndParticleModuleWeaponUpgrade::m_WaitCoreStageEffectsTime' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleWeaponUpgrade, m_CoreStageEffectsFirstDelayTime) == 0x000670, "Member 'UEndParticleModuleWeaponUpgrade::m_CoreStageEffectsFirstDelayTime' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleWeaponUpgrade, m_CoreStageEffectsDelayTime) == 0x000674, "Member 'UEndParticleModuleWeaponUpgrade::m_CoreStageEffectsDelayTime' has a wrong offset!");

// Class EndGame.EndDataObjectColosseumPositionData
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectColosseumPositionData final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectColosseumPositionData">();
	}
	static class UEndDataObjectColosseumPositionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectColosseumPositionData>();
	}
};
static_assert(alignof(UEndDataObjectColosseumPositionData) == 0x000008, "Wrong alignment on UEndDataObjectColosseumPositionData");
static_assert(sizeof(UEndDataObjectColosseumPositionData) == 0x000088, "Wrong size on UEndDataObjectColosseumPositionData");

// Class EndGame.EndDataObjectCommonSaveDataConfig
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectCommonSaveDataConfig final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectCommonSaveDataConfig">();
	}
	static class UEndDataObjectCommonSaveDataConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectCommonSaveDataConfig>();
	}
};
static_assert(alignof(UEndDataObjectCommonSaveDataConfig) == 0x000008, "Wrong alignment on UEndDataObjectCommonSaveDataConfig");
static_assert(sizeof(UEndDataObjectCommonSaveDataConfig) == 0x000088, "Wrong size on UEndDataObjectCommonSaveDataConfig");

// Class EndGame.EndDataObjectCondorFortBoard
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectCondorFortBoard final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectCondorFortBoard">();
	}
	static class UEndDataObjectCondorFortBoard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectCondorFortBoard>();
	}
};
static_assert(alignof(UEndDataObjectCondorFortBoard) == 0x000008, "Wrong alignment on UEndDataObjectCondorFortBoard");
static_assert(sizeof(UEndDataObjectCondorFortBoard) == 0x000088, "Wrong size on UEndDataObjectCondorFortBoard");

// Class EndGame.EndDataObjectCondorFortCharacter
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectCondorFortCharacter final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectCondorFortCharacter">();
	}
	static class UEndDataObjectCondorFortCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectCondorFortCharacter>();
	}
};
static_assert(alignof(UEndDataObjectCondorFortCharacter) == 0x000008, "Wrong alignment on UEndDataObjectCondorFortCharacter");
static_assert(sizeof(UEndDataObjectCondorFortCharacter) == 0x000088, "Wrong size on UEndDataObjectCondorFortCharacter");

// Class EndGame.EndDataObjectCondorFortCharacterParameter
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectCondorFortCharacterParameter final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectCondorFortCharacterParameter">();
	}
	static class UEndDataObjectCondorFortCharacterParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectCondorFortCharacterParameter>();
	}
};
static_assert(alignof(UEndDataObjectCondorFortCharacterParameter) == 0x000008, "Wrong alignment on UEndDataObjectCondorFortCharacterParameter");
static_assert(sizeof(UEndDataObjectCondorFortCharacterParameter) == 0x000088, "Wrong size on UEndDataObjectCondorFortCharacterParameter");

// Class EndGame.EndDataObjectCondorFortMateria
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectCondorFortMateria final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectCondorFortMateria">();
	}
	static class UEndDataObjectCondorFortMateria* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectCondorFortMateria>();
	}
};
static_assert(alignof(UEndDataObjectCondorFortMateria) == 0x000008, "Wrong alignment on UEndDataObjectCondorFortMateria");
static_assert(sizeof(UEndDataObjectCondorFortMateria) == 0x000088, "Wrong size on UEndDataObjectCondorFortMateria");

// Class EndGame.EndPhysicalConstraintUserData
// 0x0018 (0x0040 - 0x0028)
class UEndPhysicalConstraintUserData final : public UAssetUserData
{
public:
	class UEndPhysicalConstraintSetting*          Setting;                                           // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndPhysicalConstraintSetting*          PostSetting;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoActivate;                                     // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndPhysicalConstraintUserData">();
	}
	static class UEndPhysicalConstraintUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndPhysicalConstraintUserData>();
	}
};
static_assert(alignof(UEndPhysicalConstraintUserData) == 0x000008, "Wrong alignment on UEndPhysicalConstraintUserData");
static_assert(sizeof(UEndPhysicalConstraintUserData) == 0x000040, "Wrong size on UEndPhysicalConstraintUserData");
static_assert(offsetof(UEndPhysicalConstraintUserData, Setting) == 0x000028, "Member 'UEndPhysicalConstraintUserData::Setting' has a wrong offset!");
static_assert(offsetof(UEndPhysicalConstraintUserData, PostSetting) == 0x000030, "Member 'UEndPhysicalConstraintUserData::PostSetting' has a wrong offset!");
static_assert(offsetof(UEndPhysicalConstraintUserData, bAutoActivate) == 0x000038, "Member 'UEndPhysicalConstraintUserData::bAutoActivate' has a wrong offset!");

// Class EndGame.EndDataObjectCondorFortOpponent
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectCondorFortOpponent final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectCondorFortOpponent">();
	}
	static class UEndDataObjectCondorFortOpponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectCondorFortOpponent>();
	}
};
static_assert(alignof(UEndDataObjectCondorFortOpponent) == 0x000008, "Wrong alignment on UEndDataObjectCondorFortOpponent");
static_assert(sizeof(UEndDataObjectCondorFortOpponent) == 0x000088, "Wrong size on UEndDataObjectCondorFortOpponent");

// Class EndGame.EndDataObjectCondorFortOpponentPersonality
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectCondorFortOpponentPersonality final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectCondorFortOpponentPersonality">();
	}
	static class UEndDataObjectCondorFortOpponentPersonality* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectCondorFortOpponentPersonality>();
	}
};
static_assert(alignof(UEndDataObjectCondorFortOpponentPersonality) == 0x000008, "Wrong alignment on UEndDataObjectCondorFortOpponentPersonality");
static_assert(sizeof(UEndDataObjectCondorFortOpponentPersonality) == 0x000088, "Wrong size on UEndDataObjectCondorFortOpponentPersonality");

// Class EndGame.EndDataObjectCondorFortUnitFormation
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectCondorFortUnitFormation final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectCondorFortUnitFormation">();
	}
	static class UEndDataObjectCondorFortUnitFormation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectCondorFortUnitFormation>();
	}
};
static_assert(alignof(UEndDataObjectCondorFortUnitFormation) == 0x000008, "Wrong alignment on UEndDataObjectCondorFortUnitFormation");
static_assert(sizeof(UEndDataObjectCondorFortUnitFormation) == 0x000088, "Wrong size on UEndDataObjectCondorFortUnitFormation");

// Class EndGame.EndDataObjectCounters
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectCounters final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectCounters">();
	}
	static class UEndDataObjectCounters* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectCounters>();
	}
};
static_assert(alignof(UEndDataObjectCounters) == 0x000008, "Wrong alignment on UEndDataObjectCounters");
static_assert(sizeof(UEndDataObjectCounters) == 0x000088, "Wrong size on UEndDataObjectCounters");

// Class EndGame.EndDataObjectCutSceneBindActorList
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectCutSceneBindActorList final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectCutSceneBindActorList">();
	}
	static class UEndDataObjectCutSceneBindActorList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectCutSceneBindActorList>();
	}
};
static_assert(alignof(UEndDataObjectCutSceneBindActorList) == 0x000008, "Wrong alignment on UEndDataObjectCutSceneBindActorList");
static_assert(sizeof(UEndDataObjectCutSceneBindActorList) == 0x000088, "Wrong size on UEndDataObjectCutSceneBindActorList");

// Class EndGame.EndDataObjectCutSceneChangeEquipList
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectCutSceneChangeEquipList final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectCutSceneChangeEquipList">();
	}
	static class UEndDataObjectCutSceneChangeEquipList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectCutSceneChangeEquipList>();
	}
};
static_assert(alignof(UEndDataObjectCutSceneChangeEquipList) == 0x000008, "Wrong alignment on UEndDataObjectCutSceneChangeEquipList");
static_assert(sizeof(UEndDataObjectCutSceneChangeEquipList) == 0x000088, "Wrong size on UEndDataObjectCutSceneChangeEquipList");

// Class EndGame.EndDataObjectCutSceneListLevel
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectCutSceneListLevel final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectCutSceneListLevel">();
	}
	static class UEndDataObjectCutSceneListLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectCutSceneListLevel>();
	}
};
static_assert(alignof(UEndDataObjectCutSceneListLevel) == 0x000008, "Wrong alignment on UEndDataObjectCutSceneListLevel");
static_assert(sizeof(UEndDataObjectCutSceneListLevel) == 0x000088, "Wrong size on UEndDataObjectCutSceneListLevel");

// Class EndGame.EndMenuATBLampIcon
// 0x0010 (0x0370 - 0x0360)
class UEndMenuATBLampIcon final : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x10];                                     // 0x0360(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMenuATBLampIcon">();
	}
	static class UEndMenuATBLampIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMenuATBLampIcon>();
	}
};
static_assert(alignof(UEndMenuATBLampIcon) == 0x000008, "Wrong alignment on UEndMenuATBLampIcon");
static_assert(sizeof(UEndMenuATBLampIcon) == 0x000370, "Wrong size on UEndMenuATBLampIcon");

// Class EndGame.EndDataObjectCutSceneLoadCharaSpecList
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectCutSceneLoadCharaSpecList final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectCutSceneLoadCharaSpecList">();
	}
	static class UEndDataObjectCutSceneLoadCharaSpecList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectCutSceneLoadCharaSpecList>();
	}
};
static_assert(alignof(UEndDataObjectCutSceneLoadCharaSpecList) == 0x000008, "Wrong alignment on UEndDataObjectCutSceneLoadCharaSpecList");
static_assert(sizeof(UEndDataObjectCutSceneLoadCharaSpecList) == 0x000088, "Wrong size on UEndDataObjectCutSceneLoadCharaSpecList");

// Class EndGame.EndDataObjectDebugColorCollection
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectDebugColorCollection final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectDebugColorCollection">();
	}
	static class UEndDataObjectDebugColorCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectDebugColorCollection>();
	}
};
static_assert(alignof(UEndDataObjectDebugColorCollection) == 0x000008, "Wrong alignment on UEndDataObjectDebugColorCollection");
static_assert(sizeof(UEndDataObjectDebugColorCollection) == 0x000088, "Wrong size on UEndDataObjectDebugColorCollection");

// Class EndGame.EndDataObjectEffect2SoundTable
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectEffect2SoundTable final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectEffect2SoundTable">();
	}
	static class UEndDataObjectEffect2SoundTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectEffect2SoundTable>();
	}
};
static_assert(alignof(UEndDataObjectEffect2SoundTable) == 0x000008, "Wrong alignment on UEndDataObjectEffect2SoundTable");
static_assert(sizeof(UEndDataObjectEffect2SoundTable) == 0x000088, "Wrong size on UEndDataObjectEffect2SoundTable");

// Class EndGame.EndDataObjectEffectCharaProperty
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectEffectCharaProperty final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectEffectCharaProperty">();
	}
	static class UEndDataObjectEffectCharaProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectEffectCharaProperty>();
	}
};
static_assert(alignof(UEndDataObjectEffectCharaProperty) == 0x000008, "Wrong alignment on UEndDataObjectEffectCharaProperty");
static_assert(sizeof(UEndDataObjectEffectCharaProperty) == 0x000088, "Wrong size on UEndDataObjectEffectCharaProperty");

// Class EndGame.EndDataObjectEmotion
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectEmotion final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectEmotion">();
	}
	static class UEndDataObjectEmotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectEmotion>();
	}
};
static_assert(alignof(UEndDataObjectEmotion) == 0x000008, "Wrong alignment on UEndDataObjectEmotion");
static_assert(sizeof(UEndDataObjectEmotion) == 0x000088, "Wrong size on UEndDataObjectEmotion");

// Class EndGame.EndDataObjectEnemyBook
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectEnemyBook final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectEnemyBook">();
	}
	static class UEndDataObjectEnemyBook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectEnemyBook>();
	}
};
static_assert(alignof(UEndDataObjectEnemyBook) == 0x000008, "Wrong alignment on UEndDataObjectEnemyBook");
static_assert(sizeof(UEndDataObjectEnemyBook) == 0x000088, "Wrong size on UEndDataObjectEnemyBook");

// Class EndGame.EndMenuFieldMenuHandler
// 0x0010 (0x0038 - 0x0028)
class UEndMenuFieldMenuHandler final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCommandClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMenuFieldMenuHandler">();
	}
	static class UEndMenuFieldMenuHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMenuFieldMenuHandler>();
	}
};
static_assert(alignof(UEndMenuFieldMenuHandler) == 0x000008, "Wrong alignment on UEndMenuFieldMenuHandler");
static_assert(sizeof(UEndMenuFieldMenuHandler) == 0x000038, "Wrong size on UEndMenuFieldMenuHandler");

// Class EndGame.EndDataObjectEnemyBookAbilites
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectEnemyBookAbilites final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectEnemyBookAbilites">();
	}
	static class UEndDataObjectEnemyBookAbilites* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectEnemyBookAbilites>();
	}
};
static_assert(alignof(UEndDataObjectEnemyBookAbilites) == 0x000008, "Wrong alignment on UEndDataObjectEnemyBookAbilites");
static_assert(sizeof(UEndDataObjectEnemyBookAbilites) == 0x000088, "Wrong size on UEndDataObjectEnemyBookAbilites");

// Class EndGame.EndDataObjectEnemyBookBattleAbility
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectEnemyBookBattleAbility final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectEnemyBookBattleAbility">();
	}
	static class UEndDataObjectEnemyBookBattleAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectEnemyBookBattleAbility>();
	}
};
static_assert(alignof(UEndDataObjectEnemyBookBattleAbility) == 0x000008, "Wrong alignment on UEndDataObjectEnemyBookBattleAbility");
static_assert(sizeof(UEndDataObjectEnemyBookBattleAbility) == 0x000088, "Wrong size on UEndDataObjectEnemyBookBattleAbility");

// Class EndGame.EndDataObjectEnemyBookBattleDamageSource
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectEnemyBookBattleDamageSource final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectEnemyBookBattleDamageSource">();
	}
	static class UEndDataObjectEnemyBookBattleDamageSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectEnemyBookBattleDamageSource>();
	}
};
static_assert(alignof(UEndDataObjectEnemyBookBattleDamageSource) == 0x000008, "Wrong alignment on UEndDataObjectEnemyBookBattleDamageSource");
static_assert(sizeof(UEndDataObjectEnemyBookBattleDamageSource) == 0x000088, "Wrong size on UEndDataObjectEnemyBookBattleDamageSource");

// Class EndGame.EndDataObjectEnemyEXP
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectEnemyEXP final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectEnemyEXP">();
	}
	static class UEndDataObjectEnemyEXP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectEnemyEXP>();
	}
};
static_assert(alignof(UEndDataObjectEnemyEXP) == 0x000008, "Wrong alignment on UEndDataObjectEnemyEXP");
static_assert(sizeof(UEndDataObjectEnemyEXP) == 0x000088, "Wrong size on UEndDataObjectEnemyEXP");

// Class EndGame.EndDataObjectEnemyGil
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectEnemyGil final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectEnemyGil">();
	}
	static class UEndDataObjectEnemyGil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectEnemyGil>();
	}
};
static_assert(alignof(UEndDataObjectEnemyGil) == 0x000008, "Wrong alignment on UEndDataObjectEnemyGil");
static_assert(sizeof(UEndDataObjectEnemyGil) == 0x000088, "Wrong size on UEndDataObjectEnemyGil");

// Class EndGame.EndDataObjectEnvironmentPhysicsSpec
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectEnvironmentPhysicsSpec final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectEnvironmentPhysicsSpec">();
	}
	static class UEndDataObjectEnvironmentPhysicsSpec* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectEnvironmentPhysicsSpec>();
	}
};
static_assert(alignof(UEndDataObjectEnvironmentPhysicsSpec) == 0x000008, "Wrong alignment on UEndDataObjectEnvironmentPhysicsSpec");
static_assert(sizeof(UEndDataObjectEnvironmentPhysicsSpec) == 0x000088, "Wrong size on UEndDataObjectEnvironmentPhysicsSpec");

// Class EndGame.EndLayoutObjectPack
// 0x0058 (0x03D0 - 0x0378)
class AEndLayoutObjectPack final : public AActor
{
public:
	class FName                                   Category;                                          // 0x0378(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FTransform>          TargetPoints;                                      // 0x0380(0x0050)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndLayoutObjectPack">();
	}
	static class AEndLayoutObjectPack* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndLayoutObjectPack>();
	}
};
static_assert(alignof(AEndLayoutObjectPack) == 0x000008, "Wrong alignment on AEndLayoutObjectPack");
static_assert(sizeof(AEndLayoutObjectPack) == 0x0003D0, "Wrong size on AEndLayoutObjectPack");
static_assert(offsetof(AEndLayoutObjectPack, Category) == 0x000378, "Member 'AEndLayoutObjectPack::Category' has a wrong offset!");
static_assert(offsetof(AEndLayoutObjectPack, TargetPoints) == 0x000380, "Member 'AEndLayoutObjectPack::TargetPoints' has a wrong offset!");

// Class EndGame.EndDataObjectEnvironmentSet
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectEnvironmentSet final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectEnvironmentSet">();
	}
	static class UEndDataObjectEnvironmentSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectEnvironmentSet>();
	}
};
static_assert(alignof(UEndDataObjectEnvironmentSet) == 0x000008, "Wrong alignment on UEndDataObjectEnvironmentSet");
static_assert(sizeof(UEndDataObjectEnvironmentSet) == 0x000088, "Wrong size on UEndDataObjectEnvironmentSet");

// Class EndGame.EndDataObjectEnvironmentSetWrapper
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectEnvironmentSetWrapper final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectEnvironmentSetWrapper">();
	}
	static class UEndDataObjectEnvironmentSetWrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectEnvironmentSetWrapper>();
	}
};
static_assert(alignof(UEndDataObjectEnvironmentSetWrapper) == 0x000008, "Wrong alignment on UEndDataObjectEnvironmentSetWrapper");
static_assert(sizeof(UEndDataObjectEnvironmentSetWrapper) == 0x000088, "Wrong size on UEndDataObjectEnvironmentSetWrapper");

// Class EndGame.EndDataObjectEquipment
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectEquipment final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectEquipment">();
	}
	static class UEndDataObjectEquipment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectEquipment>();
	}
};
static_assert(alignof(UEndDataObjectEquipment) == 0x000008, "Wrong alignment on UEndDataObjectEquipment");
static_assert(sizeof(UEndDataObjectEquipment) == 0x000088, "Wrong size on UEndDataObjectEquipment");

// Class EndGame.EndDataObjectEquipmentSet
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectEquipmentSet final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectEquipmentSet">();
	}
	static class UEndDataObjectEquipmentSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectEquipmentSet>();
	}
};
static_assert(alignof(UEndDataObjectEquipmentSet) == 0x000008, "Wrong alignment on UEndDataObjectEquipmentSet");
static_assert(sizeof(UEndDataObjectEquipmentSet) == 0x000088, "Wrong size on UEndDataObjectEquipmentSet");

// Class EndGame.EndDataObjectEquipmentSkill
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectEquipmentSkill final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectEquipmentSkill">();
	}
	static class UEndDataObjectEquipmentSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectEquipmentSkill>();
	}
};
static_assert(alignof(UEndDataObjectEquipmentSkill) == 0x000008, "Wrong alignment on UEndDataObjectEquipmentSkill");
static_assert(sizeof(UEndDataObjectEquipmentSkill) == 0x000088, "Wrong size on UEndDataObjectEquipmentSkill");

// Class EndGame.EndDataObjectEventPriorityChange
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectEventPriorityChange final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectEventPriorityChange">();
	}
	static class UEndDataObjectEventPriorityChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectEventPriorityChange>();
	}
};
static_assert(alignof(UEndDataObjectEventPriorityChange) == 0x000008, "Wrong alignment on UEndDataObjectEventPriorityChange");
static_assert(sizeof(UEndDataObjectEventPriorityChange) == 0x000088, "Wrong size on UEndDataObjectEventPriorityChange");

// Class EndGame.EndLookAtSolver
// 0x0060 (0x0088 - 0x0028)
class UEndLookAtSolver final : public UObject
{
public:
	class FName                                   OriginBoneName;                                    // 0x0028(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNormalizeBoneWeight;                              // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bComponentSpaceForwardAim;                         // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSolveBoneAimVector;                            // 0x0032(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEulerInterp;                                      // 0x0033(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActiveBlendTime;                                   // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeactiveBlendTime;                                 // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActiveBlendTimeWarning;                            // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeactiveBlendTimeWarning;                          // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              BlendTimeRandomBiasRange;                          // 0x0044(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActiveAngle;                                       // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeactiveAngle;                                     // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActiveAngleWarning;                                // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeactiveAngleWarning;                              // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClampAtActiveAngle;                               // 0x005C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClampHorizontalDistanceMin;                        // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivityDurationMin;                               // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeightBias;                                        // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeightBiasWarning;                                 // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpWeightBias;                                      // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpWeightBiasWarning;                               // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEndLookAtSolveBone>            SolveBones;                                        // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndLookAtSolver">();
	}
	static class UEndLookAtSolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndLookAtSolver>();
	}
};
static_assert(alignof(UEndLookAtSolver) == 0x000008, "Wrong alignment on UEndLookAtSolver");
static_assert(sizeof(UEndLookAtSolver) == 0x000088, "Wrong size on UEndLookAtSolver");
static_assert(offsetof(UEndLookAtSolver, OriginBoneName) == 0x000028, "Member 'UEndLookAtSolver::OriginBoneName' has a wrong offset!");
static_assert(offsetof(UEndLookAtSolver, bNormalizeBoneWeight) == 0x000030, "Member 'UEndLookAtSolver::bNormalizeBoneWeight' has a wrong offset!");
static_assert(offsetof(UEndLookAtSolver, bComponentSpaceForwardAim) == 0x000031, "Member 'UEndLookAtSolver::bComponentSpaceForwardAim' has a wrong offset!");
static_assert(offsetof(UEndLookAtSolver, bUseSolveBoneAimVector) == 0x000032, "Member 'UEndLookAtSolver::bUseSolveBoneAimVector' has a wrong offset!");
static_assert(offsetof(UEndLookAtSolver, bEulerInterp) == 0x000033, "Member 'UEndLookAtSolver::bEulerInterp' has a wrong offset!");
static_assert(offsetof(UEndLookAtSolver, ActiveBlendTime) == 0x000034, "Member 'UEndLookAtSolver::ActiveBlendTime' has a wrong offset!");
static_assert(offsetof(UEndLookAtSolver, DeactiveBlendTime) == 0x000038, "Member 'UEndLookAtSolver::DeactiveBlendTime' has a wrong offset!");
static_assert(offsetof(UEndLookAtSolver, ActiveBlendTimeWarning) == 0x00003C, "Member 'UEndLookAtSolver::ActiveBlendTimeWarning' has a wrong offset!");
static_assert(offsetof(UEndLookAtSolver, DeactiveBlendTimeWarning) == 0x000040, "Member 'UEndLookAtSolver::DeactiveBlendTimeWarning' has a wrong offset!");
static_assert(offsetof(UEndLookAtSolver, BlendTimeRandomBiasRange) == 0x000044, "Member 'UEndLookAtSolver::BlendTimeRandomBiasRange' has a wrong offset!");
static_assert(offsetof(UEndLookAtSolver, ActiveAngle) == 0x00004C, "Member 'UEndLookAtSolver::ActiveAngle' has a wrong offset!");
static_assert(offsetof(UEndLookAtSolver, DeactiveAngle) == 0x000050, "Member 'UEndLookAtSolver::DeactiveAngle' has a wrong offset!");
static_assert(offsetof(UEndLookAtSolver, ActiveAngleWarning) == 0x000054, "Member 'UEndLookAtSolver::ActiveAngleWarning' has a wrong offset!");
static_assert(offsetof(UEndLookAtSolver, DeactiveAngleWarning) == 0x000058, "Member 'UEndLookAtSolver::DeactiveAngleWarning' has a wrong offset!");
static_assert(offsetof(UEndLookAtSolver, bClampAtActiveAngle) == 0x00005C, "Member 'UEndLookAtSolver::bClampAtActiveAngle' has a wrong offset!");
static_assert(offsetof(UEndLookAtSolver, ClampHorizontalDistanceMin) == 0x000060, "Member 'UEndLookAtSolver::ClampHorizontalDistanceMin' has a wrong offset!");
static_assert(offsetof(UEndLookAtSolver, ActivityDurationMin) == 0x000064, "Member 'UEndLookAtSolver::ActivityDurationMin' has a wrong offset!");
static_assert(offsetof(UEndLookAtSolver, WeightBias) == 0x000068, "Member 'UEndLookAtSolver::WeightBias' has a wrong offset!");
static_assert(offsetof(UEndLookAtSolver, WeightBiasWarning) == 0x00006C, "Member 'UEndLookAtSolver::WeightBiasWarning' has a wrong offset!");
static_assert(offsetof(UEndLookAtSolver, UpWeightBias) == 0x000070, "Member 'UEndLookAtSolver::UpWeightBias' has a wrong offset!");
static_assert(offsetof(UEndLookAtSolver, UpWeightBiasWarning) == 0x000074, "Member 'UEndLookAtSolver::UpWeightBiasWarning' has a wrong offset!");
static_assert(offsetof(UEndLookAtSolver, SolveBones) == 0x000078, "Member 'UEndLookAtSolver::SolveBones' has a wrong offset!");

// Class EndGame.EndDataObjectEventPriorityDistance
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectEventPriorityDistance final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectEventPriorityDistance">();
	}
	static class UEndDataObjectEventPriorityDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectEventPriorityDistance>();
	}
};
static_assert(alignof(UEndDataObjectEventPriorityDistance) == 0x000008, "Wrong alignment on UEndDataObjectEventPriorityDistance");
static_assert(sizeof(UEndDataObjectEventPriorityDistance) == 0x000088, "Wrong size on UEndDataObjectEventPriorityDistance");

// Class EndGame.EndDataObjectEventPriorityOverride
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectEventPriorityOverride final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectEventPriorityOverride">();
	}
	static class UEndDataObjectEventPriorityOverride* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectEventPriorityOverride>();
	}
};
static_assert(alignof(UEndDataObjectEventPriorityOverride) == 0x000008, "Wrong alignment on UEndDataObjectEventPriorityOverride");
static_assert(sizeof(UEndDataObjectEventPriorityOverride) == 0x000088, "Wrong size on UEndDataObjectEventPriorityOverride");

// Class EndGame.EndDataObjectFieldAttackAdditionalTarget
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectFieldAttackAdditionalTarget final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectFieldAttackAdditionalTarget">();
	}
	static class UEndDataObjectFieldAttackAdditionalTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectFieldAttackAdditionalTarget>();
	}
};
static_assert(alignof(UEndDataObjectFieldAttackAdditionalTarget) == 0x000008, "Wrong alignment on UEndDataObjectFieldAttackAdditionalTarget");
static_assert(sizeof(UEndDataObjectFieldAttackAdditionalTarget) == 0x000088, "Wrong size on UEndDataObjectFieldAttackAdditionalTarget");

// Class EndGame.EndDataObjectFieldAttackResponseArea
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectFieldAttackResponseArea final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectFieldAttackResponseArea">();
	}
	static class UEndDataObjectFieldAttackResponseArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectFieldAttackResponseArea>();
	}
};
static_assert(alignof(UEndDataObjectFieldAttackResponseArea) == 0x000008, "Wrong alignment on UEndDataObjectFieldAttackResponseArea");
static_assert(sizeof(UEndDataObjectFieldAttackResponseArea) == 0x000088, "Wrong size on UEndDataObjectFieldAttackResponseArea");

// Class EndGame.EndDataObjectFieldTips
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectFieldTips final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectFieldTips">();
	}
	static class UEndDataObjectFieldTips* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectFieldTips>();
	}
};
static_assert(alignof(UEndDataObjectFieldTips) == 0x000008, "Wrong alignment on UEndDataObjectFieldTips");
static_assert(sizeof(UEndDataObjectFieldTips) == 0x000088, "Wrong size on UEndDataObjectFieldTips");

// Class EndGame.EndDataObjectFootAttribute
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectFootAttribute final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectFootAttribute">();
	}
	static class UEndDataObjectFootAttribute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectFootAttribute>();
	}
};
static_assert(alignof(UEndDataObjectFootAttribute) == 0x000008, "Wrong alignment on UEndDataObjectFootAttribute");
static_assert(sizeof(UEndDataObjectFootAttribute) == 0x000088, "Wrong size on UEndDataObjectFootAttribute");

// Class EndGame.EndDataObjectFootBGMSet
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectFootBGMSet final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectFootBGMSet">();
	}
	static class UEndDataObjectFootBGMSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectFootBGMSet>();
	}
};
static_assert(alignof(UEndDataObjectFootBGMSet) == 0x000008, "Wrong alignment on UEndDataObjectFootBGMSet");
static_assert(sizeof(UEndDataObjectFootBGMSet) == 0x000088, "Wrong size on UEndDataObjectFootBGMSet");

// Class EndGame.EndDataObjectFormation
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectFormation final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectFormation">();
	}
	static class UEndDataObjectFormation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectFormation>();
	}
};
static_assert(alignof(UEndDataObjectFormation) == 0x000008, "Wrong alignment on UEndDataObjectFormation");
static_assert(sizeof(UEndDataObjectFormation) == 0x000088, "Wrong size on UEndDataObjectFormation");

// Class EndGame.EndFieldDanceMinigameSplineActor
// 0x0000 (0x0388 - 0x0388)
class AEndFieldDanceMinigameSplineActor final : public AEndSplineActorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldDanceMinigameSplineActor">();
	}
	static class AEndFieldDanceMinigameSplineActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldDanceMinigameSplineActor>();
	}
};
static_assert(alignof(AEndFieldDanceMinigameSplineActor) == 0x000008, "Wrong alignment on AEndFieldDanceMinigameSplineActor");
static_assert(sizeof(AEndFieldDanceMinigameSplineActor) == 0x000388, "Wrong size on AEndFieldDanceMinigameSplineActor");

// Class EndGame.EndDataObjectInDoorVolume
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectInDoorVolume final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectInDoorVolume">();
	}
	static class UEndDataObjectInDoorVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectInDoorVolume>();
	}
};
static_assert(alignof(UEndDataObjectInDoorVolume) == 0x000008, "Wrong alignment on UEndDataObjectInDoorVolume");
static_assert(sizeof(UEndDataObjectInDoorVolume) == 0x000088, "Wrong size on UEndDataObjectInDoorVolume");

// Class EndGame.VfxParticleModuleFogBase
// 0x0000 (0x0038 - 0x0038)
class UVfxParticleModuleFogBase : public UEndParticleModuleBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VfxParticleModuleFogBase">();
	}
	static class UVfxParticleModuleFogBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVfxParticleModuleFogBase>();
	}
};
static_assert(alignof(UVfxParticleModuleFogBase) == 0x000008, "Wrong alignment on UVfxParticleModuleFogBase");
static_assert(sizeof(UVfxParticleModuleFogBase) == 0x000038, "Wrong size on UVfxParticleModuleFogBase");

// Class EndGame.VfxParticleModuleVolumetricFogProbe
// 0x02A0 (0x02D8 - 0x0038)
class UVfxParticleModuleVolumetricFogProbe final : public UVfxParticleModuleFogBase
{
public:
	struct FRawDistributionVector                 m_LocationOffset;                                  // 0x0038(0x0060)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Color : 1;                               // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Density : 1;                             // 0x0098(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_PositionJitter : 1;                      // 0x0098(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DensityModifier : 1;                     // 0x0098(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  m_Visibility;                                      // 0x00A0(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_Radius;                                          // 0x00E0(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 m_Color;                                           // 0x0120(0x0060)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_Density;                                         // 0x0180(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_Tone;                                            // 0x01C0(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         m_PositionJitterStride;                            // 0x0200(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_204[0x4];                                      // 0x0204(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  m_PositionJitterAmplitude;                         // 0x0208(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         m_PositionJitterCycle;                             // 0x0248(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  m_PositionJitterTime;                              // 0x0250(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         m_bPositionJitterTimeRandom : 1;                   // 0x0290(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_291[0x3];                                      // 0x0291(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         m_DensityModifierStride;                           // 0x0294(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_DensityModifierIrregularity;                     // 0x0298(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VfxParticleModuleVolumetricFogProbe">();
	}
	static class UVfxParticleModuleVolumetricFogProbe* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVfxParticleModuleVolumetricFogProbe>();
	}
};
static_assert(alignof(UVfxParticleModuleVolumetricFogProbe) == 0x000008, "Wrong alignment on UVfxParticleModuleVolumetricFogProbe");
static_assert(sizeof(UVfxParticleModuleVolumetricFogProbe) == 0x0002D8, "Wrong size on UVfxParticleModuleVolumetricFogProbe");
static_assert(offsetof(UVfxParticleModuleVolumetricFogProbe, m_LocationOffset) == 0x000038, "Member 'UVfxParticleModuleVolumetricFogProbe::m_LocationOffset' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleVolumetricFogProbe, m_Visibility) == 0x0000A0, "Member 'UVfxParticleModuleVolumetricFogProbe::m_Visibility' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleVolumetricFogProbe, m_Radius) == 0x0000E0, "Member 'UVfxParticleModuleVolumetricFogProbe::m_Radius' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleVolumetricFogProbe, m_Color) == 0x000120, "Member 'UVfxParticleModuleVolumetricFogProbe::m_Color' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleVolumetricFogProbe, m_Density) == 0x000180, "Member 'UVfxParticleModuleVolumetricFogProbe::m_Density' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleVolumetricFogProbe, m_Tone) == 0x0001C0, "Member 'UVfxParticleModuleVolumetricFogProbe::m_Tone' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleVolumetricFogProbe, m_PositionJitterStride) == 0x000200, "Member 'UVfxParticleModuleVolumetricFogProbe::m_PositionJitterStride' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleVolumetricFogProbe, m_PositionJitterAmplitude) == 0x000208, "Member 'UVfxParticleModuleVolumetricFogProbe::m_PositionJitterAmplitude' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleVolumetricFogProbe, m_PositionJitterCycle) == 0x000248, "Member 'UVfxParticleModuleVolumetricFogProbe::m_PositionJitterCycle' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleVolumetricFogProbe, m_PositionJitterTime) == 0x000250, "Member 'UVfxParticleModuleVolumetricFogProbe::m_PositionJitterTime' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleVolumetricFogProbe, m_DensityModifierStride) == 0x000294, "Member 'UVfxParticleModuleVolumetricFogProbe::m_DensityModifierStride' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleVolumetricFogProbe, m_DensityModifierIrregularity) == 0x000298, "Member 'UVfxParticleModuleVolumetricFogProbe::m_DensityModifierIrregularity' has a wrong offset!");

// Class EndGame.EndDataObjectInitialParameter
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectInitialParameter final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectInitialParameter">();
	}
	static class UEndDataObjectInitialParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectInitialParameter>();
	}
};
static_assert(alignof(UEndDataObjectInitialParameter) == 0x000008, "Wrong alignment on UEndDataObjectInitialParameter");
static_assert(sizeof(UEndDataObjectInitialParameter) == 0x000088, "Wrong size on UEndDataObjectInitialParameter");

// Class EndGame.EndDataObjectInterestPointTable
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectInterestPointTable final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectInterestPointTable">();
	}
	static class UEndDataObjectInterestPointTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectInterestPointTable>();
	}
};
static_assert(alignof(UEndDataObjectInterestPointTable) == 0x000008, "Wrong alignment on UEndDataObjectInterestPointTable");
static_assert(sizeof(UEndDataObjectInterestPointTable) == 0x000088, "Wrong size on UEndDataObjectInterestPointTable");

// Class EndGame.EndDataObjectInventoryList
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectInventoryList final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectInventoryList">();
	}
	static class UEndDataObjectInventoryList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectInventoryList>();
	}
};
static_assert(alignof(UEndDataObjectInventoryList) == 0x000008, "Wrong alignment on UEndDataObjectInventoryList");
static_assert(sizeof(UEndDataObjectInventoryList) == 0x000088, "Wrong size on UEndDataObjectInventoryList");

// Class EndGame.EndDataObjectItem
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectItem final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectItem">();
	}
	static class UEndDataObjectItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectItem>();
	}
};
static_assert(alignof(UEndDataObjectItem) == 0x000008, "Wrong alignment on UEndDataObjectItem");
static_assert(sizeof(UEndDataObjectItem) == 0x000088, "Wrong size on UEndDataObjectItem");

// Class EndGame.EndDataObjectItemDropBox
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectItemDropBox final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectItemDropBox">();
	}
	static class UEndDataObjectItemDropBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectItemDropBox>();
	}
};
static_assert(alignof(UEndDataObjectItemDropBox) == 0x000008, "Wrong alignment on UEndDataObjectItemDropBox");
static_assert(sizeof(UEndDataObjectItemDropBox) == 0x000088, "Wrong size on UEndDataObjectItemDropBox");

// Class EndGame.EndFont
// 0x04C0 (0x04E8 - 0x0028)
class UEndFont final : public UObject
{
public:
	TArray<class UTexture2D*>                     Textures;                                          // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<uint16, struct FEndGlyphInfo>            GlyphTable;                                        // 0x0038(0x0050)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, uint16>                   IconTable;                                         // 0x0088(0x0050)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int32                                         Size;                                              // 0x00D8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutlineSize;                                       // 0x00DC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTexture2D*>                     AllTextures;                                       // 0x00E0(0x0010)(Edit, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x3F8];                                     // 0x00F0(0x03F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFont">();
	}
	static class UEndFont* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndFont>();
	}
};
static_assert(alignof(UEndFont) == 0x000008, "Wrong alignment on UEndFont");
static_assert(sizeof(UEndFont) == 0x0004E8, "Wrong size on UEndFont");
static_assert(offsetof(UEndFont, Textures) == 0x000028, "Member 'UEndFont::Textures' has a wrong offset!");
static_assert(offsetof(UEndFont, GlyphTable) == 0x000038, "Member 'UEndFont::GlyphTable' has a wrong offset!");
static_assert(offsetof(UEndFont, IconTable) == 0x000088, "Member 'UEndFont::IconTable' has a wrong offset!");
static_assert(offsetof(UEndFont, Size) == 0x0000D8, "Member 'UEndFont::Size' has a wrong offset!");
static_assert(offsetof(UEndFont, OutlineSize) == 0x0000DC, "Member 'UEndFont::OutlineSize' has a wrong offset!");
static_assert(offsetof(UEndFont, AllTextures) == 0x0000E0, "Member 'UEndFont::AllTextures' has a wrong offset!");

// Class EndGame.EndDataObjectJukeBox
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectJukeBox final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectJukeBox">();
	}
	static class UEndDataObjectJukeBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectJukeBox>();
	}
};
static_assert(alignof(UEndDataObjectJukeBox) == 0x000008, "Wrong alignment on UEndDataObjectJukeBox");
static_assert(sizeof(UEndDataObjectJukeBox) == 0x000088, "Wrong size on UEndDataObjectJukeBox");

// Class EndGame.EndDataObjectLearningSkill
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectLearningSkill final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectLearningSkill">();
	}
	static class UEndDataObjectLearningSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectLearningSkill>();
	}
};
static_assert(alignof(UEndDataObjectLearningSkill) == 0x000008, "Wrong alignment on UEndDataObjectLearningSkill");
static_assert(sizeof(UEndDataObjectLearningSkill) == 0x000088, "Wrong size on UEndDataObjectLearningSkill");

// Class EndGame.EndDataObjectLoadingTips
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectLoadingTips final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectLoadingTips">();
	}
	static class UEndDataObjectLoadingTips* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectLoadingTips>();
	}
};
static_assert(alignof(UEndDataObjectLoadingTips) == 0x000008, "Wrong alignment on UEndDataObjectLoadingTips");
static_assert(sizeof(UEndDataObjectLoadingTips) == 0x000088, "Wrong size on UEndDataObjectLoadingTips");

// Class EndGame.EndDataObjectLocation
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectLocation final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectLocation">();
	}
	static class UEndDataObjectLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectLocation>();
	}
};
static_assert(alignof(UEndDataObjectLocation) == 0x000008, "Wrong alignment on UEndDataObjectLocation");
static_assert(sizeof(UEndDataObjectLocation) == 0x000088, "Wrong size on UEndDataObjectLocation");

// Class EndGame.EndDataObjectLocationProgrammer
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectLocationProgrammer final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectLocationProgrammer">();
	}
	static class UEndDataObjectLocationProgrammer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectLocationProgrammer>();
	}
};
static_assert(alignof(UEndDataObjectLocationProgrammer) == 0x000008, "Wrong alignment on UEndDataObjectLocationProgrammer");
static_assert(sizeof(UEndDataObjectLocationProgrammer) == 0x000088, "Wrong size on UEndDataObjectLocationProgrammer");

// Class EndGame.EndDataObjectLocationResidentEnvironment
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectLocationResidentEnvironment final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectLocationResidentEnvironment">();
	}
	static class UEndDataObjectLocationResidentEnvironment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectLocationResidentEnvironment>();
	}
};
static_assert(alignof(UEndDataObjectLocationResidentEnvironment) == 0x000008, "Wrong alignment on UEndDataObjectLocationResidentEnvironment");
static_assert(sizeof(UEndDataObjectLocationResidentEnvironment) == 0x000088, "Wrong size on UEndDataObjectLocationResidentEnvironment");

// Class EndGame.EndMainMateriaListBoxWindow
// 0x00C0 (0x0420 - 0x0360)
class UEndMainMateriaListBoxWindow : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0xC0];                                     // 0x0360(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCommandMateriaCellSetup(class UWidget* ItemWidget, int32 ItemIndex);
	void OnMateriaCellPressed(int32 CellIndex);
	void OnMateriaCellSelectedIndexChanged(int32 CellIndex);
	void OnSetupItemForShop(class UWidget* ItemWidget, int32 ItemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainMateriaListBoxWindow">();
	}
	static class UEndMainMateriaListBoxWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainMateriaListBoxWindow>();
	}
};
static_assert(alignof(UEndMainMateriaListBoxWindow) == 0x000008, "Wrong alignment on UEndMainMateriaListBoxWindow");
static_assert(sizeof(UEndMainMateriaListBoxWindow) == 0x000420, "Wrong size on UEndMainMateriaListBoxWindow");

// Class EndGame.EndDataObjectLocationWork
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectLocationWork final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectLocationWork">();
	}
	static class UEndDataObjectLocationWork* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectLocationWork>();
	}
};
static_assert(alignof(UEndDataObjectLocationWork) == 0x000008, "Wrong alignment on UEndDataObjectLocationWork");
static_assert(sizeof(UEndDataObjectLocationWork) == 0x000088, "Wrong size on UEndDataObjectLocationWork");

// Class EndGame.EndDataObjectManual
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectManual final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectManual">();
	}
	static class UEndDataObjectManual* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectManual>();
	}
};
static_assert(alignof(UEndDataObjectManual) == 0x000008, "Wrong alignment on UEndDataObjectManual");
static_assert(sizeof(UEndDataObjectManual) == 0x000088, "Wrong size on UEndDataObjectManual");

// Class EndGame.EndDataObjectMateria
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectMateria final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectMateria">();
	}
	static class UEndDataObjectMateria* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectMateria>();
	}
};
static_assert(alignof(UEndDataObjectMateria) == 0x000008, "Wrong alignment on UEndDataObjectMateria");
static_assert(sizeof(UEndDataObjectMateria) == 0x000088, "Wrong size on UEndDataObjectMateria");

// Class EndGame.EndDataObjectMidgarMapLocationPoint
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectMidgarMapLocationPoint final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectMidgarMapLocationPoint">();
	}
	static class UEndDataObjectMidgarMapLocationPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectMidgarMapLocationPoint>();
	}
};
static_assert(alignof(UEndDataObjectMidgarMapLocationPoint) == 0x000008, "Wrong alignment on UEndDataObjectMidgarMapLocationPoint");
static_assert(sizeof(UEndDataObjectMidgarMapLocationPoint) == 0x000088, "Wrong size on UEndDataObjectMidgarMapLocationPoint");

// Class EndGame.EndDataObjectMiniGameAssetPacker
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectMiniGameAssetPacker final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectMiniGameAssetPacker">();
	}
	static class UEndDataObjectMiniGameAssetPacker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectMiniGameAssetPacker>();
	}
};
static_assert(alignof(UEndDataObjectMiniGameAssetPacker) == 0x000008, "Wrong alignment on UEndDataObjectMiniGameAssetPacker");
static_assert(sizeof(UEndDataObjectMiniGameAssetPacker) == 0x000088, "Wrong size on UEndDataObjectMiniGameAssetPacker");

// Class EndGame.EndDataObjectNaviBGMInfo
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectNaviBGMInfo final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectNaviBGMInfo">();
	}
	static class UEndDataObjectNaviBGMInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectNaviBGMInfo>();
	}
};
static_assert(alignof(UEndDataObjectNaviBGMInfo) == 0x000008, "Wrong alignment on UEndDataObjectNaviBGMInfo");
static_assert(sizeof(UEndDataObjectNaviBGMInfo) == 0x000088, "Wrong size on UEndDataObjectNaviBGMInfo");

// Class EndGame.EndMainTopMenu
// 0x01D0 (0x0600 - 0x0430)
class UEndMainTopMenu : public UEndMainMenuWindow
{
public:
	uint8                                         Pad_430[0x1C8];                                    // 0x0430(0x01C8)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndUserWidget*                         Throbber;                                          // 0x05F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnLeftMenuPressedItem(int32 ItemIndex);
	void OnLeftMenuSelectedIndexChanged(int32 ItemIndex);
	void OnLeftMenuSetupItem(class UWidget* ItemWidget, int32 ItemIndex);
	void OnPlaySlotAnimation(bool IsShow);
	bool SetupPartySlot(int32 SlotIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainTopMenu">();
	}
	static class UEndMainTopMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainTopMenu>();
	}
};
static_assert(alignof(UEndMainTopMenu) == 0x000008, "Wrong alignment on UEndMainTopMenu");
static_assert(sizeof(UEndMainTopMenu) == 0x000600, "Wrong size on UEndMainTopMenu");
static_assert(offsetof(UEndMainTopMenu, Throbber) == 0x0005F8, "Member 'UEndMainTopMenu::Throbber' has a wrong offset!");

// Class EndGame.EndDataObjectNaviMapInfo
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectNaviMapInfo final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectNaviMapInfo">();
	}
	static class UEndDataObjectNaviMapInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectNaviMapInfo>();
	}
};
static_assert(alignof(UEndDataObjectNaviMapInfo) == 0x000008, "Wrong alignment on UEndDataObjectNaviMapInfo");
static_assert(sizeof(UEndDataObjectNaviMapInfo) == 0x000088, "Wrong size on UEndDataObjectNaviMapInfo");

// Class EndGame.EndDataObjectObject
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectObject final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectObject">();
	}
	static class UEndDataObjectObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectObject>();
	}
};
static_assert(alignof(UEndDataObjectObject) == 0x000008, "Wrong alignment on UEndDataObjectObject");
static_assert(sizeof(UEndDataObjectObject) == 0x000088, "Wrong size on UEndDataObjectObject");

// Class EndGame.EndDataObjectObjectBattleScene
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectObjectBattleScene final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectObjectBattleScene">();
	}
	static class UEndDataObjectObjectBattleScene* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectObjectBattleScene>();
	}
};
static_assert(alignof(UEndDataObjectObjectBattleScene) == 0x000008, "Wrong alignment on UEndDataObjectObjectBattleScene");
static_assert(sizeof(UEndDataObjectObjectBattleScene) == 0x000088, "Wrong size on UEndDataObjectObjectBattleScene");

// Class EndGame.EndDataObjectObjectEnemy
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectObjectEnemy final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectObjectEnemy">();
	}
	static class UEndDataObjectObjectEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectObjectEnemy>();
	}
};
static_assert(alignof(UEndDataObjectObjectEnemy) == 0x000008, "Wrong alignment on UEndDataObjectObjectEnemy");
static_assert(sizeof(UEndDataObjectObjectEnemy) == 0x000088, "Wrong size on UEndDataObjectObjectEnemy");

// Class EndGame.EndDataObjectObjectEnvironmentSet
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectObjectEnvironmentSet final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectObjectEnvironmentSet">();
	}
	static class UEndDataObjectObjectEnvironmentSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectObjectEnvironmentSet>();
	}
};
static_assert(alignof(UEndDataObjectObjectEnvironmentSet) == 0x000008, "Wrong alignment on UEndDataObjectObjectEnvironmentSet");
static_assert(sizeof(UEndDataObjectObjectEnvironmentSet) == 0x000088, "Wrong size on UEndDataObjectObjectEnvironmentSet");

// Class EndGame.EndDataObjectObjectParty
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectObjectParty final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectObjectParty">();
	}
	static class UEndDataObjectObjectParty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectObjectParty>();
	}
};
static_assert(alignof(UEndDataObjectObjectParty) == 0x000008, "Wrong alignment on UEndDataObjectObjectParty");
static_assert(sizeof(UEndDataObjectObjectParty) == 0x000088, "Wrong size on UEndDataObjectObjectParty");

// Class EndGame.EndNavBattleQueryFilter
// 0x0000 (0x0048 - 0x0048)
class UEndNavBattleQueryFilter final : public UEndNavQueryFilterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavBattleQueryFilter">();
	}
	static class UEndNavBattleQueryFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavBattleQueryFilter>();
	}
};
static_assert(alignof(UEndNavBattleQueryFilter) == 0x000008, "Wrong alignment on UEndNavBattleQueryFilter");
static_assert(sizeof(UEndNavBattleQueryFilter) == 0x000048, "Wrong size on UEndNavBattleQueryFilter");

// Class EndGame.EndDataObjectObjectPlannerLevelSet
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectObjectPlannerLevelSet final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectObjectPlannerLevelSet">();
	}
	static class UEndDataObjectObjectPlannerLevelSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectObjectPlannerLevelSet>();
	}
};
static_assert(alignof(UEndDataObjectObjectPlannerLevelSet) == 0x000008, "Wrong alignment on UEndDataObjectObjectPlannerLevelSet");
static_assert(sizeof(UEndDataObjectObjectPlannerLevelSet) == 0x000088, "Wrong size on UEndDataObjectObjectPlannerLevelSet");

// Class EndGame.EndDataObjectObjectTreasure
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectObjectTreasure final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectObjectTreasure">();
	}
	static class UEndDataObjectObjectTreasure* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectObjectTreasure>();
	}
};
static_assert(alignof(UEndDataObjectObjectTreasure) == 0x000008, "Wrong alignment on UEndDataObjectObjectTreasure");
static_assert(sizeof(UEndDataObjectObjectTreasure) == 0x000088, "Wrong size on UEndDataObjectObjectTreasure");

// Class EndGame.EndDataObjectPartyEntry
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectPartyEntry final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectPartyEntry">();
	}
	static class UEndDataObjectPartyEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectPartyEntry>();
	}
};
static_assert(alignof(UEndDataObjectPartyEntry) == 0x000008, "Wrong alignment on UEndDataObjectPartyEntry");
static_assert(sizeof(UEndDataObjectPartyEntry) == 0x000088, "Wrong size on UEndDataObjectPartyEntry");

// Class EndGame.EndDataObjectPlacement
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectPlacement final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectPlacement">();
	}
	static class UEndDataObjectPlacement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectPlacement>();
	}
};
static_assert(alignof(UEndDataObjectPlacement) == 0x000008, "Wrong alignment on UEndDataObjectPlacement");
static_assert(sizeof(UEndDataObjectPlacement) == 0x000088, "Wrong size on UEndDataObjectPlacement");

// Class EndGame.EndDataObjectPlannerEvent
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectPlannerEvent final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectPlannerEvent">();
	}
	static class UEndDataObjectPlannerEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectPlannerEvent>();
	}
};
static_assert(alignof(UEndDataObjectPlannerEvent) == 0x000008, "Wrong alignment on UEndDataObjectPlannerEvent");
static_assert(sizeof(UEndDataObjectPlannerEvent) == 0x000088, "Wrong size on UEndDataObjectPlannerEvent");

// Class EndGame.EndDataObjectPlannerEventMemberExclusion
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectPlannerEventMemberExclusion final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectPlannerEventMemberExclusion">();
	}
	static class UEndDataObjectPlannerEventMemberExclusion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectPlannerEventMemberExclusion>();
	}
};
static_assert(alignof(UEndDataObjectPlannerEventMemberExclusion) == 0x000008, "Wrong alignment on UEndDataObjectPlannerEventMemberExclusion");
static_assert(sizeof(UEndDataObjectPlannerEventMemberExclusion) == 0x000088, "Wrong size on UEndDataObjectPlannerEventMemberExclusion");

// Class EndGame.EndNavFlatlandsOnlyQueryFilter
// 0x0000 (0x0048 - 0x0048)
class UEndNavFlatlandsOnlyQueryFilter final : public UEndNavQueryFilterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavFlatlandsOnlyQueryFilter">();
	}
	static class UEndNavFlatlandsOnlyQueryFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavFlatlandsOnlyQueryFilter>();
	}
};
static_assert(alignof(UEndNavFlatlandsOnlyQueryFilter) == 0x000008, "Wrong alignment on UEndNavFlatlandsOnlyQueryFilter");
static_assert(sizeof(UEndNavFlatlandsOnlyQueryFilter) == 0x000048, "Wrong size on UEndNavFlatlandsOnlyQueryFilter");

// Class EndGame.EndDataObjectPlannerEventRelativeCamera
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectPlannerEventRelativeCamera final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectPlannerEventRelativeCamera">();
	}
	static class UEndDataObjectPlannerEventRelativeCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectPlannerEventRelativeCamera>();
	}
};
static_assert(alignof(UEndDataObjectPlannerEventRelativeCamera) == 0x000008, "Wrong alignment on UEndDataObjectPlannerEventRelativeCamera");
static_assert(sizeof(UEndDataObjectPlannerEventRelativeCamera) == 0x000088, "Wrong size on UEndDataObjectPlannerEventRelativeCamera");

// Class EndGame.EndDataObjectPlannerEventRequirePacks
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectPlannerEventRequirePacks final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectPlannerEventRequirePacks">();
	}
	static class UEndDataObjectPlannerEventRequirePacks* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectPlannerEventRequirePacks>();
	}
};
static_assert(alignof(UEndDataObjectPlannerEventRequirePacks) == 0x000008, "Wrong alignment on UEndDataObjectPlannerEventRequirePacks");
static_assert(sizeof(UEndDataObjectPlannerEventRequirePacks) == 0x000088, "Wrong size on UEndDataObjectPlannerEventRequirePacks");

// Class EndGame.EndDataObjectPlannerLevelSet
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectPlannerLevelSet final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectPlannerLevelSet">();
	}
	static class UEndDataObjectPlannerLevelSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectPlannerLevelSet>();
	}
};
static_assert(alignof(UEndDataObjectPlannerLevelSet) == 0x000008, "Wrong alignment on UEndDataObjectPlannerLevelSet");
static_assert(sizeof(UEndDataObjectPlannerLevelSet) == 0x000088, "Wrong size on UEndDataObjectPlannerLevelSet");

// Class EndGame.EndDataObjectPlayerEstimateParameter
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectPlayerEstimateParameter final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectPlayerEstimateParameter">();
	}
	static class UEndDataObjectPlayerEstimateParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectPlayerEstimateParameter>();
	}
};
static_assert(alignof(UEndDataObjectPlayerEstimateParameter) == 0x000008, "Wrong alignment on UEndDataObjectPlayerEstimateParameter");
static_assert(sizeof(UEndDataObjectPlayerEstimateParameter) == 0x000088, "Wrong size on UEndDataObjectPlayerEstimateParameter");

// Class EndGame.EndDataObjectPointSound
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectPointSound final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectPointSound">();
	}
	static class UEndDataObjectPointSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectPointSound>();
	}
};
static_assert(alignof(UEndDataObjectPointSound) == 0x000008, "Wrong alignment on UEndDataObjectPointSound");
static_assert(sizeof(UEndDataObjectPointSound) == 0x000088, "Wrong size on UEndDataObjectPointSound");

// Class EndGame.EndFieldActionActorHookShot
// 0x0010 (0x0388 - 0x0378)
class AEndFieldActionActorHookShot final : public AActor
{
public:
	EHookShotSeType                               HitSeType;                                         // 0x0378(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_379[0x7];                                      // 0x0379(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndTextRenderComponent*                TextRenderComponent;                               // 0x0380(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorHookShot">();
	}
	static class AEndFieldActionActorHookShot* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorHookShot>();
	}
};
static_assert(alignof(AEndFieldActionActorHookShot) == 0x000008, "Wrong alignment on AEndFieldActionActorHookShot");
static_assert(sizeof(AEndFieldActionActorHookShot) == 0x000388, "Wrong size on AEndFieldActionActorHookShot");
static_assert(offsetof(AEndFieldActionActorHookShot, HitSeType) == 0x000378, "Member 'AEndFieldActionActorHookShot::HitSeType' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorHookShot, TextRenderComponent) == 0x000380, "Member 'AEndFieldActionActorHookShot::TextRenderComponent' has a wrong offset!");

// Class EndGame.EndMenuSound
// 0x0010 (0x00B8 - 0x00A8)
class UEndMenuSound final : public USoundBase
{
public:
	class USQEXSEADSound*                         SoundAsset;                                        // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SoundName;                                         // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMenuSound">();
	}
	static class UEndMenuSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMenuSound>();
	}
};
static_assert(alignof(UEndMenuSound) == 0x000008, "Wrong alignment on UEndMenuSound");
static_assert(sizeof(UEndMenuSound) == 0x0000B8, "Wrong size on UEndMenuSound");
static_assert(offsetof(UEndMenuSound, SoundAsset) == 0x0000A8, "Member 'UEndMenuSound::SoundAsset' has a wrong offset!");
static_assert(offsetof(UEndMenuSound, SoundName) == 0x0000B0, "Member 'UEndMenuSound::SoundName' has a wrong offset!");

// Class EndGame.EndDataObjectPushButtonAction
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectPushButtonAction final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectPushButtonAction">();
	}
	static class UEndDataObjectPushButtonAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectPushButtonAction>();
	}
};
static_assert(alignof(UEndDataObjectPushButtonAction) == 0x000008, "Wrong alignment on UEndDataObjectPushButtonAction");
static_assert(sizeof(UEndDataObjectPushButtonAction) == 0x000088, "Wrong size on UEndDataObjectPushButtonAction");

// Class EndGame.EndDataObjectResidentWork
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectResidentWork final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectResidentWork">();
	}
	static class UEndDataObjectResidentWork* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectResidentWork>();
	}
};
static_assert(alignof(UEndDataObjectResidentWork) == 0x000008, "Wrong alignment on UEndDataObjectResidentWork");
static_assert(sizeof(UEndDataObjectResidentWork) == 0x000088, "Wrong size on UEndDataObjectResidentWork");

// Class EndGame.EndDataObjectResponseArea
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectResponseArea final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectResponseArea">();
	}
	static class UEndDataObjectResponseArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectResponseArea>();
	}
};
static_assert(alignof(UEndDataObjectResponseArea) == 0x000008, "Wrong alignment on UEndDataObjectResponseArea");
static_assert(sizeof(UEndDataObjectResponseArea) == 0x000088, "Wrong size on UEndDataObjectResponseArea");

// Class EndGame.EndDataObjectRewardRandom
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectRewardRandom final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectRewardRandom">();
	}
	static class UEndDataObjectRewardRandom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectRewardRandom>();
	}
};
static_assert(alignof(UEndDataObjectRewardRandom) == 0x000008, "Wrong alignment on UEndDataObjectRewardRandom");
static_assert(sizeof(UEndDataObjectRewardRandom) == 0x000088, "Wrong size on UEndDataObjectRewardRandom");

// Class EndGame.EndFieldActionActorMonkeyBars
// 0x0128 (0x0740 - 0x0618)
class AEndFieldActionActorMonkeyBars final : public AEndFieldActionActorBase
{
public:
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0618(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<uint16, struct FMonkeyBarPoint>          MonkeyBarPointList;                                // 0x0620(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   MonkeyBarsCollisionName;                           // 0x0670(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMonkeyBarLinkPoint>            GoalPointList;                                     // 0x0678(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          bRefreshParam;                                     // 0x0688(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRefreshGoal;                                      // 0x0689(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLimitCameraPitch;                                 // 0x068A(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68B[0x1];                                      // 0x068B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LimitCameraPitchCustomFlavorName;                  // 0x068C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_694[0xAC];                                     // 0x0694(0x00AC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorMonkeyBars">();
	}
	static class AEndFieldActionActorMonkeyBars* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorMonkeyBars>();
	}
};
static_assert(alignof(AEndFieldActionActorMonkeyBars) == 0x000008, "Wrong alignment on AEndFieldActionActorMonkeyBars");
static_assert(sizeof(AEndFieldActionActorMonkeyBars) == 0x000740, "Wrong size on AEndFieldActionActorMonkeyBars");
static_assert(offsetof(AEndFieldActionActorMonkeyBars, ModifierVolume) == 0x000618, "Member 'AEndFieldActionActorMonkeyBars::ModifierVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorMonkeyBars, MonkeyBarPointList) == 0x000620, "Member 'AEndFieldActionActorMonkeyBars::MonkeyBarPointList' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorMonkeyBars, MonkeyBarsCollisionName) == 0x000670, "Member 'AEndFieldActionActorMonkeyBars::MonkeyBarsCollisionName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorMonkeyBars, GoalPointList) == 0x000678, "Member 'AEndFieldActionActorMonkeyBars::GoalPointList' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorMonkeyBars, bRefreshParam) == 0x000688, "Member 'AEndFieldActionActorMonkeyBars::bRefreshParam' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorMonkeyBars, bRefreshGoal) == 0x000689, "Member 'AEndFieldActionActorMonkeyBars::bRefreshGoal' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorMonkeyBars, bLimitCameraPitch) == 0x00068A, "Member 'AEndFieldActionActorMonkeyBars::bLimitCameraPitch' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorMonkeyBars, LimitCameraPitchCustomFlavorName) == 0x00068C, "Member 'AEndFieldActionActorMonkeyBars::LimitCameraPitchCustomFlavorName' has a wrong offset!");

// Class EndGame.EndMessageLogs
// 0x0098 (0x0190 - 0x00F8)
class UEndMessageLogs final : public UWidget
{
public:
	struct FVector2D                              Size;                                              // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                ContentClass;                                      // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                SlotPadding;                                       // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ScrollTime;                                        // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitTime;                                          // 0x011C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GradientSize;                                      // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(class UUserWidget* MessageWidget, int32 Type, const class FString& Message)> OnSetupContent;                                    // 0x0128(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0x58];                                     // 0x0138(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddMessage(const class FString& Message);
	void ClearMessages();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMessageLogs">();
	}
	static class UEndMessageLogs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMessageLogs>();
	}
};
static_assert(alignof(UEndMessageLogs) == 0x000008, "Wrong alignment on UEndMessageLogs");
static_assert(sizeof(UEndMessageLogs) == 0x000190, "Wrong size on UEndMessageLogs");
static_assert(offsetof(UEndMessageLogs, Size) == 0x0000F8, "Member 'UEndMessageLogs::Size' has a wrong offset!");
static_assert(offsetof(UEndMessageLogs, ContentClass) == 0x000100, "Member 'UEndMessageLogs::ContentClass' has a wrong offset!");
static_assert(offsetof(UEndMessageLogs, SlotPadding) == 0x000108, "Member 'UEndMessageLogs::SlotPadding' has a wrong offset!");
static_assert(offsetof(UEndMessageLogs, ScrollTime) == 0x000118, "Member 'UEndMessageLogs::ScrollTime' has a wrong offset!");
static_assert(offsetof(UEndMessageLogs, WaitTime) == 0x00011C, "Member 'UEndMessageLogs::WaitTime' has a wrong offset!");
static_assert(offsetof(UEndMessageLogs, GradientSize) == 0x000120, "Member 'UEndMessageLogs::GradientSize' has a wrong offset!");
static_assert(offsetof(UEndMessageLogs, OnSetupContent) == 0x000128, "Member 'UEndMessageLogs::OnSetupContent' has a wrong offset!");

// Class EndGame.EndDataObjectSceneChanger
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectSceneChanger final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectSceneChanger">();
	}
	static class UEndDataObjectSceneChanger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectSceneChanger>();
	}
};
static_assert(alignof(UEndDataObjectSceneChanger) == 0x000008, "Wrong alignment on UEndDataObjectSceneChanger");
static_assert(sizeof(UEndDataObjectSceneChanger) == 0x000088, "Wrong size on UEndDataObjectSceneChanger");

// Class EndGame.EndDataObjectShopList
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectShopList final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectShopList">();
	}
	static class UEndDataObjectShopList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectShopList>();
	}
};
static_assert(alignof(UEndDataObjectShopList) == 0x000008, "Wrong alignment on UEndDataObjectShopList");
static_assert(sizeof(UEndDataObjectShopList) == 0x000088, "Wrong size on UEndDataObjectShopList");

// Class EndGame.EndDataObjectSituationAction
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectSituationAction final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectSituationAction">();
	}
	static class UEndDataObjectSituationAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectSituationAction>();
	}
};
static_assert(alignof(UEndDataObjectSituationAction) == 0x000008, "Wrong alignment on UEndDataObjectSituationAction");
static_assert(sizeof(UEndDataObjectSituationAction) == 0x000088, "Wrong size on UEndDataObjectSituationAction");

// Class EndGame.EndDataObjectSituationTrigger
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectSituationTrigger final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectSituationTrigger">();
	}
	static class UEndDataObjectSituationTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectSituationTrigger>();
	}
};
static_assert(alignof(UEndDataObjectSituationTrigger) == 0x000008, "Wrong alignment on UEndDataObjectSituationTrigger");
static_assert(sizeof(UEndDataObjectSituationTrigger) == 0x000088, "Wrong size on UEndDataObjectSituationTrigger");

// Class EndGame.EndDataObjectStateChange
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectStateChange final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectStateChange">();
	}
	static class UEndDataObjectStateChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectStateChange>();
	}
};
static_assert(alignof(UEndDataObjectStateChange) == 0x000008, "Wrong alignment on UEndDataObjectStateChange");
static_assert(sizeof(UEndDataObjectStateChange) == 0x000088, "Wrong size on UEndDataObjectStateChange");

// Class EndGame.EndDataObjectStateCondition
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectStateCondition final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectStateCondition">();
	}
	static class UEndDataObjectStateCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectStateCondition>();
	}
};
static_assert(alignof(UEndDataObjectStateCondition) == 0x000008, "Wrong alignment on UEndDataObjectStateCondition");
static_assert(sizeof(UEndDataObjectStateCondition) == 0x000088, "Wrong size on UEndDataObjectStateCondition");

// Class EndGame.EndDataObjectStateTrigger
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectStateTrigger final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectStateTrigger">();
	}
	static class UEndDataObjectStateTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectStateTrigger>();
	}
};
static_assert(alignof(UEndDataObjectStateTrigger) == 0x000008, "Wrong alignment on UEndDataObjectStateTrigger");
static_assert(sizeof(UEndDataObjectStateTrigger) == 0x000088, "Wrong size on UEndDataObjectStateTrigger");

// Class EndGame.EndDataObjectStoryFlag
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectStoryFlag final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectStoryFlag">();
	}
	static class UEndDataObjectStoryFlag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectStoryFlag>();
	}
};
static_assert(alignof(UEndDataObjectStoryFlag) == 0x000008, "Wrong alignment on UEndDataObjectStoryFlag");
static_assert(sizeof(UEndDataObjectStoryFlag) == 0x000088, "Wrong size on UEndDataObjectStoryFlag");

// Class EndGame.EndDataObjectStoryJump
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectStoryJump final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectStoryJump">();
	}
	static class UEndDataObjectStoryJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectStoryJump>();
	}
};
static_assert(alignof(UEndDataObjectStoryJump) == 0x000008, "Wrong alignment on UEndDataObjectStoryJump");
static_assert(sizeof(UEndDataObjectStoryJump) == 0x000088, "Wrong size on UEndDataObjectStoryJump");

// Class EndGame.EndDataObjectStoryProgress
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectStoryProgress final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectStoryProgress">();
	}
	static class UEndDataObjectStoryProgress* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectStoryProgress>();
	}
};
static_assert(alignof(UEndDataObjectStoryProgress) == 0x000008, "Wrong alignment on UEndDataObjectStoryProgress");
static_assert(sizeof(UEndDataObjectStoryProgress) == 0x000088, "Wrong size on UEndDataObjectStoryProgress");

// Class EndGame.EndDataObjectSubStory
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectSubStory final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectSubStory">();
	}
	static class UEndDataObjectSubStory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectSubStory>();
	}
};
static_assert(alignof(UEndDataObjectSubStory) == 0x000008, "Wrong alignment on UEndDataObjectSubStory");
static_assert(sizeof(UEndDataObjectSubStory) == 0x000088, "Wrong size on UEndDataObjectSubStory");

// Class EndGame.EndMainItemMenu
// 0x0100 (0x0530 - 0x0430)
class UEndMainItemMenu : public UEndMainMenuWindow
{
public:
	uint8                                         Pad_430[0xB0];                                     // 0x0430(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSoftObjectPath>                _CategoryImagePaths;                               // 0x04E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class UEndUserWidget*                         LeftMenu;                                          // 0x04F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndUserWidget*                         ItemList;                                          // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndUserWidget*                         SelectMemberList;                                  // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndCanvasPanel*                        Detail;                                            // 0x0508(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndUserWidget*                         EquipCell_Top;                                     // 0x0510(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndBillboard*                          Billboard_Item;                                    // 0x0518(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndBillboard*                          Billboard_Materia;                                 // 0x0520(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndImage*                              LightBg00;                                         // 0x0528(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnItemMenuIndexChanged(int32 CellIndex);
	struct FVector2D OnItemMenuMeasureItem(int32 CellIndex);
	void OnItemMenuPressedItem(int32 CellIndex);
	void OnItemMenuSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnLeftMenuIndexChanged(int32 CellIndex);
	void OnLeftMenuPressedItem(int32 CellIndex);
	void OnLeftMenuSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnMemberMenuPressedItem(int32 CellIndex);
	void OnMemberMenuSetupItem(class UWidget* ItemWidget, int32 CellIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainItemMenu">();
	}
	static class UEndMainItemMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainItemMenu>();
	}
};
static_assert(alignof(UEndMainItemMenu) == 0x000008, "Wrong alignment on UEndMainItemMenu");
static_assert(sizeof(UEndMainItemMenu) == 0x000530, "Wrong size on UEndMainItemMenu");
static_assert(offsetof(UEndMainItemMenu, _CategoryImagePaths) == 0x0004E0, "Member 'UEndMainItemMenu::_CategoryImagePaths' has a wrong offset!");
static_assert(offsetof(UEndMainItemMenu, LeftMenu) == 0x0004F0, "Member 'UEndMainItemMenu::LeftMenu' has a wrong offset!");
static_assert(offsetof(UEndMainItemMenu, ItemList) == 0x0004F8, "Member 'UEndMainItemMenu::ItemList' has a wrong offset!");
static_assert(offsetof(UEndMainItemMenu, SelectMemberList) == 0x000500, "Member 'UEndMainItemMenu::SelectMemberList' has a wrong offset!");
static_assert(offsetof(UEndMainItemMenu, Detail) == 0x000508, "Member 'UEndMainItemMenu::Detail' has a wrong offset!");
static_assert(offsetof(UEndMainItemMenu, EquipCell_Top) == 0x000510, "Member 'UEndMainItemMenu::EquipCell_Top' has a wrong offset!");
static_assert(offsetof(UEndMainItemMenu, Billboard_Item) == 0x000518, "Member 'UEndMainItemMenu::Billboard_Item' has a wrong offset!");
static_assert(offsetof(UEndMainItemMenu, Billboard_Materia) == 0x000520, "Member 'UEndMainItemMenu::Billboard_Materia' has a wrong offset!");
static_assert(offsetof(UEndMainItemMenu, LightBg00) == 0x000528, "Member 'UEndMainItemMenu::LightBg00' has a wrong offset!");

// Class EndGame.EndDataObjectSubStoryCondition
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectSubStoryCondition final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectSubStoryCondition">();
	}
	static class UEndDataObjectSubStoryCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectSubStoryCondition>();
	}
};
static_assert(alignof(UEndDataObjectSubStoryCondition) == 0x000008, "Wrong alignment on UEndDataObjectSubStoryCondition");
static_assert(sizeof(UEndDataObjectSubStoryCondition) == 0x000088, "Wrong size on UEndDataObjectSubStoryCondition");

// Class EndGame.EndDataObjectSubtitleChange
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectSubtitleChange final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectSubtitleChange">();
	}
	static class UEndDataObjectSubtitleChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectSubtitleChange>();
	}
};
static_assert(alignof(UEndDataObjectSubtitleChange) == 0x000008, "Wrong alignment on UEndDataObjectSubtitleChange");
static_assert(sizeof(UEndDataObjectSubtitleChange) == 0x000088, "Wrong size on UEndDataObjectSubtitleChange");

// Class EndGame.EndDataObjectTalkCanPlayCharacterStatus
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectTalkCanPlayCharacterStatus final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectTalkCanPlayCharacterStatus">();
	}
	static class UEndDataObjectTalkCanPlayCharacterStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectTalkCanPlayCharacterStatus>();
	}
};
static_assert(alignof(UEndDataObjectTalkCanPlayCharacterStatus) == 0x000008, "Wrong alignment on UEndDataObjectTalkCanPlayCharacterStatus");
static_assert(sizeof(UEndDataObjectTalkCanPlayCharacterStatus) == 0x000088, "Wrong size on UEndDataObjectTalkCanPlayCharacterStatus");

// Class EndGame.EndDataObjectTalkChange
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectTalkChange final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectTalkChange">();
	}
	static class UEndDataObjectTalkChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectTalkChange>();
	}
};
static_assert(alignof(UEndDataObjectTalkChange) == 0x000008, "Wrong alignment on UEndDataObjectTalkChange");
static_assert(sizeof(UEndDataObjectTalkChange) == 0x000088, "Wrong size on UEndDataObjectTalkChange");

// Class EndGame.EndDataObjectTalkGroup
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectTalkGroup final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectTalkGroup">();
	}
	static class UEndDataObjectTalkGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectTalkGroup>();
	}
};
static_assert(alignof(UEndDataObjectTalkGroup) == 0x000008, "Wrong alignment on UEndDataObjectTalkGroup");
static_assert(sizeof(UEndDataObjectTalkGroup) == 0x000088, "Wrong size on UEndDataObjectTalkGroup");

// Class EndGame.EndDataObjectTalkOnEndBattleVoiceSet
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectTalkOnEndBattleVoiceSet final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectTalkOnEndBattleVoiceSet">();
	}
	static class UEndDataObjectTalkOnEndBattleVoiceSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectTalkOnEndBattleVoiceSet>();
	}
};
static_assert(alignof(UEndDataObjectTalkOnEndBattleVoiceSet) == 0x000008, "Wrong alignment on UEndDataObjectTalkOnEndBattleVoiceSet");
static_assert(sizeof(UEndDataObjectTalkOnEndBattleVoiceSet) == 0x000088, "Wrong size on UEndDataObjectTalkOnEndBattleVoiceSet");

// Class EndGame.EndNavAreaMountain
// 0x0000 (0x0040 - 0x0040)
class UEndNavAreaMountain final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavAreaMountain">();
	}
	static class UEndNavAreaMountain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavAreaMountain>();
	}
};
static_assert(alignof(UEndNavAreaMountain) == 0x000008, "Wrong alignment on UEndNavAreaMountain");
static_assert(sizeof(UEndNavAreaMountain) == 0x000040, "Wrong size on UEndNavAreaMountain");

// Class EndGame.EndDataObjectTalkPlayTrigger
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectTalkPlayTrigger final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectTalkPlayTrigger">();
	}
	static class UEndDataObjectTalkPlayTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectTalkPlayTrigger>();
	}
};
static_assert(alignof(UEndDataObjectTalkPlayTrigger) == 0x000008, "Wrong alignment on UEndDataObjectTalkPlayTrigger");
static_assert(sizeof(UEndDataObjectTalkPlayTrigger) == 0x000088, "Wrong size on UEndDataObjectTalkPlayTrigger");

// Class EndGame.EndDataObjectTalkSequence
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectTalkSequence final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectTalkSequence">();
	}
	static class UEndDataObjectTalkSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectTalkSequence>();
	}
};
static_assert(alignof(UEndDataObjectTalkSequence) == 0x000008, "Wrong alignment on UEndDataObjectTalkSequence");
static_assert(sizeof(UEndDataObjectTalkSequence) == 0x000088, "Wrong size on UEndDataObjectTalkSequence");

// Class EndGame.EndDataObjectTalkState
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectTalkState final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectTalkState">();
	}
	static class UEndDataObjectTalkState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectTalkState>();
	}
};
static_assert(alignof(UEndDataObjectTalkState) == 0x000008, "Wrong alignment on UEndDataObjectTalkState");
static_assert(sizeof(UEndDataObjectTalkState) == 0x000088, "Wrong size on UEndDataObjectTalkState");

// Class EndGame.EndDataObjectTalkStateTrigger
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectTalkStateTrigger final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectTalkStateTrigger">();
	}
	static class UEndDataObjectTalkStateTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectTalkStateTrigger>();
	}
};
static_assert(alignof(UEndDataObjectTalkStateTrigger) == 0x000008, "Wrong alignment on UEndDataObjectTalkStateTrigger");
static_assert(sizeof(UEndDataObjectTalkStateTrigger) == 0x000088, "Wrong size on UEndDataObjectTalkStateTrigger");

// Class EndGame.EndDataObjectTargetPointList
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectTargetPointList final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectTargetPointList">();
	}
	static class UEndDataObjectTargetPointList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectTargetPointList>();
	}
};
static_assert(alignof(UEndDataObjectTargetPointList) == 0x000008, "Wrong alignment on UEndDataObjectTargetPointList");
static_assert(sizeof(UEndDataObjectTargetPointList) == 0x000088, "Wrong size on UEndDataObjectTargetPointList");

// Class EndGame.EndDataObjectTextGroup
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectTextGroup final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectTextGroup">();
	}
	static class UEndDataObjectTextGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectTextGroup>();
	}
};
static_assert(alignof(UEndDataObjectTextGroup) == 0x000008, "Wrong alignment on UEndDataObjectTextGroup");
static_assert(sizeof(UEndDataObjectTextGroup) == 0x000088, "Wrong size on UEndDataObjectTextGroup");

// Class EndGame.EndNavAreaPathWay
// 0x0000 (0x0040 - 0x0040)
class UEndNavAreaPathWay final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavAreaPathWay">();
	}
	static class UEndNavAreaPathWay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavAreaPathWay>();
	}
};
static_assert(alignof(UEndNavAreaPathWay) == 0x000008, "Wrong alignment on UEndNavAreaPathWay");
static_assert(sizeof(UEndNavAreaPathWay) == 0x000040, "Wrong size on UEndNavAreaPathWay");

// Class EndGame.EndDataObjectTreasureSpec
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectTreasureSpec final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectTreasureSpec">();
	}
	static class UEndDataObjectTreasureSpec* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectTreasureSpec>();
	}
};
static_assert(alignof(UEndDataObjectTreasureSpec) == 0x000008, "Wrong alignment on UEndDataObjectTreasureSpec");
static_assert(sizeof(UEndDataObjectTreasureSpec) == 0x000088, "Wrong size on UEndDataObjectTreasureSpec");

// Class EndGame.EndDataObjectTriggerEffect
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectTriggerEffect final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectTriggerEffect">();
	}
	static class UEndDataObjectTriggerEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectTriggerEffect>();
	}
};
static_assert(alignof(UEndDataObjectTriggerEffect) == 0x000008, "Wrong alignment on UEndDataObjectTriggerEffect");
static_assert(sizeof(UEndDataObjectTriggerEffect) == 0x000088, "Wrong size on UEndDataObjectTriggerEffect");

// Class EndGame.EndDataObjectTutorial
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectTutorial final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectTutorial">();
	}
	static class UEndDataObjectTutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectTutorial>();
	}
};
static_assert(alignof(UEndDataObjectTutorial) == 0x000008, "Wrong alignment on UEndDataObjectTutorial");
static_assert(sizeof(UEndDataObjectTutorial) == 0x000088, "Wrong size on UEndDataObjectTutorial");

// Class EndGame.EndDataObjectUniqueAction
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectUniqueAction final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectUniqueAction">();
	}
	static class UEndDataObjectUniqueAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectUniqueAction>();
	}
};
static_assert(alignof(UEndDataObjectUniqueAction) == 0x000008, "Wrong alignment on UEndDataObjectUniqueAction");
static_assert(sizeof(UEndDataObjectUniqueAction) == 0x000088, "Wrong size on UEndDataObjectUniqueAction");

// Class EndGame.EndDataObjectUniqueActionProperty
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectUniqueActionProperty final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectUniqueActionProperty">();
	}
	static class UEndDataObjectUniqueActionProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectUniqueActionProperty>();
	}
};
static_assert(alignof(UEndDataObjectUniqueActionProperty) == 0x000008, "Wrong alignment on UEndDataObjectUniqueActionProperty");
static_assert(sizeof(UEndDataObjectUniqueActionProperty) == 0x000088, "Wrong size on UEndDataObjectUniqueActionProperty");

// Class EndGame.EndDataObjectUniqueActionRCSMove
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectUniqueActionRCSMove final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectUniqueActionRCSMove">();
	}
	static class UEndDataObjectUniqueActionRCSMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectUniqueActionRCSMove>();
	}
};
static_assert(alignof(UEndDataObjectUniqueActionRCSMove) == 0x000008, "Wrong alignment on UEndDataObjectUniqueActionRCSMove");
static_assert(sizeof(UEndDataObjectUniqueActionRCSMove) == 0x000088, "Wrong size on UEndDataObjectUniqueActionRCSMove");

// Class EndGame.EndFieldActionActorCardKeyDoor
// 0x00F8 (0x0710 - 0x0618)
class AEndFieldActionActorCardKeyDoor final : public AEndFieldActionActorBase
{
public:
	class FName                                   AnimationActorName;                                // 0x0618(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TerminalFirstName;                                 // 0x0620(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TerminalSecondName;                                // 0x0628(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TerminalLevelName;                                 // 0x0630(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TerminalSecondLevelName;                           // 0x0638(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndCardKeyDoorType                           DoorType;                                          // 0x0640(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndCardKeyDoorTerminalType                   TerminalType;                                      // 0x0644(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HaveNotCardKeyTrigger;                             // 0x0648(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HaveCardKeyTrigger;                                // 0x0650(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        OpenVolume;                                        // 0x0658(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        CloseVolume;                                       // 0x0660(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        TargetIconFirstVolume;                             // 0x0668(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        TargetIconSecondVolume;                            // 0x0670(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndSwitchAreaBoxComponent*             DividedVersatileVolume;                            // 0x0678(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0680(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoClosingTime;                                   // 0x0688(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68C[0x84];                                     // 0x068C(0x0084)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorCardKeyDoor">();
	}
	static class AEndFieldActionActorCardKeyDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorCardKeyDoor>();
	}
};
static_assert(alignof(AEndFieldActionActorCardKeyDoor) == 0x000008, "Wrong alignment on AEndFieldActionActorCardKeyDoor");
static_assert(sizeof(AEndFieldActionActorCardKeyDoor) == 0x000710, "Wrong size on AEndFieldActionActorCardKeyDoor");
static_assert(offsetof(AEndFieldActionActorCardKeyDoor, AnimationActorName) == 0x000618, "Member 'AEndFieldActionActorCardKeyDoor::AnimationActorName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCardKeyDoor, TerminalFirstName) == 0x000620, "Member 'AEndFieldActionActorCardKeyDoor::TerminalFirstName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCardKeyDoor, TerminalSecondName) == 0x000628, "Member 'AEndFieldActionActorCardKeyDoor::TerminalSecondName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCardKeyDoor, TerminalLevelName) == 0x000630, "Member 'AEndFieldActionActorCardKeyDoor::TerminalLevelName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCardKeyDoor, TerminalSecondLevelName) == 0x000638, "Member 'AEndFieldActionActorCardKeyDoor::TerminalSecondLevelName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCardKeyDoor, DoorType) == 0x000640, "Member 'AEndFieldActionActorCardKeyDoor::DoorType' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCardKeyDoor, TerminalType) == 0x000644, "Member 'AEndFieldActionActorCardKeyDoor::TerminalType' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCardKeyDoor, HaveNotCardKeyTrigger) == 0x000648, "Member 'AEndFieldActionActorCardKeyDoor::HaveNotCardKeyTrigger' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCardKeyDoor, HaveCardKeyTrigger) == 0x000650, "Member 'AEndFieldActionActorCardKeyDoor::HaveCardKeyTrigger' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCardKeyDoor, OpenVolume) == 0x000658, "Member 'AEndFieldActionActorCardKeyDoor::OpenVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCardKeyDoor, CloseVolume) == 0x000660, "Member 'AEndFieldActionActorCardKeyDoor::CloseVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCardKeyDoor, TargetIconFirstVolume) == 0x000668, "Member 'AEndFieldActionActorCardKeyDoor::TargetIconFirstVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCardKeyDoor, TargetIconSecondVolume) == 0x000670, "Member 'AEndFieldActionActorCardKeyDoor::TargetIconSecondVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCardKeyDoor, DividedVersatileVolume) == 0x000678, "Member 'AEndFieldActionActorCardKeyDoor::DividedVersatileVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCardKeyDoor, ModifierVolume) == 0x000680, "Member 'AEndFieldActionActorCardKeyDoor::ModifierVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCardKeyDoor, AutoClosingTime) == 0x000688, "Member 'AEndFieldActionActorCardKeyDoor::AutoClosingTime' has a wrong offset!");

// Class EndGame.EndDataObjectUniqueActionSearchLight
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectUniqueActionSearchLight final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectUniqueActionSearchLight">();
	}
	static class UEndDataObjectUniqueActionSearchLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectUniqueActionSearchLight>();
	}
};
static_assert(alignof(UEndDataObjectUniqueActionSearchLight) == 0x000008, "Wrong alignment on UEndDataObjectUniqueActionSearchLight");
static_assert(sizeof(UEndDataObjectUniqueActionSearchLight) == 0x000088, "Wrong size on UEndDataObjectUniqueActionSearchLight");

// Class EndGame.EndDataObjectWeaponUpgrade
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectWeaponUpgrade final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectWeaponUpgrade">();
	}
	static class UEndDataObjectWeaponUpgrade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectWeaponUpgrade>();
	}
};
static_assert(alignof(UEndDataObjectWeaponUpgrade) == 0x000008, "Wrong alignment on UEndDataObjectWeaponUpgrade");
static_assert(sizeof(UEndDataObjectWeaponUpgrade) == 0x000088, "Wrong size on UEndDataObjectWeaponUpgrade");

// Class EndGame.EndFieldActionActorPassThrough
// 0x0068 (0x0680 - 0x0618)
class AEndFieldActionActorPassThrough final : public AEndFieldActionActorBase
{
public:
	class UEndFieldActionTriggerComponent*        EnterVolume;                                       // 0x0618(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        ExitVolume;                                        // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0628(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_630[0x50];                                     // 0x0630(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorPassThrough">();
	}
	static class AEndFieldActionActorPassThrough* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorPassThrough>();
	}
};
static_assert(alignof(AEndFieldActionActorPassThrough) == 0x000008, "Wrong alignment on AEndFieldActionActorPassThrough");
static_assert(sizeof(AEndFieldActionActorPassThrough) == 0x000680, "Wrong size on AEndFieldActionActorPassThrough");
static_assert(offsetof(AEndFieldActionActorPassThrough, EnterVolume) == 0x000618, "Member 'AEndFieldActionActorPassThrough::EnterVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorPassThrough, ExitVolume) == 0x000620, "Member 'AEndFieldActionActorPassThrough::ExitVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorPassThrough, ModifierVolume) == 0x000628, "Member 'AEndFieldActionActorPassThrough::ModifierVolume' has a wrong offset!");

// Class EndGame.EndDataObjectWeaponUpgradeTreeLevel
// 0x0050 (0x0088 - 0x0038)
class UEndDataObjectWeaponUpgradeTreeLevel final : public UEndDataObjectBase
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDataObjectWeaponUpgradeTreeLevel">();
	}
	static class UEndDataObjectWeaponUpgradeTreeLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDataObjectWeaponUpgradeTreeLevel>();
	}
};
static_assert(alignof(UEndDataObjectWeaponUpgradeTreeLevel) == 0x000008, "Wrong alignment on UEndDataObjectWeaponUpgradeTreeLevel");
static_assert(sizeof(UEndDataObjectWeaponUpgradeTreeLevel) == 0x000088, "Wrong size on UEndDataObjectWeaponUpgradeTreeLevel");

// Class EndGame.EndDebugAPI
// 0x0000 (0x0028 - 0x0028)
class UEndDebugAPI final : public UObject
{
public:
	static void AddAction(class FName Action);
	static void AddSelectHistory(const class FString& str);
	static class FString GetCutSceneEventID(class FName Action);
	static class FString GetDebugState(class FName TableID, const class FString& defaultState);
	static bool GetDebugStateBool(class FName TableID, bool defaultBool);
	static bool IsCompletedTrace();
	static void PrintMemory();
	static void RequestExit();
	static void SetControlRotation(float Pitch, float Yaw, float Roll);
	static void StartCPUCapture();
	static void StopCPUCapture();
	static void TraceGPU();
	static TArray<class FString> UpdateSelectHistory(const TArray<class FString>& list, bool changeOrder);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDebugAPI">();
	}
	static class UEndDebugAPI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDebugAPI>();
	}
};
static_assert(alignof(UEndDebugAPI) == 0x000008, "Wrong alignment on UEndDebugAPI");
static_assert(sizeof(UEndDebugAPI) == 0x000028, "Wrong size on UEndDebugAPI");

// Class EndGame.EndDebugTextComponent
// 0x0100 (0x07F0 - 0x06F0)
class UEndDebugTextComponent final : public UPrimitiveComponent
{
public:
	uint8                                         Pad_6F0[0x100];                                    // 0x06F0(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDebugTextComponent">();
	}
	static class UEndDebugTextComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDebugTextComponent>();
	}
};
static_assert(alignof(UEndDebugTextComponent) == 0x000010, "Wrong alignment on UEndDebugTextComponent");
static_assert(sizeof(UEndDebugTextComponent) == 0x0007F0, "Wrong size on UEndDebugTextComponent");

// Class EndGame.EndDescriptionWindow
// 0x0008 (0x0368 - 0x0360)
class UEndDescriptionWindow : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x8];                                      // 0x0360(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDescriptionWindow">();
	}
	static class UEndDescriptionWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDescriptionWindow>();
	}
};
static_assert(alignof(UEndDescriptionWindow) == 0x000008, "Wrong alignment on UEndDescriptionWindow");
static_assert(sizeof(UEndDescriptionWindow) == 0x000368, "Wrong size on UEndDescriptionWindow");

// Class EndGame.EndFieldActionSplineComponent
// 0x0000 (0x07E0 - 0x07E0)
class UEndFieldActionSplineComponent : public USplineComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionSplineComponent">();
	}
	static class UEndFieldActionSplineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndFieldActionSplineComponent>();
	}
};
static_assert(alignof(UEndFieldActionSplineComponent) == 0x000010, "Wrong alignment on UEndFieldActionSplineComponent");
static_assert(sizeof(UEndFieldActionSplineComponent) == 0x0007E0, "Wrong size on UEndFieldActionSplineComponent");

// Class EndGame.EndDuctActionSplineComponent
// 0x0080 (0x0860 - 0x07E0)
class UEndDuctActionSplineComponent final : public UEndFieldActionSplineComponent
{
public:
	int8                                          Index_0;                                           // 0x07E0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7E1[0x7];                                      // 0x07E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEndDuctSplineLinkInfo>         StartLinkIndexList;                                // 0x07E8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPrivate)
	TArray<struct FEndDuctSplineLinkInfo>         EndLinkIndexList;                                  // 0x07F8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPrivate)
	struct FEndDuctMoveSelectMenu                 LeadSelectMenu;                                    // 0x0808(0x002C)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPrivate)
	struct FEndDuctMoveSelectMenu                 EndSelectMenu;                                     // 0x0834(0x002C)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDuctActionSplineComponent">();
	}
	static class UEndDuctActionSplineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDuctActionSplineComponent>();
	}
};
static_assert(alignof(UEndDuctActionSplineComponent) == 0x000010, "Wrong alignment on UEndDuctActionSplineComponent");
static_assert(sizeof(UEndDuctActionSplineComponent) == 0x000860, "Wrong size on UEndDuctActionSplineComponent");
static_assert(offsetof(UEndDuctActionSplineComponent, Index_0) == 0x0007E0, "Member 'UEndDuctActionSplineComponent::Index_0' has a wrong offset!");
static_assert(offsetof(UEndDuctActionSplineComponent, StartLinkIndexList) == 0x0007E8, "Member 'UEndDuctActionSplineComponent::StartLinkIndexList' has a wrong offset!");
static_assert(offsetof(UEndDuctActionSplineComponent, EndLinkIndexList) == 0x0007F8, "Member 'UEndDuctActionSplineComponent::EndLinkIndexList' has a wrong offset!");
static_assert(offsetof(UEndDuctActionSplineComponent, LeadSelectMenu) == 0x000808, "Member 'UEndDuctActionSplineComponent::LeadSelectMenu' has a wrong offset!");
static_assert(offsetof(UEndDuctActionSplineComponent, EndSelectMenu) == 0x000834, "Member 'UEndDuctActionSplineComponent::EndSelectMenu' has a wrong offset!");

// Class EndGame.EndDirectionalTriggerDrawComponent
// 0x0000 (0x00F8 - 0x00F8)
class UEndDirectionalTriggerDrawComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDirectionalTriggerDrawComponent">();
	}
	static class UEndDirectionalTriggerDrawComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDirectionalTriggerDrawComponent>();
	}
};
static_assert(alignof(UEndDirectionalTriggerDrawComponent) == 0x000008, "Wrong alignment on UEndDirectionalTriggerDrawComponent");
static_assert(sizeof(UEndDirectionalTriggerDrawComponent) == 0x0000F8, "Wrong size on UEndDirectionalTriggerDrawComponent");

// Class EndGame.EndDirectionalTriggerBox
// 0x0018 (0x03A0 - 0x0388)
class AEndDirectionalTriggerBox final : public AEndTriggerBox
{
public:
	class FName                                   FrontTriggerName;                                  // 0x0388(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BackTriggerName;                                   // 0x0390(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDirectionalTriggerBox">();
	}
	static class AEndDirectionalTriggerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndDirectionalTriggerBox>();
	}
};
static_assert(alignof(AEndDirectionalTriggerBox) == 0x000008, "Wrong alignment on AEndDirectionalTriggerBox");
static_assert(sizeof(AEndDirectionalTriggerBox) == 0x0003A0, "Wrong size on AEndDirectionalTriggerBox");
static_assert(offsetof(AEndDirectionalTriggerBox, FrontTriggerName) == 0x000388, "Member 'AEndDirectionalTriggerBox::FrontTriggerName' has a wrong offset!");
static_assert(offsetof(AEndDirectionalTriggerBox, BackTriggerName) == 0x000390, "Member 'AEndDirectionalTriggerBox::BackTriggerName' has a wrong offset!");

// Class EndGame.EndFieldActionActorTarzanJump
// 0x0108 (0x0720 - 0x0618)
class AEndFieldActionActorTarzanJump final : public AEndFieldActionActorBase
{
public:
	class UEndFieldActionTriggerComponent*        EnterVolume;                                       // 0x0618(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        ExitVolume;                                        // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0628(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEndTarzanJumpInfo>             TarzanJumpSetting;                                 // 0x0630(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FVector                                StartIconPosition;                                 // 0x0640(0x000C)(Edit, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GoalIconPosition;                                  // 0x064C(0x000C)(Edit, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_658[0xC8];                                     // 0x0658(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorTarzanJump">();
	}
	static class AEndFieldActionActorTarzanJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorTarzanJump>();
	}
};
static_assert(alignof(AEndFieldActionActorTarzanJump) == 0x000008, "Wrong alignment on AEndFieldActionActorTarzanJump");
static_assert(sizeof(AEndFieldActionActorTarzanJump) == 0x000720, "Wrong size on AEndFieldActionActorTarzanJump");
static_assert(offsetof(AEndFieldActionActorTarzanJump, EnterVolume) == 0x000618, "Member 'AEndFieldActionActorTarzanJump::EnterVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorTarzanJump, ExitVolume) == 0x000620, "Member 'AEndFieldActionActorTarzanJump::ExitVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorTarzanJump, ModifierVolume) == 0x000628, "Member 'AEndFieldActionActorTarzanJump::ModifierVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorTarzanJump, TarzanJumpSetting) == 0x000630, "Member 'AEndFieldActionActorTarzanJump::TarzanJumpSetting' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorTarzanJump, StartIconPosition) == 0x000640, "Member 'AEndFieldActionActorTarzanJump::StartIconPosition' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorTarzanJump, GoalIconPosition) == 0x00064C, "Member 'AEndFieldActionActorTarzanJump::GoalIconPosition' has a wrong offset!");

// Class EndGame.EndDisable3DAudioUITriggerBox
// 0x0008 (0x0390 - 0x0388)
class AEndDisable3DAudioUITriggerBox final : public AEndTriggerBox
{
public:
	bool                                          IsEnableStateOnOff;                                // 0x0388(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDuckingPlay;                                     // 0x0389(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38A[0x6];                                      // 0x038A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDisable3DAudioUITriggerBox">();
	}
	static class AEndDisable3DAudioUITriggerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndDisable3DAudioUITriggerBox>();
	}
};
static_assert(alignof(AEndDisable3DAudioUITriggerBox) == 0x000008, "Wrong alignment on AEndDisable3DAudioUITriggerBox");
static_assert(sizeof(AEndDisable3DAudioUITriggerBox) == 0x000390, "Wrong size on AEndDisable3DAudioUITriggerBox");
static_assert(offsetof(AEndDisable3DAudioUITriggerBox, IsEnableStateOnOff) == 0x000388, "Member 'AEndDisable3DAudioUITriggerBox::IsEnableStateOnOff' has a wrong offset!");
static_assert(offsetof(AEndDisable3DAudioUITriggerBox, IsDuckingPlay) == 0x000389, "Member 'AEndDisable3DAudioUITriggerBox::IsDuckingPlay' has a wrong offset!");

// Class EndGame.EndDuringCharacterMovementComponent
// 0x0018 (0x0110 - 0x00F8)
class UEndDuringCharacterMovementComponent final : public UActorComponent
{
public:
	uint8                                         Pad_F8[0x18];                                      // 0x00F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDuringCharacterMovementComponent">();
	}
	static class UEndDuringCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDuringCharacterMovementComponent>();
	}
};
static_assert(alignof(UEndDuringCharacterMovementComponent) == 0x000008, "Wrong alignment on UEndDuringCharacterMovementComponent");
static_assert(sizeof(UEndDuringCharacterMovementComponent) == 0x000110, "Wrong size on UEndDuringCharacterMovementComponent");

// Class EndGame.EndEffectComponent
// 0x0028 (0x0120 - 0x00F8)
class UEndEffectComponent final : public UActorComponent
{
public:
	EEndEffectCategory                            m_Category;                                        // 0x00F8(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FA[0x2];                                       // 0x00FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           m_Color;                                           // 0x00FC(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         m_Luminance;                                       // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         m_Opacity;                                         // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_114[0xC];                                      // 0x0114(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEffectComponent">();
	}
	static class UEndEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEffectComponent>();
	}
};
static_assert(alignof(UEndEffectComponent) == 0x000008, "Wrong alignment on UEndEffectComponent");
static_assert(sizeof(UEndEffectComponent) == 0x000120, "Wrong size on UEndEffectComponent");
static_assert(offsetof(UEndEffectComponent, m_Category) == 0x0000F8, "Member 'UEndEffectComponent::m_Category' has a wrong offset!");
static_assert(offsetof(UEndEffectComponent, m_Color) == 0x0000FC, "Member 'UEndEffectComponent::m_Color' has a wrong offset!");
static_assert(offsetof(UEndEffectComponent, m_Luminance) == 0x00010C, "Member 'UEndEffectComponent::m_Luminance' has a wrong offset!");
static_assert(offsetof(UEndEffectComponent, m_Opacity) == 0x000110, "Member 'UEndEffectComponent::m_Opacity' has a wrong offset!");

// Class EndGame.EndEffectLinearFloat
// 0x0018 (0x0070 - 0x0058)
class UEndEffectLinearFloat final : public UDistributionFloatConstantCurve
{
public:
	uint8                                         Pad_58[0x18];                                      // 0x0058(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEffectLinearFloat">();
	}
	static class UEndEffectLinearFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEffectLinearFloat>();
	}
};
static_assert(alignof(UEndEffectLinearFloat) == 0x000008, "Wrong alignment on UEndEffectLinearFloat");
static_assert(sizeof(UEndEffectLinearFloat) == 0x000070, "Wrong size on UEndEffectLinearFloat");

// Class EndGame.EndEffectLinearVector
// 0x0028 (0x0088 - 0x0060)
class UEndEffectLinearVector final : public UDistributionVectorConstantCurve
{
public:
	uint8                                         m_EnableLinearX : 1;                               // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         m_EnableLinearY : 1;                               // 0x0060(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         m_EnableLinearZ : 1;                               // 0x0060(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x27];                                      // 0x0061(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEffectLinearVector">();
	}
	static class UEndEffectLinearVector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEffectLinearVector>();
	}
};
static_assert(alignof(UEndEffectLinearVector) == 0x000008, "Wrong alignment on UEndEffectLinearVector");
static_assert(sizeof(UEndEffectLinearVector) == 0x000088, "Wrong size on UEndEffectLinearVector");

// Class EndGame.EndEffectNoiseFloat
// 0x0080 (0x00D8 - 0x0058)
class UEndEffectNoiseFloat final : public UDistributionFloatConstantCurve
{
public:
	EEndEffectInterpolateKind                     m_InterpolateKind;                                 // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInterpCurveFloat                      m_CycleTime;                                       // 0x0060(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_RandomCurve;                                     // 0x0078(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         m_RandomSeed;                                      // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x1C];                                      // 0x00BC(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEffectNoiseFloat">();
	}
	static class UEndEffectNoiseFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEffectNoiseFloat>();
	}
};
static_assert(alignof(UEndEffectNoiseFloat) == 0x000008, "Wrong alignment on UEndEffectNoiseFloat");
static_assert(sizeof(UEndEffectNoiseFloat) == 0x0000D8, "Wrong size on UEndEffectNoiseFloat");
static_assert(offsetof(UEndEffectNoiseFloat, m_InterpolateKind) == 0x000058, "Member 'UEndEffectNoiseFloat::m_InterpolateKind' has a wrong offset!");
static_assert(offsetof(UEndEffectNoiseFloat, m_CycleTime) == 0x000060, "Member 'UEndEffectNoiseFloat::m_CycleTime' has a wrong offset!");
static_assert(offsetof(UEndEffectNoiseFloat, m_RandomCurve) == 0x000078, "Member 'UEndEffectNoiseFloat::m_RandomCurve' has a wrong offset!");
static_assert(offsetof(UEndEffectNoiseFloat, m_RandomSeed) == 0x0000B8, "Member 'UEndEffectNoiseFloat::m_RandomSeed' has a wrong offset!");

// Class EndGame.EndHandEffectorSolver
// 0x0030 (0x0058 - 0x0028)
class UEndHandEffectorSolver final : public UObject
{
public:
	TArray<int32>                                 HandMaxIterations;                                 // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         HandReachPrecision;                                // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetReachStepPercent;                            // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PullDistribution;                                  // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlwaysLockRate;                                    // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEndHandEffectorSolveHand>      Hands;                                             // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndHandEffectorSolver">();
	}
	static class UEndHandEffectorSolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndHandEffectorSolver>();
	}
};
static_assert(alignof(UEndHandEffectorSolver) == 0x000008, "Wrong alignment on UEndHandEffectorSolver");
static_assert(sizeof(UEndHandEffectorSolver) == 0x000058, "Wrong size on UEndHandEffectorSolver");
static_assert(offsetof(UEndHandEffectorSolver, HandMaxIterations) == 0x000028, "Member 'UEndHandEffectorSolver::HandMaxIterations' has a wrong offset!");
static_assert(offsetof(UEndHandEffectorSolver, HandReachPrecision) == 0x000038, "Member 'UEndHandEffectorSolver::HandReachPrecision' has a wrong offset!");
static_assert(offsetof(UEndHandEffectorSolver, TargetReachStepPercent) == 0x00003C, "Member 'UEndHandEffectorSolver::TargetReachStepPercent' has a wrong offset!");
static_assert(offsetof(UEndHandEffectorSolver, PullDistribution) == 0x000040, "Member 'UEndHandEffectorSolver::PullDistribution' has a wrong offset!");
static_assert(offsetof(UEndHandEffectorSolver, AlwaysLockRate) == 0x000044, "Member 'UEndHandEffectorSolver::AlwaysLockRate' has a wrong offset!");
static_assert(offsetof(UEndHandEffectorSolver, Hands) == 0x000048, "Member 'UEndHandEffectorSolver::Hands' has a wrong offset!");

// Class EndGame.EndEffectNoiseVector
// 0x00B0 (0x0110 - 0x0060)
class UEndEffectNoiseVector final : public UDistributionVectorConstantCurve
{
public:
	EEndEffectInterpolateKind                     m_InterpolateKind;                                 // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInterpCurveFloat                      m_CycleTime;                                       // 0x0068(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 m_RandomCurve;                                     // 0x0080(0x0060)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         m_RandomSeed;                                      // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x2C];                                      // 0x00E4(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEffectNoiseVector">();
	}
	static class UEndEffectNoiseVector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEffectNoiseVector>();
	}
};
static_assert(alignof(UEndEffectNoiseVector) == 0x000008, "Wrong alignment on UEndEffectNoiseVector");
static_assert(sizeof(UEndEffectNoiseVector) == 0x000110, "Wrong size on UEndEffectNoiseVector");
static_assert(offsetof(UEndEffectNoiseVector, m_InterpolateKind) == 0x000060, "Member 'UEndEffectNoiseVector::m_InterpolateKind' has a wrong offset!");
static_assert(offsetof(UEndEffectNoiseVector, m_CycleTime) == 0x000068, "Member 'UEndEffectNoiseVector::m_CycleTime' has a wrong offset!");
static_assert(offsetof(UEndEffectNoiseVector, m_RandomCurve) == 0x000080, "Member 'UEndEffectNoiseVector::m_RandomCurve' has a wrong offset!");
static_assert(offsetof(UEndEffectNoiseVector, m_RandomSeed) == 0x0000E0, "Member 'UEndEffectNoiseVector::m_RandomSeed' has a wrong offset!");

// Class EndGame.EndEffectSinCosFloat
// 0x0030 (0x0088 - 0x0058)
class UEndEffectSinCosFloat final : public UDistributionFloatConstantCurve
{
public:
	struct FInterpCurveFloat                      m_ValueScale;                                      // 0x0058(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_CycleTime;                                       // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         m_UseCos : 1;                                      // 0x0074(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         m_Absolute : 1;                                    // 0x0074(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_75[0x13];                                      // 0x0075(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEffectSinCosFloat">();
	}
	static class UEndEffectSinCosFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEffectSinCosFloat>();
	}
};
static_assert(alignof(UEndEffectSinCosFloat) == 0x000008, "Wrong alignment on UEndEffectSinCosFloat");
static_assert(sizeof(UEndEffectSinCosFloat) == 0x000088, "Wrong size on UEndEffectSinCosFloat");
static_assert(offsetof(UEndEffectSinCosFloat, m_ValueScale) == 0x000058, "Member 'UEndEffectSinCosFloat::m_ValueScale' has a wrong offset!");
static_assert(offsetof(UEndEffectSinCosFloat, m_CycleTime) == 0x000070, "Member 'UEndEffectSinCosFloat::m_CycleTime' has a wrong offset!");

// Class EndGame.EndEmissiveColorComponent
// 0x0298 (0x0390 - 0x00F8)
class UEndEmissiveColorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_F8[0xE8];                                      // 0x00F8(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndEmissiveColorUserData*              EmissiveColorUserData;                             // 0x01E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USkeletalMeshComponent*>         Meshes;                                            // 0x01E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F8[0x198];                                    // 0x01F8(0x0198)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEmissiveColorComponent">();
	}
	static class UEndEmissiveColorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEmissiveColorComponent>();
	}
};
static_assert(alignof(UEndEmissiveColorComponent) == 0x000008, "Wrong alignment on UEndEmissiveColorComponent");
static_assert(sizeof(UEndEmissiveColorComponent) == 0x000390, "Wrong size on UEndEmissiveColorComponent");
static_assert(offsetof(UEndEmissiveColorComponent, EmissiveColorUserData) == 0x0001E0, "Member 'UEndEmissiveColorComponent::EmissiveColorUserData' has a wrong offset!");
static_assert(offsetof(UEndEmissiveColorComponent, Meshes) == 0x0001E8, "Member 'UEndEmissiveColorComponent::Meshes' has a wrong offset!");

// Class EndGame.EndEmissiveColorUserData
// 0x0008 (0x0030 - 0x0028)
class UEndEmissiveColorUserData final : public USkeletalMeshUserData
{
public:
	class UEndColorPalette*                       ColorPalette;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEmissiveColorUserData">();
	}
	static class UEndEmissiveColorUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEmissiveColorUserData>();
	}
};
static_assert(alignof(UEndEmissiveColorUserData) == 0x000008, "Wrong alignment on UEndEmissiveColorUserData");
static_assert(sizeof(UEndEmissiveColorUserData) == 0x000030, "Wrong size on UEndEmissiveColorUserData");
static_assert(offsetof(UEndEmissiveColorUserData, ColorPalette) == 0x000028, "Member 'UEndEmissiveColorUserData::ColorPalette' has a wrong offset!");

// Class EndGame.EndEmitter
// 0x0068 (0x0430 - 0x03C8)
class AEndEmitter final : public AEmitter
{
public:
	uint8                                         Pad_3C8[0x30];                                     // 0x03C8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEndSoundHandle                        BeginSoundAudioComponent;                          // 0x03F8(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FEndSoundHandle                        FinishSoundAudioComponent;                         // 0x0408(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FEndSoundHandle                        EventSoundAudioComponent;                          // 0x0418(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class USoundBase*                             PlacementSoundAsset;                               // 0x0428(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEmitter">();
	}
	static class AEndEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndEmitter>();
	}
};
static_assert(alignof(AEndEmitter) == 0x000008, "Wrong alignment on AEndEmitter");
static_assert(sizeof(AEndEmitter) == 0x000430, "Wrong size on AEndEmitter");
static_assert(offsetof(AEndEmitter, BeginSoundAudioComponent) == 0x0003F8, "Member 'AEndEmitter::BeginSoundAudioComponent' has a wrong offset!");
static_assert(offsetof(AEndEmitter, FinishSoundAudioComponent) == 0x000408, "Member 'AEndEmitter::FinishSoundAudioComponent' has a wrong offset!");
static_assert(offsetof(AEndEmitter, EventSoundAudioComponent) == 0x000418, "Member 'AEndEmitter::EventSoundAudioComponent' has a wrong offset!");
static_assert(offsetof(AEndEmitter, PlacementSoundAsset) == 0x000428, "Member 'AEndEmitter::PlacementSoundAsset' has a wrong offset!");

// Class EndGame.EndEnemyStatusIcon
// 0x0030 (0x0390 - 0x0360)
class UEndEnemyStatusIcon : public UEndUserWidget
{
public:
	struct FLinearColor                           _BpDefaultColor;                                   // 0x0360(0x0010)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _BpRegenerateColor;                                // 0x0370(0x0010)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_380[0x10];                                     // 0x0380(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnemyStatusIcon">();
	}
	static class UEndEnemyStatusIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnemyStatusIcon>();
	}
};
static_assert(alignof(UEndEnemyStatusIcon) == 0x000008, "Wrong alignment on UEndEnemyStatusIcon");
static_assert(sizeof(UEndEnemyStatusIcon) == 0x000390, "Wrong size on UEndEnemyStatusIcon");
static_assert(offsetof(UEndEnemyStatusIcon, _BpDefaultColor) == 0x000360, "Member 'UEndEnemyStatusIcon::_BpDefaultColor' has a wrong offset!");
static_assert(offsetof(UEndEnemyStatusIcon, _BpRegenerateColor) == 0x000370, "Member 'UEndEnemyStatusIcon::_BpRegenerateColor' has a wrong offset!");

// Class EndGame.EndEnemyTargetPoint
// 0x0010 (0x0388 - 0x0378)
class AEndEnemyTargetPoint final : public ATargetPoint
{
public:
	class FString                                 BattleCharaSpecName;                               // 0x0378(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnemyTargetPoint">();
	}
	static class AEndEnemyTargetPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndEnemyTargetPoint>();
	}
};
static_assert(alignof(AEndEnemyTargetPoint) == 0x000008, "Wrong alignment on AEndEnemyTargetPoint");
static_assert(sizeof(AEndEnemyTargetPoint) == 0x000388, "Wrong size on AEndEnemyTargetPoint");
static_assert(offsetof(AEndEnemyTargetPoint, BattleCharaSpecName) == 0x000378, "Member 'AEndEnemyTargetPoint::BattleCharaSpecName' has a wrong offset!");

// Class EndGame.EndEnvironmentInstancedStaticMeshActor
// 0x0050 (0x03C8 - 0x0378)
class AEndEnvironmentInstancedStaticMeshActor final : public AActor
{
public:
	uint8                                         Pad_378[0x10];                                     // 0x0378(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UInstancedStaticMeshComponent*          InstancedMeshComponent;                            // 0x0388(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseAnimation;                                     // 0x0390(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_391[0x3];                                      // 0x0391(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AnimateDirection;                                  // 0x0394(0x000C)(Edit, BlueprintVisible, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimateTime;                                       // 0x03A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimateTimeRate;                                   // 0x03A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimateTimeMax;                                    // 0x03A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3AC[0x1C];                                     // 0x03AC(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvironmentInstancedStaticMeshActor">();
	}
	static class AEndEnvironmentInstancedStaticMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndEnvironmentInstancedStaticMeshActor>();
	}
};
static_assert(alignof(AEndEnvironmentInstancedStaticMeshActor) == 0x000008, "Wrong alignment on AEndEnvironmentInstancedStaticMeshActor");
static_assert(sizeof(AEndEnvironmentInstancedStaticMeshActor) == 0x0003C8, "Wrong size on AEndEnvironmentInstancedStaticMeshActor");
static_assert(offsetof(AEndEnvironmentInstancedStaticMeshActor, InstancedMeshComponent) == 0x000388, "Member 'AEndEnvironmentInstancedStaticMeshActor::InstancedMeshComponent' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentInstancedStaticMeshActor, bUseAnimation) == 0x000390, "Member 'AEndEnvironmentInstancedStaticMeshActor::bUseAnimation' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentInstancedStaticMeshActor, AnimateDirection) == 0x000394, "Member 'AEndEnvironmentInstancedStaticMeshActor::AnimateDirection' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentInstancedStaticMeshActor, AnimateTime) == 0x0003A0, "Member 'AEndEnvironmentInstancedStaticMeshActor::AnimateTime' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentInstancedStaticMeshActor, AnimateTimeRate) == 0x0003A4, "Member 'AEndEnvironmentInstancedStaticMeshActor::AnimateTimeRate' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentInstancedStaticMeshActor, AnimateTimeMax) == 0x0003A8, "Member 'AEndEnvironmentInstancedStaticMeshActor::AnimateTimeMax' has a wrong offset!");

// Class EndGame.EndEnvironmentPhysAddForceActor
// 0x0020 (0x0398 - 0x0378)
class AEndEnvironmentPhysAddForceActor final : public AActor
{
public:
	EEndEnvironmentPhysForceScale                 AddForceScale;                                     // 0x0378(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_379[0x3];                                      // 0x0379(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AppliedRadius;                                     // 0x037C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLimitAngle;                                       // 0x0380(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_381[0x3];                                      // 0x0381(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AppliedAngle;                                      // 0x0384(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImmediate;                                        // 0x0388(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_389[0x3];                                      // 0x0389(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AppliedSeconds;                                    // 0x038C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreZ;                                          // 0x0390(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_391[0x7];                                      // 0x0391(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvironmentPhysAddForceActor">();
	}
	static class AEndEnvironmentPhysAddForceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndEnvironmentPhysAddForceActor>();
	}
};
static_assert(alignof(AEndEnvironmentPhysAddForceActor) == 0x000008, "Wrong alignment on AEndEnvironmentPhysAddForceActor");
static_assert(sizeof(AEndEnvironmentPhysAddForceActor) == 0x000398, "Wrong size on AEndEnvironmentPhysAddForceActor");
static_assert(offsetof(AEndEnvironmentPhysAddForceActor, AddForceScale) == 0x000378, "Member 'AEndEnvironmentPhysAddForceActor::AddForceScale' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentPhysAddForceActor, AppliedRadius) == 0x00037C, "Member 'AEndEnvironmentPhysAddForceActor::AppliedRadius' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentPhysAddForceActor, bLimitAngle) == 0x000380, "Member 'AEndEnvironmentPhysAddForceActor::bLimitAngle' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentPhysAddForceActor, AppliedAngle) == 0x000384, "Member 'AEndEnvironmentPhysAddForceActor::AppliedAngle' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentPhysAddForceActor, bImmediate) == 0x000388, "Member 'AEndEnvironmentPhysAddForceActor::bImmediate' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentPhysAddForceActor, AppliedSeconds) == 0x00038C, "Member 'AEndEnvironmentPhysAddForceActor::AppliedSeconds' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentPhysAddForceActor, bIgnoreZ) == 0x000390, "Member 'AEndEnvironmentPhysAddForceActor::bIgnoreZ' has a wrong offset!");

// Class EndGame.EndNavAreaCinemaObstacle
// 0x0000 (0x0040 - 0x0040)
class UEndNavAreaCinemaObstacle final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavAreaCinemaObstacle">();
	}
	static class UEndNavAreaCinemaObstacle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavAreaCinemaObstacle>();
	}
};
static_assert(alignof(UEndNavAreaCinemaObstacle) == 0x000008, "Wrong alignment on UEndNavAreaCinemaObstacle");
static_assert(sizeof(UEndNavAreaCinemaObstacle) == 0x000040, "Wrong size on UEndNavAreaCinemaObstacle");

// Class EndGame.EndEnvironmentPhysClassReferencedActor
// 0x0010 (0x0388 - 0x0378)
class AEndEnvironmentPhysClassReferencedActor final : public AActor
{
public:
	TArray<TSubclassOf<class UObject>>            AssetUserData;                                     // 0x0378(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvironmentPhysClassReferencedActor">();
	}
	static class AEndEnvironmentPhysClassReferencedActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndEnvironmentPhysClassReferencedActor>();
	}
};
static_assert(alignof(AEndEnvironmentPhysClassReferencedActor) == 0x000008, "Wrong alignment on AEndEnvironmentPhysClassReferencedActor");
static_assert(sizeof(AEndEnvironmentPhysClassReferencedActor) == 0x000388, "Wrong size on AEndEnvironmentPhysClassReferencedActor");
static_assert(offsetof(AEndEnvironmentPhysClassReferencedActor, AssetUserData) == 0x000378, "Member 'AEndEnvironmentPhysClassReferencedActor::AssetUserData' has a wrong offset!");

// Class EndGame.EndEnvironmentSkeletalMeshActor
// 0x01F8 (0x05F8 - 0x0400)
class AEndEnvironmentSkeletalMeshActor final : public ASkeletalMeshActor
{
public:
	uint8                                         Pad_400[0x30];                                     // 0x0400(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimationAsset*>                AnimationAssets;                                   // 0x0430(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        AssetUserData;                                     // 0x0440(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        LocationAssetUserData;                             // 0x0450(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, class UObject*>             Resources;                                         // 0x0460(0x0050)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class FName                                   EnvironmentSpecName;                               // 0x04B0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckedLocationAssetData;                         // 0x04B8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B9[0x7];                                      // 0x04B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LocationName;                                      // 0x04C0(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AssetDataPath;                                     // 0x04D0(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdjustTerrainCollisionRotation;                   // 0x04E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E1[0x3];                                      // 0x04E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RotationAdjustStartLocation;                       // 0x04E4(0x000C)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RotationAdjustEndLocation;                         // 0x04F0(0x000C)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSeeThroughSkillCamera;                      // 0x04FC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4FD[0x3];                                      // 0x04FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEndIgnoreSkillCameraRelatedActorData> IgnoreSkillCameraRelatedActorDataList;             // 0x0500(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_510[0x18];                                     // 0x0510(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUpdateCollisionFlagsOnChangeTickPause;            // 0x0528(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_529[0xAF];                                     // 0x0529(0x00AF)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LimitMovementForwardAnimation;                     // 0x05D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   LimitMovementBackwardAnimation;                    // 0x05E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E8[0x10];                                     // 0x05E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvironmentSkeletalMeshActor">();
	}
	static class AEndEnvironmentSkeletalMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndEnvironmentSkeletalMeshActor>();
	}
};
static_assert(alignof(AEndEnvironmentSkeletalMeshActor) == 0x000008, "Wrong alignment on AEndEnvironmentSkeletalMeshActor");
static_assert(sizeof(AEndEnvironmentSkeletalMeshActor) == 0x0005F8, "Wrong size on AEndEnvironmentSkeletalMeshActor");
static_assert(offsetof(AEndEnvironmentSkeletalMeshActor, AnimationAssets) == 0x000430, "Member 'AEndEnvironmentSkeletalMeshActor::AnimationAssets' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentSkeletalMeshActor, AssetUserData) == 0x000440, "Member 'AEndEnvironmentSkeletalMeshActor::AssetUserData' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentSkeletalMeshActor, LocationAssetUserData) == 0x000450, "Member 'AEndEnvironmentSkeletalMeshActor::LocationAssetUserData' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentSkeletalMeshActor, Resources) == 0x000460, "Member 'AEndEnvironmentSkeletalMeshActor::Resources' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentSkeletalMeshActor, EnvironmentSpecName) == 0x0004B0, "Member 'AEndEnvironmentSkeletalMeshActor::EnvironmentSpecName' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentSkeletalMeshActor, bCheckedLocationAssetData) == 0x0004B8, "Member 'AEndEnvironmentSkeletalMeshActor::bCheckedLocationAssetData' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentSkeletalMeshActor, LocationName) == 0x0004C0, "Member 'AEndEnvironmentSkeletalMeshActor::LocationName' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentSkeletalMeshActor, AssetDataPath) == 0x0004D0, "Member 'AEndEnvironmentSkeletalMeshActor::AssetDataPath' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentSkeletalMeshActor, bAdjustTerrainCollisionRotation) == 0x0004E0, "Member 'AEndEnvironmentSkeletalMeshActor::bAdjustTerrainCollisionRotation' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentSkeletalMeshActor, RotationAdjustStartLocation) == 0x0004E4, "Member 'AEndEnvironmentSkeletalMeshActor::RotationAdjustStartLocation' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentSkeletalMeshActor, RotationAdjustEndLocation) == 0x0004F0, "Member 'AEndEnvironmentSkeletalMeshActor::RotationAdjustEndLocation' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentSkeletalMeshActor, bEnableSeeThroughSkillCamera) == 0x0004FC, "Member 'AEndEnvironmentSkeletalMeshActor::bEnableSeeThroughSkillCamera' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentSkeletalMeshActor, IgnoreSkillCameraRelatedActorDataList) == 0x000500, "Member 'AEndEnvironmentSkeletalMeshActor::IgnoreSkillCameraRelatedActorDataList' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentSkeletalMeshActor, bUpdateCollisionFlagsOnChangeTickPause) == 0x000528, "Member 'AEndEnvironmentSkeletalMeshActor::bUpdateCollisionFlagsOnChangeTickPause' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentSkeletalMeshActor, LimitMovementForwardAnimation) == 0x0005D8, "Member 'AEndEnvironmentSkeletalMeshActor::LimitMovementForwardAnimation' has a wrong offset!");
static_assert(offsetof(AEndEnvironmentSkeletalMeshActor, LimitMovementBackwardAnimation) == 0x0005E0, "Member 'AEndEnvironmentSkeletalMeshActor::LimitMovementBackwardAnimation' has a wrong offset!");

// Class EndGame.EndEnvQueryCharacterGenerator
// 0x0068 (0x00B8 - 0x0050)
class UEndEnvQueryCharacterGenerator final : public UEnvQueryGenerator
{
public:
	struct FAIDataProviderBoolValue               GenerateOnlyActorsInRadius;                        // 0x0050(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              SearchRadius;                                      // 0x0080(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           SearchCenter;                                      // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryCharacterGenerator">();
	}
	static class UEndEnvQueryCharacterGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryCharacterGenerator>();
	}
};
static_assert(alignof(UEndEnvQueryCharacterGenerator) == 0x000008, "Wrong alignment on UEndEnvQueryCharacterGenerator");
static_assert(sizeof(UEndEnvQueryCharacterGenerator) == 0x0000B8, "Wrong size on UEndEnvQueryCharacterGenerator");
static_assert(offsetof(UEndEnvQueryCharacterGenerator, GenerateOnlyActorsInRadius) == 0x000050, "Member 'UEndEnvQueryCharacterGenerator::GenerateOnlyActorsInRadius' has a wrong offset!");
static_assert(offsetof(UEndEnvQueryCharacterGenerator, SearchRadius) == 0x000080, "Member 'UEndEnvQueryCharacterGenerator::SearchRadius' has a wrong offset!");
static_assert(offsetof(UEndEnvQueryCharacterGenerator, SearchCenter) == 0x0000B0, "Member 'UEndEnvQueryCharacterGenerator::SearchCenter' has a wrong offset!");

// Class EndGame.EndFeelerActorInterface
// 0x0000 (0x0028 - 0x0028)
class IEndFeelerActorInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFeelerActorInterface">();
	}
	static class IEndFeelerActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEndFeelerActorInterface>();
	}
};
static_assert(alignof(IEndFeelerActorInterface) == 0x000008, "Wrong alignment on IEndFeelerActorInterface");
static_assert(sizeof(IEndFeelerActorInterface) == 0x000028, "Wrong size on IEndFeelerActorInterface");

// Class EndGame.EndEnvQueryComponent
// 0x0018 (0x0110 - 0x00F8)
class UEndEnvQueryComponent final : public UActorComponent
{
public:
	uint8                                         Pad_F8[0x18];                                      // 0x00F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AActor* GetActor(EEqsType Index_0, int32 ID);
	struct FVector GetLocation(EEqsType Index_0, int32 ID);
	float GetScore(EEqsType Index_0, int32 ID);
	bool IsQueryVisible(EEqsType Index_0);
	void RunQuery(float DeltaTime);
	void SetQuery(EEqsType Index_0, class UEnvQuery* InQuery);
	void SetQueryActive(EEqsType Index_0, bool Flag);
	void SetQueryAllActive(EEqsType Index_0, bool Flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryComponent">();
	}
	static class UEndEnvQueryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryComponent>();
	}
};
static_assert(alignof(UEndEnvQueryComponent) == 0x000008, "Wrong alignment on UEndEnvQueryComponent");
static_assert(sizeof(UEndEnvQueryComponent) == 0x000110, "Wrong size on UEndEnvQueryComponent");

// Class EndGame.EndEnvQueryContext_AIPCCommandTargetFeetLocation
// 0x0000 (0x0028 - 0x0028)
class UEndEnvQueryContext_AIPCCommandTargetFeetLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryContext_AIPCCommandTargetFeetLocation">();
	}
	static class UEndEnvQueryContext_AIPCCommandTargetFeetLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryContext_AIPCCommandTargetFeetLocation>();
	}
};
static_assert(alignof(UEndEnvQueryContext_AIPCCommandTargetFeetLocation) == 0x000008, "Wrong alignment on UEndEnvQueryContext_AIPCCommandTargetFeetLocation");
static_assert(sizeof(UEndEnvQueryContext_AIPCCommandTargetFeetLocation) == 0x000028, "Wrong size on UEndEnvQueryContext_AIPCCommandTargetFeetLocation");

// Class EndGame.EndEnvQueryContext_AIPCCoverTargetFeetLocation
// 0x0000 (0x0028 - 0x0028)
class UEndEnvQueryContext_AIPCCoverTargetFeetLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryContext_AIPCCoverTargetFeetLocation">();
	}
	static class UEndEnvQueryContext_AIPCCoverTargetFeetLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryContext_AIPCCoverTargetFeetLocation>();
	}
};
static_assert(alignof(UEndEnvQueryContext_AIPCCoverTargetFeetLocation) == 0x000008, "Wrong alignment on UEndEnvQueryContext_AIPCCoverTargetFeetLocation");
static_assert(sizeof(UEndEnvQueryContext_AIPCCoverTargetFeetLocation) == 0x000028, "Wrong size on UEndEnvQueryContext_AIPCCoverTargetFeetLocation");

// Class EndGame.EndEnvQueryContext_AIPCCoverTargetTransform
// 0x0000 (0x0028 - 0x0028)
class UEndEnvQueryContext_AIPCCoverTargetTransform final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryContext_AIPCCoverTargetTransform">();
	}
	static class UEndEnvQueryContext_AIPCCoverTargetTransform* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryContext_AIPCCoverTargetTransform>();
	}
};
static_assert(alignof(UEndEnvQueryContext_AIPCCoverTargetTransform) == 0x000008, "Wrong alignment on UEndEnvQueryContext_AIPCCoverTargetTransform");
static_assert(sizeof(UEndEnvQueryContext_AIPCCoverTargetTransform) == 0x000028, "Wrong size on UEndEnvQueryContext_AIPCCoverTargetTransform");

// Class EndGame.EndEnvQueryContext_AIPCTargetTransform
// 0x0000 (0x0028 - 0x0028)
class UEndEnvQueryContext_AIPCTargetTransform final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryContext_AIPCTargetTransform">();
	}
	static class UEndEnvQueryContext_AIPCTargetTransform* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryContext_AIPCTargetTransform>();
	}
};
static_assert(alignof(UEndEnvQueryContext_AIPCTargetTransform) == 0x000008, "Wrong alignment on UEndEnvQueryContext_AIPCTargetTransform");
static_assert(sizeof(UEndEnvQueryContext_AIPCTargetTransform) == 0x000028, "Wrong size on UEndEnvQueryContext_AIPCTargetTransform");

// Class EndGame.EndEnvQueryContext_AttackActor
// 0x0000 (0x0028 - 0x0028)
class UEndEnvQueryContext_AttackActor final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryContext_AttackActor">();
	}
	static class UEndEnvQueryContext_AttackActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryContext_AttackActor>();
	}
};
static_assert(alignof(UEndEnvQueryContext_AttackActor) == 0x000008, "Wrong alignment on UEndEnvQueryContext_AttackActor");
static_assert(sizeof(UEndEnvQueryContext_AttackActor) == 0x000028, "Wrong size on UEndEnvQueryContext_AttackActor");

// Class EndGame.EndFieldActionActorBalanceMove
// 0x0088 (0x06A0 - 0x0618)
class AEndFieldActionActorBalanceMove final : public AEndFieldActionActorBase
{
public:
	class UEndFieldActionSplineComponent*         BalanceMoveComponent;                              // 0x0618(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        EnterVolume;                                       // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        ExitVolume;                                        // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndSwitchAreaBoxComponent*             DividedImpassableEnterVolume;                      // 0x0630(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndSwitchAreaBoxComponent*             DividedImpassableExitVolume;                       // 0x0638(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0640(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoBoxRotation;                                   // 0x0648(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_649[0x3];                                      // 0x0649(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CustomFieldActionName;                             // 0x064C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_654[0x4C];                                     // 0x0654(0x004C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorBalanceMove">();
	}
	static class AEndFieldActionActorBalanceMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorBalanceMove>();
	}
};
static_assert(alignof(AEndFieldActionActorBalanceMove) == 0x000008, "Wrong alignment on AEndFieldActionActorBalanceMove");
static_assert(sizeof(AEndFieldActionActorBalanceMove) == 0x0006A0, "Wrong size on AEndFieldActionActorBalanceMove");
static_assert(offsetof(AEndFieldActionActorBalanceMove, BalanceMoveComponent) == 0x000618, "Member 'AEndFieldActionActorBalanceMove::BalanceMoveComponent' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBalanceMove, EnterVolume) == 0x000620, "Member 'AEndFieldActionActorBalanceMove::EnterVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBalanceMove, ExitVolume) == 0x000628, "Member 'AEndFieldActionActorBalanceMove::ExitVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBalanceMove, DividedImpassableEnterVolume) == 0x000630, "Member 'AEndFieldActionActorBalanceMove::DividedImpassableEnterVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBalanceMove, DividedImpassableExitVolume) == 0x000638, "Member 'AEndFieldActionActorBalanceMove::DividedImpassableExitVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBalanceMove, ModifierVolume) == 0x000640, "Member 'AEndFieldActionActorBalanceMove::ModifierVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBalanceMove, AutoBoxRotation) == 0x000648, "Member 'AEndFieldActionActorBalanceMove::AutoBoxRotation' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorBalanceMove, CustomFieldActionName) == 0x00064C, "Member 'AEndFieldActionActorBalanceMove::CustomFieldActionName' has a wrong offset!");

// Class EndGame.EndEnvQueryContext_CameraTransform
// 0x0000 (0x0028 - 0x0028)
class UEndEnvQueryContext_CameraTransform final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryContext_CameraTransform">();
	}
	static class UEndEnvQueryContext_CameraTransform* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryContext_CameraTransform>();
	}
};
static_assert(alignof(UEndEnvQueryContext_CameraTransform) == 0x000008, "Wrong alignment on UEndEnvQueryContext_CameraTransform");
static_assert(sizeof(UEndEnvQueryContext_CameraTransform) == 0x000028, "Wrong size on UEndEnvQueryContext_CameraTransform");

// Class EndGame.EndEnvQueryContext_EnemyList
// 0x0000 (0x0028 - 0x0028)
class UEndEnvQueryContext_EnemyList final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryContext_EnemyList">();
	}
	static class UEndEnvQueryContext_EnemyList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryContext_EnemyList>();
	}
};
static_assert(alignof(UEndEnvQueryContext_EnemyList) == 0x000008, "Wrong alignment on UEndEnvQueryContext_EnemyList");
static_assert(sizeof(UEndEnvQueryContext_EnemyList) == 0x000028, "Wrong size on UEndEnvQueryContext_EnemyList");

// Class EndGame.EndFieldActionActorLiftingRope
// 0x0068 (0x0680 - 0x0618)
class AEndFieldActionActorLiftingRope final : public AEndFieldActionActorBase
{
public:
	ELiftingRopeActorMoveType                     MoveType;                                          // 0x0618(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_619[0x7];                                      // 0x0619(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndFieldActionTriggerComponent*        UpperVolume;                                       // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        LowerVolume;                                       // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0630(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_638[0x48];                                     // 0x0638(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorLiftingRope">();
	}
	static class AEndFieldActionActorLiftingRope* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorLiftingRope>();
	}
};
static_assert(alignof(AEndFieldActionActorLiftingRope) == 0x000008, "Wrong alignment on AEndFieldActionActorLiftingRope");
static_assert(sizeof(AEndFieldActionActorLiftingRope) == 0x000680, "Wrong size on AEndFieldActionActorLiftingRope");
static_assert(offsetof(AEndFieldActionActorLiftingRope, MoveType) == 0x000618, "Member 'AEndFieldActionActorLiftingRope::MoveType' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorLiftingRope, UpperVolume) == 0x000620, "Member 'AEndFieldActionActorLiftingRope::UpperVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorLiftingRope, LowerVolume) == 0x000628, "Member 'AEndFieldActionActorLiftingRope::LowerVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorLiftingRope, ModifierVolume) == 0x000630, "Member 'AEndFieldActionActorLiftingRope::ModifierVolume' has a wrong offset!");

// Class EndGame.EndEnvQueryContext_EvaluateActor
// 0x0000 (0x0028 - 0x0028)
class UEndEnvQueryContext_EvaluateActor final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryContext_EvaluateActor">();
	}
	static class UEndEnvQueryContext_EvaluateActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryContext_EvaluateActor>();
	}
};
static_assert(alignof(UEndEnvQueryContext_EvaluateActor) == 0x000008, "Wrong alignment on UEndEnvQueryContext_EvaluateActor");
static_assert(sizeof(UEndEnvQueryContext_EvaluateActor) == 0x000028, "Wrong size on UEndEnvQueryContext_EvaluateActor");

// Class EndGame.EndEnvQueryContext_Field_OtherMembers
// 0x0000 (0x0028 - 0x0028)
class UEndEnvQueryContext_Field_OtherMembers final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryContext_Field_OtherMembers">();
	}
	static class UEndEnvQueryContext_Field_OtherMembers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryContext_Field_OtherMembers>();
	}
};
static_assert(alignof(UEndEnvQueryContext_Field_OtherMembers) == 0x000008, "Wrong alignment on UEndEnvQueryContext_Field_OtherMembers");
static_assert(sizeof(UEndEnvQueryContext_Field_OtherMembers) == 0x000028, "Wrong size on UEndEnvQueryContext_Field_OtherMembers");

// Class EndGame.EndParticleModuleCameraShake
// 0x0090 (0x00C8 - 0x0038)
class UEndParticleModuleCameraShake final : public UParticleModuleCameraBase
{
public:
	struct FEndCameraShakeParam                   m_EndCameraShakeParam;                             // 0x0038(0x0068)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x28];                                      // 0x00A0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndParticleModuleCameraShake">();
	}
	static class UEndParticleModuleCameraShake* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndParticleModuleCameraShake>();
	}
};
static_assert(alignof(UEndParticleModuleCameraShake) == 0x000008, "Wrong alignment on UEndParticleModuleCameraShake");
static_assert(sizeof(UEndParticleModuleCameraShake) == 0x0000C8, "Wrong size on UEndParticleModuleCameraShake");
static_assert(offsetof(UEndParticleModuleCameraShake, m_EndCameraShakeParam) == 0x000038, "Member 'UEndParticleModuleCameraShake::m_EndCameraShakeParam' has a wrong offset!");

// Class EndGame.EndEnvQueryContext_Field_OtherMembersNoLeader
// 0x0000 (0x0028 - 0x0028)
class UEndEnvQueryContext_Field_OtherMembersNoLeader final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryContext_Field_OtherMembersNoLeader">();
	}
	static class UEndEnvQueryContext_Field_OtherMembersNoLeader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryContext_Field_OtherMembersNoLeader>();
	}
};
static_assert(alignof(UEndEnvQueryContext_Field_OtherMembersNoLeader) == 0x000008, "Wrong alignment on UEndEnvQueryContext_Field_OtherMembersNoLeader");
static_assert(sizeof(UEndEnvQueryContext_Field_OtherMembersNoLeader) == 0x000028, "Wrong size on UEndEnvQueryContext_Field_OtherMembersNoLeader");

// Class EndGame.EndEnvQueryContext_Field_FollowMembers
// 0x0000 (0x0028 - 0x0028)
class UEndEnvQueryContext_Field_FollowMembers final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryContext_Field_FollowMembers">();
	}
	static class UEndEnvQueryContext_Field_FollowMembers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryContext_Field_FollowMembers>();
	}
};
static_assert(alignof(UEndEnvQueryContext_Field_FollowMembers) == 0x000008, "Wrong alignment on UEndEnvQueryContext_Field_FollowMembers");
static_assert(sizeof(UEndEnvQueryContext_Field_FollowMembers) == 0x000028, "Wrong size on UEndEnvQueryContext_Field_FollowMembers");

// Class EndGame.EndEnvQueryContext_Field_FollowMembersNoLeader
// 0x0000 (0x0028 - 0x0028)
class UEndEnvQueryContext_Field_FollowMembersNoLeader final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryContext_Field_FollowMembersNoLeader">();
	}
	static class UEndEnvQueryContext_Field_FollowMembersNoLeader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryContext_Field_FollowMembersNoLeader>();
	}
};
static_assert(alignof(UEndEnvQueryContext_Field_FollowMembersNoLeader) == 0x000008, "Wrong alignment on UEndEnvQueryContext_Field_FollowMembersNoLeader");
static_assert(sizeof(UEndEnvQueryContext_Field_FollowMembersNoLeader) == 0x000028, "Wrong size on UEndEnvQueryContext_Field_FollowMembersNoLeader");

// Class EndGame.EndDebugDanceMinigameSplineActorObject
// 0x0008 (0x0030 - 0x0028)
class UEndDebugDanceMinigameSplineActorObject final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndDebugDanceMinigameSplineActorObject">();
	}
	static class UEndDebugDanceMinigameSplineActorObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndDebugDanceMinigameSplineActorObject>();
	}
};
static_assert(alignof(UEndDebugDanceMinigameSplineActorObject) == 0x000008, "Wrong alignment on UEndDebugDanceMinigameSplineActorObject");
static_assert(sizeof(UEndDebugDanceMinigameSplineActorObject) == 0x000030, "Wrong size on UEndDebugDanceMinigameSplineActorObject");

// Class EndGame.EndEnvQueryContext_Field_FollowMembersForward
// 0x0000 (0x0028 - 0x0028)
class UEndEnvQueryContext_Field_FollowMembersForward final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryContext_Field_FollowMembersForward">();
	}
	static class UEndEnvQueryContext_Field_FollowMembersForward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryContext_Field_FollowMembersForward>();
	}
};
static_assert(alignof(UEndEnvQueryContext_Field_FollowMembersForward) == 0x000008, "Wrong alignment on UEndEnvQueryContext_Field_FollowMembersForward");
static_assert(sizeof(UEndEnvQueryContext_Field_FollowMembersForward) == 0x000028, "Wrong size on UEndEnvQueryContext_Field_FollowMembersForward");

// Class EndGame.EndEnvQueryContext_Field_FollowMembersBackward
// 0x0000 (0x0028 - 0x0028)
class UEndEnvQueryContext_Field_FollowMembersBackward final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryContext_Field_FollowMembersBackward">();
	}
	static class UEndEnvQueryContext_Field_FollowMembersBackward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryContext_Field_FollowMembersBackward>();
	}
};
static_assert(alignof(UEndEnvQueryContext_Field_FollowMembersBackward) == 0x000008, "Wrong alignment on UEndEnvQueryContext_Field_FollowMembersBackward");
static_assert(sizeof(UEndEnvQueryContext_Field_FollowMembersBackward) == 0x000028, "Wrong size on UEndEnvQueryContext_Field_FollowMembersBackward");

// Class EndGame.EndEnvQueryContext_LowerCityChildCronyTarget
// 0x0000 (0x0028 - 0x0028)
class UEndEnvQueryContext_LowerCityChildCronyTarget final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryContext_LowerCityChildCronyTarget">();
	}
	static class UEndEnvQueryContext_LowerCityChildCronyTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryContext_LowerCityChildCronyTarget>();
	}
};
static_assert(alignof(UEndEnvQueryContext_LowerCityChildCronyTarget) == 0x000008, "Wrong alignment on UEndEnvQueryContext_LowerCityChildCronyTarget");
static_assert(sizeof(UEndEnvQueryContext_LowerCityChildCronyTarget) == 0x000028, "Wrong size on UEndEnvQueryContext_LowerCityChildCronyTarget");

// Class EndGame.EndEnvQueryContext_LowerCityChildCronyTargetGoal
// 0x0000 (0x0028 - 0x0028)
class UEndEnvQueryContext_LowerCityChildCronyTargetGoal final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryContext_LowerCityChildCronyTargetGoal">();
	}
	static class UEndEnvQueryContext_LowerCityChildCronyTargetGoal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryContext_LowerCityChildCronyTargetGoal>();
	}
};
static_assert(alignof(UEndEnvQueryContext_LowerCityChildCronyTargetGoal) == 0x000008, "Wrong alignment on UEndEnvQueryContext_LowerCityChildCronyTargetGoal");
static_assert(sizeof(UEndEnvQueryContext_LowerCityChildCronyTargetGoal) == 0x000028, "Wrong size on UEndEnvQueryContext_LowerCityChildCronyTargetGoal");

// Class EndGame.EndParticleModuleCameraLocation
// 0x0000 (0x0038 - 0x0038)
class UEndParticleModuleCameraLocation final : public UParticleModuleCameraBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndParticleModuleCameraLocation">();
	}
	static class UEndParticleModuleCameraLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndParticleModuleCameraLocation>();
	}
};
static_assert(alignof(UEndParticleModuleCameraLocation) == 0x000008, "Wrong alignment on UEndParticleModuleCameraLocation");
static_assert(sizeof(UEndParticleModuleCameraLocation) == 0x000038, "Wrong size on UEndParticleModuleCameraLocation");

// Class EndGame.EndEnvQueryContext_Field_FollowTarget
// 0x0000 (0x0028 - 0x0028)
class UEndEnvQueryContext_Field_FollowTarget final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryContext_Field_FollowTarget">();
	}
	static class UEndEnvQueryContext_Field_FollowTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryContext_Field_FollowTarget>();
	}
};
static_assert(alignof(UEndEnvQueryContext_Field_FollowTarget) == 0x000008, "Wrong alignment on UEndEnvQueryContext_Field_FollowTarget");
static_assert(sizeof(UEndEnvQueryContext_Field_FollowTarget) == 0x000028, "Wrong size on UEndEnvQueryContext_Field_FollowTarget");

// Class EndGame.EndEnvQueryContext_LeaderActor
// 0x0000 (0x0028 - 0x0028)
class UEndEnvQueryContext_LeaderActor final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryContext_LeaderActor">();
	}
	static class UEndEnvQueryContext_LeaderActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryContext_LeaderActor>();
	}
};
static_assert(alignof(UEndEnvQueryContext_LeaderActor) == 0x000008, "Wrong alignment on UEndEnvQueryContext_LeaderActor");
static_assert(sizeof(UEndEnvQueryContext_LeaderActor) == 0x000028, "Wrong size on UEndEnvQueryContext_LeaderActor");

// Class EndGame.EndAutoSeComponentSoundIndexTable
// 0x0308 (0x0338 - 0x0030)
class UEndAutoSeComponentSoundIndexTable final : public UDataAsset
{
public:
	struct FEndAutoSeComponentAssetTablePerAttribute PerAttribute[0x1E];                                // 0x0030(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndAutoSeComponentAssetTableNonAttribute NonAttribute;                                      // 0x0300(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAutoSeComponentSoundIndexTable">();
	}
	static class UEndAutoSeComponentSoundIndexTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAutoSeComponentSoundIndexTable>();
	}
};
static_assert(alignof(UEndAutoSeComponentSoundIndexTable) == 0x000008, "Wrong alignment on UEndAutoSeComponentSoundIndexTable");
static_assert(sizeof(UEndAutoSeComponentSoundIndexTable) == 0x000338, "Wrong size on UEndAutoSeComponentSoundIndexTable");
static_assert(offsetof(UEndAutoSeComponentSoundIndexTable, PerAttribute) == 0x000030, "Member 'UEndAutoSeComponentSoundIndexTable::PerAttribute' has a wrong offset!");
static_assert(offsetof(UEndAutoSeComponentSoundIndexTable, NonAttribute) == 0x000300, "Member 'UEndAutoSeComponentSoundIndexTable::NonAttribute' has a wrong offset!");

// Class EndGame.EndEnvQueryContext_OtherActors
// 0x0000 (0x0028 - 0x0028)
class UEndEnvQueryContext_OtherActors final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryContext_OtherActors">();
	}
	static class UEndEnvQueryContext_OtherActors* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryContext_OtherActors>();
	}
};
static_assert(alignof(UEndEnvQueryContext_OtherActors) == 0x000008, "Wrong alignment on UEndEnvQueryContext_OtherActors");
static_assert(sizeof(UEndEnvQueryContext_OtherActors) == 0x000028, "Wrong size on UEndEnvQueryContext_OtherActors");

// Class EndGame.EndEnvQueryContext_OtherAllyActors
// 0x0000 (0x0028 - 0x0028)
class UEndEnvQueryContext_OtherAllyActors final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryContext_OtherAllyActors">();
	}
	static class UEndEnvQueryContext_OtherAllyActors* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryContext_OtherAllyActors>();
	}
};
static_assert(alignof(UEndEnvQueryContext_OtherAllyActors) == 0x000008, "Wrong alignment on UEndEnvQueryContext_OtherAllyActors");
static_assert(sizeof(UEndEnvQueryContext_OtherAllyActors) == 0x000028, "Wrong size on UEndEnvQueryContext_OtherAllyActors");

// Class EndGame.EndEnvQueryContext_QuerierFloorLocation
// 0x0000 (0x0028 - 0x0028)
class UEndEnvQueryContext_QuerierFloorLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryContext_QuerierFloorLocation">();
	}
	static class UEndEnvQueryContext_QuerierFloorLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryContext_QuerierFloorLocation>();
	}
};
static_assert(alignof(UEndEnvQueryContext_QuerierFloorLocation) == 0x000008, "Wrong alignment on UEndEnvQueryContext_QuerierFloorLocation");
static_assert(sizeof(UEndEnvQueryContext_QuerierFloorLocation) == 0x000028, "Wrong size on UEndEnvQueryContext_QuerierFloorLocation");

// Class EndGame.EndEnvQueryContext_SummonOwner
// 0x0000 (0x0028 - 0x0028)
class UEndEnvQueryContext_SummonOwner final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryContext_SummonOwner">();
	}
	static class UEndEnvQueryContext_SummonOwner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryContext_SummonOwner>();
	}
};
static_assert(alignof(UEndEnvQueryContext_SummonOwner) == 0x000008, "Wrong alignment on UEndEnvQueryContext_SummonOwner");
static_assert(sizeof(UEndEnvQueryContext_SummonOwner) == 0x000028, "Wrong size on UEndEnvQueryContext_SummonOwner");

// Class EndGame.EndParticleModuleFitGround
// 0x0018 (0x0050 - 0x0038)
class UEndParticleModuleFitGround final : public UEndParticleModuleBase
{
public:
	float                                         m_RayCastUp;                                       // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_RayCastDown;                                     // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_Timer;                                           // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_GroundOffset;                                    // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         m_FitNormal : 1;                                   // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndParticleModuleFitGround">();
	}
	static class UEndParticleModuleFitGround* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndParticleModuleFitGround>();
	}
};
static_assert(alignof(UEndParticleModuleFitGround) == 0x000008, "Wrong alignment on UEndParticleModuleFitGround");
static_assert(sizeof(UEndParticleModuleFitGround) == 0x000050, "Wrong size on UEndParticleModuleFitGround");
static_assert(offsetof(UEndParticleModuleFitGround, m_RayCastUp) == 0x000038, "Member 'UEndParticleModuleFitGround::m_RayCastUp' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleFitGround, m_RayCastDown) == 0x00003C, "Member 'UEndParticleModuleFitGround::m_RayCastDown' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleFitGround, m_Timer) == 0x000040, "Member 'UEndParticleModuleFitGround::m_Timer' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleFitGround, m_GroundOffset) == 0x000044, "Member 'UEndParticleModuleFitGround::m_GroundOffset' has a wrong offset!");

// Class EndGame.EndEnvQueryContext_SyncSocket
// 0x0000 (0x0028 - 0x0028)
class UEndEnvQueryContext_SyncSocket final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryContext_SyncSocket">();
	}
	static class UEndEnvQueryContext_SyncSocket* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryContext_SyncSocket>();
	}
};
static_assert(alignof(UEndEnvQueryContext_SyncSocket) == 0x000008, "Wrong alignment on UEndEnvQueryContext_SyncSocket");
static_assert(sizeof(UEndEnvQueryContext_SyncSocket) == 0x000028, "Wrong size on UEndEnvQueryContext_SyncSocket");

// Class EndGame.EndMainMenu
// 0x0080 (0x03E0 - 0x0360)
class UEndMainMenu : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x40];                                     // 0x0360(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndTextBlock*                          TitleText;                                         // 0x03A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndTextBlock*                          TimeText;                                          // 0x03A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndTextBlock*                          GilText;                                           // 0x03B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndTextBlock*                          HelpText;                                          // 0x03B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndTextBlock*                          GuideText;                                         // 0x03C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C8[0x18];                                     // 0x03C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainMenu">();
	}
	static class UEndMainMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainMenu>();
	}
};
static_assert(alignof(UEndMainMenu) == 0x000008, "Wrong alignment on UEndMainMenu");
static_assert(sizeof(UEndMainMenu) == 0x0003E0, "Wrong size on UEndMainMenu");
static_assert(offsetof(UEndMainMenu, TitleText) == 0x0003A0, "Member 'UEndMainMenu::TitleText' has a wrong offset!");
static_assert(offsetof(UEndMainMenu, TimeText) == 0x0003A8, "Member 'UEndMainMenu::TimeText' has a wrong offset!");
static_assert(offsetof(UEndMainMenu, GilText) == 0x0003B0, "Member 'UEndMainMenu::GilText' has a wrong offset!");
static_assert(offsetof(UEndMainMenu, HelpText) == 0x0003B8, "Member 'UEndMainMenu::HelpText' has a wrong offset!");
static_assert(offsetof(UEndMainMenu, GuideText) == 0x0003C0, "Member 'UEndMainMenu::GuideText' has a wrong offset!");

// Class EndGame.EndEnvQueryCoverTest
// 0x0008 (0x01C8 - 0x01C0)
class UEndEnvQueryCoverTest final : public UEnvQueryTest
{
public:
	float                                         Size;                                              // 0x01C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C4[0x4];                                      // 0x01C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryCoverTest">();
	}
	static class UEndEnvQueryCoverTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryCoverTest>();
	}
};
static_assert(alignof(UEndEnvQueryCoverTest) == 0x000008, "Wrong alignment on UEndEnvQueryCoverTest");
static_assert(sizeof(UEndEnvQueryCoverTest) == 0x0001C8, "Wrong size on UEndEnvQueryCoverTest");
static_assert(offsetof(UEndEnvQueryCoverTest, Size) == 0x0001C0, "Member 'UEndEnvQueryCoverTest::Size' has a wrong offset!");

// Class EndGame.EndEnvQueryGenerator_SWPOnCircle
// 0x0000 (0x01E8 - 0x01E8)
class UEndEnvQueryGenerator_SWPOnCircle final : public UEnvQueryGenerator_OnCircle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryGenerator_SWPOnCircle">();
	}
	static class UEndEnvQueryGenerator_SWPOnCircle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryGenerator_SWPOnCircle>();
	}
};
static_assert(alignof(UEndEnvQueryGenerator_SWPOnCircle) == 0x000008, "Wrong alignment on UEndEnvQueryGenerator_SWPOnCircle");
static_assert(sizeof(UEndEnvQueryGenerator_SWPOnCircle) == 0x0001E8, "Wrong size on UEndEnvQueryGenerator_SWPOnCircle");

// Class EndGame.EndEnvQueryItemType_Sphere
// 0x0000 (0x0030 - 0x0030)
class UEndEnvQueryItemType_Sphere final : public UEnvQueryItemType_VectorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryItemType_Sphere">();
	}
	static class UEndEnvQueryItemType_Sphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryItemType_Sphere>();
	}
};
static_assert(alignof(UEndEnvQueryItemType_Sphere) == 0x000008, "Wrong alignment on UEndEnvQueryItemType_Sphere");
static_assert(sizeof(UEndEnvQueryItemType_Sphere) == 0x000030, "Wrong size on UEndEnvQueryItemType_Sphere");

// Class EndGame.EndMainWeaponUpgradeEquipMenu
// 0x03C0 (0x07F0 - 0x0430)
class UEndMainWeaponUpgradeEquipMenu : public UEndMainMenuWindow
{
public:
	uint8                                         Pad_430[0x378];                                    // 0x0430(0x0378)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPaperSprite*>                   _CharaImages;                                      // 0x07A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UTexture2D*>                     _DetailCharaImages;                                // 0x07B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class UEndEquipmentMateriaInfoWindow*         SkillList;                                         // 0x07C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndWeaponUpgradeCircleGauge*           CircleGauge2;                                      // 0x07D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndUserWidget*                         SpAutoList;                                        // 0x07D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndSortWindow*                         SortList;                                          // 0x07E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7E8[0x8];                                      // 0x07E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCoreListSetupItemAerith(class UWidget* ItemWidget, int32 CellIndex);
	void OnCoreListSetupItemBarret(class UWidget* ItemWidget, int32 CellIndex);
	void OnCoreListSetupItemCloud(class UWidget* ItemWidget, int32 CellIndex);
	void OnCoreListSetupItemSonon(class UWidget* ItemWidget, int32 CellIndex);
	void OnCoreListSetupItemTifa(class UWidget* ItemWidget, int32 CellIndex);
	void OnCoreListSetupItemYuffie(class UWidget* ItemWidget, int32 CellIndex);
	void OnEquipMenuPressedItem(int32 CellIndex);
	void OnEquipMenuSelectedIndexChanged(int32 CellIndex);
	void OnEquipMenuSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnMemberMenuPressedItem(int32 CellIndex);
	void OnMemberMenuSelectedIndexChanged(int32 CellIndex);
	void OnMemberMenuSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnSortListPressedItem(int32 CellIndex);
	void OnSpListPressedItem(int32 CellIndex);
	void OnSpListSelectedIndexChanged(int32 CellIndex);
	void OnSpListSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void UpdateCharaImage(EPlayerType PlayerType, class UEndImage* Widget, class UPaperSprite* Sprite);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainWeaponUpgradeEquipMenu">();
	}
	static class UEndMainWeaponUpgradeEquipMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainWeaponUpgradeEquipMenu>();
	}
};
static_assert(alignof(UEndMainWeaponUpgradeEquipMenu) == 0x000008, "Wrong alignment on UEndMainWeaponUpgradeEquipMenu");
static_assert(sizeof(UEndMainWeaponUpgradeEquipMenu) == 0x0007F0, "Wrong size on UEndMainWeaponUpgradeEquipMenu");
static_assert(offsetof(UEndMainWeaponUpgradeEquipMenu, _CharaImages) == 0x0007A8, "Member 'UEndMainWeaponUpgradeEquipMenu::_CharaImages' has a wrong offset!");
static_assert(offsetof(UEndMainWeaponUpgradeEquipMenu, _DetailCharaImages) == 0x0007B8, "Member 'UEndMainWeaponUpgradeEquipMenu::_DetailCharaImages' has a wrong offset!");
static_assert(offsetof(UEndMainWeaponUpgradeEquipMenu, SkillList) == 0x0007C8, "Member 'UEndMainWeaponUpgradeEquipMenu::SkillList' has a wrong offset!");
static_assert(offsetof(UEndMainWeaponUpgradeEquipMenu, CircleGauge2) == 0x0007D0, "Member 'UEndMainWeaponUpgradeEquipMenu::CircleGauge2' has a wrong offset!");
static_assert(offsetof(UEndMainWeaponUpgradeEquipMenu, SpAutoList) == 0x0007D8, "Member 'UEndMainWeaponUpgradeEquipMenu::SpAutoList' has a wrong offset!");
static_assert(offsetof(UEndMainWeaponUpgradeEquipMenu, SortList) == 0x0007E0, "Member 'UEndMainWeaponUpgradeEquipMenu::SortList' has a wrong offset!");

// Class EndGame.EndEnvQueryItemType_Transform
// 0x0000 (0x0030 - 0x0030)
class UEndEnvQueryItemType_Transform final : public UEnvQueryItemType_VectorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryItemType_Transform">();
	}
	static class UEndEnvQueryItemType_Transform* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryItemType_Transform>();
	}
};
static_assert(alignof(UEndEnvQueryItemType_Transform) == 0x000008, "Wrong alignment on UEndEnvQueryItemType_Transform");
static_assert(sizeof(UEndEnvQueryItemType_Transform) == 0x000030, "Wrong size on UEndEnvQueryItemType_Transform");

// Class EndGame.EndEnvQueryTest_AddRandomScore
// 0x0000 (0x01C0 - 0x01C0)
class UEndEnvQueryTest_AddRandomScore final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryTest_AddRandomScore">();
	}
	static class UEndEnvQueryTest_AddRandomScore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryTest_AddRandomScore>();
	}
};
static_assert(alignof(UEndEnvQueryTest_AddRandomScore) == 0x000008, "Wrong alignment on UEndEnvQueryTest_AddRandomScore");
static_assert(sizeof(UEndEnvQueryTest_AddRandomScore) == 0x0001C0, "Wrong size on UEndEnvQueryTest_AddRandomScore");

// Class EndGame.EndEnvQueryTest_AIPCLineOfSight
// 0x0008 (0x01C8 - 0x01C0)
class UEndEnvQueryTest_AIPCLineOfSight final : public UEnvQueryTest
{
public:
	EAIPCTargetLocationType                       TargetLocationType;                                // 0x01C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ConsiderWeaponRange;                               // 0x01C1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ConsiderCheckOnNavmesh;                            // 0x01C2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C3[0x5];                                      // 0x01C3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryTest_AIPCLineOfSight">();
	}
	static class UEndEnvQueryTest_AIPCLineOfSight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryTest_AIPCLineOfSight>();
	}
};
static_assert(alignof(UEndEnvQueryTest_AIPCLineOfSight) == 0x000008, "Wrong alignment on UEndEnvQueryTest_AIPCLineOfSight");
static_assert(sizeof(UEndEnvQueryTest_AIPCLineOfSight) == 0x0001C8, "Wrong size on UEndEnvQueryTest_AIPCLineOfSight");
static_assert(offsetof(UEndEnvQueryTest_AIPCLineOfSight, TargetLocationType) == 0x0001C0, "Member 'UEndEnvQueryTest_AIPCLineOfSight::TargetLocationType' has a wrong offset!");
static_assert(offsetof(UEndEnvQueryTest_AIPCLineOfSight, ConsiderWeaponRange) == 0x0001C1, "Member 'UEndEnvQueryTest_AIPCLineOfSight::ConsiderWeaponRange' has a wrong offset!");
static_assert(offsetof(UEndEnvQueryTest_AIPCLineOfSight, ConsiderCheckOnNavmesh) == 0x0001C2, "Member 'UEndEnvQueryTest_AIPCLineOfSight::ConsiderCheckOnNavmesh' has a wrong offset!");

// Class EndGame.EndFieldActionActorWireMeshMove
// 0x01B8 (0x0530 - 0x0378)
class AEndFieldActionActorWireMeshMove final : public AActor
{
public:
	int32                                         PointSpaceLR;                                      // 0x0378(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndWireMeshMoveDoorWayCreateComponent* EndWireMeshMoveDoorWayCreate;                      // 0x0380(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndWireMeshMoveDoorWayCreateComponent* EndWireMeshMoveDoorWayCreate1;                     // 0x0388(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextRenderComponent*                TextRenderComponent;                               // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FWireMovePointData>             PointData;                                         // 0x0398(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint32                                        PointMaxNum;                                       // 0x03A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3AC[0x184];                                    // 0x03AC(0x0184)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorWireMeshMove">();
	}
	static class AEndFieldActionActorWireMeshMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorWireMeshMove>();
	}
};
static_assert(alignof(AEndFieldActionActorWireMeshMove) == 0x000008, "Wrong alignment on AEndFieldActionActorWireMeshMove");
static_assert(sizeof(AEndFieldActionActorWireMeshMove) == 0x000530, "Wrong size on AEndFieldActionActorWireMeshMove");
static_assert(offsetof(AEndFieldActionActorWireMeshMove, PointSpaceLR) == 0x000378, "Member 'AEndFieldActionActorWireMeshMove::PointSpaceLR' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorWireMeshMove, EndWireMeshMoveDoorWayCreate) == 0x000380, "Member 'AEndFieldActionActorWireMeshMove::EndWireMeshMoveDoorWayCreate' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorWireMeshMove, EndWireMeshMoveDoorWayCreate1) == 0x000388, "Member 'AEndFieldActionActorWireMeshMove::EndWireMeshMoveDoorWayCreate1' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorWireMeshMove, TextRenderComponent) == 0x000390, "Member 'AEndFieldActionActorWireMeshMove::TextRenderComponent' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorWireMeshMove, PointData) == 0x000398, "Member 'AEndFieldActionActorWireMeshMove::PointData' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorWireMeshMove, PointMaxNum) == 0x0003A8, "Member 'AEndFieldActionActorWireMeshMove::PointMaxNum' has a wrong offset!");

// Class EndGame.EndEnvQueryTest_AIPCSimpleCover
// 0x0000 (0x01C0 - 0x01C0)
class UEndEnvQueryTest_AIPCSimpleCover final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryTest_AIPCSimpleCover">();
	}
	static class UEndEnvQueryTest_AIPCSimpleCover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryTest_AIPCSimpleCover>();
	}
};
static_assert(alignof(UEndEnvQueryTest_AIPCSimpleCover) == 0x000008, "Wrong alignment on UEndEnvQueryTest_AIPCSimpleCover");
static_assert(sizeof(UEndEnvQueryTest_AIPCSimpleCover) == 0x0001C0, "Wrong size on UEndEnvQueryTest_AIPCSimpleCover");

// Class EndGame.EndParticleModuleTypeDataGpu
// 0x0000 (0x04E0 - 0x04E0)
class UEndParticleModuleTypeDataGpu final : public UParticleModuleTypeDataGpu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndParticleModuleTypeDataGpu">();
	}
	static class UEndParticleModuleTypeDataGpu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndParticleModuleTypeDataGpu>();
	}
};
static_assert(alignof(UEndParticleModuleTypeDataGpu) == 0x000010, "Wrong alignment on UEndParticleModuleTypeDataGpu");
static_assert(sizeof(UEndParticleModuleTypeDataGpu) == 0x0004E0, "Wrong size on UEndParticleModuleTypeDataGpu");

// Class EndGame.EndEnvQueryTest_AIPCSupportFieldZone
// 0x0000 (0x01C0 - 0x01C0)
class UEndEnvQueryTest_AIPCSupportFieldZone final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryTest_AIPCSupportFieldZone">();
	}
	static class UEndEnvQueryTest_AIPCSupportFieldZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryTest_AIPCSupportFieldZone>();
	}
};
static_assert(alignof(UEndEnvQueryTest_AIPCSupportFieldZone) == 0x000008, "Wrong alignment on UEndEnvQueryTest_AIPCSupportFieldZone");
static_assert(sizeof(UEndEnvQueryTest_AIPCSupportFieldZone) == 0x0001C0, "Wrong size on UEndEnvQueryTest_AIPCSupportFieldZone");

// Class EndGame.EndEnvQueryTest_CommandAngle
// 0x0000 (0x01C0 - 0x01C0)
class UEndEnvQueryTest_CommandAngle final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryTest_CommandAngle">();
	}
	static class UEndEnvQueryTest_CommandAngle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryTest_CommandAngle>();
	}
};
static_assert(alignof(UEndEnvQueryTest_CommandAngle) == 0x000008, "Wrong alignment on UEndEnvQueryTest_CommandAngle");
static_assert(sizeof(UEndEnvQueryTest_CommandAngle) == 0x0001C0, "Wrong size on UEndEnvQueryTest_CommandAngle");

// Class EndGame.EndImGuiField
// 0x0000 (0x0028 - 0x0028)
class UEndImGuiField final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndImGuiField">();
	}
	static class UEndImGuiField* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndImGuiField>();
	}
};
static_assert(alignof(UEndImGuiField) == 0x000008, "Wrong alignment on UEndImGuiField");
static_assert(sizeof(UEndImGuiField) == 0x000028, "Wrong size on UEndImGuiField");

// Class EndGame.EndEnvQueryTest_DamageSource
// 0x0000 (0x01C0 - 0x01C0)
class UEndEnvQueryTest_DamageSource final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryTest_DamageSource">();
	}
	static class UEndEnvQueryTest_DamageSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryTest_DamageSource>();
	}
};
static_assert(alignof(UEndEnvQueryTest_DamageSource) == 0x000008, "Wrong alignment on UEndEnvQueryTest_DamageSource");
static_assert(sizeof(UEndEnvQueryTest_DamageSource) == 0x0001C0, "Wrong size on UEndEnvQueryTest_DamageSource");

// Class EndGame.EndEnvQueryTest_DamageSourceAvoidance
// 0x0000 (0x01C0 - 0x01C0)
class UEndEnvQueryTest_DamageSourceAvoidance final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryTest_DamageSourceAvoidance">();
	}
	static class UEndEnvQueryTest_DamageSourceAvoidance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryTest_DamageSourceAvoidance>();
	}
};
static_assert(alignof(UEndEnvQueryTest_DamageSourceAvoidance) == 0x000008, "Wrong alignment on UEndEnvQueryTest_DamageSourceAvoidance");
static_assert(sizeof(UEndEnvQueryTest_DamageSourceAvoidance) == 0x0001C0, "Wrong size on UEndEnvQueryTest_DamageSourceAvoidance");

// Class EndGame.EndEnvQueryTest_DefenceRange
// 0x0000 (0x01C0 - 0x01C0)
class UEndEnvQueryTest_DefenceRange final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryTest_DefenceRange">();
	}
	static class UEndEnvQueryTest_DefenceRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryTest_DefenceRange>();
	}
};
static_assert(alignof(UEndEnvQueryTest_DefenceRange) == 0x000008, "Wrong alignment on UEndEnvQueryTest_DefenceRange");
static_assert(sizeof(UEndEnvQueryTest_DefenceRange) == 0x0001C0, "Wrong size on UEndEnvQueryTest_DefenceRange");

// Class EndGame.EndFIeldActionAdjustIconComponent
// 0x0000 (0x0840 - 0x0840)
class UEndFIeldActionAdjustIconComponent final : public UStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFIeldActionAdjustIconComponent">();
	}
	static class UEndFIeldActionAdjustIconComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndFIeldActionAdjustIconComponent>();
	}
};
static_assert(alignof(UEndFIeldActionAdjustIconComponent) == 0x000010, "Wrong alignment on UEndFIeldActionAdjustIconComponent");
static_assert(sizeof(UEndFIeldActionAdjustIconComponent) == 0x000840, "Wrong size on UEndFIeldActionAdjustIconComponent");

// Class EndGame.EndEnvQueryTest_DoorActionFilter
// 0x0000 (0x01C0 - 0x01C0)
class UEndEnvQueryTest_DoorActionFilter final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryTest_DoorActionFilter">();
	}
	static class UEndEnvQueryTest_DoorActionFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryTest_DoorActionFilter>();
	}
};
static_assert(alignof(UEndEnvQueryTest_DoorActionFilter) == 0x000008, "Wrong alignment on UEndEnvQueryTest_DoorActionFilter");
static_assert(sizeof(UEndEnvQueryTest_DoorActionFilter) == 0x0001C0, "Wrong size on UEndEnvQueryTest_DoorActionFilter");

// Class EndGame.EndEnvQueryTest_FeetHeight
// 0x0008 (0x01C8 - 0x01C0)
class UEndEnvQueryTest_FeetHeight final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           FeetHeight;                                        // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryTest_FeetHeight">();
	}
	static class UEndEnvQueryTest_FeetHeight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryTest_FeetHeight>();
	}
};
static_assert(alignof(UEndEnvQueryTest_FeetHeight) == 0x000008, "Wrong alignment on UEndEnvQueryTest_FeetHeight");
static_assert(sizeof(UEndEnvQueryTest_FeetHeight) == 0x0001C8, "Wrong size on UEndEnvQueryTest_FeetHeight");
static_assert(offsetof(UEndEnvQueryTest_FeetHeight, FeetHeight) == 0x0001C0, "Member 'UEndEnvQueryTest_FeetHeight::FeetHeight' has a wrong offset!");

// Class EndGame.EndEnvQueryTest_Field_CheckPartyIndex
// 0x0008 (0x01C8 - 0x01C0)
class UEndEnvQueryTest_Field_CheckPartyIndex final : public UEnvQueryTest
{
public:
	int32                                         m_Index;                                           // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndAiMathCmp                                 m_ArithmeticOperation;                             // 0x01C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C5[0x3];                                      // 0x01C5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryTest_Field_CheckPartyIndex">();
	}
	static class UEndEnvQueryTest_Field_CheckPartyIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryTest_Field_CheckPartyIndex>();
	}
};
static_assert(alignof(UEndEnvQueryTest_Field_CheckPartyIndex) == 0x000008, "Wrong alignment on UEndEnvQueryTest_Field_CheckPartyIndex");
static_assert(sizeof(UEndEnvQueryTest_Field_CheckPartyIndex) == 0x0001C8, "Wrong size on UEndEnvQueryTest_Field_CheckPartyIndex");
static_assert(offsetof(UEndEnvQueryTest_Field_CheckPartyIndex, m_Index) == 0x0001C0, "Member 'UEndEnvQueryTest_Field_CheckPartyIndex::m_Index' has a wrong offset!");
static_assert(offsetof(UEndEnvQueryTest_Field_CheckPartyIndex, m_ArithmeticOperation) == 0x0001C4, "Member 'UEndEnvQueryTest_Field_CheckPartyIndex::m_ArithmeticOperation' has a wrong offset!");

// Class EndGame.EndInterestPoint
// 0x0138 (0x04B0 - 0x0378)
class AEndInterestPoint final : public AActor
{
public:
	uint8                                         Pad_378[0xC8];                                     // 0x0378(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	EEndInterestPointReactionActorType            Type;                                              // 0x0440(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_441[0x3];                                      // 0x0441(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterestRadius;                                    // 0x0444(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEndInterestPointTemplate                     InterestTemplateID;                                // 0x0448(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_449[0x3];                                      // 0x0449(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   InterestOverrideID;                                // 0x044C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsForcedRecognition;                               // 0x0454(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_455[0x3];                                      // 0x0455(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndTextRenderComponent*                TextRenderComponent;                               // 0x0458(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_460[0x50];                                     // 0x0460(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndInterestPoint">();
	}
	static class AEndInterestPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndInterestPoint>();
	}
};
static_assert(alignof(AEndInterestPoint) == 0x000008, "Wrong alignment on AEndInterestPoint");
static_assert(sizeof(AEndInterestPoint) == 0x0004B0, "Wrong size on AEndInterestPoint");
static_assert(offsetof(AEndInterestPoint, Type) == 0x000440, "Member 'AEndInterestPoint::Type' has a wrong offset!");
static_assert(offsetof(AEndInterestPoint, InterestRadius) == 0x000444, "Member 'AEndInterestPoint::InterestRadius' has a wrong offset!");
static_assert(offsetof(AEndInterestPoint, InterestTemplateID) == 0x000448, "Member 'AEndInterestPoint::InterestTemplateID' has a wrong offset!");
static_assert(offsetof(AEndInterestPoint, InterestOverrideID) == 0x00044C, "Member 'AEndInterestPoint::InterestOverrideID' has a wrong offset!");
static_assert(offsetof(AEndInterestPoint, IsForcedRecognition) == 0x000454, "Member 'AEndInterestPoint::IsForcedRecognition' has a wrong offset!");
static_assert(offsetof(AEndInterestPoint, TextRenderComponent) == 0x000458, "Member 'AEndInterestPoint::TextRenderComponent' has a wrong offset!");

// Class EndGame.EndEnvQueryTest_Field_Escape
// 0x0068 (0x0228 - 0x01C0)
class UEndEnvQueryTest_Field_Escape final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           m_EscapeContext;                                   // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              m_Radius;                                          // 0x01C8(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               m_bEscapeTreasure;                                 // 0x01F8(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryTest_Field_Escape">();
	}
	static class UEndEnvQueryTest_Field_Escape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryTest_Field_Escape>();
	}
};
static_assert(alignof(UEndEnvQueryTest_Field_Escape) == 0x000008, "Wrong alignment on UEndEnvQueryTest_Field_Escape");
static_assert(sizeof(UEndEnvQueryTest_Field_Escape) == 0x000228, "Wrong size on UEndEnvQueryTest_Field_Escape");
static_assert(offsetof(UEndEnvQueryTest_Field_Escape, m_EscapeContext) == 0x0001C0, "Member 'UEndEnvQueryTest_Field_Escape::m_EscapeContext' has a wrong offset!");
static_assert(offsetof(UEndEnvQueryTest_Field_Escape, m_Radius) == 0x0001C8, "Member 'UEndEnvQueryTest_Field_Escape::m_Radius' has a wrong offset!");
static_assert(offsetof(UEndEnvQueryTest_Field_Escape, m_bEscapeTreasure) == 0x0001F8, "Member 'UEndEnvQueryTest_Field_Escape::m_bEscapeTreasure' has a wrong offset!");

// Class EndGame.EndEnvQueryTest_Field_FollowMemberNum
// 0x0008 (0x01C8 - 0x01C0)
class UEndEnvQueryTest_Field_FollowMemberNum final : public UEnvQueryTest
{
public:
	int32                                         m_Num;                                             // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndAiMathCmp                                 m_ArithmeticOperation;                             // 0x01C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C5[0x3];                                      // 0x01C5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryTest_Field_FollowMemberNum">();
	}
	static class UEndEnvQueryTest_Field_FollowMemberNum* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryTest_Field_FollowMemberNum>();
	}
};
static_assert(alignof(UEndEnvQueryTest_Field_FollowMemberNum) == 0x000008, "Wrong alignment on UEndEnvQueryTest_Field_FollowMemberNum");
static_assert(sizeof(UEndEnvQueryTest_Field_FollowMemberNum) == 0x0001C8, "Wrong size on UEndEnvQueryTest_Field_FollowMemberNum");
static_assert(offsetof(UEndEnvQueryTest_Field_FollowMemberNum, m_Num) == 0x0001C0, "Member 'UEndEnvQueryTest_Field_FollowMemberNum::m_Num' has a wrong offset!");
static_assert(offsetof(UEndEnvQueryTest_Field_FollowMemberNum, m_ArithmeticOperation) == 0x0001C4, "Member 'UEndEnvQueryTest_Field_FollowMemberNum::m_ArithmeticOperation' has a wrong offset!");

// Class EndGame.EndEnvQueryTest_HeatValue
// 0x0000 (0x01C0 - 0x01C0)
class UEndEnvQueryTest_HeatValue final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryTest_HeatValue">();
	}
	static class UEndEnvQueryTest_HeatValue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryTest_HeatValue>();
	}
};
static_assert(alignof(UEndEnvQueryTest_HeatValue) == 0x000008, "Wrong alignment on UEndEnvQueryTest_HeatValue");
static_assert(sizeof(UEndEnvQueryTest_HeatValue) == 0x0001C0, "Wrong size on UEndEnvQueryTest_HeatValue");

// Class EndGame.EndFieldActionActorCrouched
// 0x00A8 (0x06C0 - 0x0618)
class AEndFieldActionActorCrouched final : public AEndFieldActionActorBase
{
public:
	ECrouchedType                                 CrouchedType;                                      // 0x0618(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_619[0x7];                                      // 0x0619(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndFieldActionSplineComponent*         CrouchedComponent;                                 // 0x0620(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        EnterVolume;                                       // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        ExitVolume;                                        // 0x0630(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndSwitchAreaBoxComponent*             DividedImpassableEnterVolume;                      // 0x0638(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndSwitchAreaBoxComponent*             DividedImpassableExitVolume;                       // 0x0640(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0648(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWalkPathMove;                                     // 0x0650(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnablePassing;                                    // 0x0651(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndCrouchedMoveType                          CrouchedMoveType;                                  // 0x0652(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_653[0x1];                                      // 0x0653(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GoalDistanceOffsetLeft;                            // 0x0654(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GoalDistanceOffsetRight;                           // 0x0658(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoBoxRotation;                                   // 0x065C(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NavAttributeChange;                                // 0x065D(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65E[0x62];                                     // 0x065E(0x0062)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorCrouched">();
	}
	static class AEndFieldActionActorCrouched* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorCrouched>();
	}
};
static_assert(alignof(AEndFieldActionActorCrouched) == 0x000008, "Wrong alignment on AEndFieldActionActorCrouched");
static_assert(sizeof(AEndFieldActionActorCrouched) == 0x0006C0, "Wrong size on AEndFieldActionActorCrouched");
static_assert(offsetof(AEndFieldActionActorCrouched, CrouchedType) == 0x000618, "Member 'AEndFieldActionActorCrouched::CrouchedType' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCrouched, CrouchedComponent) == 0x000620, "Member 'AEndFieldActionActorCrouched::CrouchedComponent' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCrouched, EnterVolume) == 0x000628, "Member 'AEndFieldActionActorCrouched::EnterVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCrouched, ExitVolume) == 0x000630, "Member 'AEndFieldActionActorCrouched::ExitVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCrouched, DividedImpassableEnterVolume) == 0x000638, "Member 'AEndFieldActionActorCrouched::DividedImpassableEnterVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCrouched, DividedImpassableExitVolume) == 0x000640, "Member 'AEndFieldActionActorCrouched::DividedImpassableExitVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCrouched, ModifierVolume) == 0x000648, "Member 'AEndFieldActionActorCrouched::ModifierVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCrouched, bWalkPathMove) == 0x000650, "Member 'AEndFieldActionActorCrouched::bWalkPathMove' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCrouched, bEnablePassing) == 0x000651, "Member 'AEndFieldActionActorCrouched::bEnablePassing' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCrouched, CrouchedMoveType) == 0x000652, "Member 'AEndFieldActionActorCrouched::CrouchedMoveType' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCrouched, GoalDistanceOffsetLeft) == 0x000654, "Member 'AEndFieldActionActorCrouched::GoalDistanceOffsetLeft' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCrouched, GoalDistanceOffsetRight) == 0x000658, "Member 'AEndFieldActionActorCrouched::GoalDistanceOffsetRight' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCrouched, AutoBoxRotation) == 0x00065C, "Member 'AEndFieldActionActorCrouched::AutoBoxRotation' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCrouched, NavAttributeChange) == 0x00065D, "Member 'AEndFieldActionActorCrouched::NavAttributeChange' has a wrong offset!");

// Class EndGame.EndEnvQueryTest_InCamera
// 0x0000 (0x01C0 - 0x01C0)
class UEndEnvQueryTest_InCamera final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryTest_InCamera">();
	}
	static class UEndEnvQueryTest_InCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryTest_InCamera>();
	}
};
static_assert(alignof(UEndEnvQueryTest_InCamera) == 0x000008, "Wrong alignment on UEndEnvQueryTest_InCamera");
static_assert(sizeof(UEndEnvQueryTest_InCamera) == 0x0001C0, "Wrong size on UEndEnvQueryTest_InCamera");

// Class EndGame.EndEnvQueryTest_LowerCityChildCrony
// 0x0008 (0x01C8 - 0x01C0)
class UEndEnvQueryTest_LowerCityChildCrony final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           m_TargetContext;                                   // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryTest_LowerCityChildCrony">();
	}
	static class UEndEnvQueryTest_LowerCityChildCrony* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryTest_LowerCityChildCrony>();
	}
};
static_assert(alignof(UEndEnvQueryTest_LowerCityChildCrony) == 0x000008, "Wrong alignment on UEndEnvQueryTest_LowerCityChildCrony");
static_assert(sizeof(UEndEnvQueryTest_LowerCityChildCrony) == 0x0001C8, "Wrong size on UEndEnvQueryTest_LowerCityChildCrony");
static_assert(offsetof(UEndEnvQueryTest_LowerCityChildCrony, m_TargetContext) == 0x0001C0, "Member 'UEndEnvQueryTest_LowerCityChildCrony::m_TargetContext' has a wrong offset!");

// Class EndGame.EndEnvQueryTest_NavmeshDistanceRatio
// 0x0040 (0x0200 - 0x01C0)
class UEndEnvQueryTest_NavmeshDistanceRatio final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           Center;                                            // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              Ratio;                                             // 0x01C8(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EEndQueryFilterType                           QueryFilterType;                                   // 0x01F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryTest_NavmeshDistanceRatio">();
	}
	static class UEndEnvQueryTest_NavmeshDistanceRatio* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryTest_NavmeshDistanceRatio>();
	}
};
static_assert(alignof(UEndEnvQueryTest_NavmeshDistanceRatio) == 0x000008, "Wrong alignment on UEndEnvQueryTest_NavmeshDistanceRatio");
static_assert(sizeof(UEndEnvQueryTest_NavmeshDistanceRatio) == 0x000200, "Wrong size on UEndEnvQueryTest_NavmeshDistanceRatio");
static_assert(offsetof(UEndEnvQueryTest_NavmeshDistanceRatio, Center) == 0x0001C0, "Member 'UEndEnvQueryTest_NavmeshDistanceRatio::Center' has a wrong offset!");
static_assert(offsetof(UEndEnvQueryTest_NavmeshDistanceRatio, Ratio) == 0x0001C8, "Member 'UEndEnvQueryTest_NavmeshDistanceRatio::Ratio' has a wrong offset!");
static_assert(offsetof(UEndEnvQueryTest_NavmeshDistanceRatio, QueryFilterType) == 0x0001F8, "Member 'UEndEnvQueryTest_NavmeshDistanceRatio::QueryFilterType' has a wrong offset!");

// Class EndGame.EndEnvQueryTest_NavmeshOcclusion
// 0x0008 (0x01C8 - 0x01C0)
class UEndEnvQueryTest_NavmeshOcclusion final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           Target;                                            // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryTest_NavmeshOcclusion">();
	}
	static class UEndEnvQueryTest_NavmeshOcclusion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryTest_NavmeshOcclusion>();
	}
};
static_assert(alignof(UEndEnvQueryTest_NavmeshOcclusion) == 0x000008, "Wrong alignment on UEndEnvQueryTest_NavmeshOcclusion");
static_assert(sizeof(UEndEnvQueryTest_NavmeshOcclusion) == 0x0001C8, "Wrong size on UEndEnvQueryTest_NavmeshOcclusion");
static_assert(offsetof(UEndEnvQueryTest_NavmeshOcclusion, Target) == 0x0001C0, "Member 'UEndEnvQueryTest_NavmeshOcclusion::Target' has a wrong offset!");

// Class EndGame.EndEnvQueryTest_NavmeshRaycast
// 0x0008 (0x01C8 - 0x01C0)
class UEndEnvQueryTest_NavmeshRaycast final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           Target;                                            // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryTest_NavmeshRaycast">();
	}
	static class UEndEnvQueryTest_NavmeshRaycast* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryTest_NavmeshRaycast>();
	}
};
static_assert(alignof(UEndEnvQueryTest_NavmeshRaycast) == 0x000008, "Wrong alignment on UEndEnvQueryTest_NavmeshRaycast");
static_assert(sizeof(UEndEnvQueryTest_NavmeshRaycast) == 0x0001C8, "Wrong size on UEndEnvQueryTest_NavmeshRaycast");
static_assert(offsetof(UEndEnvQueryTest_NavmeshRaycast, Target) == 0x0001C0, "Member 'UEndEnvQueryTest_NavmeshRaycast::Target' has a wrong offset!");

// Class EndGame.EndWireMeshMoveDoorWayCreateComponent
// 0x0010 (0x0730 - 0x0720)
class UEndWireMeshMoveDoorWayCreateComponent final : public UBoxComponent
{
public:
	EEndWireMeshMoveStartType                     MoveStartType;                                     // 0x0720(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NotCreateGoal;                                     // 0x0721(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_722[0xE];                                      // 0x0722(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndWireMeshMoveDoorWayCreateComponent">();
	}
	static class UEndWireMeshMoveDoorWayCreateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndWireMeshMoveDoorWayCreateComponent>();
	}
};
static_assert(alignof(UEndWireMeshMoveDoorWayCreateComponent) == 0x000010, "Wrong alignment on UEndWireMeshMoveDoorWayCreateComponent");
static_assert(sizeof(UEndWireMeshMoveDoorWayCreateComponent) == 0x000730, "Wrong size on UEndWireMeshMoveDoorWayCreateComponent");
static_assert(offsetof(UEndWireMeshMoveDoorWayCreateComponent, MoveStartType) == 0x000720, "Member 'UEndWireMeshMoveDoorWayCreateComponent::MoveStartType' has a wrong offset!");
static_assert(offsetof(UEndWireMeshMoveDoorWayCreateComponent, NotCreateGoal) == 0x000721, "Member 'UEndWireMeshMoveDoorWayCreateComponent::NotCreateGoal' has a wrong offset!");

// Class EndGame.EndEnvQueryTest_PathDistance
// 0x0008 (0x01C8 - 0x01C0)
class UEndEnvQueryTest_PathDistance final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           DistanceTo;                                        // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryTest_PathDistance">();
	}
	static class UEndEnvQueryTest_PathDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryTest_PathDistance>();
	}
};
static_assert(alignof(UEndEnvQueryTest_PathDistance) == 0x000008, "Wrong alignment on UEndEnvQueryTest_PathDistance");
static_assert(sizeof(UEndEnvQueryTest_PathDistance) == 0x0001C8, "Wrong size on UEndEnvQueryTest_PathDistance");
static_assert(offsetof(UEndEnvQueryTest_PathDistance, DistanceTo) == 0x0001C0, "Member 'UEndEnvQueryTest_PathDistance::DistanceTo' has a wrong offset!");

// Class EndGame.EndEnvQueryTest_SupportFieldMagic
// 0x0000 (0x01C0 - 0x01C0)
class UEndEnvQueryTest_SupportFieldMagic final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryTest_SupportFieldMagic">();
	}
	static class UEndEnvQueryTest_SupportFieldMagic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryTest_SupportFieldMagic>();
	}
};
static_assert(alignof(UEndEnvQueryTest_SupportFieldMagic) == 0x000008, "Wrong alignment on UEndEnvQueryTest_SupportFieldMagic");
static_assert(sizeof(UEndEnvQueryTest_SupportFieldMagic) == 0x0001C0, "Wrong size on UEndEnvQueryTest_SupportFieldMagic");

// Class EndGame.EndFieldActionActorHangMove
// 0x0010 (0x0628 - 0x0618)
class AEndFieldActionActorHangMove final : public AEndFieldActionActorBase
{
public:
	EEndFieldActionHangMoveDirection              MoveDirection;                                     // 0x0618(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_619[0x3];                                      // 0x0619(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MoveStepNum;                                       // 0x061C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        PressVolume;                                       // 0x0620(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorHangMove">();
	}
	static class AEndFieldActionActorHangMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorHangMove>();
	}
};
static_assert(alignof(AEndFieldActionActorHangMove) == 0x000008, "Wrong alignment on AEndFieldActionActorHangMove");
static_assert(sizeof(AEndFieldActionActorHangMove) == 0x000628, "Wrong size on AEndFieldActionActorHangMove");
static_assert(offsetof(AEndFieldActionActorHangMove, MoveDirection) == 0x000618, "Member 'AEndFieldActionActorHangMove::MoveDirection' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorHangMove, MoveStepNum) == 0x00061C, "Member 'AEndFieldActionActorHangMove::MoveStepNum' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorHangMove, PressVolume) == 0x000620, "Member 'AEndFieldActionActorHangMove::PressVolume' has a wrong offset!");

// Class EndGame.EndEnvQueryTest_TreasureFilter
// 0x0000 (0x01C0 - 0x01C0)
class UEndEnvQueryTest_TreasureFilter final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEnvQueryTest_TreasureFilter">();
	}
	static class UEndEnvQueryTest_TreasureFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEnvQueryTest_TreasureFilter>();
	}
};
static_assert(alignof(UEndEnvQueryTest_TreasureFilter) == 0x000008, "Wrong alignment on UEndEnvQueryTest_TreasureFilter");
static_assert(sizeof(UEndEnvQueryTest_TreasureFilter) == 0x0001C0, "Wrong size on UEndEnvQueryTest_TreasureFilter");

// Class EndGame.EndEQContext_DefenceLocation
// 0x0000 (0x0028 - 0x0028)
class UEndEQContext_DefenceLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEQContext_DefenceLocation">();
	}
	static class UEndEQContext_DefenceLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEQContext_DefenceLocation>();
	}
};
static_assert(alignof(UEndEQContext_DefenceLocation) == 0x000008, "Wrong alignment on UEndEQContext_DefenceLocation");
static_assert(sizeof(UEndEQContext_DefenceLocation) == 0x000028, "Wrong size on UEndEQContext_DefenceLocation");

// Class EndGame.EndEQContext_SummonPreciseTarget
// 0x0000 (0x0028 - 0x0028)
class UEndEQContext_SummonPreciseTarget final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEQContext_SummonPreciseTarget">();
	}
	static class UEndEQContext_SummonPreciseTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEQContext_SummonPreciseTarget>();
	}
};
static_assert(alignof(UEndEQContext_SummonPreciseTarget) == 0x000008, "Wrong alignment on UEndEQContext_SummonPreciseTarget");
static_assert(sizeof(UEndEQContext_SummonPreciseTarget) == 0x000028, "Wrong size on UEndEQContext_SummonPreciseTarget");

// Class EndGame.EndEQContext_SummonWarpPoint
// 0x0000 (0x0028 - 0x0028)
class UEndEQContext_SummonWarpPoint final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEQContext_SummonWarpPoint">();
	}
	static class UEndEQContext_SummonWarpPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEQContext_SummonWarpPoint>();
	}
};
static_assert(alignof(UEndEQContext_SummonWarpPoint) == 0x000008, "Wrong alignment on UEndEQContext_SummonWarpPoint");
static_assert(sizeof(UEndEQContext_SummonWarpPoint) == 0x000028, "Wrong size on UEndEQContext_SummonWarpPoint");

// Class EndGame.EndEquipmentCell
// 0x0040 (0x03A0 - 0x0360)
class UEndEquipmentCell : public UEndUserWidget
{
public:
	class UEndImageSet*                           Title_Icon;                                        // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Title;                                         // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        AbilityBox;                                        // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_AccessoryInfo;                                 // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndImage*                              Icon_Clear;                                        // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndProgressBar*                        Gauge_Exp;                                         // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndBillboard*                          Billboard_Character;                               // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndBillboard*                          Billboard_Weapon;                                  // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void UpdateEquipStatus(int32 Attack, int32 Defense, int32 MagicAttack, int32 MagicDefense);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEquipmentCell">();
	}
	static class UEndEquipmentCell* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEquipmentCell>();
	}
};
static_assert(alignof(UEndEquipmentCell) == 0x000008, "Wrong alignment on UEndEquipmentCell");
static_assert(sizeof(UEndEquipmentCell) == 0x0003A0, "Wrong size on UEndEquipmentCell");
static_assert(offsetof(UEndEquipmentCell, Title_Icon) == 0x000360, "Member 'UEndEquipmentCell::Title_Icon' has a wrong offset!");
static_assert(offsetof(UEndEquipmentCell, Txt_Title) == 0x000368, "Member 'UEndEquipmentCell::Txt_Title' has a wrong offset!");
static_assert(offsetof(UEndEquipmentCell, AbilityBox) == 0x000370, "Member 'UEndEquipmentCell::AbilityBox' has a wrong offset!");
static_assert(offsetof(UEndEquipmentCell, Txt_AccessoryInfo) == 0x000378, "Member 'UEndEquipmentCell::Txt_AccessoryInfo' has a wrong offset!");
static_assert(offsetof(UEndEquipmentCell, Icon_Clear) == 0x000380, "Member 'UEndEquipmentCell::Icon_Clear' has a wrong offset!");
static_assert(offsetof(UEndEquipmentCell, Gauge_Exp) == 0x000388, "Member 'UEndEquipmentCell::Gauge_Exp' has a wrong offset!");
static_assert(offsetof(UEndEquipmentCell, Billboard_Character) == 0x000390, "Member 'UEndEquipmentCell::Billboard_Character' has a wrong offset!");
static_assert(offsetof(UEndEquipmentCell, Billboard_Weapon) == 0x000398, "Member 'UEndEquipmentCell::Billboard_Weapon' has a wrong offset!");

// Class EndGame.EndFieldAIEN1008Controller
// 0x0000 (0x5750 - 0x5750)
class AEndFieldAIEN1008Controller final : public AEndFieldAIController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldAIEN1008Controller">();
	}
	static class AEndFieldAIEN1008Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldAIEN1008Controller>();
	}
};
static_assert(alignof(AEndFieldAIEN1008Controller) == 0x000008, "Wrong alignment on AEndFieldAIEN1008Controller");
static_assert(sizeof(AEndFieldAIEN1008Controller) == 0x005750, "Wrong size on AEndFieldAIEN1008Controller");

// Class EndGame.EndEquipmentMateriaInfoWindow
// 0x0238 (0x0598 - 0x0360)
class UEndEquipmentMateriaInfoWindow : public UEndUserWidget
{
public:
	class UEndVirtualScrollBox*                   StarInfoList;                                      // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVerticalBox*                           MateriaInfoBox;                                    // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        InfoWindow;                                        // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Title;                                         // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Title2;                                        // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndVirtualScrollBox*                   MateriaInfoList;                                   // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        TipMovieBox;                                       // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        AbilityInfoBox;                                    // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_MovieInfo;                                     // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndImage*                              Tips;                                              // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Nut_Exp;                                           // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHorizontalBox*                         GaugeBox;                                          // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndProgressBar*                        Gauge_Exp;                                         // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndImage*                              Icon_Clear;                                        // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Info;                                          // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        AccessoryInfoBox;                                  // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_AccessoryInfo;                                 // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_AttributeTitle;                                // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Attribute;                                     // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_StatusTitle;                                   // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Status;                                        // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_408[0x190];                                    // 0x0408(0x0190)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCoreListSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnMateriaInfoListSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	struct FVector2D OnMeasureInfoListSize(int32 CellIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndEquipmentMateriaInfoWindow">();
	}
	static class UEndEquipmentMateriaInfoWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndEquipmentMateriaInfoWindow>();
	}
};
static_assert(alignof(UEndEquipmentMateriaInfoWindow) == 0x000008, "Wrong alignment on UEndEquipmentMateriaInfoWindow");
static_assert(sizeof(UEndEquipmentMateriaInfoWindow) == 0x000598, "Wrong size on UEndEquipmentMateriaInfoWindow");
static_assert(offsetof(UEndEquipmentMateriaInfoWindow, StarInfoList) == 0x000360, "Member 'UEndEquipmentMateriaInfoWindow::StarInfoList' has a wrong offset!");
static_assert(offsetof(UEndEquipmentMateriaInfoWindow, MateriaInfoBox) == 0x000368, "Member 'UEndEquipmentMateriaInfoWindow::MateriaInfoBox' has a wrong offset!");
static_assert(offsetof(UEndEquipmentMateriaInfoWindow, InfoWindow) == 0x000370, "Member 'UEndEquipmentMateriaInfoWindow::InfoWindow' has a wrong offset!");
static_assert(offsetof(UEndEquipmentMateriaInfoWindow, Txt_Title) == 0x000378, "Member 'UEndEquipmentMateriaInfoWindow::Txt_Title' has a wrong offset!");
static_assert(offsetof(UEndEquipmentMateriaInfoWindow, Txt_Title2) == 0x000380, "Member 'UEndEquipmentMateriaInfoWindow::Txt_Title2' has a wrong offset!");
static_assert(offsetof(UEndEquipmentMateriaInfoWindow, MateriaInfoList) == 0x000388, "Member 'UEndEquipmentMateriaInfoWindow::MateriaInfoList' has a wrong offset!");
static_assert(offsetof(UEndEquipmentMateriaInfoWindow, TipMovieBox) == 0x000390, "Member 'UEndEquipmentMateriaInfoWindow::TipMovieBox' has a wrong offset!");
static_assert(offsetof(UEndEquipmentMateriaInfoWindow, AbilityInfoBox) == 0x000398, "Member 'UEndEquipmentMateriaInfoWindow::AbilityInfoBox' has a wrong offset!");
static_assert(offsetof(UEndEquipmentMateriaInfoWindow, Txt_MovieInfo) == 0x0003A0, "Member 'UEndEquipmentMateriaInfoWindow::Txt_MovieInfo' has a wrong offset!");
static_assert(offsetof(UEndEquipmentMateriaInfoWindow, Tips) == 0x0003A8, "Member 'UEndEquipmentMateriaInfoWindow::Tips' has a wrong offset!");
static_assert(offsetof(UEndEquipmentMateriaInfoWindow, Nut_Exp) == 0x0003B0, "Member 'UEndEquipmentMateriaInfoWindow::Nut_Exp' has a wrong offset!");
static_assert(offsetof(UEndEquipmentMateriaInfoWindow, GaugeBox) == 0x0003B8, "Member 'UEndEquipmentMateriaInfoWindow::GaugeBox' has a wrong offset!");
static_assert(offsetof(UEndEquipmentMateriaInfoWindow, Gauge_Exp) == 0x0003C0, "Member 'UEndEquipmentMateriaInfoWindow::Gauge_Exp' has a wrong offset!");
static_assert(offsetof(UEndEquipmentMateriaInfoWindow, Icon_Clear) == 0x0003C8, "Member 'UEndEquipmentMateriaInfoWindow::Icon_Clear' has a wrong offset!");
static_assert(offsetof(UEndEquipmentMateriaInfoWindow, Txt_Info) == 0x0003D0, "Member 'UEndEquipmentMateriaInfoWindow::Txt_Info' has a wrong offset!");
static_assert(offsetof(UEndEquipmentMateriaInfoWindow, AccessoryInfoBox) == 0x0003D8, "Member 'UEndEquipmentMateriaInfoWindow::AccessoryInfoBox' has a wrong offset!");
static_assert(offsetof(UEndEquipmentMateriaInfoWindow, Txt_AccessoryInfo) == 0x0003E0, "Member 'UEndEquipmentMateriaInfoWindow::Txt_AccessoryInfo' has a wrong offset!");
static_assert(offsetof(UEndEquipmentMateriaInfoWindow, Txt_AttributeTitle) == 0x0003E8, "Member 'UEndEquipmentMateriaInfoWindow::Txt_AttributeTitle' has a wrong offset!");
static_assert(offsetof(UEndEquipmentMateriaInfoWindow, Txt_Attribute) == 0x0003F0, "Member 'UEndEquipmentMateriaInfoWindow::Txt_Attribute' has a wrong offset!");
static_assert(offsetof(UEndEquipmentMateriaInfoWindow, Txt_StatusTitle) == 0x0003F8, "Member 'UEndEquipmentMateriaInfoWindow::Txt_StatusTitle' has a wrong offset!");
static_assert(offsetof(UEndEquipmentMateriaInfoWindow, Txt_Status) == 0x000400, "Member 'UEndEquipmentMateriaInfoWindow::Txt_Status' has a wrong offset!");

// Class EndGame.EndExponentialHeightFogController
// 0x0000 (0x0380 - 0x0380)
class AEndExponentialHeightFogController final : public AExponentialHeightFogController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndExponentialHeightFogController">();
	}
	static class AEndExponentialHeightFogController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndExponentialHeightFogController>();
	}
};
static_assert(alignof(AEndExponentialHeightFogController) == 0x000008, "Wrong alignment on AEndExponentialHeightFogController");
static_assert(sizeof(AEndExponentialHeightFogController) == 0x000380, "Wrong size on AEndExponentialHeightFogController");

// Class EndGame.EndFA0122RobotArmCharacter
// 0x0190 (0x2450 - 0x22C0)
class AEndFA0122RobotArmCharacter final : public AEndCharacter
{
public:
	struct FSQEXSEADSoundKey                      Turning;                                           // 0x22B8(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSQEXSEADSoundKey                      StopTurning;                                       // 0x22F0(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   TurnAttachBoneName;                                // 0x2328(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSQEXSEADSoundKey                      Elevating;                                         // 0x2330(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSQEXSEADSoundKey                      StopElevating;                                     // 0x2368(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   ElevateAttachBoneName;                             // 0x23A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSQEXSEADSoundKey                      EnvironmentHit;                                    // 0x23A8(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSQEXSEADSoundKey                      ContainerHit;                                      // 0x23E0(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class USQEXSEADSound*                         TurningSoundAsset;                                 // 0x2418(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USQEXSEADSound*                         StopTurningSoundAsset;                             // 0x2420(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USQEXSEADSound*                         ElevatingSoundAsset;                               // 0x2428(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USQEXSEADSound*                         StopElevatingSoundAsset;                           // 0x2430(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USQEXSEADSound*                         EnvironmentHitSoundAsset;                          // 0x2438(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USQEXSEADSound*                         ContainerHitSoundAsset;                            // 0x2440(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2448[0x8];                                     // 0x2448(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFA0122RobotArmCharacter">();
	}
	static class AEndFA0122RobotArmCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFA0122RobotArmCharacter>();
	}
};
static_assert(alignof(AEndFA0122RobotArmCharacter) == 0x000010, "Wrong alignment on AEndFA0122RobotArmCharacter");
static_assert(sizeof(AEndFA0122RobotArmCharacter) == 0x002450, "Wrong size on AEndFA0122RobotArmCharacter");
static_assert(offsetof(AEndFA0122RobotArmCharacter, Turning) == 0x0022B8, "Member 'AEndFA0122RobotArmCharacter::Turning' has a wrong offset!");
static_assert(offsetof(AEndFA0122RobotArmCharacter, StopTurning) == 0x0022F0, "Member 'AEndFA0122RobotArmCharacter::StopTurning' has a wrong offset!");
static_assert(offsetof(AEndFA0122RobotArmCharacter, TurnAttachBoneName) == 0x002328, "Member 'AEndFA0122RobotArmCharacter::TurnAttachBoneName' has a wrong offset!");
static_assert(offsetof(AEndFA0122RobotArmCharacter, Elevating) == 0x002330, "Member 'AEndFA0122RobotArmCharacter::Elevating' has a wrong offset!");
static_assert(offsetof(AEndFA0122RobotArmCharacter, StopElevating) == 0x002368, "Member 'AEndFA0122RobotArmCharacter::StopElevating' has a wrong offset!");
static_assert(offsetof(AEndFA0122RobotArmCharacter, ElevateAttachBoneName) == 0x0023A0, "Member 'AEndFA0122RobotArmCharacter::ElevateAttachBoneName' has a wrong offset!");
static_assert(offsetof(AEndFA0122RobotArmCharacter, EnvironmentHit) == 0x0023A8, "Member 'AEndFA0122RobotArmCharacter::EnvironmentHit' has a wrong offset!");
static_assert(offsetof(AEndFA0122RobotArmCharacter, ContainerHit) == 0x0023E0, "Member 'AEndFA0122RobotArmCharacter::ContainerHit' has a wrong offset!");
static_assert(offsetof(AEndFA0122RobotArmCharacter, TurningSoundAsset) == 0x002418, "Member 'AEndFA0122RobotArmCharacter::TurningSoundAsset' has a wrong offset!");
static_assert(offsetof(AEndFA0122RobotArmCharacter, StopTurningSoundAsset) == 0x002420, "Member 'AEndFA0122RobotArmCharacter::StopTurningSoundAsset' has a wrong offset!");
static_assert(offsetof(AEndFA0122RobotArmCharacter, ElevatingSoundAsset) == 0x002428, "Member 'AEndFA0122RobotArmCharacter::ElevatingSoundAsset' has a wrong offset!");
static_assert(offsetof(AEndFA0122RobotArmCharacter, StopElevatingSoundAsset) == 0x002430, "Member 'AEndFA0122RobotArmCharacter::StopElevatingSoundAsset' has a wrong offset!");
static_assert(offsetof(AEndFA0122RobotArmCharacter, EnvironmentHitSoundAsset) == 0x002438, "Member 'AEndFA0122RobotArmCharacter::EnvironmentHitSoundAsset' has a wrong offset!");
static_assert(offsetof(AEndFA0122RobotArmCharacter, ContainerHitSoundAsset) == 0x002440, "Member 'AEndFA0122RobotArmCharacter::ContainerHitSoundAsset' has a wrong offset!");

// Class EndGame.EndFacialBlendUserData
// 0x0010 (0x0038 - 0x0028)
class UEndFacialBlendUserData final : public UAssetUserData
{
public:
	TArray<class FName>                           BlendIgnoreBoneNames;                              // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFacialBlendUserData">();
	}
	static class UEndFacialBlendUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndFacialBlendUserData>();
	}
};
static_assert(alignof(UEndFacialBlendUserData) == 0x000008, "Wrong alignment on UEndFacialBlendUserData");
static_assert(sizeof(UEndFacialBlendUserData) == 0x000038, "Wrong size on UEndFacialBlendUserData");
static_assert(offsetof(UEndFacialBlendUserData, BlendIgnoreBoneNames) == 0x000028, "Member 'UEndFacialBlendUserData::BlendIgnoreBoneNames' has a wrong offset!");

// Class EndGame.EndFacialRig
// 0x01E0 (0x0208 - 0x0028)
class UEndFacialRig final : public UObject
{
public:
	TArray<class FName>                           EyeBoneNames;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           EyelidsBoneNames;                                  // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           ForeheadBoneNames;                                 // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           GlabellaBoneNames;                                 // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           BrowBoneNames;                                     // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   EyeMoveBlendSpaceName;                             // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeMoveBlendInterpSpeed;                           // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtWeightBias;                                  // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtUpWeightBias;                                // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SaccadeFrequencyRange;                             // 0x008C(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SaccadeMoveAngleMax;                               // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SaccadeMoveAngleSoftLimitRate;                     // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FixationVelocityThreshold;                         // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MicroSaccadeFrequencyRange;                        // 0x00A0(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MicroSaccadeMoveAngle;                             // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RandomAdditiveSaccadeFrequencyRange;               // 0x00AC(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomAdditiveSaccadeMoveAngle;                    // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RandomAdditiveSaccadeMoveRollRange;                // 0x00B8(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomAdditiveSaccadeTimeDuration;                 // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BlinkPoseName;                                     // 0x00C4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlinkThreshold;                                    // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FullBlinkThreshold;                                // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PeriodicBlinkCurve;                                // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ReflectiveBlinkCurve;                              // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PeriodicBlinkBiasRange;                            // 0x00E8(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefrectiveBlinkSaccadeMoveAngleThreshold;          // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefrectiveBlinkIntervalMin;                        // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              NeutralBlinkFrequencyRange;                        // 0x00F8(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CautionBlinkFrequencyRange;                        // 0x0100(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LipSyncBrowMoveBlendSpaceName;                     // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EmotionBlendSpaceName;                             // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DefaultEmotionBlendInput;                          // 0x0118(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultEmotionBlendInputInterpSpeed;               // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EEndEmotionType, struct FVector2D>       EmotionBlendInputTable;                            // 0x0128(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<EEndEmotionType, float>                  EmotionBlendInputInterpSpeedTable;                 // 0x0178(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UCurveFloat*                            EmotionBlendCurve;                                 // 0x01C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmotionTimeOffset;                                 // 0x01D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EmotionLerpMaxLevel;                               // 0x01D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RandomIdleEmotionWaitTimeRange;                    // 0x01D8(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RandomIdleEmotionKeepTimeRange;                    // 0x01E0(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RandomIdleEmotionBlendInTimeRange;                 // 0x01E8(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RandomIdleEmotionBlendOutTimeRange;                // 0x01F0(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RandomIdleEmotionBlendInputAdditiveRangeX;         // 0x01F8(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RandomIdleEmotionBlendInputAdditiveRangeY;         // 0x0200(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFacialRig">();
	}
	static class UEndFacialRig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndFacialRig>();
	}
};
static_assert(alignof(UEndFacialRig) == 0x000008, "Wrong alignment on UEndFacialRig");
static_assert(sizeof(UEndFacialRig) == 0x000208, "Wrong size on UEndFacialRig");
static_assert(offsetof(UEndFacialRig, EyeBoneNames) == 0x000028, "Member 'UEndFacialRig::EyeBoneNames' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, EyelidsBoneNames) == 0x000038, "Member 'UEndFacialRig::EyelidsBoneNames' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, ForeheadBoneNames) == 0x000048, "Member 'UEndFacialRig::ForeheadBoneNames' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, GlabellaBoneNames) == 0x000058, "Member 'UEndFacialRig::GlabellaBoneNames' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, BrowBoneNames) == 0x000068, "Member 'UEndFacialRig::BrowBoneNames' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, EyeMoveBlendSpaceName) == 0x000078, "Member 'UEndFacialRig::EyeMoveBlendSpaceName' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, EyeMoveBlendInterpSpeed) == 0x000080, "Member 'UEndFacialRig::EyeMoveBlendInterpSpeed' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, LookAtWeightBias) == 0x000084, "Member 'UEndFacialRig::LookAtWeightBias' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, LookAtUpWeightBias) == 0x000088, "Member 'UEndFacialRig::LookAtUpWeightBias' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, SaccadeFrequencyRange) == 0x00008C, "Member 'UEndFacialRig::SaccadeFrequencyRange' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, SaccadeMoveAngleMax) == 0x000094, "Member 'UEndFacialRig::SaccadeMoveAngleMax' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, SaccadeMoveAngleSoftLimitRate) == 0x000098, "Member 'UEndFacialRig::SaccadeMoveAngleSoftLimitRate' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, FixationVelocityThreshold) == 0x00009C, "Member 'UEndFacialRig::FixationVelocityThreshold' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, MicroSaccadeFrequencyRange) == 0x0000A0, "Member 'UEndFacialRig::MicroSaccadeFrequencyRange' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, MicroSaccadeMoveAngle) == 0x0000A8, "Member 'UEndFacialRig::MicroSaccadeMoveAngle' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, RandomAdditiveSaccadeFrequencyRange) == 0x0000AC, "Member 'UEndFacialRig::RandomAdditiveSaccadeFrequencyRange' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, RandomAdditiveSaccadeMoveAngle) == 0x0000B4, "Member 'UEndFacialRig::RandomAdditiveSaccadeMoveAngle' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, RandomAdditiveSaccadeMoveRollRange) == 0x0000B8, "Member 'UEndFacialRig::RandomAdditiveSaccadeMoveRollRange' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, RandomAdditiveSaccadeTimeDuration) == 0x0000C0, "Member 'UEndFacialRig::RandomAdditiveSaccadeTimeDuration' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, BlinkPoseName) == 0x0000C4, "Member 'UEndFacialRig::BlinkPoseName' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, BlinkThreshold) == 0x0000CC, "Member 'UEndFacialRig::BlinkThreshold' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, FullBlinkThreshold) == 0x0000D0, "Member 'UEndFacialRig::FullBlinkThreshold' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, PeriodicBlinkCurve) == 0x0000D8, "Member 'UEndFacialRig::PeriodicBlinkCurve' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, ReflectiveBlinkCurve) == 0x0000E0, "Member 'UEndFacialRig::ReflectiveBlinkCurve' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, PeriodicBlinkBiasRange) == 0x0000E8, "Member 'UEndFacialRig::PeriodicBlinkBiasRange' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, RefrectiveBlinkSaccadeMoveAngleThreshold) == 0x0000F0, "Member 'UEndFacialRig::RefrectiveBlinkSaccadeMoveAngleThreshold' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, RefrectiveBlinkIntervalMin) == 0x0000F4, "Member 'UEndFacialRig::RefrectiveBlinkIntervalMin' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, NeutralBlinkFrequencyRange) == 0x0000F8, "Member 'UEndFacialRig::NeutralBlinkFrequencyRange' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, CautionBlinkFrequencyRange) == 0x000100, "Member 'UEndFacialRig::CautionBlinkFrequencyRange' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, LipSyncBrowMoveBlendSpaceName) == 0x000108, "Member 'UEndFacialRig::LipSyncBrowMoveBlendSpaceName' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, EmotionBlendSpaceName) == 0x000110, "Member 'UEndFacialRig::EmotionBlendSpaceName' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, DefaultEmotionBlendInput) == 0x000118, "Member 'UEndFacialRig::DefaultEmotionBlendInput' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, DefaultEmotionBlendInputInterpSpeed) == 0x000120, "Member 'UEndFacialRig::DefaultEmotionBlendInputInterpSpeed' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, EmotionBlendInputTable) == 0x000128, "Member 'UEndFacialRig::EmotionBlendInputTable' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, EmotionBlendInputInterpSpeedTable) == 0x000178, "Member 'UEndFacialRig::EmotionBlendInputInterpSpeedTable' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, EmotionBlendCurve) == 0x0001C8, "Member 'UEndFacialRig::EmotionBlendCurve' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, EmotionTimeOffset) == 0x0001D0, "Member 'UEndFacialRig::EmotionTimeOffset' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, EmotionLerpMaxLevel) == 0x0001D4, "Member 'UEndFacialRig::EmotionLerpMaxLevel' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, RandomIdleEmotionWaitTimeRange) == 0x0001D8, "Member 'UEndFacialRig::RandomIdleEmotionWaitTimeRange' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, RandomIdleEmotionKeepTimeRange) == 0x0001E0, "Member 'UEndFacialRig::RandomIdleEmotionKeepTimeRange' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, RandomIdleEmotionBlendInTimeRange) == 0x0001E8, "Member 'UEndFacialRig::RandomIdleEmotionBlendInTimeRange' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, RandomIdleEmotionBlendOutTimeRange) == 0x0001F0, "Member 'UEndFacialRig::RandomIdleEmotionBlendOutTimeRange' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, RandomIdleEmotionBlendInputAdditiveRangeX) == 0x0001F8, "Member 'UEndFacialRig::RandomIdleEmotionBlendInputAdditiveRangeX' has a wrong offset!");
static_assert(offsetof(UEndFacialRig, RandomIdleEmotionBlendInputAdditiveRangeY) == 0x000200, "Member 'UEndFacialRig::RandomIdleEmotionBlendInputAdditiveRangeY' has a wrong offset!");

// Class EndGame.EndFeelerWallExActor
// 0x00C0 (0x0440 - 0x0380)
class AEndFeelerWallExActor final : public ATriggerBox
{
public:
	uint8                                         Pad_380[0x10];                                     // 0x0380(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WaveCount;                                         // 0x0390(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRefreshInstance;                                  // 0x0394(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_395[0x3];                                      // 0x0395(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEndFeelerWallExWave>           Waves;                                             // 0x0398(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FEndFeelerWallExSetting                Setting;                                           // 0x03A8(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         FadeInWaitTime;                                    // 0x03E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideFadeInTime;                                // 0x03EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideFadeOutTime;                               // 0x03F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F4[0x4C];                                     // 0x03F4(0x004C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Play(float BlendTime);
	void Stop(float BlendTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFeelerWallExActor">();
	}
	static class AEndFeelerWallExActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFeelerWallExActor>();
	}
};
static_assert(alignof(AEndFeelerWallExActor) == 0x000008, "Wrong alignment on AEndFeelerWallExActor");
static_assert(sizeof(AEndFeelerWallExActor) == 0x000440, "Wrong size on AEndFeelerWallExActor");
static_assert(offsetof(AEndFeelerWallExActor, WaveCount) == 0x000390, "Member 'AEndFeelerWallExActor::WaveCount' has a wrong offset!");
static_assert(offsetof(AEndFeelerWallExActor, bRefreshInstance) == 0x000394, "Member 'AEndFeelerWallExActor::bRefreshInstance' has a wrong offset!");
static_assert(offsetof(AEndFeelerWallExActor, Waves) == 0x000398, "Member 'AEndFeelerWallExActor::Waves' has a wrong offset!");
static_assert(offsetof(AEndFeelerWallExActor, Setting) == 0x0003A8, "Member 'AEndFeelerWallExActor::Setting' has a wrong offset!");
static_assert(offsetof(AEndFeelerWallExActor, FadeInWaitTime) == 0x0003E8, "Member 'AEndFeelerWallExActor::FadeInWaitTime' has a wrong offset!");
static_assert(offsetof(AEndFeelerWallExActor, OverrideFadeInTime) == 0x0003EC, "Member 'AEndFeelerWallExActor::OverrideFadeInTime' has a wrong offset!");
static_assert(offsetof(AEndFeelerWallExActor, OverrideFadeOutTime) == 0x0003F0, "Member 'AEndFeelerWallExActor::OverrideFadeOutTime' has a wrong offset!");

// Class EndGame.EndFieldActionActorAutoDoor
// 0x00F0 (0x0708 - 0x0618)
class AEndFieldActionActorAutoDoor final : public AEndFieldActionActorBase
{
public:
	class FName                                   AnimationActorName;                                // 0x0618(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAutoDoorActiveEffectType                     AutoDoorActiveEffectType;                          // 0x0620(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_621[0x7];                                      // 0x0621(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndFieldActionTriggerComponent*        OpenVolume;                                        // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        CloseVolume;                                       // 0x0630(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndSwitchAreaBoxComponent*             DividedVersatileVolume;                            // 0x0638(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0640(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   PcWallComponent;                                   // 0x0648(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   PartyWallComponent;                                // 0x0650(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   EnemyWallComponent;                                // 0x0658(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            staticMeshObject;                                  // 0x0660(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoClosingTime;                                   // 0x0668(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisablePartyWall;                                  // 0x066C(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableEnemyWall;                                  // 0x066D(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_66E[0x2];                                      // 0x066E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	EEndOneWayType                                Type;                                              // 0x0670(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_674[0x94];                                     // 0x0674(0x0094)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorAutoDoor">();
	}
	static class AEndFieldActionActorAutoDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorAutoDoor>();
	}
};
static_assert(alignof(AEndFieldActionActorAutoDoor) == 0x000008, "Wrong alignment on AEndFieldActionActorAutoDoor");
static_assert(sizeof(AEndFieldActionActorAutoDoor) == 0x000708, "Wrong size on AEndFieldActionActorAutoDoor");
static_assert(offsetof(AEndFieldActionActorAutoDoor, AnimationActorName) == 0x000618, "Member 'AEndFieldActionActorAutoDoor::AnimationActorName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorAutoDoor, AutoDoorActiveEffectType) == 0x000620, "Member 'AEndFieldActionActorAutoDoor::AutoDoorActiveEffectType' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorAutoDoor, OpenVolume) == 0x000628, "Member 'AEndFieldActionActorAutoDoor::OpenVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorAutoDoor, CloseVolume) == 0x000630, "Member 'AEndFieldActionActorAutoDoor::CloseVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorAutoDoor, DividedVersatileVolume) == 0x000638, "Member 'AEndFieldActionActorAutoDoor::DividedVersatileVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorAutoDoor, ModifierVolume) == 0x000640, "Member 'AEndFieldActionActorAutoDoor::ModifierVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorAutoDoor, PcWallComponent) == 0x000648, "Member 'AEndFieldActionActorAutoDoor::PcWallComponent' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorAutoDoor, PartyWallComponent) == 0x000650, "Member 'AEndFieldActionActorAutoDoor::PartyWallComponent' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorAutoDoor, EnemyWallComponent) == 0x000658, "Member 'AEndFieldActionActorAutoDoor::EnemyWallComponent' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorAutoDoor, staticMeshObject) == 0x000660, "Member 'AEndFieldActionActorAutoDoor::staticMeshObject' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorAutoDoor, AutoClosingTime) == 0x000668, "Member 'AEndFieldActionActorAutoDoor::AutoClosingTime' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorAutoDoor, DisablePartyWall) == 0x00066C, "Member 'AEndFieldActionActorAutoDoor::DisablePartyWall' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorAutoDoor, DisableEnemyWall) == 0x00066D, "Member 'AEndFieldActionActorAutoDoor::DisableEnemyWall' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorAutoDoor, Type) == 0x000670, "Member 'AEndFieldActionActorAutoDoor::Type' has a wrong offset!");

// Class EndGame.EndFieldActionDrawComponent
// 0x0000 (0x00F8 - 0x00F8)
class UEndFieldActionDrawComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionDrawComponent">();
	}
	static class UEndFieldActionDrawComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndFieldActionDrawComponent>();
	}
};
static_assert(alignof(UEndFieldActionDrawComponent) == 0x000008, "Wrong alignment on UEndFieldActionDrawComponent");
static_assert(sizeof(UEndFieldActionDrawComponent) == 0x0000F8, "Wrong size on UEndFieldActionDrawComponent");

// Class EndGame.EndFieldActionActorCocoon
// 0x0088 (0x06A0 - 0x0618)
class AEndFieldActionActorCocoon final : public AEndFieldActionActorBase
{
public:
	class FName                                   AnimationActorName;                                // 0x0618(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        EnterVolume;                                       // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndSwitchAreaBoxComponent*             DividedImpassableEnterVolume;                      // 0x0628(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndSwitchAreaBoxComponent*             DividedImpassableExitVolume;                       // 0x0630(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          WallVolume;                                        // 0x0638(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0640(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_648[0x58];                                     // 0x0648(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorCocoon">();
	}
	static class AEndFieldActionActorCocoon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorCocoon>();
	}
};
static_assert(alignof(AEndFieldActionActorCocoon) == 0x000008, "Wrong alignment on AEndFieldActionActorCocoon");
static_assert(sizeof(AEndFieldActionActorCocoon) == 0x0006A0, "Wrong size on AEndFieldActionActorCocoon");
static_assert(offsetof(AEndFieldActionActorCocoon, AnimationActorName) == 0x000618, "Member 'AEndFieldActionActorCocoon::AnimationActorName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCocoon, EnterVolume) == 0x000620, "Member 'AEndFieldActionActorCocoon::EnterVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCocoon, DividedImpassableEnterVolume) == 0x000628, "Member 'AEndFieldActionActorCocoon::DividedImpassableEnterVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCocoon, DividedImpassableExitVolume) == 0x000630, "Member 'AEndFieldActionActorCocoon::DividedImpassableExitVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCocoon, WallVolume) == 0x000638, "Member 'AEndFieldActionActorCocoon::WallVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCocoon, ModifierVolume) == 0x000640, "Member 'AEndFieldActionActorCocoon::ModifierVolume' has a wrong offset!");

// Class EndGame.EndFieldActionActorCrack
// 0x0088 (0x06A0 - 0x0618)
class AEndFieldActionActorCrack final : public AEndFieldActionActorBase
{
public:
	class UEndFieldActionSplineComponent*         CrackComponent;                                    // 0x0618(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        EnterVolume;                                       // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        ExitVolume;                                        // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndSwitchAreaBoxComponent*             DividedImpassableEnterVolume;                      // 0x0630(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndSwitchAreaBoxComponent*             DividedImpassableExitVolume;                       // 0x0638(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0640(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWalkPathMove;                                     // 0x0648(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndCrackMoveType                             CrackMoveType;                                     // 0x0649(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64A[0x2];                                      // 0x064A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GoalDistanceOffsetLeft;                            // 0x064C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GoalDistanceOffsetRight;                           // 0x0650(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ExceptionFlg;                                      // 0x0654(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_655[0x4B];                                     // 0x0655(0x004B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorCrack">();
	}
	static class AEndFieldActionActorCrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorCrack>();
	}
};
static_assert(alignof(AEndFieldActionActorCrack) == 0x000008, "Wrong alignment on AEndFieldActionActorCrack");
static_assert(sizeof(AEndFieldActionActorCrack) == 0x0006A0, "Wrong size on AEndFieldActionActorCrack");
static_assert(offsetof(AEndFieldActionActorCrack, CrackComponent) == 0x000618, "Member 'AEndFieldActionActorCrack::CrackComponent' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCrack, EnterVolume) == 0x000620, "Member 'AEndFieldActionActorCrack::EnterVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCrack, ExitVolume) == 0x000628, "Member 'AEndFieldActionActorCrack::ExitVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCrack, DividedImpassableEnterVolume) == 0x000630, "Member 'AEndFieldActionActorCrack::DividedImpassableEnterVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCrack, DividedImpassableExitVolume) == 0x000638, "Member 'AEndFieldActionActorCrack::DividedImpassableExitVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCrack, ModifierVolume) == 0x000640, "Member 'AEndFieldActionActorCrack::ModifierVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCrack, bWalkPathMove) == 0x000648, "Member 'AEndFieldActionActorCrack::bWalkPathMove' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCrack, CrackMoveType) == 0x000649, "Member 'AEndFieldActionActorCrack::CrackMoveType' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCrack, GoalDistanceOffsetLeft) == 0x00064C, "Member 'AEndFieldActionActorCrack::GoalDistanceOffsetLeft' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCrack, GoalDistanceOffsetRight) == 0x000650, "Member 'AEndFieldActionActorCrack::GoalDistanceOffsetRight' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorCrack, ExceptionFlg) == 0x000654, "Member 'AEndFieldActionActorCrack::ExceptionFlg' has a wrong offset!");

// Class EndGame.EndFieldActionActorDoor
// 0x0100 (0x0718 - 0x0618)
class AEndFieldActionActorDoor final : public AEndFieldActionActorBase
{
public:
	bool                                          bApplyUpdateOpenNavArea;                           // 0x0618(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDoorType                                     DoorType;                                          // 0x0619(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61A[0x2];                                      // 0x061A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AnimationActorName;                                // 0x061C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableForceAutoClose;                             // 0x0624(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDoorActiveEffectType                         DoorActiveEffectType;                              // 0x0625(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTargetIconAdjustment;                             // 0x0626(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_627[0x1];                                      // 0x0627(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetIconPress;                                   // 0x0628(0x000C)(Edit, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetIconPull;                                    // 0x0634(0x000C)(Edit, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FindControllerKey;                                 // 0x0640(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LightMapOverrideVolumeLevelName;                   // 0x0644(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LightMapOverrideVolumeName;                        // 0x064C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartTurnHandleTrigger;                            // 0x0654(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndTurnHandleTrigger;                              // 0x065C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CameraFlavorDatatableName;                         // 0x0664(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_66C[0x4];                                      // 0x066C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndFieldActionTriggerComponent*        PressVolume;                                       // 0x0670(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        PullVolume;                                        // 0x0678(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndSwitchAreaBoxComponent*             DividedVersatileVolume;                            // 0x0680(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndSwitchAreaBoxComponent*             DividedImpassableVolume;                           // 0x0688(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndSwitchAreaBoxComponent*             OpendDoorVolumeLeft;                               // 0x0690(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndSwitchAreaBoxComponent*             OpendDoorVolumeRight;                              // 0x0698(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndSwitchAreaBoxComponent*             OpendDoorVolumeLeft2;                              // 0x06A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndSwitchAreaBoxComponent*             OpendDoorVolumeRight2;                             // 0x06A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x06B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B8[0x60];                                     // 0x06B8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorDoor">();
	}
	static class AEndFieldActionActorDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorDoor>();
	}
};
static_assert(alignof(AEndFieldActionActorDoor) == 0x000008, "Wrong alignment on AEndFieldActionActorDoor");
static_assert(sizeof(AEndFieldActionActorDoor) == 0x000718, "Wrong size on AEndFieldActionActorDoor");
static_assert(offsetof(AEndFieldActionActorDoor, bApplyUpdateOpenNavArea) == 0x000618, "Member 'AEndFieldActionActorDoor::bApplyUpdateOpenNavArea' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorDoor, DoorType) == 0x000619, "Member 'AEndFieldActionActorDoor::DoorType' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorDoor, AnimationActorName) == 0x00061C, "Member 'AEndFieldActionActorDoor::AnimationActorName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorDoor, DisableForceAutoClose) == 0x000624, "Member 'AEndFieldActionActorDoor::DisableForceAutoClose' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorDoor, DoorActiveEffectType) == 0x000625, "Member 'AEndFieldActionActorDoor::DoorActiveEffectType' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorDoor, bTargetIconAdjustment) == 0x000626, "Member 'AEndFieldActionActorDoor::bTargetIconAdjustment' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorDoor, TargetIconPress) == 0x000628, "Member 'AEndFieldActionActorDoor::TargetIconPress' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorDoor, TargetIconPull) == 0x000634, "Member 'AEndFieldActionActorDoor::TargetIconPull' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorDoor, FindControllerKey) == 0x000640, "Member 'AEndFieldActionActorDoor::FindControllerKey' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorDoor, LightMapOverrideVolumeLevelName) == 0x000644, "Member 'AEndFieldActionActorDoor::LightMapOverrideVolumeLevelName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorDoor, LightMapOverrideVolumeName) == 0x00064C, "Member 'AEndFieldActionActorDoor::LightMapOverrideVolumeName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorDoor, StartTurnHandleTrigger) == 0x000654, "Member 'AEndFieldActionActorDoor::StartTurnHandleTrigger' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorDoor, EndTurnHandleTrigger) == 0x00065C, "Member 'AEndFieldActionActorDoor::EndTurnHandleTrigger' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorDoor, CameraFlavorDatatableName) == 0x000664, "Member 'AEndFieldActionActorDoor::CameraFlavorDatatableName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorDoor, PressVolume) == 0x000670, "Member 'AEndFieldActionActorDoor::PressVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorDoor, PullVolume) == 0x000678, "Member 'AEndFieldActionActorDoor::PullVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorDoor, DividedVersatileVolume) == 0x000680, "Member 'AEndFieldActionActorDoor::DividedVersatileVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorDoor, DividedImpassableVolume) == 0x000688, "Member 'AEndFieldActionActorDoor::DividedImpassableVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorDoor, OpendDoorVolumeLeft) == 0x000690, "Member 'AEndFieldActionActorDoor::OpendDoorVolumeLeft' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorDoor, OpendDoorVolumeRight) == 0x000698, "Member 'AEndFieldActionActorDoor::OpendDoorVolumeRight' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorDoor, OpendDoorVolumeLeft2) == 0x0006A0, "Member 'AEndFieldActionActorDoor::OpendDoorVolumeLeft2' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorDoor, OpendDoorVolumeRight2) == 0x0006A8, "Member 'AEndFieldActionActorDoor::OpendDoorVolumeRight2' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorDoor, ModifierVolume) == 0x0006B0, "Member 'AEndFieldActionActorDoor::ModifierVolume' has a wrong offset!");

// Class EndGame.EndFieldActionActorEvade
// 0x0068 (0x0680 - 0x0618)
class AEndFieldActionActorEvade final : public AEndFieldActionActorBase
{
public:
	EEvadeActionType                              EvadeActionType;                                   // 0x0618(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEvadeType                                    EvadeType;                                         // 0x0619(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61A[0x6];                                      // 0x061A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndFieldActionTriggerComponent*        EnterVolume;                                       // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        ExitVolume;                                        // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0630(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_638[0x48];                                     // 0x0638(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorEvade">();
	}
	static class AEndFieldActionActorEvade* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorEvade>();
	}
};
static_assert(alignof(AEndFieldActionActorEvade) == 0x000008, "Wrong alignment on AEndFieldActionActorEvade");
static_assert(sizeof(AEndFieldActionActorEvade) == 0x000680, "Wrong size on AEndFieldActionActorEvade");
static_assert(offsetof(AEndFieldActionActorEvade, EvadeActionType) == 0x000618, "Member 'AEndFieldActionActorEvade::EvadeActionType' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorEvade, EvadeType) == 0x000619, "Member 'AEndFieldActionActorEvade::EvadeType' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorEvade, EnterVolume) == 0x000620, "Member 'AEndFieldActionActorEvade::EnterVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorEvade, ExitVolume) == 0x000628, "Member 'AEndFieldActionActorEvade::ExitVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorEvade, ModifierVolume) == 0x000630, "Member 'AEndFieldActionActorEvade::ModifierVolume' has a wrong offset!");

// Class EndGame.EndHoocShotTriggerComponent
// 0x0000 (0x0740 - 0x0740)
class UEndHoocShotTriggerComponent final : public UEndFieldActionTriggerComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndHoocShotTriggerComponent">();
	}
	static class UEndHoocShotTriggerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndHoocShotTriggerComponent>();
	}
};
static_assert(alignof(UEndHoocShotTriggerComponent) == 0x000010, "Wrong alignment on UEndHoocShotTriggerComponent");
static_assert(sizeof(UEndHoocShotTriggerComponent) == 0x000740, "Wrong size on UEndHoocShotTriggerComponent");

// Class EndGame.EndMonkeyBarCreateBoxComponent
// 0x0010 (0x0730 - 0x0720)
class UEndMonkeyBarCreateBoxComponent final : public UBoxComponent
{
public:
	uint8                                         BoxID;                                             // 0x0720(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_721[0xF];                                      // 0x0721(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMonkeyBarCreateBoxComponent">();
	}
	static class UEndMonkeyBarCreateBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMonkeyBarCreateBoxComponent>();
	}
};
static_assert(alignof(UEndMonkeyBarCreateBoxComponent) == 0x000010, "Wrong alignment on UEndMonkeyBarCreateBoxComponent");
static_assert(sizeof(UEndMonkeyBarCreateBoxComponent) == 0x000730, "Wrong size on UEndMonkeyBarCreateBoxComponent");
static_assert(offsetof(UEndMonkeyBarCreateBoxComponent, BoxID) == 0x000720, "Member 'UEndMonkeyBarCreateBoxComponent::BoxID' has a wrong offset!");

// Class EndGame.EndFieldActionActorPoleSlider
// 0x0068 (0x0680 - 0x0618)
class AEndFieldActionActorPoleSlider final : public AEndFieldActionActorBase
{
public:
	class UEndFieldActionTriggerComponent*        UpperVolume;                                       // 0x0618(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        LowerVolume;                                       // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0628(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeaveAngle;                                        // 0x0630(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_634[0x4C];                                     // 0x0634(0x004C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorPoleSlider">();
	}
	static class AEndFieldActionActorPoleSlider* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorPoleSlider>();
	}
};
static_assert(alignof(AEndFieldActionActorPoleSlider) == 0x000008, "Wrong alignment on AEndFieldActionActorPoleSlider");
static_assert(sizeof(AEndFieldActionActorPoleSlider) == 0x000680, "Wrong size on AEndFieldActionActorPoleSlider");
static_assert(offsetof(AEndFieldActionActorPoleSlider, UpperVolume) == 0x000618, "Member 'AEndFieldActionActorPoleSlider::UpperVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorPoleSlider, LowerVolume) == 0x000620, "Member 'AEndFieldActionActorPoleSlider::LowerVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorPoleSlider, ModifierVolume) == 0x000628, "Member 'AEndFieldActionActorPoleSlider::ModifierVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorPoleSlider, LeaveAngle) == 0x000630, "Member 'AEndFieldActionActorPoleSlider::LeaveAngle' has a wrong offset!");

// Class EndGame.EndFieldActionActorPushContainer
// 0x0040 (0x0658 - 0x0618)
class AEndFieldActionActorPushContainer final : public AEndFieldActionActorBase
{
public:
	class FName                                   EnvActorName;                                      // 0x0618(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LongPushTime;                                      // 0x0620(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LastPushStartTrigger;                              // 0x0624(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PushCompletedTrigger;                              // 0x062C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_634[0x4];                                      // 0x0634(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndFieldActionTriggerComponent*        PushVolume;                                        // 0x0638(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_640[0x18];                                     // 0x0640(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorPushContainer">();
	}
	static class AEndFieldActionActorPushContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorPushContainer>();
	}
};
static_assert(alignof(AEndFieldActionActorPushContainer) == 0x000008, "Wrong alignment on AEndFieldActionActorPushContainer");
static_assert(sizeof(AEndFieldActionActorPushContainer) == 0x000658, "Wrong size on AEndFieldActionActorPushContainer");
static_assert(offsetof(AEndFieldActionActorPushContainer, EnvActorName) == 0x000618, "Member 'AEndFieldActionActorPushContainer::EnvActorName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorPushContainer, LongPushTime) == 0x000620, "Member 'AEndFieldActionActorPushContainer::LongPushTime' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorPushContainer, LastPushStartTrigger) == 0x000624, "Member 'AEndFieldActionActorPushContainer::LastPushStartTrigger' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorPushContainer, PushCompletedTrigger) == 0x00062C, "Member 'AEndFieldActionActorPushContainer::PushCompletedTrigger' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorPushContainer, PushVolume) == 0x000638, "Member 'AEndFieldActionActorPushContainer::PushVolume' has a wrong offset!");

// Class EndGame.EndFieldActionActorRubbleJump
// 0x0068 (0x0680 - 0x0618)
class AEndFieldActionActorRubbleJump final : public AEndFieldActionActorBase
{
public:
	ERubbleJumpType                               JumpType;                                          // 0x0618(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HiddenEffect;                                      // 0x0619(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61A[0x6];                                      // 0x061A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndFieldActionTriggerComponent*        EnterVolume;                                       // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        ExitVolume;                                        // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0630(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_638[0x48];                                     // 0x0638(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorRubbleJump">();
	}
	static class AEndFieldActionActorRubbleJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorRubbleJump>();
	}
};
static_assert(alignof(AEndFieldActionActorRubbleJump) == 0x000008, "Wrong alignment on AEndFieldActionActorRubbleJump");
static_assert(sizeof(AEndFieldActionActorRubbleJump) == 0x000680, "Wrong size on AEndFieldActionActorRubbleJump");
static_assert(offsetof(AEndFieldActionActorRubbleJump, JumpType) == 0x000618, "Member 'AEndFieldActionActorRubbleJump::JumpType' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorRubbleJump, HiddenEffect) == 0x000619, "Member 'AEndFieldActionActorRubbleJump::HiddenEffect' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorRubbleJump, EnterVolume) == 0x000620, "Member 'AEndFieldActionActorRubbleJump::EnterVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorRubbleJump, ExitVolume) == 0x000628, "Member 'AEndFieldActionActorRubbleJump::ExitVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorRubbleJump, ModifierVolume) == 0x000630, "Member 'AEndFieldActionActorRubbleJump::ModifierVolume' has a wrong offset!");

// Class EndGame.EndFieldActionActorTrap
// 0x0068 (0x0680 - 0x0618)
class AEndFieldActionActorTrap final : public AEndFieldActionActorBase
{
public:
	class UEndFieldActionTriggerComponent*        EnterVolume;                                       // 0x0618(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        ExitVolume;                                        // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0628(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_630[0x50];                                     // 0x0630(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorTrap">();
	}
	static class AEndFieldActionActorTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorTrap>();
	}
};
static_assert(alignof(AEndFieldActionActorTrap) == 0x000008, "Wrong alignment on AEndFieldActionActorTrap");
static_assert(sizeof(AEndFieldActionActorTrap) == 0x000680, "Wrong size on AEndFieldActionActorTrap");
static_assert(offsetof(AEndFieldActionActorTrap, EnterVolume) == 0x000618, "Member 'AEndFieldActionActorTrap::EnterVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorTrap, ExitVolume) == 0x000620, "Member 'AEndFieldActionActorTrap::ExitVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorTrap, ModifierVolume) == 0x000628, "Member 'AEndFieldActionActorTrap::ModifierVolume' has a wrong offset!");

// Class EndGame.EndFieldActionActorWallRun
// 0x0070 (0x0688 - 0x0618)
class AEndFieldActionActorWallRun final : public AEndFieldActionActorBase
{
public:
	EWallRunMoveType                              MoveType;                                          // 0x0618(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_619[0x3];                                      // 0x0619(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OnStartNavTriggerName;                             // 0x061C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OnEndNavTriggerName;                               // 0x0624(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OnStandByTriggerName;                              // 0x062C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OnStartTriggerName;                                // 0x0634(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OnArrivalTriggerName;                              // 0x063C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OnReturnStartTriggerName;                          // 0x0644(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OnReturnEndTriggerName;                            // 0x064C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_654[0x4];                                      // 0x0654(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndFieldActionTriggerComponent*        RangeVolume;                                       // 0x0658(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        IconMarkerVolume;                                  // 0x0660(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        TargetWaitVolume;                                  // 0x0668(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0670(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_678[0x10];                                     // 0x0678(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorWallRun">();
	}
	static class AEndFieldActionActorWallRun* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorWallRun>();
	}
};
static_assert(alignof(AEndFieldActionActorWallRun) == 0x000008, "Wrong alignment on AEndFieldActionActorWallRun");
static_assert(sizeof(AEndFieldActionActorWallRun) == 0x000688, "Wrong size on AEndFieldActionActorWallRun");
static_assert(offsetof(AEndFieldActionActorWallRun, MoveType) == 0x000618, "Member 'AEndFieldActionActorWallRun::MoveType' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorWallRun, OnStartNavTriggerName) == 0x00061C, "Member 'AEndFieldActionActorWallRun::OnStartNavTriggerName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorWallRun, OnEndNavTriggerName) == 0x000624, "Member 'AEndFieldActionActorWallRun::OnEndNavTriggerName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorWallRun, OnStandByTriggerName) == 0x00062C, "Member 'AEndFieldActionActorWallRun::OnStandByTriggerName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorWallRun, OnStartTriggerName) == 0x000634, "Member 'AEndFieldActionActorWallRun::OnStartTriggerName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorWallRun, OnArrivalTriggerName) == 0x00063C, "Member 'AEndFieldActionActorWallRun::OnArrivalTriggerName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorWallRun, OnReturnStartTriggerName) == 0x000644, "Member 'AEndFieldActionActorWallRun::OnReturnStartTriggerName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorWallRun, OnReturnEndTriggerName) == 0x00064C, "Member 'AEndFieldActionActorWallRun::OnReturnEndTriggerName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorWallRun, RangeVolume) == 0x000658, "Member 'AEndFieldActionActorWallRun::RangeVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorWallRun, IconMarkerVolume) == 0x000660, "Member 'AEndFieldActionActorWallRun::IconMarkerVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorWallRun, TargetWaitVolume) == 0x000668, "Member 'AEndFieldActionActorWallRun::TargetWaitVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorWallRun, ModifierVolume) == 0x000670, "Member 'AEndFieldActionActorWallRun::ModifierVolume' has a wrong offset!");

// Class EndGame.EndWireMeshMoveDrawComponent
// 0x0000 (0x00F8 - 0x00F8)
class UEndWireMeshMoveDrawComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndWireMeshMoveDrawComponent">();
	}
	static class UEndWireMeshMoveDrawComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndWireMeshMoveDrawComponent>();
	}
};
static_assert(alignof(UEndWireMeshMoveDrawComponent) == 0x000008, "Wrong alignment on UEndWireMeshMoveDrawComponent");
static_assert(sizeof(UEndWireMeshMoveDrawComponent) == 0x0000F8, "Wrong size on UEndWireMeshMoveDrawComponent");

// Class EndGame.EndWireMeshMovePointCreateBoxComponent
// 0x0000 (0x0720 - 0x0720)
class UEndWireMeshMovePointCreateBoxComponent final : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndWireMeshMovePointCreateBoxComponent">();
	}
	static class UEndWireMeshMovePointCreateBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndWireMeshMovePointCreateBoxComponent>();
	}
};
static_assert(alignof(UEndWireMeshMovePointCreateBoxComponent) == 0x000010, "Wrong alignment on UEndWireMeshMovePointCreateBoxComponent");
static_assert(sizeof(UEndWireMeshMovePointCreateBoxComponent) == 0x000720, "Wrong size on UEndWireMeshMovePointCreateBoxComponent");

// Class EndGame.EndFieldActionActorWMElevator
// 0x00F8 (0x0710 - 0x0618)
class AEndFieldActionActorWMElevator final : public AEndFieldActionActorBase
{
public:
	class UEndFieldActionTriggerComponent*        OutSideVolume;                                     // 0x0618(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        InSideVolume;                                      // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFieldActionTriggerComponent*        InSideCollisionVolume;                             // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          LeaderMovePointVolume;                             // 0x0630(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          PartyMovePointVolume1;                             // 0x0638(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          PartyMovePointVolume2;                             // 0x0640(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x0648(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AnimationActorName;                                // 0x0650(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NextWMElevatorFieldActorName;                      // 0x0658(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FadeOutAfterTrigger;                               // 0x0660(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CameraShakeStartTrigger;                           // 0x0668(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InSideMenuTitleID;                                 // 0x0670(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AnimationBackEnvActorName;                         // 0x0678(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReverseBackEnvPlay;                             // 0x0680(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_681[0x8F];                                     // 0x0681(0x008F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionActorWMElevator">();
	}
	static class AEndFieldActionActorWMElevator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionActorWMElevator>();
	}
};
static_assert(alignof(AEndFieldActionActorWMElevator) == 0x000008, "Wrong alignment on AEndFieldActionActorWMElevator");
static_assert(sizeof(AEndFieldActionActorWMElevator) == 0x000710, "Wrong size on AEndFieldActionActorWMElevator");
static_assert(offsetof(AEndFieldActionActorWMElevator, OutSideVolume) == 0x000618, "Member 'AEndFieldActionActorWMElevator::OutSideVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorWMElevator, InSideVolume) == 0x000620, "Member 'AEndFieldActionActorWMElevator::InSideVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorWMElevator, InSideCollisionVolume) == 0x000628, "Member 'AEndFieldActionActorWMElevator::InSideCollisionVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorWMElevator, LeaderMovePointVolume) == 0x000630, "Member 'AEndFieldActionActorWMElevator::LeaderMovePointVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorWMElevator, PartyMovePointVolume1) == 0x000638, "Member 'AEndFieldActionActorWMElevator::PartyMovePointVolume1' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorWMElevator, PartyMovePointVolume2) == 0x000640, "Member 'AEndFieldActionActorWMElevator::PartyMovePointVolume2' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorWMElevator, ModifierVolume) == 0x000648, "Member 'AEndFieldActionActorWMElevator::ModifierVolume' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorWMElevator, AnimationActorName) == 0x000650, "Member 'AEndFieldActionActorWMElevator::AnimationActorName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorWMElevator, NextWMElevatorFieldActorName) == 0x000658, "Member 'AEndFieldActionActorWMElevator::NextWMElevatorFieldActorName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorWMElevator, FadeOutAfterTrigger) == 0x000660, "Member 'AEndFieldActionActorWMElevator::FadeOutAfterTrigger' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorWMElevator, CameraShakeStartTrigger) == 0x000668, "Member 'AEndFieldActionActorWMElevator::CameraShakeStartTrigger' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorWMElevator, InSideMenuTitleID) == 0x000670, "Member 'AEndFieldActionActorWMElevator::InSideMenuTitleID' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorWMElevator, AnimationBackEnvActorName) == 0x000678, "Member 'AEndFieldActionActorWMElevator::AnimationBackEnvActorName' has a wrong offset!");
static_assert(offsetof(AEndFieldActionActorWMElevator, bIsReverseBackEnvPlay) == 0x000680, "Member 'AEndFieldActionActorWMElevator::bIsReverseBackEnvPlay' has a wrong offset!");

// Class EndGame.EndFieldActionWallVolume
// 0x0008 (0x0380 - 0x0378)
class AEndFieldActionWallVolume final : public AActor
{
public:
	class UBoxComponent*                          BoxComponent;                                      // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldActionWallVolume">();
	}
	static class AEndFieldActionWallVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldActionWallVolume>();
	}
};
static_assert(alignof(AEndFieldActionWallVolume) == 0x000008, "Wrong alignment on AEndFieldActionWallVolume");
static_assert(sizeof(AEndFieldActionWallVolume) == 0x000380, "Wrong size on AEndFieldActionWallVolume");
static_assert(offsetof(AEndFieldActionWallVolume, BoxComponent) == 0x000378, "Member 'AEndFieldActionWallVolume::BoxComponent' has a wrong offset!");

// Class EndGame.EndFieldAIVE0002Controller
// 0x0040 (0x5790 - 0x5750)
class AEndFieldAIVE0002Controller final : public AEndFieldAIController
{
public:
	uint8                                         Pad_5750[0x40];                                    // 0x5750(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldAIVE0002Controller">();
	}
	static class AEndFieldAIVE0002Controller* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldAIVE0002Controller>();
	}
};
static_assert(alignof(AEndFieldAIVE0002Controller) == 0x000008, "Wrong alignment on AEndFieldAIVE0002Controller");
static_assert(sizeof(AEndFieldAIVE0002Controller) == 0x005790, "Wrong size on AEndFieldAIVE0002Controller");

// Class EndGame.EndFieldAttakDisableBoxActor
// 0x0000 (0x0380 - 0x0380)
class AEndFieldAttakDisableBoxActor final : public ATriggerBox
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldAttakDisableBoxActor">();
	}
	static class AEndFieldAttakDisableBoxActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldAttakDisableBoxActor>();
	}
};
static_assert(alignof(AEndFieldAttakDisableBoxActor) == 0x000008, "Wrong alignment on AEndFieldAttakDisableBoxActor");
static_assert(sizeof(AEndFieldAttakDisableBoxActor) == 0x000380, "Wrong size on AEndFieldAttakDisableBoxActor");

// Class EndGame.EndFieldCameraOperator
// 0x06F8 (0x0A70 - 0x0378)
class AEndFieldCameraOperator final : public AActor
{
public:
	uint8                                         Pad_378[0x258];                                    // 0x0378(0x0258)(Fixing Size After Last Property [ Dumper-7 ])
	class AEndCharacter*                          ownerChara;                                        // 0x05D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D8[0x498];                                    // 0x05D8(0x0498)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOwnerCharaChangedAttachedActors();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldCameraOperator">();
	}
	static class AEndFieldCameraOperator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndFieldCameraOperator>();
	}
};
static_assert(alignof(AEndFieldCameraOperator) == 0x000008, "Wrong alignment on AEndFieldCameraOperator");
static_assert(sizeof(AEndFieldCameraOperator) == 0x000A70, "Wrong size on AEndFieldCameraOperator");
static_assert(offsetof(AEndFieldCameraOperator, ownerChara) == 0x0005D0, "Member 'AEndFieldCameraOperator::ownerChara' has a wrong offset!");

// Class EndGame.EndFieldQuestIcon
// 0x0008 (0x0368 - 0x0360)
class UEndFieldQuestIcon final : public UEndUserWidget
{
public:
	float                                         MaxDistance;                                       // 0x0360(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldQuestIcon">();
	}
	static class UEndFieldQuestIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndFieldQuestIcon>();
	}
};
static_assert(alignof(UEndFieldQuestIcon) == 0x000008, "Wrong alignment on UEndFieldQuestIcon");
static_assert(sizeof(UEndFieldQuestIcon) == 0x000368, "Wrong size on UEndFieldQuestIcon");
static_assert(offsetof(UEndFieldQuestIcon, MaxDistance) == 0x000360, "Member 'UEndFieldQuestIcon::MaxDistance' has a wrong offset!");

// Class EndGame.EndFieldStatusMenu
// 0x0018 (0x0378 - 0x0360)
class UEndFieldStatusMenu : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x18];                                     // 0x0360(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndFieldStatusMenu">();
	}
	static class UEndFieldStatusMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndFieldStatusMenu>();
	}
};
static_assert(alignof(UEndFieldStatusMenu) == 0x000008, "Wrong alignment on UEndFieldStatusMenu");
static_assert(sizeof(UEndFieldStatusMenu) == 0x000378, "Wrong size on UEndFieldStatusMenu");

// Class EndGame.EndAutoSeCallback
// 0x00F8 (0x0120 - 0x0028)
class UEndAutoSeCallback final : public USQEXSEADAutoSeComponentCallback
{
public:
	uint8                                         Pad_28[0xD8];                                      // 0x0028(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndAutoSeComponentSoundIndexTable*     SoundIndexTable;                                   // 0x0100(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USQEXSEADSound*                         SoundBank;                                         // 0x0108(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x10];                                     // 0x0110(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAutoSeCallback">();
	}
	static class UEndAutoSeCallback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndAutoSeCallback>();
	}
};
static_assert(alignof(UEndAutoSeCallback) == 0x000008, "Wrong alignment on UEndAutoSeCallback");
static_assert(sizeof(UEndAutoSeCallback) == 0x000120, "Wrong size on UEndAutoSeCallback");
static_assert(offsetof(UEndAutoSeCallback, SoundIndexTable) == 0x000100, "Member 'UEndAutoSeCallback::SoundIndexTable' has a wrong offset!");
static_assert(offsetof(UEndAutoSeCallback, SoundBank) == 0x000108, "Member 'UEndAutoSeCallback::SoundBank' has a wrong offset!");

// Class EndGame.EndGameEngine
// 0x0000 (0x10C0 - 0x10C0)
class UEndGameEngine final : public UGameEngine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndGameEngine">();
	}
	static class UEndGameEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndGameEngine>();
	}
};
static_assert(alignof(UEndGameEngine) == 0x000008, "Wrong alignment on UEndGameEngine");
static_assert(sizeof(UEndGameEngine) == 0x0010C0, "Wrong size on UEndGameEngine");

// Class EndGame.EndGameMode
// 0x0408 (0x0810 - 0x0408)
class AEndGameMode : public AGameModeBase
{
public:
	uint8                                         Pad_408[0x348];                                    // 0x0408(0x0348)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          DebugGameMode;                                     // 0x0750(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugGameMode_Normal;                              // 0x0751(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugGameMode_E3;                                  // 0x0752(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugGameMode_Playable;                            // 0x0753(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugGameModeFlags;                                // 0x0754(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          GamePlayMode;                                      // 0x0758(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_759[0x7];                                      // 0x0759(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        TotalTickTime;                                     // 0x0760(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        FrameTickTime;                                     // 0x0768(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        FrameTickCount;                                    // 0x0770(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SystemDeltaTimeSeconds;                            // 0x0778(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_77C[0x4];                                      // 0x077C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UObject*>                          ReferenceAssets;                                   // 0x0780(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        OnUnloadEnvLevelAssetReferences;                   // 0x07D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UEndCrossSaveManager*                   CrossSaveManager;                                  // 0x07E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E8[0x28];                                     // 0x07E8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void InitEditorGameMode(const class UObject* WorldContextObject, class FName LocationName, bool QuickStart, class FName OverRideEnvName, class FName InCutName, const struct FLatentActionInfo& LatentInfo);
	static void InitEditorPreviewGameMode(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndGameMode">();
	}
	static class AEndGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndGameMode>();
	}
};
static_assert(alignof(AEndGameMode) == 0x000008, "Wrong alignment on AEndGameMode");
static_assert(sizeof(AEndGameMode) == 0x000810, "Wrong size on AEndGameMode");
static_assert(offsetof(AEndGameMode, DebugGameMode) == 0x000750, "Member 'AEndGameMode::DebugGameMode' has a wrong offset!");
static_assert(offsetof(AEndGameMode, DebugGameMode_Normal) == 0x000751, "Member 'AEndGameMode::DebugGameMode_Normal' has a wrong offset!");
static_assert(offsetof(AEndGameMode, DebugGameMode_E3) == 0x000752, "Member 'AEndGameMode::DebugGameMode_E3' has a wrong offset!");
static_assert(offsetof(AEndGameMode, DebugGameMode_Playable) == 0x000753, "Member 'AEndGameMode::DebugGameMode_Playable' has a wrong offset!");
static_assert(offsetof(AEndGameMode, DebugGameModeFlags) == 0x000754, "Member 'AEndGameMode::DebugGameModeFlags' has a wrong offset!");
static_assert(offsetof(AEndGameMode, GamePlayMode) == 0x000758, "Member 'AEndGameMode::GamePlayMode' has a wrong offset!");
static_assert(offsetof(AEndGameMode, TotalTickTime) == 0x000760, "Member 'AEndGameMode::TotalTickTime' has a wrong offset!");
static_assert(offsetof(AEndGameMode, FrameTickTime) == 0x000768, "Member 'AEndGameMode::FrameTickTime' has a wrong offset!");
static_assert(offsetof(AEndGameMode, FrameTickCount) == 0x000770, "Member 'AEndGameMode::FrameTickCount' has a wrong offset!");
static_assert(offsetof(AEndGameMode, SystemDeltaTimeSeconds) == 0x000778, "Member 'AEndGameMode::SystemDeltaTimeSeconds' has a wrong offset!");
static_assert(offsetof(AEndGameMode, ReferenceAssets) == 0x000780, "Member 'AEndGameMode::ReferenceAssets' has a wrong offset!");
static_assert(offsetof(AEndGameMode, OnUnloadEnvLevelAssetReferences) == 0x0007D0, "Member 'AEndGameMode::OnUnloadEnvLevelAssetReferences' has a wrong offset!");
static_assert(offsetof(AEndGameMode, CrossSaveManager) == 0x0007E0, "Member 'AEndGameMode::CrossSaveManager' has a wrong offset!");

// Class EndGame.EndGameOverMenu
// 0x0040 (0x03A0 - 0x0360)
class UEndGameOverMenu : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x40];                                     // 0x0360(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndGameOverMenu">();
	}
	static class UEndGameOverMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndGameOverMenu>();
	}
};
static_assert(alignof(UEndGameOverMenu) == 0x000008, "Wrong alignment on UEndGameOverMenu");
static_assert(sizeof(UEndGameOverMenu) == 0x0003A0, "Wrong size on UEndGameOverMenu");

// Class EndGame.EndGameState
// 0x0180 (0x0538 - 0x03B8)
class AEndGameState : public AGameStateBase
{
public:
	EGameState                                    GameState;                                         // 0x03B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameStateChange                       GameStateChange[0x40];                             // 0x03B9(0x0002)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_439[0x3];                                      // 0x0439(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GameStateChangeCount;                              // 0x043C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameMode                                     GameMode;                                          // 0x0440(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_441[0x7];                                      // 0x0441(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ActiveLocation;                                    // 0x0448(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TruthLocation;                                     // 0x0458(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PrevActiveLocation;                                // 0x0468(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OriginalLocation;                                  // 0x0478(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActiveLocationSlot;                                // 0x0488(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrevActiveLocationSlot;                            // 0x048C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LoadedLocation;                                    // 0x0490(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TestCutSceneName;                                  // 0x04A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequestActiveLocation;                            // 0x04B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B1[0x7];                                      // 0x04B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RequestTargetLocationStr;                          // 0x04B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   RequestOverRideEnvName;                            // 0x04C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRequestTruthLocation;                             // 0x04D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D1[0x7];                                      // 0x04D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RequestTruthLocationStr;                           // 0x04D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint64                                        GameStatus;                                        // 0x04E8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        GamePause;                                         // 0x04F0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        RequestGamePauseOn;                                // 0x04F4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        RequestGamePauseOff;                               // 0x04F8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndSystemPauseMenuKind                       NextPauseMenuKind;                                 // 0x04FC(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HideWorld;                                         // 0x04FD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4FE[0x2];                                      // 0x04FE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GameSpeed[0xC];                                    // 0x0500(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_530[0x8];                                      // 0x0530(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void OnDebugPauseEnable();
	static void OnDebugPauseFrameSkip();
	static void SendGameTrigger(const class UObject* WorldContextObject, EGameTrigger Trigger, EGameState toState, const struct FLatentActionInfo& LatentInfo);
	static void WaitGameDifferentState(const class UObject* WorldContextObject, EGameState toState, const struct FLatentActionInfo& LatentInfo);
	static void WaitGameDifferentStateList(const class UObject* WorldContextObject, const TArray<EGameState>& toStateList, const struct FLatentActionInfo& LatentInfo);
	static void WaitGameState(const class UObject* WorldContextObject, EGameState toState, const struct FLatentActionInfo& LatentInfo);

	void ActivateLocation(const class FString& TargetLocation, class FName OverRideEnvName);
	float GetGameSpeed();
	bool IsGamePause();
	bool IsGameStatus(EGameStatus Status);
	void SetGameSpeed(EGameSpeed Type, float Speed);
	void SetGameStatus(EGameStatus Status, bool Set);
	void SetRequestGamePauseOn(EGamePause Pause);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndGameState">();
	}
	static class AEndGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndGameState>();
	}
};
static_assert(alignof(AEndGameState) == 0x000008, "Wrong alignment on AEndGameState");
static_assert(sizeof(AEndGameState) == 0x000538, "Wrong size on AEndGameState");
static_assert(offsetof(AEndGameState, GameState) == 0x0003B8, "Member 'AEndGameState::GameState' has a wrong offset!");
static_assert(offsetof(AEndGameState, GameStateChange) == 0x0003B9, "Member 'AEndGameState::GameStateChange' has a wrong offset!");
static_assert(offsetof(AEndGameState, GameStateChangeCount) == 0x00043C, "Member 'AEndGameState::GameStateChangeCount' has a wrong offset!");
static_assert(offsetof(AEndGameState, GameMode) == 0x000440, "Member 'AEndGameState::GameMode' has a wrong offset!");
static_assert(offsetof(AEndGameState, ActiveLocation) == 0x000448, "Member 'AEndGameState::ActiveLocation' has a wrong offset!");
static_assert(offsetof(AEndGameState, TruthLocation) == 0x000458, "Member 'AEndGameState::TruthLocation' has a wrong offset!");
static_assert(offsetof(AEndGameState, PrevActiveLocation) == 0x000468, "Member 'AEndGameState::PrevActiveLocation' has a wrong offset!");
static_assert(offsetof(AEndGameState, OriginalLocation) == 0x000478, "Member 'AEndGameState::OriginalLocation' has a wrong offset!");
static_assert(offsetof(AEndGameState, ActiveLocationSlot) == 0x000488, "Member 'AEndGameState::ActiveLocationSlot' has a wrong offset!");
static_assert(offsetof(AEndGameState, PrevActiveLocationSlot) == 0x00048C, "Member 'AEndGameState::PrevActiveLocationSlot' has a wrong offset!");
static_assert(offsetof(AEndGameState, LoadedLocation) == 0x000490, "Member 'AEndGameState::LoadedLocation' has a wrong offset!");
static_assert(offsetof(AEndGameState, TestCutSceneName) == 0x0004A0, "Member 'AEndGameState::TestCutSceneName' has a wrong offset!");
static_assert(offsetof(AEndGameState, bRequestActiveLocation) == 0x0004B0, "Member 'AEndGameState::bRequestActiveLocation' has a wrong offset!");
static_assert(offsetof(AEndGameState, RequestTargetLocationStr) == 0x0004B8, "Member 'AEndGameState::RequestTargetLocationStr' has a wrong offset!");
static_assert(offsetof(AEndGameState, RequestOverRideEnvName) == 0x0004C8, "Member 'AEndGameState::RequestOverRideEnvName' has a wrong offset!");
static_assert(offsetof(AEndGameState, bRequestTruthLocation) == 0x0004D0, "Member 'AEndGameState::bRequestTruthLocation' has a wrong offset!");
static_assert(offsetof(AEndGameState, RequestTruthLocationStr) == 0x0004D8, "Member 'AEndGameState::RequestTruthLocationStr' has a wrong offset!");
static_assert(offsetof(AEndGameState, GameStatus) == 0x0004E8, "Member 'AEndGameState::GameStatus' has a wrong offset!");
static_assert(offsetof(AEndGameState, GamePause) == 0x0004F0, "Member 'AEndGameState::GamePause' has a wrong offset!");
static_assert(offsetof(AEndGameState, RequestGamePauseOn) == 0x0004F4, "Member 'AEndGameState::RequestGamePauseOn' has a wrong offset!");
static_assert(offsetof(AEndGameState, RequestGamePauseOff) == 0x0004F8, "Member 'AEndGameState::RequestGamePauseOff' has a wrong offset!");
static_assert(offsetof(AEndGameState, NextPauseMenuKind) == 0x0004FC, "Member 'AEndGameState::NextPauseMenuKind' has a wrong offset!");
static_assert(offsetof(AEndGameState, HideWorld) == 0x0004FD, "Member 'AEndGameState::HideWorld' has a wrong offset!");
static_assert(offsetof(AEndGameState, GameSpeed) == 0x000500, "Member 'AEndGameState::GameSpeed' has a wrong offset!");

// Class EndGame.EndGauge
// 0x0298 (0x0390 - 0x00F8)
class UEndGauge final : public UWidget
{
public:
	struct FProgressBarStyle                      WidgetStyle;                                       // 0x00F8(0x0170)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             ValueDelegate;                                     // 0x0270(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PreviewValue;                                      // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x0284(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             MaxValueDelegate;                                  // 0x0288(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	EProgressBarFillType                          BarFillType;                                       // 0x0298(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x3];                                      // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              BorderPadding;                                     // 0x029C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FillColorAndOpacity;                               // 0x02A4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             FillColorAndOpacityDelegate;                       // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           FillEndColorAndOpacity;                            // 0x02C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             FillEndColorAndOpacityDelegate;                    // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           PreviewColorAndOpacity;                            // 0x02E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             PreviewColorAndOpacityDelegate;                    // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FSlateBrush                            PreviewBrush;                                      // 0x0308(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_380[0x10];                                     // 0x0380(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFillColorAndOpacity(const struct FLinearColor& InColor);
	void SetFillEndColorAndOpacity(const struct FLinearColor& InColor);
	void SetMaxValue(float InMaxValue);
	void SetPreviewColorAndOpacity(const struct FLinearColor& InColor);
	void SetPreviewValue(float InPreviewValue);
	void SetValue(float InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndGauge">();
	}
	static class UEndGauge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndGauge>();
	}
};
static_assert(alignof(UEndGauge) == 0x000008, "Wrong alignment on UEndGauge");
static_assert(sizeof(UEndGauge) == 0x000390, "Wrong size on UEndGauge");
static_assert(offsetof(UEndGauge, WidgetStyle) == 0x0000F8, "Member 'UEndGauge::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UEndGauge, Value) == 0x000268, "Member 'UEndGauge::Value' has a wrong offset!");
static_assert(offsetof(UEndGauge, ValueDelegate) == 0x000270, "Member 'UEndGauge::ValueDelegate' has a wrong offset!");
static_assert(offsetof(UEndGauge, PreviewValue) == 0x000280, "Member 'UEndGauge::PreviewValue' has a wrong offset!");
static_assert(offsetof(UEndGauge, MaxValue) == 0x000284, "Member 'UEndGauge::MaxValue' has a wrong offset!");
static_assert(offsetof(UEndGauge, MaxValueDelegate) == 0x000288, "Member 'UEndGauge::MaxValueDelegate' has a wrong offset!");
static_assert(offsetof(UEndGauge, BarFillType) == 0x000298, "Member 'UEndGauge::BarFillType' has a wrong offset!");
static_assert(offsetof(UEndGauge, BorderPadding) == 0x00029C, "Member 'UEndGauge::BorderPadding' has a wrong offset!");
static_assert(offsetof(UEndGauge, FillColorAndOpacity) == 0x0002A4, "Member 'UEndGauge::FillColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UEndGauge, FillColorAndOpacityDelegate) == 0x0002B8, "Member 'UEndGauge::FillColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UEndGauge, FillEndColorAndOpacity) == 0x0002C8, "Member 'UEndGauge::FillEndColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UEndGauge, FillEndColorAndOpacityDelegate) == 0x0002D8, "Member 'UEndGauge::FillEndColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UEndGauge, PreviewColorAndOpacity) == 0x0002E8, "Member 'UEndGauge::PreviewColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UEndGauge, PreviewColorAndOpacityDelegate) == 0x0002F8, "Member 'UEndGauge::PreviewColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UEndGauge, PreviewBrush) == 0x000308, "Member 'UEndGauge::PreviewBrush' has a wrong offset!");

// Class EndGame.EndGBikeMenu
// 0x0000 (0x0360 - 0x0360)
class UEndGBikeMenu final : public UEndUserWidget
{
public:
	void OnGBikeCellSetup(class UWidget* ItemWidget, int32 ItemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndGBikeMenu">();
	}
	static class UEndGBikeMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndGBikeMenu>();
	}
};
static_assert(alignof(UEndGBikeMenu) == 0x000008, "Wrong alignment on UEndGBikeMenu");
static_assert(sizeof(UEndGBikeMenu) == 0x000360, "Wrong size on UEndGBikeMenu");

// Class EndGame.EndImage
// 0x00D0 (0x01C8 - 0x00F8)
class UEndImage final : public UWidget
{
public:
	struct FSlateBrush                            Brush;                                             // 0x00F8(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TDelegate<void()>                             BrushDelegate;                                     // 0x0170(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorAndOpacity;                                   // 0x0180(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ColorAndOpacityDelegate;                           // 0x0190(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	EBlendMode                                    BlendMode;                                         // 0x01A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(const struct FGeometry& MyGeometry, struct FPointerEvent& MouseEvent)> OnMouseButtonDownEvent;                            // 0x01A8(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B8[0x10];                                     // 0x01B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMaterialInstanceDynamic* GetDynamicMaterial();
	void SetBlendMode(EBlendMode InBlendMode);
	void SetBrush(const struct FSlateBrush& InBrush);
	void SetBrushFromAsset(class USlateBrushAsset* Asset);
	void SetBrushFromMaterial(class UMaterialInterface* Material);
	void SetBrushFromTexture(class UTexture2D* Texture, bool bMatchSize);
	void SetBrushFromTextureDynamic(class UTexture2DDynamic* Texture, bool bMatchSize);
	void SetColorAndOpacity(const struct FLinearColor& InColorAndOpacity);
	void SetOpacity(float InOpacity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndImage">();
	}
	static class UEndImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndImage>();
	}
};
static_assert(alignof(UEndImage) == 0x000008, "Wrong alignment on UEndImage");
static_assert(sizeof(UEndImage) == 0x0001C8, "Wrong size on UEndImage");
static_assert(offsetof(UEndImage, Brush) == 0x0000F8, "Member 'UEndImage::Brush' has a wrong offset!");
static_assert(offsetof(UEndImage, BrushDelegate) == 0x000170, "Member 'UEndImage::BrushDelegate' has a wrong offset!");
static_assert(offsetof(UEndImage, ColorAndOpacity) == 0x000180, "Member 'UEndImage::ColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UEndImage, ColorAndOpacityDelegate) == 0x000190, "Member 'UEndImage::ColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UEndImage, BlendMode) == 0x0001A0, "Member 'UEndImage::BlendMode' has a wrong offset!");
static_assert(offsetof(UEndImage, OnMouseButtonDownEvent) == 0x0001A8, "Member 'UEndImage::OnMouseButtonDownEvent' has a wrong offset!");

// Class EndGame.EndImGuiCinema
// 0x0000 (0x0028 - 0x0028)
class UEndImGuiCinema final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndImGuiCinema">();
	}
	static class UEndImGuiCinema* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndImGuiCinema>();
	}
};
static_assert(alignof(UEndImGuiCinema) == 0x000008, "Wrong alignment on UEndImGuiCinema");
static_assert(sizeof(UEndImGuiCinema) == 0x000028, "Wrong size on UEndImGuiCinema");

// Class EndGame.EndImGuiCommand
// 0x0000 (0x0028 - 0x0028)
class UEndImGuiCommand final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndImGuiCommand">();
	}
	static class UEndImGuiCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndImGuiCommand>();
	}
};
static_assert(alignof(UEndImGuiCommand) == 0x000008, "Wrong alignment on UEndImGuiCommand");
static_assert(sizeof(UEndImGuiCommand) == 0x000028, "Wrong size on UEndImGuiCommand");

// Class EndGame.EndImGuiDataBase
// 0x0000 (0x0028 - 0x0028)
class UEndImGuiDataBase final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndImGuiDataBase">();
	}
	static class UEndImGuiDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndImGuiDataBase>();
	}
};
static_assert(alignof(UEndImGuiDataBase) == 0x000008, "Wrong alignment on UEndImGuiDataBase");
static_assert(sizeof(UEndImGuiDataBase) == 0x000028, "Wrong size on UEndImGuiDataBase");

// Class EndGame.EndImGuiEffect
// 0x0000 (0x0028 - 0x0028)
class UEndImGuiEffect final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndImGuiEffect">();
	}
	static class UEndImGuiEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndImGuiEffect>();
	}
};
static_assert(alignof(UEndImGuiEffect) == 0x000008, "Wrong alignment on UEndImGuiEffect");
static_assert(sizeof(UEndImGuiEffect) == 0x000028, "Wrong size on UEndImGuiEffect");

// Class EndGame.EndImGuiNavMesh
// 0x0000 (0x0028 - 0x0028)
class UEndImGuiNavMesh final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndImGuiNavMesh">();
	}
	static class UEndImGuiNavMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndImGuiNavMesh>();
	}
};
static_assert(alignof(UEndImGuiNavMesh) == 0x000008, "Wrong alignment on UEndImGuiNavMesh");
static_assert(sizeof(UEndImGuiNavMesh) == 0x000028, "Wrong size on UEndImGuiNavMesh");

// Class EndGame.EndImGuiParty
// 0x0000 (0x0028 - 0x0028)
class UEndImGuiParty final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndImGuiParty">();
	}
	static class UEndImGuiParty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndImGuiParty>();
	}
};
static_assert(alignof(UEndImGuiParty) == 0x000008, "Wrong alignment on UEndImGuiParty");
static_assert(sizeof(UEndImGuiParty) == 0x000028, "Wrong size on UEndImGuiParty");

// Class EndGame.EndImGuiTalk
// 0x0000 (0x0028 - 0x0028)
class UEndImGuiTalk final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndImGuiTalk">();
	}
	static class UEndImGuiTalk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndImGuiTalk>();
	}
};
static_assert(alignof(UEndImGuiTalk) == 0x000008, "Wrong alignment on UEndImGuiTalk");
static_assert(sizeof(UEndImGuiTalk) == 0x000028, "Wrong size on UEndImGuiTalk");

// Class EndGame.EndInstancedLightweightPhysicsComponent
// 0x00A0 (0x09F0 - 0x0950)
class UEndInstancedLightweightPhysicsComponent final : public UInstancedStaticMeshComponent
{
public:
	float                                         Radius;                                            // 0x0950(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReserveCount;                                      // 0x0954(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitialTranslationNoise;                           // 0x0958(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               InitialRotationNoise;                              // 0x0964(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                BoundedTranslationNoise;                           // 0x0970(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               BoundedRotationNoise;                              // 0x097C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         BoundTraceIntervalFrame;                           // 0x0988(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoundAttenuationMin;                               // 0x098C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoundAttenuationMax;                               // 0x0990(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BoundCountMax;                                     // 0x0994(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBoundedDelayDestroyTime;                        // 0x0998(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundedStopSecnods;                               // 0x099C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundedAdjustRotationSpeed;                       // 0x09A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               InitialCompositeRotation;                          // 0x09A4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               GroundedCompositeRotation;                         // 0x09B0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TraceIntervalSecondMin;                            // 0x09BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisableGravityHeightVelocityThreshold;             // 0x09C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C4[0x4];                                      // 0x09C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             HitSound;                                          // 0x09C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HitSoundName;                                      // 0x09D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D8[0x18];                                     // 0x09D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddPhysicsInstance(const struct FTransform& Transform, const struct FVector& Impulse, float DelayTime, float LifeTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndInstancedLightweightPhysicsComponent">();
	}
	static class UEndInstancedLightweightPhysicsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndInstancedLightweightPhysicsComponent>();
	}
};
static_assert(alignof(UEndInstancedLightweightPhysicsComponent) == 0x000010, "Wrong alignment on UEndInstancedLightweightPhysicsComponent");
static_assert(sizeof(UEndInstancedLightweightPhysicsComponent) == 0x0009F0, "Wrong size on UEndInstancedLightweightPhysicsComponent");
static_assert(offsetof(UEndInstancedLightweightPhysicsComponent, Radius) == 0x000950, "Member 'UEndInstancedLightweightPhysicsComponent::Radius' has a wrong offset!");
static_assert(offsetof(UEndInstancedLightweightPhysicsComponent, ReserveCount) == 0x000954, "Member 'UEndInstancedLightweightPhysicsComponent::ReserveCount' has a wrong offset!");
static_assert(offsetof(UEndInstancedLightweightPhysicsComponent, InitialTranslationNoise) == 0x000958, "Member 'UEndInstancedLightweightPhysicsComponent::InitialTranslationNoise' has a wrong offset!");
static_assert(offsetof(UEndInstancedLightweightPhysicsComponent, InitialRotationNoise) == 0x000964, "Member 'UEndInstancedLightweightPhysicsComponent::InitialRotationNoise' has a wrong offset!");
static_assert(offsetof(UEndInstancedLightweightPhysicsComponent, BoundedTranslationNoise) == 0x000970, "Member 'UEndInstancedLightweightPhysicsComponent::BoundedTranslationNoise' has a wrong offset!");
static_assert(offsetof(UEndInstancedLightweightPhysicsComponent, BoundedRotationNoise) == 0x00097C, "Member 'UEndInstancedLightweightPhysicsComponent::BoundedRotationNoise' has a wrong offset!");
static_assert(offsetof(UEndInstancedLightweightPhysicsComponent, BoundTraceIntervalFrame) == 0x000988, "Member 'UEndInstancedLightweightPhysicsComponent::BoundTraceIntervalFrame' has a wrong offset!");
static_assert(offsetof(UEndInstancedLightweightPhysicsComponent, BoundAttenuationMin) == 0x00098C, "Member 'UEndInstancedLightweightPhysicsComponent::BoundAttenuationMin' has a wrong offset!");
static_assert(offsetof(UEndInstancedLightweightPhysicsComponent, BoundAttenuationMax) == 0x000990, "Member 'UEndInstancedLightweightPhysicsComponent::BoundAttenuationMax' has a wrong offset!");
static_assert(offsetof(UEndInstancedLightweightPhysicsComponent, BoundCountMax) == 0x000994, "Member 'UEndInstancedLightweightPhysicsComponent::BoundCountMax' has a wrong offset!");
static_assert(offsetof(UEndInstancedLightweightPhysicsComponent, MaxBoundedDelayDestroyTime) == 0x000998, "Member 'UEndInstancedLightweightPhysicsComponent::MaxBoundedDelayDestroyTime' has a wrong offset!");
static_assert(offsetof(UEndInstancedLightweightPhysicsComponent, GroundedStopSecnods) == 0x00099C, "Member 'UEndInstancedLightweightPhysicsComponent::GroundedStopSecnods' has a wrong offset!");
static_assert(offsetof(UEndInstancedLightweightPhysicsComponent, GroundedAdjustRotationSpeed) == 0x0009A0, "Member 'UEndInstancedLightweightPhysicsComponent::GroundedAdjustRotationSpeed' has a wrong offset!");
static_assert(offsetof(UEndInstancedLightweightPhysicsComponent, InitialCompositeRotation) == 0x0009A4, "Member 'UEndInstancedLightweightPhysicsComponent::InitialCompositeRotation' has a wrong offset!");
static_assert(offsetof(UEndInstancedLightweightPhysicsComponent, GroundedCompositeRotation) == 0x0009B0, "Member 'UEndInstancedLightweightPhysicsComponent::GroundedCompositeRotation' has a wrong offset!");
static_assert(offsetof(UEndInstancedLightweightPhysicsComponent, TraceIntervalSecondMin) == 0x0009BC, "Member 'UEndInstancedLightweightPhysicsComponent::TraceIntervalSecondMin' has a wrong offset!");
static_assert(offsetof(UEndInstancedLightweightPhysicsComponent, DisableGravityHeightVelocityThreshold) == 0x0009C0, "Member 'UEndInstancedLightweightPhysicsComponent::DisableGravityHeightVelocityThreshold' has a wrong offset!");
static_assert(offsetof(UEndInstancedLightweightPhysicsComponent, HitSound) == 0x0009C8, "Member 'UEndInstancedLightweightPhysicsComponent::HitSound' has a wrong offset!");
static_assert(offsetof(UEndInstancedLightweightPhysicsComponent, HitSoundName) == 0x0009D0, "Member 'UEndInstancedLightweightPhysicsComponent::HitSoundName' has a wrong offset!");

// Class EndGame.EndInteractorInterface
// 0x0000 (0x0028 - 0x0028)
class IEndInteractorInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndInteractorInterface">();
	}
	static class IEndInteractorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEndInteractorInterface>();
	}
};
static_assert(alignof(IEndInteractorInterface) == 0x000008, "Wrong alignment on IEndInteractorInterface");
static_assert(sizeof(IEndInteractorInterface) == 0x000028, "Wrong size on IEndInteractorInterface");

// Class EndGame.EndItemDropComponent
// 0x0058 (0x0150 - 0x00F8)
class UEndItemDropComponent final : public UActorComponent
{
public:
	class FName                                   MakoStoneDamageSourceOwnerName;                    // 0x00F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableMakoStoneEffect;                           // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x4F];                                     // 0x0101(0x004F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndItemDropComponent">();
	}
	static class UEndItemDropComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndItemDropComponent>();
	}
};
static_assert(alignof(UEndItemDropComponent) == 0x000008, "Wrong alignment on UEndItemDropComponent");
static_assert(sizeof(UEndItemDropComponent) == 0x000150, "Wrong size on UEndItemDropComponent");
static_assert(offsetof(UEndItemDropComponent, MakoStoneDamageSourceOwnerName) == 0x0000F8, "Member 'UEndItemDropComponent::MakoStoneDamageSourceOwnerName' has a wrong offset!");
static_assert(offsetof(UEndItemDropComponent, bDisableMakoStoneEffect) == 0x000100, "Member 'UEndItemDropComponent::bDisableMakoStoneEffect' has a wrong offset!");

// Class EndGame.EndItemSelectMemberList
// 0x0050 (0x03B0 - 0x0360)
class UEndItemSelectMemberList final : public UEndMainMenuListBase
{
public:
	uint8                                         Pad_360[0x50];                                     // 0x0360(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndItemSelectMemberList">();
	}
	static class UEndItemSelectMemberList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndItemSelectMemberList>();
	}
};
static_assert(alignof(UEndItemSelectMemberList) == 0x000008, "Wrong alignment on UEndItemSelectMemberList");
static_assert(sizeof(UEndItemSelectMemberList) == 0x0003B0, "Wrong size on UEndItemSelectMemberList");

// Class EndGame.EndJoint
// 0x0080 (0x00A8 - 0x0028)
class UEndJoint final : public UObject
{
public:
	class FName                                   BoneName;                                          // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularVelocity;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimTransitionTimeBias;                             // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AimAxis;                                           // 0x0038(0x000C)(Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AimAxisRotation;                                   // 0x0044(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               AimUpRotation;                                     // 0x0050(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseAimUpVector;                                   // 0x005C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimUpRate;                                         // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AimTargetOffset;                                   // 0x0064(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActiveAimAngularVelocity;                          // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeactiveAimAngularVelocity;                        // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActiveAimTranslationVelocity;                      // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeactiveAimTranslationVelocity;                    // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableVibration;                                  // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndJointLimitType                            LimitType;                                         // 0x0081(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x2];                                       // 0x0082(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEndJointEulerRotationLimit            EulerRotationLimit;                                // 0x0084(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndJointHingeRotationLimit            HingeRotationLimit;                                // 0x009C(0x000C)(Deprecated, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndJoint">();
	}
	static class UEndJoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndJoint>();
	}
};
static_assert(alignof(UEndJoint) == 0x000008, "Wrong alignment on UEndJoint");
static_assert(sizeof(UEndJoint) == 0x0000A8, "Wrong size on UEndJoint");
static_assert(offsetof(UEndJoint, BoneName) == 0x000028, "Member 'UEndJoint::BoneName' has a wrong offset!");
static_assert(offsetof(UEndJoint, AngularVelocity) == 0x000030, "Member 'UEndJoint::AngularVelocity' has a wrong offset!");
static_assert(offsetof(UEndJoint, AimTransitionTimeBias) == 0x000034, "Member 'UEndJoint::AimTransitionTimeBias' has a wrong offset!");
static_assert(offsetof(UEndJoint, AimAxis) == 0x000038, "Member 'UEndJoint::AimAxis' has a wrong offset!");
static_assert(offsetof(UEndJoint, AimAxisRotation) == 0x000044, "Member 'UEndJoint::AimAxisRotation' has a wrong offset!");
static_assert(offsetof(UEndJoint, AimUpRotation) == 0x000050, "Member 'UEndJoint::AimUpRotation' has a wrong offset!");
static_assert(offsetof(UEndJoint, bUseAimUpVector) == 0x00005C, "Member 'UEndJoint::bUseAimUpVector' has a wrong offset!");
static_assert(offsetof(UEndJoint, AimUpRate) == 0x000060, "Member 'UEndJoint::AimUpRate' has a wrong offset!");
static_assert(offsetof(UEndJoint, AimTargetOffset) == 0x000064, "Member 'UEndJoint::AimTargetOffset' has a wrong offset!");
static_assert(offsetof(UEndJoint, ActiveAimAngularVelocity) == 0x000070, "Member 'UEndJoint::ActiveAimAngularVelocity' has a wrong offset!");
static_assert(offsetof(UEndJoint, DeactiveAimAngularVelocity) == 0x000074, "Member 'UEndJoint::DeactiveAimAngularVelocity' has a wrong offset!");
static_assert(offsetof(UEndJoint, ActiveAimTranslationVelocity) == 0x000078, "Member 'UEndJoint::ActiveAimTranslationVelocity' has a wrong offset!");
static_assert(offsetof(UEndJoint, DeactiveAimTranslationVelocity) == 0x00007C, "Member 'UEndJoint::DeactiveAimTranslationVelocity' has a wrong offset!");
static_assert(offsetof(UEndJoint, bEnableVibration) == 0x000080, "Member 'UEndJoint::bEnableVibration' has a wrong offset!");
static_assert(offsetof(UEndJoint, LimitType) == 0x000081, "Member 'UEndJoint::LimitType' has a wrong offset!");
static_assert(offsetof(UEndJoint, EulerRotationLimit) == 0x000084, "Member 'UEndJoint::EulerRotationLimit' has a wrong offset!");
static_assert(offsetof(UEndJoint, HingeRotationLimit) == 0x00009C, "Member 'UEndJoint::HingeRotationLimit' has a wrong offset!");

// Class EndGame.EndLevelLoader
// 0x0000 (0x0028 - 0x0028)
class UEndLevelLoader final : public UObject
{
public:
	static void CheckLoadStreamLevel(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	static void CheckLoadStreamLevelSepc(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	static int32 DoLoadStreamLevelSet(EStreamLevelSetSlot Slot);
	static class AActor* FindActorFromLevel(class FName LevelName, class FName ActorName);
	static class AActor* FindActorFromWorld(class FName ActorName);
	static class AEndCharacter* FindCharacterFromLevel(class FName LevelName, class FName ActorName);
	static class AEndCharacter* FindCharacterFromWorld(class FName ActorName);
	static void FinishLoadStreamLevel(const class UObject* WorldContextObject);
	static void FinishLoadStreamLevelSet(EStreamLevelSetSlot Slot);
	static void FinishLoadStreamLevelSpec();
	static TArray<uint8> GetCacheLoadStreamHideLevelSet(EStreamLevelSetSlot Slot);
	static class FName GetLoadStreamLevel(const class UObject* WorldContextObject);
	static TArray<class FName> GetLoadStreamLevels(const class UObject* WorldContextObject, bool load);
	static TArray<class FName> GetLoadStreamLevelSet(EStreamLevelSetSlot Slot);
	static class FName GetLoadStreamLevelSpec(const class UObject* WorldContextObject);
	static int32 GetLoadStreamLevelSpecPriority(const class UObject* WorldContextObject);
	static TArray<class FName> GetUnLoadStreamLevelSet(EStreamLevelSetSlot Slot);
	static bool IsBoostLoading(const class UObject* WorldContextObject);
	static bool IsLoadStreamLevel(const class UObject* WorldContextObject);
	static bool IsLoadStreamLevelSpec(const class UObject* WorldContextObject);
	static void LoadStreamLevelGroups(const class UObject* WorldContextObject, int32 Priority, const TArray<class FName>& LevelNames, const struct FLatentActionInfo& LatentInfo);
	static void LoadStreamLevelGroupsWithHide(const class UObject* WorldContextObject, int32 Priority, const TArray<class FName>& LevelNames, const TArray<uint8>& hides, EStreamLevelSetSlot Slot, const struct FLatentActionInfo& LatentInfo);
	static void LoadStreamLevels(const class UObject* WorldContextObject, const TArray<class FName>& LevelNames, const struct FLatentActionInfo& LatentInfo);
	static void LoadStreamLevelSet(const class UObject* WorldContextObject, EStreamLevelSetSlot Slot, int32 Priority, const TArray<class FName>& LevelNames, const struct FLatentActionInfo& LatentInfo);
	static void LoadStreamLevelSingle(const class UObject* WorldContextObject, int32 Priority, class FName LevelNames, const struct FLatentActionInfo& LatentInfo);
	static void LoadStreamLevelSingleWithHide(const class UObject* WorldContextObject, int32 Priority, class FName LevelNames, uint8 hide, const struct FLatentActionInfo& LatentInfo);
	static void LoadStreamLevelSpec(const class UObject* WorldContextObject, int32 Priority, class FName SpecName, const struct FLatentActionInfo& LatentInfo);
	static void LoadStreamLevelSpecInternal(const class UObject* WorldContextObject, int32 Priority, class FName SpecName, const struct FLatentActionInfo& LatentInfo);
	static class FString MakeLongLevelName(const class FString& ShortName);
	static void SetShowFrameLimitFree(const class UObject* WorldContextObject, bool isFree);
	static void UnloadStreamLevelGroups(const class UObject* WorldContextObject, int32 Priority, const TArray<class FName>& LevelNames, const struct FLatentActionInfo& LatentInfo);
	static void UnloadStreamLevels(const class UObject* WorldContextObject, const TArray<class FName>& LevelNames, const struct FLatentActionInfo& LatentInfo);
	static void UnloadStreamLevelSingle(const class UObject* WorldContextObject, int32 Priority, class FName LevelNames, const struct FLatentActionInfo& LatentInfo);
	static void UnLoadStreamLevelSpec(const class UObject* WorldContextObject, int32 Priority, class FName SpecName, const struct FLatentActionInfo& LatentInfo);
	static void UnLoadStreamLevelSpecInternal(const class UObject* WorldContextObject, int32 Priority, class FName SpecName, const struct FLatentActionInfo& LatentInfo);
	static void WaitShowSlicingLevelSet(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	static void WaitStreamLevelEmpty(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndLevelLoader">();
	}
	static class UEndLevelLoader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndLevelLoader>();
	}
};
static_assert(alignof(UEndLevelLoader) == 0x000008, "Wrong alignment on UEndLevelLoader");
static_assert(sizeof(UEndLevelLoader) == 0x000028, "Wrong size on UEndLevelLoader");

// Class EndGame.EndLinkIcon
// 0x0008 (0x0368 - 0x0360)
class UEndLinkIcon final : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x8];                                      // 0x0360(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndLinkIcon">();
	}
	static class UEndLinkIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndLinkIcon>();
	}
};
static_assert(alignof(UEndLinkIcon) == 0x000008, "Wrong alignment on UEndLinkIcon");
static_assert(sizeof(UEndLinkIcon) == 0x000368, "Wrong size on UEndLinkIcon");

// Class EndGame.EndLipSyncSolver
// 0x0058 (0x0080 - 0x0028)
class UEndLipSyncSolver final : public UObject
{
public:
	float                                         AudioPowerTimeOffset;                              // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AudioPowerAttenuationSpeed;                        // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AudioLargeAttackThreshold;                         // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEndLipSyncAudioAttackAnimation> AudioLargeAttackAnimations;                        // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FEndLipSyncAudioAttackBrowAnimation> AudioLargeAttackBrowAnimations;                    // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         AudioSmallAttackThreshold;                         // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEndLipSyncAudioAttackAnimation> AudioSmallAttackAnimations;                        // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FEndLipSyncAudioAttackBrowAnimation> AudioSmallAttackBrowAnimations;                    // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndLipSyncSolver">();
	}
	static class UEndLipSyncSolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndLipSyncSolver>();
	}
};
static_assert(alignof(UEndLipSyncSolver) == 0x000008, "Wrong alignment on UEndLipSyncSolver");
static_assert(sizeof(UEndLipSyncSolver) == 0x000080, "Wrong size on UEndLipSyncSolver");
static_assert(offsetof(UEndLipSyncSolver, AudioPowerTimeOffset) == 0x000028, "Member 'UEndLipSyncSolver::AudioPowerTimeOffset' has a wrong offset!");
static_assert(offsetof(UEndLipSyncSolver, AudioPowerAttenuationSpeed) == 0x00002C, "Member 'UEndLipSyncSolver::AudioPowerAttenuationSpeed' has a wrong offset!");
static_assert(offsetof(UEndLipSyncSolver, AudioLargeAttackThreshold) == 0x000030, "Member 'UEndLipSyncSolver::AudioLargeAttackThreshold' has a wrong offset!");
static_assert(offsetof(UEndLipSyncSolver, AudioLargeAttackAnimations) == 0x000038, "Member 'UEndLipSyncSolver::AudioLargeAttackAnimations' has a wrong offset!");
static_assert(offsetof(UEndLipSyncSolver, AudioLargeAttackBrowAnimations) == 0x000048, "Member 'UEndLipSyncSolver::AudioLargeAttackBrowAnimations' has a wrong offset!");
static_assert(offsetof(UEndLipSyncSolver, AudioSmallAttackThreshold) == 0x000058, "Member 'UEndLipSyncSolver::AudioSmallAttackThreshold' has a wrong offset!");
static_assert(offsetof(UEndLipSyncSolver, AudioSmallAttackAnimations) == 0x000060, "Member 'UEndLipSyncSolver::AudioSmallAttackAnimations' has a wrong offset!");
static_assert(offsetof(UEndLipSyncSolver, AudioSmallAttackBrowAnimations) == 0x000070, "Member 'UEndLipSyncSolver::AudioSmallAttackBrowAnimations' has a wrong offset!");

// Class EndGame.EndListBox
// 0x0088 (0x0180 - 0x00F8)
class UEndListBox final : public UWidget
{
public:
	EOrientation                                  Orientation;                                       // 0x00F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UWidget>                    ContentClass;                                      // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount;                                         // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DesiredCount;                                      // 0x010C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                SlotPadding;                                       // 0x0110(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class UWidget* ItemWidget, int32 ItemIndex)> OnSetupItem;                                       // 0x0120(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPressedItem;                                     // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnSelectedIndexChanged;                            // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_150[0x10];                                     // 0x0150(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UWidget*>                        ContentWidgets;                                    // 0x0160(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UWidget*>                        CachedWidgets;                                     // 0x0170(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void RefreshItem(int32 Index_0);
	void RefreshItems();
	void SetDesiredCount(int32 InDesiredCount);
	void SetItemCount(int32 InItemCount);
	void SetPadding(const struct FMargin& InPadding);
	void SetSelectedIndex(int32 UserIndex, int32 SlotIndex);

	class UWidget* GetChildAt(int32 Index_0) const;
	int32 GetSelectedIndex(int32 UserIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndListBox">();
	}
	static class UEndListBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndListBox>();
	}
};
static_assert(alignof(UEndListBox) == 0x000008, "Wrong alignment on UEndListBox");
static_assert(sizeof(UEndListBox) == 0x000180, "Wrong size on UEndListBox");
static_assert(offsetof(UEndListBox, Orientation) == 0x0000F8, "Member 'UEndListBox::Orientation' has a wrong offset!");
static_assert(offsetof(UEndListBox, ContentClass) == 0x000100, "Member 'UEndListBox::ContentClass' has a wrong offset!");
static_assert(offsetof(UEndListBox, ItemCount) == 0x000108, "Member 'UEndListBox::ItemCount' has a wrong offset!");
static_assert(offsetof(UEndListBox, DesiredCount) == 0x00010C, "Member 'UEndListBox::DesiredCount' has a wrong offset!");
static_assert(offsetof(UEndListBox, SlotPadding) == 0x000110, "Member 'UEndListBox::SlotPadding' has a wrong offset!");
static_assert(offsetof(UEndListBox, OnSetupItem) == 0x000120, "Member 'UEndListBox::OnSetupItem' has a wrong offset!");
static_assert(offsetof(UEndListBox, OnPressedItem) == 0x000130, "Member 'UEndListBox::OnPressedItem' has a wrong offset!");
static_assert(offsetof(UEndListBox, OnSelectedIndexChanged) == 0x000140, "Member 'UEndListBox::OnSelectedIndexChanged' has a wrong offset!");
static_assert(offsetof(UEndListBox, ContentWidgets) == 0x000160, "Member 'UEndListBox::ContentWidgets' has a wrong offset!");
static_assert(offsetof(UEndListBox, CachedWidgets) == 0x000170, "Member 'UEndListBox::CachedWidgets' has a wrong offset!");

// Class EndGame.EndLocationTitle
// 0x0008 (0x0368 - 0x0360)
class UEndLocationTitle final : public UEndUserWidget
{
public:
	float                                         LoopTime;                                          // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndLocationTitle">();
	}
	static class UEndLocationTitle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndLocationTitle>();
	}
};
static_assert(alignof(UEndLocationTitle) == 0x000008, "Wrong alignment on UEndLocationTitle");
static_assert(sizeof(UEndLocationTitle) == 0x000368, "Wrong size on UEndLocationTitle");
static_assert(offsetof(UEndLocationTitle, LoopTime) == 0x000360, "Member 'UEndLocationTitle::LoopTime' has a wrong offset!");

// Class EndGame.EndMainBattleSettingAbilityList
// 0x0000 (0x0360 - 0x0360)
class UEndMainBattleSettingAbilityList final : public UEndUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainBattleSettingAbilityList">();
	}
	static class UEndMainBattleSettingAbilityList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainBattleSettingAbilityList>();
	}
};
static_assert(alignof(UEndMainBattleSettingAbilityList) == 0x000008, "Wrong alignment on UEndMainBattleSettingAbilityList");
static_assert(sizeof(UEndMainBattleSettingAbilityList) == 0x000360, "Wrong size on UEndMainBattleSettingAbilityList");

// Class EndGame.EndMainBattleSettingLimitInfoPane
// 0x0008 (0x0368 - 0x0360)
class UEndMainBattleSettingLimitInfoPane final : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x8];                                      // 0x0360(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainBattleSettingLimitInfoPane">();
	}
	static class UEndMainBattleSettingLimitInfoPane* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainBattleSettingLimitInfoPane>();
	}
};
static_assert(alignof(UEndMainBattleSettingLimitInfoPane) == 0x000008, "Wrong alignment on UEndMainBattleSettingLimitInfoPane");
static_assert(sizeof(UEndMainBattleSettingLimitInfoPane) == 0x000368, "Wrong size on UEndMainBattleSettingLimitInfoPane");

// Class EndGame.EndMainBattleSettingLimitList
// 0x0020 (0x0380 - 0x0360)
class UEndMainBattleSettingLimitList final : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x20];                                     // 0x0360(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEndBattleSettingLimitListLevel(class UWidget* ItemWidget, int32 ItemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainBattleSettingLimitList">();
	}
	static class UEndMainBattleSettingLimitList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainBattleSettingLimitList>();
	}
};
static_assert(alignof(UEndMainBattleSettingLimitList) == 0x000008, "Wrong alignment on UEndMainBattleSettingLimitList");
static_assert(sizeof(UEndMainBattleSettingLimitList) == 0x000380, "Wrong size on UEndMainBattleSettingLimitList");

// Class EndGame.EndMainBattleSettingMenu
// 0x0170 (0x05A0 - 0x0430)
class UEndMainBattleSettingMenu : public UEndMainMenuWindow
{
public:
	uint8                                         Pad_430[0x170];                                    // 0x0430(0x0170)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAbilityCellPressed(int32 AbilityCellIndex);
	void OnAbilityCellSetup(class UWidget* ItemWidget, int32 CellIndex);
	void OnAbilitySelectedIndexChanged(int32 AbilityCellIndex);
	void OnCategoryCellPressed(int32 CommandCellIndex);
	void OnCategoryCellSetup(class UWidget* ItemWidget, int32 CellIndex);
	void OnCategorySelectedIndexChanged(int32 CategoryCellIndex);
	void OnLeftMenuPressedItem(int32 CellIndex);
	void OnLeftMenuSelectedIndexChanged(int32 CellIndex);
	void OnLeftMenuSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnLimitCellPressed(int32 LimitCellIndex);
	void OnLimitCellSelectedIndexChanged(int32 CellIndex);
	void OnLimitCellSetup(class UWidget* ItemWidget, int32 CellIndex);
	void OnSettingCellPressed(int32 SettingCellIndex);
	void OnSettingCellSelectedIndexChanged(int32 CellIndex);
	void OnSettingCellSetup(class UWidget* ItemWidget, int32 CellIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainBattleSettingMenu">();
	}
	static class UEndMainBattleSettingMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainBattleSettingMenu>();
	}
};
static_assert(alignof(UEndMainBattleSettingMenu) == 0x000008, "Wrong alignment on UEndMainBattleSettingMenu");
static_assert(sizeof(UEndMainBattleSettingMenu) == 0x0005A0, "Wrong size on UEndMainBattleSettingMenu");

// Class EndGame.EndMainDlcTopMenu
// 0x0090 (0x04C0 - 0x0430)
class UEndMainDlcTopMenu : public UEndMainMenuWindow
{
public:
	uint8                                         Pad_430[0x68];                                     // 0x0430(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndCanvasPanel*                        All_Dlc;                                           // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndVirtualScrollBox*                   ReportList;                                        // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndBillboard*                          Billboard_Img;                                     // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndStringScrollBox*                    DlcInfo;                                           // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B8[0x8];                                      // 0x04B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPressedItemInternal(int32 CellIndex);
	void OnSelectedIndexChangedInternal(int32 CellIndex);
	void OnSetupItemInternal(class UWidget* ItemWidget, int32 CellIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainDlcTopMenu">();
	}
	static class UEndMainDlcTopMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainDlcTopMenu>();
	}
};
static_assert(alignof(UEndMainDlcTopMenu) == 0x000008, "Wrong alignment on UEndMainDlcTopMenu");
static_assert(sizeof(UEndMainDlcTopMenu) == 0x0004C0, "Wrong size on UEndMainDlcTopMenu");
static_assert(offsetof(UEndMainDlcTopMenu, All_Dlc) == 0x000498, "Member 'UEndMainDlcTopMenu::All_Dlc' has a wrong offset!");
static_assert(offsetof(UEndMainDlcTopMenu, ReportList) == 0x0004A0, "Member 'UEndMainDlcTopMenu::ReportList' has a wrong offset!");
static_assert(offsetof(UEndMainDlcTopMenu, Billboard_Img) == 0x0004A8, "Member 'UEndMainDlcTopMenu::Billboard_Img' has a wrong offset!");
static_assert(offsetof(UEndMainDlcTopMenu, DlcInfo) == 0x0004B0, "Member 'UEndMainDlcTopMenu::DlcInfo' has a wrong offset!");

// Class EndGame.EndMainEquipMateriaInfoWindow
// 0x0000 (0x0380 - 0x0380)
class UEndMainEquipMateriaInfoWindow : public UEndMainEquipInfoWindowBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainEquipMateriaInfoWindow">();
	}
	static class UEndMainEquipMateriaInfoWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainEquipMateriaInfoWindow>();
	}
};
static_assert(alignof(UEndMainEquipMateriaInfoWindow) == 0x000008, "Wrong alignment on UEndMainEquipMateriaInfoWindow");
static_assert(sizeof(UEndMainEquipMateriaInfoWindow) == 0x000380, "Wrong size on UEndMainEquipMateriaInfoWindow");

// Class EndGame.EndMainEquipmentMateriaMenu
// 0x0210 (0x0640 - 0x0430)
class UEndMainEquipmentMateriaMenu : public UEndMainMenuWindow
{
public:
	uint8                                         Pad_430[0x188];                                    // 0x0430(0x0188)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSoftObjectPath>                _CharaImagePaths;                                  // 0x05B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UTexture2D*>                     _MateriaImages;                                    // 0x05C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class UEndImage*                              Billboard_Materia;                                 // 0x05D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndBillboard*                          Billboard_Weapon_Top;                              // 0x05E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndEquipmentMateriaInfoWindow*         SkillList;                                         // 0x05E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndTextBlock*                          Txt_Title;                                         // 0x05F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndCanvasPanel*                        BtnRemove;                                         // 0x05F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndTextBlock*                          Txt_BtnIcon;                                       // 0x0600(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndTextBlock*                          Txt_Btn;                                           // 0x0608(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndUserWidget*                         AccessoryInfo;                                     // 0x0610(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndSortWindow*                         SortList;                                          // 0x0618(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UEndUserWidget>             MateriaQuickWidget;                                // 0x0620(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndQuickMateriaMenu*                   _MateriaQuickWindow;                               // 0x0628(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_630[0x10];                                     // 0x0630(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCharaMenuPressedItem(int32 CellIndex);
	void OnCharaMenuSelectedIndexChanged(int32 CellIndex);
	void OnCharaMenuSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnEquipCategoryMenuPressedItem(int32 CellIndex);
	void OnEquipCategoryMenuSelectedIndexChanged(int32 CellIndex);
	void OnEquipCategoryMenuSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	struct FVector2D OnEquipMenuMeasureItem(int32 ItemIndex);
	void OnEquipMenuPressedItem(int32 CellIndex);
	void OnEquipMenuSelectedIndexChanged(int32 CellIndex);
	void OnEquipMenuSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	struct FVector2D OnMateriaMenuMeasureItem(int32 ItemIndex);
	void OnMateriaMenuPressedItem(int32 CellIndex);
	void OnMateriaMenuSelectedIndexChanged(int32 CellIndex);
	void OnMateriaMenuSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnSlotIndexChanged();
	void OnSlotPressed();
	void OnSortListPressedItem(int32 CellIndex);
	void OnSummonMateriaSlotPressed();
	void UpdateStatusPanel(EPlayerType PlayerType);
	void UpdateStatusPanelWithEquipment(EPlayerType PlayerType, EEquipmentCategoryMain EquipType, const class FName& EquipID, int32 EquipIndex);
	void UpdateStatusPanelWithMateria(EPlayerType PlayerType, EEquipmentCategoryMain EquipType, int32 SlotIndex, int32 OrigMateriaIndex, int32 TargetMateriaIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainEquipmentMateriaMenu">();
	}
	static class UEndMainEquipmentMateriaMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainEquipmentMateriaMenu>();
	}
};
static_assert(alignof(UEndMainEquipmentMateriaMenu) == 0x000008, "Wrong alignment on UEndMainEquipmentMateriaMenu");
static_assert(sizeof(UEndMainEquipmentMateriaMenu) == 0x000640, "Wrong size on UEndMainEquipmentMateriaMenu");
static_assert(offsetof(UEndMainEquipmentMateriaMenu, _CharaImagePaths) == 0x0005B8, "Member 'UEndMainEquipmentMateriaMenu::_CharaImagePaths' has a wrong offset!");
static_assert(offsetof(UEndMainEquipmentMateriaMenu, _MateriaImages) == 0x0005C8, "Member 'UEndMainEquipmentMateriaMenu::_MateriaImages' has a wrong offset!");
static_assert(offsetof(UEndMainEquipmentMateriaMenu, Billboard_Materia) == 0x0005D8, "Member 'UEndMainEquipmentMateriaMenu::Billboard_Materia' has a wrong offset!");
static_assert(offsetof(UEndMainEquipmentMateriaMenu, Billboard_Weapon_Top) == 0x0005E0, "Member 'UEndMainEquipmentMateriaMenu::Billboard_Weapon_Top' has a wrong offset!");
static_assert(offsetof(UEndMainEquipmentMateriaMenu, SkillList) == 0x0005E8, "Member 'UEndMainEquipmentMateriaMenu::SkillList' has a wrong offset!");
static_assert(offsetof(UEndMainEquipmentMateriaMenu, Txt_Title) == 0x0005F0, "Member 'UEndMainEquipmentMateriaMenu::Txt_Title' has a wrong offset!");
static_assert(offsetof(UEndMainEquipmentMateriaMenu, BtnRemove) == 0x0005F8, "Member 'UEndMainEquipmentMateriaMenu::BtnRemove' has a wrong offset!");
static_assert(offsetof(UEndMainEquipmentMateriaMenu, Txt_BtnIcon) == 0x000600, "Member 'UEndMainEquipmentMateriaMenu::Txt_BtnIcon' has a wrong offset!");
static_assert(offsetof(UEndMainEquipmentMateriaMenu, Txt_Btn) == 0x000608, "Member 'UEndMainEquipmentMateriaMenu::Txt_Btn' has a wrong offset!");
static_assert(offsetof(UEndMainEquipmentMateriaMenu, AccessoryInfo) == 0x000610, "Member 'UEndMainEquipmentMateriaMenu::AccessoryInfo' has a wrong offset!");
static_assert(offsetof(UEndMainEquipmentMateriaMenu, SortList) == 0x000618, "Member 'UEndMainEquipmentMateriaMenu::SortList' has a wrong offset!");
static_assert(offsetof(UEndMainEquipmentMateriaMenu, MateriaQuickWidget) == 0x000620, "Member 'UEndMainEquipmentMateriaMenu::MateriaQuickWidget' has a wrong offset!");
static_assert(offsetof(UEndMainEquipmentMateriaMenu, _MateriaQuickWindow) == 0x000628, "Member 'UEndMainEquipmentMateriaMenu::_MateriaQuickWindow' has a wrong offset!");

// Class EndGame.EndMainEquipMenu
// 0x00A0 (0x04D0 - 0x0430)
class UEndMainEquipMenu final : public UEndMainMenuWindow
{
public:
	uint8                                         Pad_430[0xA0];                                     // 0x0430(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCommandEquipCellSetup(class UWidget* ItemWidget, int32 ItemIndex);
	void OnCommandEquipStatusCellSetup(class UWidget* ItemWidget, int32 ItemIndex);
	void OnCommandMemberCellSetup(class UWidget* ItemWidget, int32 ItemIndex);
	void OnEndEquipMenuMemberClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainEquipMenu">();
	}
	static class UEndMainEquipMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainEquipMenu>();
	}
};
static_assert(alignof(UEndMainEquipMenu) == 0x000008, "Wrong alignment on UEndMainEquipMenu");
static_assert(sizeof(UEndMainEquipMenu) == 0x0004D0, "Wrong size on UEndMainEquipMenu");

// Class EndGame.EndMainEquipSelectButtonCell
// 0x0000 (0x0360 - 0x0360)
class UEndMainEquipSelectButtonCell final : public UEndUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainEquipSelectButtonCell">();
	}
	static class UEndMainEquipSelectButtonCell* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainEquipSelectButtonCell>();
	}
};
static_assert(alignof(UEndMainEquipSelectButtonCell) == 0x000008, "Wrong alignment on UEndMainEquipSelectButtonCell");
static_assert(sizeof(UEndMainEquipSelectButtonCell) == 0x000360, "Wrong size on UEndMainEquipSelectButtonCell");

// Class EndGame.EndMainEquipSelectCell
// 0x0000 (0x0360 - 0x0360)
class UEndMainEquipSelectCell : public UEndUserWidget
{
public:
	void OnEndEquipCellClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainEquipSelectCell">();
	}
	static class UEndMainEquipSelectCell* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainEquipSelectCell>();
	}
};
static_assert(alignof(UEndMainEquipSelectCell) == 0x000008, "Wrong alignment on UEndMainEquipSelectCell");
static_assert(sizeof(UEndMainEquipSelectCell) == 0x000360, "Wrong size on UEndMainEquipSelectCell");

// Class EndGame.EndMainItemMenuList
// 0x0020 (0x0380 - 0x0360)
class UEndMainItemMenuList : public UEndMainMenuListBase
{
public:
	uint8                                         Pad_360[0x20];                                     // 0x0360(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainItemMenuList">();
	}
	static class UEndMainItemMenuList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainItemMenuList>();
	}
};
static_assert(alignof(UEndMainItemMenuList) == 0x000008, "Wrong alignment on UEndMainItemMenuList");
static_assert(sizeof(UEndMainItemMenuList) == 0x000380, "Wrong size on UEndMainItemMenuList");

// Class EndGame.EndMainItemSelectBtnText
// 0x0030 (0x0390 - 0x0360)
class UEndMainItemSelectBtnText : public UEndUserWidget
{
public:
	class UEndUserWidget*                         Icon_Item;                                         // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Name;                                          // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Icon_Range;                                        // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Amount;                                        // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        Pnl_AutoMark;                                      // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndButton*                             SelectBtn;                                         // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainItemSelectBtnText">();
	}
	static class UEndMainItemSelectBtnText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainItemSelectBtnText>();
	}
};
static_assert(alignof(UEndMainItemSelectBtnText) == 0x000008, "Wrong alignment on UEndMainItemSelectBtnText");
static_assert(sizeof(UEndMainItemSelectBtnText) == 0x000390, "Wrong size on UEndMainItemSelectBtnText");
static_assert(offsetof(UEndMainItemSelectBtnText, Icon_Item) == 0x000360, "Member 'UEndMainItemSelectBtnText::Icon_Item' has a wrong offset!");
static_assert(offsetof(UEndMainItemSelectBtnText, Txt_Name) == 0x000368, "Member 'UEndMainItemSelectBtnText::Txt_Name' has a wrong offset!");
static_assert(offsetof(UEndMainItemSelectBtnText, Icon_Range) == 0x000370, "Member 'UEndMainItemSelectBtnText::Icon_Range' has a wrong offset!");
static_assert(offsetof(UEndMainItemSelectBtnText, Txt_Amount) == 0x000378, "Member 'UEndMainItemSelectBtnText::Txt_Amount' has a wrong offset!");
static_assert(offsetof(UEndMainItemSelectBtnText, Pnl_AutoMark) == 0x000380, "Member 'UEndMainItemSelectBtnText::Pnl_AutoMark' has a wrong offset!");
static_assert(offsetof(UEndMainItemSelectBtnText, SelectBtn) == 0x000388, "Member 'UEndMainItemSelectBtnText::SelectBtn' has a wrong offset!");

// Class EndGame.EndMainMagicMenu
// 0x00F0 (0x0520 - 0x0430)
class UEndMainMagicMenu : public UEndMainMenuWindow
{
public:
	uint8                                         Pad_430[0xA0];                                     // 0x0430(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndTextBlock*                          Txt_Category_Title;                                // 0x04D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndBillboard*                          Billboard_CategoryImg;                             // 0x04D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndUserWidget*                         LeftMenu;                                          // 0x04E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndUserWidget*                         ItemList;                                          // 0x04E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndUserWidget*                         SelectMemberList;                                  // 0x04F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndCanvasPanel*                        Detail;                                            // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndUserWidget*                         EquipCell_Top;                                     // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndBillboard*                          Billboard_CharaImg;                                // 0x0508(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FSoftObjectPath>                _CharaImagePaths;                                  // 0x0510(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void OnLeftMenuIndexChanged(int32 CellIndex);
	void OnLeftMenuPressedItem(int32 CellIndex);
	void OnLeftMenuSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnMagicMenuIndexChanged(int32 CellIndex);
	void OnMagicMenuPressedItem(int32 CellIndex);
	void OnMagicMenuSetupItem(class UWidget* ItemWidget, int32 CellIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainMagicMenu">();
	}
	static class UEndMainMagicMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainMagicMenu>();
	}
};
static_assert(alignof(UEndMainMagicMenu) == 0x000008, "Wrong alignment on UEndMainMagicMenu");
static_assert(sizeof(UEndMainMagicMenu) == 0x000520, "Wrong size on UEndMainMagicMenu");
static_assert(offsetof(UEndMainMagicMenu, Txt_Category_Title) == 0x0004D0, "Member 'UEndMainMagicMenu::Txt_Category_Title' has a wrong offset!");
static_assert(offsetof(UEndMainMagicMenu, Billboard_CategoryImg) == 0x0004D8, "Member 'UEndMainMagicMenu::Billboard_CategoryImg' has a wrong offset!");
static_assert(offsetof(UEndMainMagicMenu, LeftMenu) == 0x0004E0, "Member 'UEndMainMagicMenu::LeftMenu' has a wrong offset!");
static_assert(offsetof(UEndMainMagicMenu, ItemList) == 0x0004E8, "Member 'UEndMainMagicMenu::ItemList' has a wrong offset!");
static_assert(offsetof(UEndMainMagicMenu, SelectMemberList) == 0x0004F0, "Member 'UEndMainMagicMenu::SelectMemberList' has a wrong offset!");
static_assert(offsetof(UEndMainMagicMenu, Detail) == 0x0004F8, "Member 'UEndMainMagicMenu::Detail' has a wrong offset!");
static_assert(offsetof(UEndMainMagicMenu, EquipCell_Top) == 0x000500, "Member 'UEndMainMagicMenu::EquipCell_Top' has a wrong offset!");
static_assert(offsetof(UEndMainMagicMenu, Billboard_CharaImg) == 0x000508, "Member 'UEndMainMagicMenu::Billboard_CharaImg' has a wrong offset!");
static_assert(offsetof(UEndMainMagicMenu, _CharaImagePaths) == 0x000510, "Member 'UEndMainMagicMenu::_CharaImagePaths' has a wrong offset!");

// Class EndGame.EndMainMagicMenuList
// 0x0010 (0x0370 - 0x0360)
class UEndMainMagicMenuList final : public UEndMainMenuListBase
{
public:
	uint8                                         Pad_360[0x10];                                     // 0x0360(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainMagicMenuList">();
	}
	static class UEndMainMagicMenuList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainMagicMenuList>();
	}
};
static_assert(alignof(UEndMainMagicMenuList) == 0x000008, "Wrong alignment on UEndMainMagicMenuList");
static_assert(sizeof(UEndMainMagicMenuList) == 0x000370, "Wrong size on UEndMainMagicMenuList");

// Class EndGame.EndMainManualMenu
// 0x0100 (0x0530 - 0x0430)
class UEndMainManualMenu : public UEndMainMenuWindow
{
public:
	uint8                                         Pad_430[0xC8];                                     // 0x0430(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndVirtualScrollBox*                   LeftMenu;                                          // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndCanvasPanel*                        Detail;                                            // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndTextBlock*                          Txt_Category_Title;                                // 0x0508(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndTextBlock*                          Txt_Detail_Title;                                  // 0x0510(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndImageSet*                           Title_Icon;                                        // 0x0518(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndVirtualScrollBox*                   DetailScrollBox;                                   // 0x0520(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndBillboard*                          Billboard_CategoryImg;                             // 0x0528(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnLeftMenuPressedItem(int32 CellIndex);
	void OnLeftMenuSelectedIndexChanged(int32 CellIndex);
	void OnLeftMenuSetupItem(class UWidget* ItemWidget, int32 CellIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainManualMenu">();
	}
	static class UEndMainManualMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainManualMenu>();
	}
};
static_assert(alignof(UEndMainManualMenu) == 0x000008, "Wrong alignment on UEndMainManualMenu");
static_assert(sizeof(UEndMainManualMenu) == 0x000530, "Wrong size on UEndMainManualMenu");
static_assert(offsetof(UEndMainManualMenu, LeftMenu) == 0x0004F8, "Member 'UEndMainManualMenu::LeftMenu' has a wrong offset!");
static_assert(offsetof(UEndMainManualMenu, Detail) == 0x000500, "Member 'UEndMainManualMenu::Detail' has a wrong offset!");
static_assert(offsetof(UEndMainManualMenu, Txt_Category_Title) == 0x000508, "Member 'UEndMainManualMenu::Txt_Category_Title' has a wrong offset!");
static_assert(offsetof(UEndMainManualMenu, Txt_Detail_Title) == 0x000510, "Member 'UEndMainManualMenu::Txt_Detail_Title' has a wrong offset!");
static_assert(offsetof(UEndMainManualMenu, Title_Icon) == 0x000518, "Member 'UEndMainManualMenu::Title_Icon' has a wrong offset!");
static_assert(offsetof(UEndMainManualMenu, DetailScrollBox) == 0x000520, "Member 'UEndMainManualMenu::DetailScrollBox' has a wrong offset!");
static_assert(offsetof(UEndMainManualMenu, Billboard_CategoryImg) == 0x000528, "Member 'UEndMainManualMenu::Billboard_CategoryImg' has a wrong offset!");

// Class EndGame.EndMainMenuCharaCell
// 0x0000 (0x0360 - 0x0360)
class UEndMainMenuCharaCell final : public UEndUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainMenuCharaCell">();
	}
	static class UEndMainMenuCharaCell* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainMenuCharaCell>();
	}
};
static_assert(alignof(UEndMainMenuCharaCell) == 0x000008, "Wrong alignment on UEndMainMenuCharaCell");
static_assert(sizeof(UEndMainMenuCharaCell) == 0x000360, "Wrong size on UEndMainMenuCharaCell");

// Class EndGame.EndMainPlaylogList
// 0x0000 (0x0360 - 0x0360)
class UEndMainPlaylogList : public UEndUserWidget
{
public:
	void OnLogListSetupItem(class UWidget* ItemWidget, int32 ItemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainPlaylogList">();
	}
	static class UEndMainPlaylogList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainPlaylogList>();
	}
};
static_assert(alignof(UEndMainPlaylogList) == 0x000008, "Wrong alignment on UEndMainPlaylogList");
static_assert(sizeof(UEndMainPlaylogList) == 0x000360, "Wrong size on UEndMainPlaylogList");

// Class EndGame.EndMainStatusMenu
// 0x0110 (0x0540 - 0x0430)
class UEndMainStatusMenu : public UEndMainMenuWindow
{
public:
	uint8                                         Pad_430[0x110];                                    // 0x0430(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLeftMenuSelectedIndexChanged(int32 CellIndex);
	void OnLeftMenuSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	struct FVector2D OnMeasureAbilityItem(int32 CellIndex);
	struct FVector2D OnMeasureLimitItem(int32 CellIndex);
	struct FVector2D OnMeasureMagicItem(int32 CellIndex);
	struct FVector2D OnMeasureStatusItem(int32 ItemIndex);
	struct FVector2D OnMeasureSummonItem(int32 CellIndex);
	void OnSetupAbilityItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnSetupLimitItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnSetupMagicItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnSetupStatusItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnSetupSummonItem(class UWidget* ItemWidget, int32 CellIndex);
	void SetupDescriptionTitle();
	void UpdateDescription(EPlayerType PlayerType);
	void UpdateEquipmentInfo(int32 CellIndex, EPlayerType PlayerType);
	void UpdatePlayerStatusInfo(int32 CellIndex, EPlayerType PlayerType);
	void UpdateStatusPanel(EPlayerType PlayerType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainStatusMenu">();
	}
	static class UEndMainStatusMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainStatusMenu>();
	}
};
static_assert(alignof(UEndMainStatusMenu) == 0x000008, "Wrong alignment on UEndMainStatusMenu");
static_assert(sizeof(UEndMainStatusMenu) == 0x000540, "Wrong size on UEndMainStatusMenu");

// Class EndGame.EndMainWeaponUpgradeListCell
// 0x0000 (0x0360 - 0x0360)
class UEndMainWeaponUpgradeListCell : public UEndUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainWeaponUpgradeListCell">();
	}
	static class UEndMainWeaponUpgradeListCell* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainWeaponUpgradeListCell>();
	}
};
static_assert(alignof(UEndMainWeaponUpgradeListCell) == 0x000008, "Wrong alignment on UEndMainWeaponUpgradeListCell");
static_assert(sizeof(UEndMainWeaponUpgradeListCell) == 0x000360, "Wrong size on UEndMainWeaponUpgradeListCell");

// Class EndGame.EndMainWeaponUpgradeMenu
// 0x0320 (0x0680 - 0x0360)
class UEndMainWeaponUpgradeMenu : public UEndUserWidget
{
public:
	class USoundAttenuation*                      SoundAttenuation;                                  // 0x0360(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_368[0x308];                                    // 0x0368(0x0308)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndUserWidget*                         SpBox;                                             // 0x0670(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_678[0x8];                                      // 0x0678(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCoreMenuSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnMenuInFinish();
	void OnNoButtonClicked();
	void OnSkillListMenuSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnYesButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMainWeaponUpgradeMenu">();
	}
	static class UEndMainWeaponUpgradeMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMainWeaponUpgradeMenu>();
	}
};
static_assert(alignof(UEndMainWeaponUpgradeMenu) == 0x000008, "Wrong alignment on UEndMainWeaponUpgradeMenu");
static_assert(sizeof(UEndMainWeaponUpgradeMenu) == 0x000680, "Wrong size on UEndMainWeaponUpgradeMenu");
static_assert(offsetof(UEndMainWeaponUpgradeMenu, SoundAttenuation) == 0x000360, "Member 'UEndMainWeaponUpgradeMenu::SoundAttenuation' has a wrong offset!");
static_assert(offsetof(UEndMainWeaponUpgradeMenu, SpBox) == 0x000670, "Member 'UEndMainWeaponUpgradeMenu::SpBox' has a wrong offset!");

// Class EndGame.EndMapJournalMenu
// 0x0140 (0x04A0 - 0x0360)
class UEndMapJournalMenu : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0xB0];                                     // 0x0360(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndTextBlock*                          TitleText;                                         // 0x0410(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndTextBlock*                          LeftText;                                          // 0x0418(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndTextBlock*                          LeftText2;                                         // 0x0420(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndTextBlock*                          RightText;                                         // 0x0428(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndTextBlock*                          RightText2;                                        // 0x0430(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidget*                                L2Image;                                           // 0x0438(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidget*                                R2Image;                                           // 0x0440(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidget*                                LeftImage;                                         // 0x0448(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidget*                                LeftImage2;                                        // 0x0450(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidget*                                RightImage;                                        // 0x0458(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidget*                                RightImage2;                                       // 0x0460(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndTextBlock*                          TimeText;                                          // 0x0468(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndTextBlock*                          GilText;                                           // 0x0470(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndTextBlock*                          HelpText;                                          // 0x0478(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndTextBlock*                          GuideText;                                         // 0x0480(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndTextBlock*                          MiniGuideText;                                     // 0x0488(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMapJournalMenu">();
	}
	static class UEndMapJournalMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMapJournalMenu>();
	}
};
static_assert(alignof(UEndMapJournalMenu) == 0x000008, "Wrong alignment on UEndMapJournalMenu");
static_assert(sizeof(UEndMapJournalMenu) == 0x0004A0, "Wrong size on UEndMapJournalMenu");
static_assert(offsetof(UEndMapJournalMenu, TitleText) == 0x000410, "Member 'UEndMapJournalMenu::TitleText' has a wrong offset!");
static_assert(offsetof(UEndMapJournalMenu, LeftText) == 0x000418, "Member 'UEndMapJournalMenu::LeftText' has a wrong offset!");
static_assert(offsetof(UEndMapJournalMenu, LeftText2) == 0x000420, "Member 'UEndMapJournalMenu::LeftText2' has a wrong offset!");
static_assert(offsetof(UEndMapJournalMenu, RightText) == 0x000428, "Member 'UEndMapJournalMenu::RightText' has a wrong offset!");
static_assert(offsetof(UEndMapJournalMenu, RightText2) == 0x000430, "Member 'UEndMapJournalMenu::RightText2' has a wrong offset!");
static_assert(offsetof(UEndMapJournalMenu, L2Image) == 0x000438, "Member 'UEndMapJournalMenu::L2Image' has a wrong offset!");
static_assert(offsetof(UEndMapJournalMenu, R2Image) == 0x000440, "Member 'UEndMapJournalMenu::R2Image' has a wrong offset!");
static_assert(offsetof(UEndMapJournalMenu, LeftImage) == 0x000448, "Member 'UEndMapJournalMenu::LeftImage' has a wrong offset!");
static_assert(offsetof(UEndMapJournalMenu, LeftImage2) == 0x000450, "Member 'UEndMapJournalMenu::LeftImage2' has a wrong offset!");
static_assert(offsetof(UEndMapJournalMenu, RightImage) == 0x000458, "Member 'UEndMapJournalMenu::RightImage' has a wrong offset!");
static_assert(offsetof(UEndMapJournalMenu, RightImage2) == 0x000460, "Member 'UEndMapJournalMenu::RightImage2' has a wrong offset!");
static_assert(offsetof(UEndMapJournalMenu, TimeText) == 0x000468, "Member 'UEndMapJournalMenu::TimeText' has a wrong offset!");
static_assert(offsetof(UEndMapJournalMenu, GilText) == 0x000470, "Member 'UEndMapJournalMenu::GilText' has a wrong offset!");
static_assert(offsetof(UEndMapJournalMenu, HelpText) == 0x000478, "Member 'UEndMapJournalMenu::HelpText' has a wrong offset!");
static_assert(offsetof(UEndMapJournalMenu, GuideText) == 0x000480, "Member 'UEndMapJournalMenu::GuideText' has a wrong offset!");
static_assert(offsetof(UEndMapJournalMenu, MiniGuideText) == 0x000488, "Member 'UEndMapJournalMenu::MiniGuideText' has a wrong offset!");

// Class EndGame.EndMenuBPAPI
// 0x0000 (0x0028 - 0x0028)
class UEndMenuBPAPI final : public UBlueprintFunctionLibrary
{
public:
	static void BPAbsoluteToViewport(class UWorld* World, const struct FGeometry& Geometry, const struct FVector2D& AbsoluteCoordinate, struct FVector2D* ScreenPosition, struct FVector2D* ViewportPosition);
	static const TArray<class FName> BPGetAllChapters();
	static const int32 BPGetCurrentChapter(class FName* ChapterID);
	static const struct FEndDataTableEquipment BPGetCurrentEquipment(EPlayerType PlayerType, EEquipmentCategoryMain EquipType);
	static const int32 BPGetFinalPower(EPlayerType PlayerType, int32 PowerValue, EEndBattleDamageSourcePowerType PowerType);
	static const class FString BPGetFirstName(EPlayerType Type);
	static const class FString BPGetLastName(EPlayerType Type);
	static class FName BPGetMemberName(EPlayerType PlayerType);
	static int32 BPGetPlayerDexterity(EPlayerType Type);
	static int32 BPGetPlayerExperience(EPlayerType Type);
	static int32 BPGetPlayerExperienceBase(EPlayerType Type);
	static int32 BPGetPlayerExperienceNext(EPlayerType Type);
	static int32 BPGetPlayerHP(EPlayerType Type);
	static int32 BPGetPlayerHPMax(EPlayerType Type);
	static int32 BPGetPlayerLevel(EPlayerType Type);
	static int32 BPGetPlayerLimit(EPlayerType Type);
	static int32 BPGetPlayerLimitLevel(EPlayerType Type);
	static int32 BPGetPlayerLimitLevelMax(EPlayerType Type);
	static int32 BPGetPlayerLimitMax(EPlayerType Type);
	static int32 BPGetPlayerLuck(EPlayerType Type);
	static int32 BPGetPlayerMagic(EPlayerType Type);
	static int32 BPGetPlayerMagicAttack(EPlayerType Type);
	static int32 BPGetPlayerMagicDefense(EPlayerType Type);
	static int32 BPGetPlayerMaxMP(EPlayerType Type);
	static int32 BPGetPlayerMP(EPlayerType Type);
	static int32 BPGetPlayerPhysicsAttack(EPlayerType Type);
	static int32 BPGetPlayerPhysicsDefense(EPlayerType Type);
	static int32 BPGetPlayerSpirit(EPlayerType Type);
	static const struct FEndPlayerStatus BPGetPlayerStatus(EPlayerType PlayerType);
	static const struct FEndPlayerStatus BPGetPlayerStatusWithEquipment(EPlayerType PlayerType, EEquipmentCategoryMain EquipType, const class FName& EquipID, int32 EquipmentIndexToEquip);
	static const struct FEndPlayerStatus BPGetPlayerStatusWithMateria(EPlayerType PlayerType, int32 OrigMateriaIndex, int32 TargetMateriaIndex, int32 SlotIndex, EEquipmentCategoryMain materiaEquipType);
	static int32 BPGetPlayerStrength(EPlayerType Type);
	static int32 BPGetPlayerVitality(EPlayerType Type);
	static const bool BPIsCharacterDead(EPlayerType PlayerType);
	static void BPLocalToViewport(class UWorld* World, const struct FGeometry& Geometry, const struct FVector2D& LocalCoordinate, struct FVector2D* ScreenPosition, struct FVector2D* ViewportPosition);
	static void BPSetPlayerExperience(EPlayerType Type, int32 Exp);
	static void BPSetPlayerHP(EPlayerType Type, int32 HP);
	static void BPSetPlayerHPMax(EPlayerType Type, int32 HP);
	static void BPSetPlayerLevel(EPlayerType Type, int32 Level);
	static void BPSetPlayerLimit(EPlayerType Type, int32 Limit);
	static void BPSetPlayerLimitLevel(EPlayerType Type, int32 LimitLevel);
	static void BPSetPlayerLimitLevelMax(EPlayerType Type, int32 LimitLevelMax);
	static void BPSetPlayerLimitMax(EPlayerType Type, int32 LimitMax);
	static void BPSetPlayerMaxMP(EPlayerType Type, int32 MaxHp);
	static void BPSetPlayerMP(EPlayerType Type, int32 MP);
	static void BPSetupBillboard(class UUserWidget* TopStatus, EPlayerType PlayerType, bool enableReleaseSlate);
	static void BPSetupLeaderLabel(class UUserWidget* TopStatus, EPlayerType PlayerType, EPlayerType LeaderType);
	static void BPSetupStatus(class UUserWidget* TopStatus, EPlayerType PlayerType);
	static void BPSetupStatusPanel(class UUserWidget* TopStatus, EPlayerType PlayerType, EPlayerType LeaderType);
	static void BPViewportToAbsolute(class UWorld* World, const struct FGeometry& Geometry, const struct FVector2D& ViewportPosition, struct FVector2D* AbsoluteCoordinate);
	static void BPViewportToLocal(class UWorld* World, const struct FGeometry& Geometry, const struct FVector2D& ViewportPosition, struct FVector2D* LocalCoordinate);
	static void ResetLinkedMateria(const TArray<class UEndMainMateriaListBoxWindow*>& MateriaLists);
	static void SetIgnoreListRepeatKey(const class UEndListBox* Widget, const class FName& ButtonName);
	static void SetIgnoreRepeatKey(const class UEndVirtualScrollBox* Widget, const class FName& ButtonName);
	static void UpdateLinkedMateria(const TArray<class UEndMainMateriaListBoxWindow*>& MateriaLists);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMenuBPAPI">();
	}
	static class UEndMenuBPAPI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMenuBPAPI>();
	}
};
static_assert(alignof(UEndMenuBPAPI) == 0x000008, "Wrong alignment on UEndMenuBPAPI");
static_assert(sizeof(UEndMenuBPAPI) == 0x000028, "Wrong size on UEndMenuBPAPI");

// Class EndGame.EndMenuCategoryChangeBtn
// 0x0000 (0x0360 - 0x0360)
class UEndMenuCategoryChangeBtn : public UEndUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMenuCategoryChangeBtn">();
	}
	static class UEndMenuCategoryChangeBtn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMenuCategoryChangeBtn>();
	}
};
static_assert(alignof(UEndMenuCategoryChangeBtn) == 0x000008, "Wrong alignment on UEndMenuCategoryChangeBtn");
static_assert(sizeof(UEndMenuCategoryChangeBtn) == 0x000360, "Wrong size on UEndMenuCategoryChangeBtn");

// Class EndGame.EndMenuCmdLimitEffect
// 0x0008 (0x0368 - 0x0360)
class UEndMenuCmdLimitEffect : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x8];                                      // 0x0360(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMenuCmdLimitEffect">();
	}
	static class UEndMenuCmdLimitEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMenuCmdLimitEffect>();
	}
};
static_assert(alignof(UEndMenuCmdLimitEffect) == 0x000008, "Wrong alignment on UEndMenuCmdLimitEffect");
static_assert(sizeof(UEndMenuCmdLimitEffect) == 0x000368, "Wrong size on UEndMenuCmdLimitEffect");

// Class EndGame.EndMenuCmdSummonEffect
// 0x0018 (0x0378 - 0x0360)
class UEndMenuCmdSummonEffect : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x18];                                     // 0x0360(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMenuCmdSummonEffect">();
	}
	static class UEndMenuCmdSummonEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMenuCmdSummonEffect>();
	}
};
static_assert(alignof(UEndMenuCmdSummonEffect) == 0x000008, "Wrong alignment on UEndMenuCmdSummonEffect");
static_assert(sizeof(UEndMenuCmdSummonEffect) == 0x000378, "Wrong size on UEndMenuCmdSummonEffect");

// Class EndGame.EndMenuColosseumPrototypeData
// 0x0150 (0x0178 - 0x0028)
class UEndMenuColosseumPrototypeData final : public UObject
{
public:
	TMap<class FName, struct FEndMenuColosseumCourseBattlePrototypeData> CourseBattles;                                     // 0x0028(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FEndMenuColosseumSpecialBattlePrototypeData> SpecialBattles;                                    // 0x0078(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FEndMenuColosseumPowerUpPrototypeData> PowerUpList;                                       // 0x00C8(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FEndMenuColosseumSupplyPrototypeData> SupplyList;                                        // 0x0118(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FEndMenuColosseumHandicapPrototypeData> HandicapList;                                      // 0x0128(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMenuColosseumPrototypeData">();
	}
	static class UEndMenuColosseumPrototypeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMenuColosseumPrototypeData>();
	}
};
static_assert(alignof(UEndMenuColosseumPrototypeData) == 0x000008, "Wrong alignment on UEndMenuColosseumPrototypeData");
static_assert(sizeof(UEndMenuColosseumPrototypeData) == 0x000178, "Wrong size on UEndMenuColosseumPrototypeData");
static_assert(offsetof(UEndMenuColosseumPrototypeData, CourseBattles) == 0x000028, "Member 'UEndMenuColosseumPrototypeData::CourseBattles' has a wrong offset!");
static_assert(offsetof(UEndMenuColosseumPrototypeData, SpecialBattles) == 0x000078, "Member 'UEndMenuColosseumPrototypeData::SpecialBattles' has a wrong offset!");
static_assert(offsetof(UEndMenuColosseumPrototypeData, PowerUpList) == 0x0000C8, "Member 'UEndMenuColosseumPrototypeData::PowerUpList' has a wrong offset!");
static_assert(offsetof(UEndMenuColosseumPrototypeData, SupplyList) == 0x000118, "Member 'UEndMenuColosseumPrototypeData::SupplyList' has a wrong offset!");
static_assert(offsetof(UEndMenuColosseumPrototypeData, HandicapList) == 0x000128, "Member 'UEndMenuColosseumPrototypeData::HandicapList' has a wrong offset!");

// Class EndGame.EndMenuGameOverHandler
// 0x0010 (0x0038 - 0x0028)
class UEndMenuGameOverHandler final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCommandCellSetup(class UWidget* ItemWidget, int32 ItemIndex);
	void OnCommandClicked(int32 ItemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMenuGameOverHandler">();
	}
	static class UEndMenuGameOverHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMenuGameOverHandler>();
	}
};
static_assert(alignof(UEndMenuGameOverHandler) == 0x000008, "Wrong alignment on UEndMenuGameOverHandler");
static_assert(sizeof(UEndMenuGameOverHandler) == 0x000038, "Wrong size on UEndMenuGameOverHandler");

// Class EndGame.EndMenuMateriaEquipCell
// 0x0000 (0x0360 - 0x0360)
class UEndMenuMateriaEquipCell : public UEndUserWidget
{
public:
	void OnUpdateEquipStatus(const struct FEndDataTableEquipment& equipment);
	void OnUpdateEquipUpgradedStatus(int32 Attack, int32 Defense, int32 MagicAttack, int32 MagicDefense, int32 AttackAdd, int32 DefenseAdd, int32 MagicAttackAdd, int32 MagicDefenseAdd);
	void OnUpdateMaterialStatus(const class FString& ApStr, float Percent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMenuMateriaEquipCell">();
	}
	static class UEndMenuMateriaEquipCell* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMenuMateriaEquipCell>();
	}
};
static_assert(alignof(UEndMenuMateriaEquipCell) == 0x000008, "Wrong alignment on UEndMenuMateriaEquipCell");
static_assert(sizeof(UEndMenuMateriaEquipCell) == 0x000360, "Wrong size on UEndMenuMateriaEquipCell");

// Class EndGame.EndMenuMemberSelectBtn
// 0x0000 (0x0360 - 0x0360)
class UEndMenuMemberSelectBtn : public UEndUserWidget
{
public:
	void OnChangeCharacterCell(EPlayerType PlayerType);
	void OnSetupCharacterCell(EPlayerType PlayerType);
	void OnSetupSelectBtn(EPlayerType PlayerType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMenuMemberSelectBtn">();
	}
	static class UEndMenuMemberSelectBtn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMenuMemberSelectBtn>();
	}
};
static_assert(alignof(UEndMenuMemberSelectBtn) == 0x000008, "Wrong alignment on UEndMenuMemberSelectBtn");
static_assert(sizeof(UEndMenuMemberSelectBtn) == 0x000360, "Wrong size on UEndMenuMemberSelectBtn");

// Class EndGame.EndMenuMigration
// 0x0000 (0x0028 - 0x0028)
class UEndMenuMigration final : public UObject
{
public:
	static class FText GetTextFromTextBlock(class UWidget* InTextBlock);
	static void SetTextToTextBlock(class UWidget* InTextBlock, const class FText& InText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMenuMigration">();
	}
	static class UEndMenuMigration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMenuMigration>();
	}
};
static_assert(alignof(UEndMenuMigration) == 0x000008, "Wrong alignment on UEndMenuMigration");
static_assert(sizeof(UEndMenuMigration) == 0x000028, "Wrong size on UEndMenuMigration");

// Class EndGame.EndMenuSpeedMeterIcon
// 0x0010 (0x0370 - 0x0360)
class UEndMenuSpeedMeterIcon final : public UEndUserWidget
{
public:
	float                                         START;                                             // 0x0360(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0364(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeterUpAnimationPower;                             // 0x0368(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36C[0x4];                                      // 0x036C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMenuSpeedMeterIcon">();
	}
	static class UEndMenuSpeedMeterIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMenuSpeedMeterIcon>();
	}
};
static_assert(alignof(UEndMenuSpeedMeterIcon) == 0x000008, "Wrong alignment on UEndMenuSpeedMeterIcon");
static_assert(sizeof(UEndMenuSpeedMeterIcon) == 0x000370, "Wrong size on UEndMenuSpeedMeterIcon");
static_assert(offsetof(UEndMenuSpeedMeterIcon, START) == 0x000360, "Member 'UEndMenuSpeedMeterIcon::START' has a wrong offset!");
static_assert(offsetof(UEndMenuSpeedMeterIcon, Max) == 0x000364, "Member 'UEndMenuSpeedMeterIcon::Max' has a wrong offset!");
static_assert(offsetof(UEndMenuSpeedMeterIcon, MeterUpAnimationPower) == 0x000368, "Member 'UEndMenuSpeedMeterIcon::MeterUpAnimationPower' has a wrong offset!");

// Class EndGame.EndMenuStatusPaneCell
// 0x0488 (0x07E8 - 0x0360)
class UEndMenuStatusPaneCell : public UEndUserWidget
{
public:
	struct FSlateBrush                            _DefaultBrush;                                     // 0x0360(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            _PreviewBrush;                                     // 0x03D8(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            _StopBrush;                                        // 0x0450(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            _AliveBrush;                                       // 0x04C8(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            _DeadBrush;                                        // 0x0540(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            _SupporterBrush;                                   // 0x05B8(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLinearColor                           _SyncNameColor;                                    // 0x0630(0x0010)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _SyncActive;                                       // 0x0640(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_641[0x3];                                      // 0x0641(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEndStatusMenuHPColors                 _DeufaultHPColor;                                  // 0x0644(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FEndStatusMenuHPColors                 _DeadLineHPColor;                                  // 0x0664(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_684[0x164];                                    // 0x0684(0x0164)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMenuStatusPaneCell">();
	}
	static class UEndMenuStatusPaneCell* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMenuStatusPaneCell>();
	}
};
static_assert(alignof(UEndMenuStatusPaneCell) == 0x000008, "Wrong alignment on UEndMenuStatusPaneCell");
static_assert(sizeof(UEndMenuStatusPaneCell) == 0x0007E8, "Wrong size on UEndMenuStatusPaneCell");
static_assert(offsetof(UEndMenuStatusPaneCell, _DefaultBrush) == 0x000360, "Member 'UEndMenuStatusPaneCell::_DefaultBrush' has a wrong offset!");
static_assert(offsetof(UEndMenuStatusPaneCell, _PreviewBrush) == 0x0003D8, "Member 'UEndMenuStatusPaneCell::_PreviewBrush' has a wrong offset!");
static_assert(offsetof(UEndMenuStatusPaneCell, _StopBrush) == 0x000450, "Member 'UEndMenuStatusPaneCell::_StopBrush' has a wrong offset!");
static_assert(offsetof(UEndMenuStatusPaneCell, _AliveBrush) == 0x0004C8, "Member 'UEndMenuStatusPaneCell::_AliveBrush' has a wrong offset!");
static_assert(offsetof(UEndMenuStatusPaneCell, _DeadBrush) == 0x000540, "Member 'UEndMenuStatusPaneCell::_DeadBrush' has a wrong offset!");
static_assert(offsetof(UEndMenuStatusPaneCell, _SupporterBrush) == 0x0005B8, "Member 'UEndMenuStatusPaneCell::_SupporterBrush' has a wrong offset!");
static_assert(offsetof(UEndMenuStatusPaneCell, _SyncNameColor) == 0x000630, "Member 'UEndMenuStatusPaneCell::_SyncNameColor' has a wrong offset!");
static_assert(offsetof(UEndMenuStatusPaneCell, _SyncActive) == 0x000640, "Member 'UEndMenuStatusPaneCell::_SyncActive' has a wrong offset!");
static_assert(offsetof(UEndMenuStatusPaneCell, _DeufaultHPColor) == 0x000644, "Member 'UEndMenuStatusPaneCell::_DeufaultHPColor' has a wrong offset!");
static_assert(offsetof(UEndMenuStatusPaneCell, _DeadLineHPColor) == 0x000664, "Member 'UEndMenuStatusPaneCell::_DeadLineHPColor' has a wrong offset!");

// Class EndGame.EndMessageLogsCell
// 0x0008 (0x0368 - 0x0360)
class UEndMessageLogsCell : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x8];                                      // 0x0360(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMessageLogsCell">();
	}
	static class UEndMessageLogsCell* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMessageLogsCell>();
	}
};
static_assert(alignof(UEndMessageLogsCell) == 0x000008, "Wrong alignment on UEndMessageLogsCell");
static_assert(sizeof(UEndMessageLogsCell) == 0x000368, "Wrong size on UEndMessageLogsCell");

// Class EndGame.EndMessageWindow
// 0x00B0 (0x0410 - 0x0360)
class UEndMessageWindow : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0xB0];                                     // 0x0360(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMessageWindow">();
	}
	static class UEndMessageWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMessageWindow>();
	}
};
static_assert(alignof(UEndMessageWindow) == 0x000008, "Wrong alignment on UEndMessageWindow");
static_assert(sizeof(UEndMessageWindow) == 0x000410, "Wrong size on UEndMessageWindow");

// Class EndGame.EndMidgarMenu
// 0x01D0 (0x0600 - 0x0430)
class UEndMidgarMenu : public UEndMainMenuWindow
{
public:
	float                                         ZoomMinDistance;                                   // 0x0430(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomMaxDistance;                                   // 0x0434(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomDistanceUpperLayerDefault;                     // 0x0438(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomDistanceLowerLayerDefault;                     // 0x043C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultCurrentLocationAngleOffset;                 // 0x0440(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResetAnimationLength;                              // 0x0444(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MidgarSectorsAnimationLength;                      // 0x0448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInOutLenght;                                   // 0x044C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationYMin;                                      // 0x0450(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationYMax;                                      // 0x0454(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationYDefault;                                  // 0x0458(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationXDefault;                                  // 0x045C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutAnimationSpeedUp;                               // 0x0460(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationXSpeed;                                    // 0x0464(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationYSpeed;                                    // 0x0468(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomSpeed;                                         // 0x046C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_470[0x190];                                    // 0x0470(0x0190)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ShowLegend(bool Show);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMidgarMenu">();
	}
	static class UEndMidgarMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndMidgarMenu>();
	}
};
static_assert(alignof(UEndMidgarMenu) == 0x000008, "Wrong alignment on UEndMidgarMenu");
static_assert(sizeof(UEndMidgarMenu) == 0x000600, "Wrong size on UEndMidgarMenu");
static_assert(offsetof(UEndMidgarMenu, ZoomMinDistance) == 0x000430, "Member 'UEndMidgarMenu::ZoomMinDistance' has a wrong offset!");
static_assert(offsetof(UEndMidgarMenu, ZoomMaxDistance) == 0x000434, "Member 'UEndMidgarMenu::ZoomMaxDistance' has a wrong offset!");
static_assert(offsetof(UEndMidgarMenu, ZoomDistanceUpperLayerDefault) == 0x000438, "Member 'UEndMidgarMenu::ZoomDistanceUpperLayerDefault' has a wrong offset!");
static_assert(offsetof(UEndMidgarMenu, ZoomDistanceLowerLayerDefault) == 0x00043C, "Member 'UEndMidgarMenu::ZoomDistanceLowerLayerDefault' has a wrong offset!");
static_assert(offsetof(UEndMidgarMenu, DefaultCurrentLocationAngleOffset) == 0x000440, "Member 'UEndMidgarMenu::DefaultCurrentLocationAngleOffset' has a wrong offset!");
static_assert(offsetof(UEndMidgarMenu, ResetAnimationLength) == 0x000444, "Member 'UEndMidgarMenu::ResetAnimationLength' has a wrong offset!");
static_assert(offsetof(UEndMidgarMenu, MidgarSectorsAnimationLength) == 0x000448, "Member 'UEndMidgarMenu::MidgarSectorsAnimationLength' has a wrong offset!");
static_assert(offsetof(UEndMidgarMenu, FadeInOutLenght) == 0x00044C, "Member 'UEndMidgarMenu::FadeInOutLenght' has a wrong offset!");
static_assert(offsetof(UEndMidgarMenu, RotationYMin) == 0x000450, "Member 'UEndMidgarMenu::RotationYMin' has a wrong offset!");
static_assert(offsetof(UEndMidgarMenu, RotationYMax) == 0x000454, "Member 'UEndMidgarMenu::RotationYMax' has a wrong offset!");
static_assert(offsetof(UEndMidgarMenu, RotationYDefault) == 0x000458, "Member 'UEndMidgarMenu::RotationYDefault' has a wrong offset!");
static_assert(offsetof(UEndMidgarMenu, RotationXDefault) == 0x00045C, "Member 'UEndMidgarMenu::RotationXDefault' has a wrong offset!");
static_assert(offsetof(UEndMidgarMenu, OutAnimationSpeedUp) == 0x000460, "Member 'UEndMidgarMenu::OutAnimationSpeedUp' has a wrong offset!");
static_assert(offsetof(UEndMidgarMenu, RotationXSpeed) == 0x000464, "Member 'UEndMidgarMenu::RotationXSpeed' has a wrong offset!");
static_assert(offsetof(UEndMidgarMenu, RotationYSpeed) == 0x000468, "Member 'UEndMidgarMenu::RotationYSpeed' has a wrong offset!");
static_assert(offsetof(UEndMidgarMenu, ZoomSpeed) == 0x00046C, "Member 'UEndMidgarMenu::ZoomSpeed' has a wrong offset!");

// Class EndGame.EndMotionSwitchBox
// 0x0008 (0x0390 - 0x0388)
class AEndMotionSwitchBox final : public AEndTriggerBox
{
public:
	class FName                                   MotionSwitchName;                                  // 0x0388(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndMotionSwitchBox">();
	}
	static class AEndMotionSwitchBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndMotionSwitchBox>();
	}
};
static_assert(alignof(AEndMotionSwitchBox) == 0x000008, "Wrong alignment on AEndMotionSwitchBox");
static_assert(sizeof(AEndMotionSwitchBox) == 0x000390, "Wrong size on AEndMotionSwitchBox");
static_assert(offsetof(AEndMotionSwitchBox, MotionSwitchName) == 0x000388, "Member 'AEndMotionSwitchBox::MotionSwitchName' has a wrong offset!");

// Class EndGame.EndNavAreaAddAttribute
// 0x0000 (0x0040 - 0x0040)
class UEndNavAreaAddAttribute final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavAreaAddAttribute">();
	}
	static class UEndNavAreaAddAttribute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavAreaAddAttribute>();
	}
};
static_assert(alignof(UEndNavAreaAddAttribute) == 0x000008, "Wrong alignment on UEndNavAreaAddAttribute");
static_assert(sizeof(UEndNavAreaAddAttribute) == 0x000040, "Wrong size on UEndNavAreaAddAttribute");

// Class EndGame.EndNavAreaAddAttribute2
// 0x0000 (0x0040 - 0x0040)
class UEndNavAreaAddAttribute2 final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavAreaAddAttribute2">();
	}
	static class UEndNavAreaAddAttribute2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavAreaAddAttribute2>();
	}
};
static_assert(alignof(UEndNavAreaAddAttribute2) == 0x000008, "Wrong alignment on UEndNavAreaAddAttribute2");
static_assert(sizeof(UEndNavAreaAddAttribute2) == 0x000040, "Wrong size on UEndNavAreaAddAttribute2");

// Class EndGame.EndNavAreaAddAttribute3
// 0x0000 (0x0040 - 0x0040)
class UEndNavAreaAddAttribute3 final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavAreaAddAttribute3">();
	}
	static class UEndNavAreaAddAttribute3* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavAreaAddAttribute3>();
	}
};
static_assert(alignof(UEndNavAreaAddAttribute3) == 0x000008, "Wrong alignment on UEndNavAreaAddAttribute3");
static_assert(sizeof(UEndNavAreaAddAttribute3) == 0x000040, "Wrong size on UEndNavAreaAddAttribute3");

// Class EndGame.EndNavAreaAddAttribute4
// 0x0000 (0x0040 - 0x0040)
class UEndNavAreaAddAttribute4 final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavAreaAddAttribute4">();
	}
	static class UEndNavAreaAddAttribute4* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavAreaAddAttribute4>();
	}
};
static_assert(alignof(UEndNavAreaAddAttribute4) == 0x000008, "Wrong alignment on UEndNavAreaAddAttribute4");
static_assert(sizeof(UEndNavAreaAddAttribute4) == 0x000040, "Wrong size on UEndNavAreaAddAttribute4");

// Class EndGame.EndNavAreaCentralPathWay
// 0x0000 (0x0040 - 0x0040)
class UEndNavAreaCentralPathWay final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavAreaCentralPathWay">();
	}
	static class UEndNavAreaCentralPathWay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavAreaCentralPathWay>();
	}
};
static_assert(alignof(UEndNavAreaCentralPathWay) == 0x000008, "Wrong alignment on UEndNavAreaCentralPathWay");
static_assert(sizeof(UEndNavAreaCentralPathWay) == 0x000040, "Wrong size on UEndNavAreaCentralPathWay");

// Class EndGame.EndNavAreaCover
// 0x0028 (0x0068 - 0x0040)
class UEndNavAreaCover final : public UNavArea
{
public:
	int32                                         Capacity;                                          // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndNavAreaPermission                         Permission;                                        // 0x0044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           PermissionCharas;                                  // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         Tags;                                              // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavAreaCover">();
	}
	static class UEndNavAreaCover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavAreaCover>();
	}
};
static_assert(alignof(UEndNavAreaCover) == 0x000008, "Wrong alignment on UEndNavAreaCover");
static_assert(sizeof(UEndNavAreaCover) == 0x000068, "Wrong size on UEndNavAreaCover");
static_assert(offsetof(UEndNavAreaCover, Capacity) == 0x000040, "Member 'UEndNavAreaCover::Capacity' has a wrong offset!");
static_assert(offsetof(UEndNavAreaCover, Permission) == 0x000044, "Member 'UEndNavAreaCover::Permission' has a wrong offset!");
static_assert(offsetof(UEndNavAreaCover, PermissionCharas) == 0x000048, "Member 'UEndNavAreaCover::PermissionCharas' has a wrong offset!");
static_assert(offsetof(UEndNavAreaCover, Tags) == 0x000058, "Member 'UEndNavAreaCover::Tags' has a wrong offset!");

// Class EndGame.EndNavAreaCrack
// 0x0000 (0x0040 - 0x0040)
class UEndNavAreaCrack final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavAreaCrack">();
	}
	static class UEndNavAreaCrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavAreaCrack>();
	}
};
static_assert(alignof(UEndNavAreaCrack) == 0x000008, "Wrong alignment on UEndNavAreaCrack");
static_assert(sizeof(UEndNavAreaCrack) == 0x000040, "Wrong size on UEndNavAreaCrack");

// Class EndGame.EndNavAreaCrouched
// 0x0000 (0x0040 - 0x0040)
class UEndNavAreaCrouched final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavAreaCrouched">();
	}
	static class UEndNavAreaCrouched* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavAreaCrouched>();
	}
};
static_assert(alignof(UEndNavAreaCrouched) == 0x000008, "Wrong alignment on UEndNavAreaCrouched");
static_assert(sizeof(UEndNavAreaCrouched) == 0x000040, "Wrong size on UEndNavAreaCrouched");

// Class EndGame.EndNavAreaDoor
// 0x0000 (0x0040 - 0x0040)
class UEndNavAreaDoor final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavAreaDoor">();
	}
	static class UEndNavAreaDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavAreaDoor>();
	}
};
static_assert(alignof(UEndNavAreaDoor) == 0x000008, "Wrong alignment on UEndNavAreaDoor");
static_assert(sizeof(UEndNavAreaDoor) == 0x000040, "Wrong size on UEndNavAreaDoor");

// Class EndGame.EndNavAreaFlatlands
// 0x0000 (0x0040 - 0x0040)
class UEndNavAreaFlatlands final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavAreaFlatlands">();
	}
	static class UEndNavAreaFlatlands* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavAreaFlatlands>();
	}
};
static_assert(alignof(UEndNavAreaFlatlands) == 0x000008, "Wrong alignment on UEndNavAreaFlatlands");
static_assert(sizeof(UEndNavAreaFlatlands) == 0x000040, "Wrong size on UEndNavAreaFlatlands");

// Class EndGame.EndNavAreaFieldAction
// 0x0000 (0x0040 - 0x0040)
class UEndNavAreaFieldAction final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavAreaFieldAction">();
	}
	static class UEndNavAreaFieldAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavAreaFieldAction>();
	}
};
static_assert(alignof(UEndNavAreaFieldAction) == 0x000008, "Wrong alignment on UEndNavAreaFieldAction");
static_assert(sizeof(UEndNavAreaFieldAction) == 0x000040, "Wrong size on UEndNavAreaFieldAction");

// Class EndGame.EndNavAreaHookShot
// 0x0000 (0x0040 - 0x0040)
class UEndNavAreaHookShot final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavAreaHookShot">();
	}
	static class UEndNavAreaHookShot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavAreaHookShot>();
	}
};
static_assert(alignof(UEndNavAreaHookShot) == 0x000008, "Wrong alignment on UEndNavAreaHookShot");
static_assert(sizeof(UEndNavAreaHookShot) == 0x000040, "Wrong size on UEndNavAreaHookShot");

// Class EndGame.EndNavAreaIgnore
// 0x0000 (0x0040 - 0x0040)
class UEndNavAreaIgnore final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavAreaIgnore">();
	}
	static class UEndNavAreaIgnore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavAreaIgnore>();
	}
};
static_assert(alignof(UEndNavAreaIgnore) == 0x000008, "Wrong alignment on UEndNavAreaIgnore");
static_assert(sizeof(UEndNavAreaIgnore) == 0x000040, "Wrong size on UEndNavAreaIgnore");

// Class EndGame.EndNavAreaImpassable
// 0x0000 (0x0040 - 0x0040)
class UEndNavAreaImpassable final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavAreaImpassable">();
	}
	static class UEndNavAreaImpassable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavAreaImpassable>();
	}
};
static_assert(alignof(UEndNavAreaImpassable) == 0x000008, "Wrong alignment on UEndNavAreaImpassable");
static_assert(sizeof(UEndNavAreaImpassable) == 0x000040, "Wrong size on UEndNavAreaImpassable");

// Class EndGame.EndNavAreaInDoor
// 0x0000 (0x0040 - 0x0040)
class UEndNavAreaInDoor final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavAreaInDoor">();
	}
	static class UEndNavAreaInDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavAreaInDoor>();
	}
};
static_assert(alignof(UEndNavAreaInDoor) == 0x000008, "Wrong alignment on UEndNavAreaInDoor");
static_assert(sizeof(UEndNavAreaInDoor) == 0x000040, "Wrong size on UEndNavAreaInDoor");

// Class EndGame.EndNavAreaRedLaserGimmick
// 0x0000 (0x0040 - 0x0040)
class UEndNavAreaRedLaserGimmick final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavAreaRedLaserGimmick">();
	}
	static class UEndNavAreaRedLaserGimmick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavAreaRedLaserGimmick>();
	}
};
static_assert(alignof(UEndNavAreaRedLaserGimmick) == 0x000008, "Wrong alignment on UEndNavAreaRedLaserGimmick");
static_assert(sizeof(UEndNavAreaRedLaserGimmick) == 0x000040, "Wrong size on UEndNavAreaRedLaserGimmick");

// Class EndGame.EndNavAreaVersatile
// 0x0000 (0x0040 - 0x0040)
class UEndNavAreaVersatile final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavAreaVersatile">();
	}
	static class UEndNavAreaVersatile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavAreaVersatile>();
	}
};
static_assert(alignof(UEndNavAreaVersatile) == 0x000008, "Wrong alignment on UEndNavAreaVersatile");
static_assert(sizeof(UEndNavAreaVersatile) == 0x000040, "Wrong size on UEndNavAreaVersatile");

// Class EndGame.EndNavAreaVersatile2
// 0x0000 (0x0040 - 0x0040)
class UEndNavAreaVersatile2 final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavAreaVersatile2">();
	}
	static class UEndNavAreaVersatile2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavAreaVersatile2>();
	}
};
static_assert(alignof(UEndNavAreaVersatile2) == 0x000008, "Wrong alignment on UEndNavAreaVersatile2");
static_assert(sizeof(UEndNavAreaVersatile2) == 0x000040, "Wrong size on UEndNavAreaVersatile2");

// Class EndGame.EndNavAreaVersatile3
// 0x0000 (0x0040 - 0x0040)
class UEndNavAreaVersatile3 final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavAreaVersatile3">();
	}
	static class UEndNavAreaVersatile3* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavAreaVersatile3>();
	}
};
static_assert(alignof(UEndNavAreaVersatile3) == 0x000008, "Wrong alignment on UEndNavAreaVersatile3");
static_assert(sizeof(UEndNavAreaVersatile3) == 0x000040, "Wrong size on UEndNavAreaVersatile3");

// Class EndGame.EndNavBattleCautionQueryFilter
// 0x0000 (0x0048 - 0x0048)
class UEndNavBattleCautionQueryFilter final : public UEndNavQueryFilterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavBattleCautionQueryFilter">();
	}
	static class UEndNavBattleCautionQueryFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavBattleCautionQueryFilter>();
	}
};
static_assert(alignof(UEndNavBattleCautionQueryFilter) == 0x000008, "Wrong alignment on UEndNavBattleCautionQueryFilter");
static_assert(sizeof(UEndNavBattleCautionQueryFilter) == 0x000048, "Wrong size on UEndNavBattleCautionQueryFilter");

// Class EndGame.EndNavSimpleBattleQueryFilter
// 0x0000 (0x0048 - 0x0048)
class UEndNavSimpleBattleQueryFilter final : public UEndNavQueryFilterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavSimpleBattleQueryFilter">();
	}
	static class UEndNavSimpleBattleQueryFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavSimpleBattleQueryFilter>();
	}
};
static_assert(alignof(UEndNavSimpleBattleQueryFilter) == 0x000008, "Wrong alignment on UEndNavSimpleBattleQueryFilter");
static_assert(sizeof(UEndNavSimpleBattleQueryFilter) == 0x000048, "Wrong size on UEndNavSimpleBattleQueryFilter");

// Class EndGame.EndNavNoBattleQueryFilter
// 0x0000 (0x0048 - 0x0048)
class UEndNavNoBattleQueryFilter final : public UEndNavQueryFilterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavNoBattleQueryFilter">();
	}
	static class UEndNavNoBattleQueryFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavNoBattleQueryFilter>();
	}
};
static_assert(alignof(UEndNavNoBattleQueryFilter) == 0x000008, "Wrong alignment on UEndNavNoBattleQueryFilter");
static_assert(sizeof(UEndNavNoBattleQueryFilter) == 0x000048, "Wrong size on UEndNavNoBattleQueryFilter");

// Class EndGame.EndNavCenterWayStreetQueryFilter
// 0x0000 (0x0048 - 0x0048)
class UEndNavCenterWayStreetQueryFilter final : public UEndNavQueryFilterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavCenterWayStreetQueryFilter">();
	}
	static class UEndNavCenterWayStreetQueryFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavCenterWayStreetQueryFilter>();
	}
};
static_assert(alignof(UEndNavCenterWayStreetQueryFilter) == 0x000008, "Wrong alignment on UEndNavCenterWayStreetQueryFilter");
static_assert(sizeof(UEndNavCenterWayStreetQueryFilter) == 0x000048, "Wrong size on UEndNavCenterWayStreetQueryFilter");

// Class EndGame.EndNavCoverQueryFilter
// 0x0000 (0x0048 - 0x0048)
class UEndNavCoverQueryFilter final : public UEndNavQueryFilterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavCoverQueryFilter">();
	}
	static class UEndNavCoverQueryFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavCoverQueryFilter>();
	}
};
static_assert(alignof(UEndNavCoverQueryFilter) == 0x000008, "Wrong alignment on UEndNavCoverQueryFilter");
static_assert(sizeof(UEndNavCoverQueryFilter) == 0x000048, "Wrong size on UEndNavCoverQueryFilter");

// Class EndGame.EndNavWaterSurfaceOnlyQueryFilter
// 0x0000 (0x0048 - 0x0048)
class UEndNavWaterSurfaceOnlyQueryFilter final : public UEndNavQueryFilterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavWaterSurfaceOnlyQueryFilter">();
	}
	static class UEndNavWaterSurfaceOnlyQueryFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavWaterSurfaceOnlyQueryFilter>();
	}
};
static_assert(alignof(UEndNavWaterSurfaceOnlyQueryFilter) == 0x000008, "Wrong alignment on UEndNavWaterSurfaceOnlyQueryFilter");
static_assert(sizeof(UEndNavWaterSurfaceOnlyQueryFilter) == 0x000048, "Wrong size on UEndNavWaterSurfaceOnlyQueryFilter");

// Class EndGame.EndNavMountainOnlyQueryFilter
// 0x0000 (0x0048 - 0x0048)
class UEndNavMountainOnlyQueryFilter final : public UEndNavQueryFilterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavMountainOnlyQueryFilter">();
	}
	static class UEndNavMountainOnlyQueryFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavMountainOnlyQueryFilter>();
	}
};
static_assert(alignof(UEndNavMountainOnlyQueryFilter) == 0x000008, "Wrong alignment on UEndNavMountainOnlyQueryFilter");
static_assert(sizeof(UEndNavMountainOnlyQueryFilter) == 0x000048, "Wrong size on UEndNavMountainOnlyQueryFilter");

// Class EndGame.EndNavFlatlandsWaterSurfaceQueryFilter
// 0x0000 (0x0048 - 0x0048)
class UEndNavFlatlandsWaterSurfaceQueryFilter final : public UEndNavQueryFilterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavFlatlandsWaterSurfaceQueryFilter">();
	}
	static class UEndNavFlatlandsWaterSurfaceQueryFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavFlatlandsWaterSurfaceQueryFilter>();
	}
};
static_assert(alignof(UEndNavFlatlandsWaterSurfaceQueryFilter) == 0x000008, "Wrong alignment on UEndNavFlatlandsWaterSurfaceQueryFilter");
static_assert(sizeof(UEndNavFlatlandsWaterSurfaceQueryFilter) == 0x000048, "Wrong size on UEndNavFlatlandsWaterSurfaceQueryFilter");

// Class EndGame.EndNavFlatlandsMountainQueryFilter
// 0x0000 (0x0048 - 0x0048)
class UEndNavFlatlandsMountainQueryFilter final : public UEndNavQueryFilterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavFlatlandsMountainQueryFilter">();
	}
	static class UEndNavFlatlandsMountainQueryFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavFlatlandsMountainQueryFilter>();
	}
};
static_assert(alignof(UEndNavFlatlandsMountainQueryFilter) == 0x000008, "Wrong alignment on UEndNavFlatlandsMountainQueryFilter");
static_assert(sizeof(UEndNavFlatlandsMountainQueryFilter) == 0x000048, "Wrong size on UEndNavFlatlandsMountainQueryFilter");

// Class EndGame.EndNaviMap
// 0x0058 (0x0150 - 0x00F8)
class UEndNaviMap final : public UWidget
{
public:
	struct FVector2D                              Size;                                              // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PixelPerCm;                                        // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndNaviMapPrototypeData*               PrototypeData;                                     // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNaviMapPrototypeDataV2*             PrototypeDataV2;                                   // 0x0110(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 MaskTexture;                                       // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_120[0x20];                                     // 0x0120(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UWidget*>                        IconWidgets;                                       // 0x0140(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	struct FVector2D ConvertToPosition2D(const struct FVector& InPos);
	void SetPosition3D(const struct FVector& InPos);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNaviMap">();
	}
	static class UEndNaviMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNaviMap>();
	}
};
static_assert(alignof(UEndNaviMap) == 0x000008, "Wrong alignment on UEndNaviMap");
static_assert(sizeof(UEndNaviMap) == 0x000150, "Wrong size on UEndNaviMap");
static_assert(offsetof(UEndNaviMap, Size) == 0x0000F8, "Member 'UEndNaviMap::Size' has a wrong offset!");
static_assert(offsetof(UEndNaviMap, PixelPerCm) == 0x000100, "Member 'UEndNaviMap::PixelPerCm' has a wrong offset!");
static_assert(offsetof(UEndNaviMap, PrototypeData) == 0x000108, "Member 'UEndNaviMap::PrototypeData' has a wrong offset!");
static_assert(offsetof(UEndNaviMap, PrototypeDataV2) == 0x000110, "Member 'UEndNaviMap::PrototypeDataV2' has a wrong offset!");
static_assert(offsetof(UEndNaviMap, MaskTexture) == 0x000118, "Member 'UEndNaviMap::MaskTexture' has a wrong offset!");
static_assert(offsetof(UEndNaviMap, IconWidgets) == 0x000140, "Member 'UEndNaviMap::IconWidgets' has a wrong offset!");

// Class EndGame.EndNaviMapIcon
// 0x00B8 (0x0418 - 0x0360)
class UEndNaviMapIcon : public UEndUserWidget
{
public:
	struct FSlateBrush                            ArrowBrush;                                        // 0x0360(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	ENaviMapIconDirection                         ArrowDirection;                                    // 0x03D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D9[0x3];                                      // 0x03D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ArrowOffset;                                       // 0x03DC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysShowDistance;                               // 0x03E4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSecretDistance;                                   // 0x03E5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideDistance;                                     // 0x03E6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInsideArea;                                       // 0x03E7(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E8[0x28];                                     // 0x03E8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndTextBlock*                          CachedDistanceTextBlock;                           // 0x0410(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetDistance(float InDistance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNaviMapIcon">();
	}
	static class UEndNaviMapIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNaviMapIcon>();
	}
};
static_assert(alignof(UEndNaviMapIcon) == 0x000008, "Wrong alignment on UEndNaviMapIcon");
static_assert(sizeof(UEndNaviMapIcon) == 0x000418, "Wrong size on UEndNaviMapIcon");
static_assert(offsetof(UEndNaviMapIcon, ArrowBrush) == 0x000360, "Member 'UEndNaviMapIcon::ArrowBrush' has a wrong offset!");
static_assert(offsetof(UEndNaviMapIcon, ArrowDirection) == 0x0003D8, "Member 'UEndNaviMapIcon::ArrowDirection' has a wrong offset!");
static_assert(offsetof(UEndNaviMapIcon, ArrowOffset) == 0x0003DC, "Member 'UEndNaviMapIcon::ArrowOffset' has a wrong offset!");
static_assert(offsetof(UEndNaviMapIcon, bAlwaysShowDistance) == 0x0003E4, "Member 'UEndNaviMapIcon::bAlwaysShowDistance' has a wrong offset!");
static_assert(offsetof(UEndNaviMapIcon, bSecretDistance) == 0x0003E5, "Member 'UEndNaviMapIcon::bSecretDistance' has a wrong offset!");
static_assert(offsetof(UEndNaviMapIcon, bHideDistance) == 0x0003E6, "Member 'UEndNaviMapIcon::bHideDistance' has a wrong offset!");
static_assert(offsetof(UEndNaviMapIcon, bInsideArea) == 0x0003E7, "Member 'UEndNaviMapIcon::bInsideArea' has a wrong offset!");
static_assert(offsetof(UEndNaviMapIcon, CachedDistanceTextBlock) == 0x000410, "Member 'UEndNaviMapIcon::CachedDistanceTextBlock' has a wrong offset!");

// Class EndGame.EndNaviMapOctagon
// 0x0060 (0x0158 - 0x00F8)
class UEndNaviMapOctagon final : public UWidget
{
public:
	float                                         PixelPerCm;                                        // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              NaviMapSize;                                       // 0x00FC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndNaviMapPrototypeData*               PrototypeData;                                     // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndNaviMapPrototypeDataV2*             PrototypeDataV2;                                   // 0x0110(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 RenderTexture;                                     // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 MaskTexture;                                       // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x20];                                     // 0x0128(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UWidget*>                        IconWidgets;                                       // 0x0148(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	struct FVector2D ConvertToPosition2D(const struct FVector& InPos);
	void SetPosition3D(const struct FVector& InPos);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNaviMapOctagon">();
	}
	static class UEndNaviMapOctagon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNaviMapOctagon>();
	}
};
static_assert(alignof(UEndNaviMapOctagon) == 0x000008, "Wrong alignment on UEndNaviMapOctagon");
static_assert(sizeof(UEndNaviMapOctagon) == 0x000158, "Wrong size on UEndNaviMapOctagon");
static_assert(offsetof(UEndNaviMapOctagon, PixelPerCm) == 0x0000F8, "Member 'UEndNaviMapOctagon::PixelPerCm' has a wrong offset!");
static_assert(offsetof(UEndNaviMapOctagon, NaviMapSize) == 0x0000FC, "Member 'UEndNaviMapOctagon::NaviMapSize' has a wrong offset!");
static_assert(offsetof(UEndNaviMapOctagon, PrototypeData) == 0x000108, "Member 'UEndNaviMapOctagon::PrototypeData' has a wrong offset!");
static_assert(offsetof(UEndNaviMapOctagon, PrototypeDataV2) == 0x000110, "Member 'UEndNaviMapOctagon::PrototypeDataV2' has a wrong offset!");
static_assert(offsetof(UEndNaviMapOctagon, RenderTexture) == 0x000118, "Member 'UEndNaviMapOctagon::RenderTexture' has a wrong offset!");
static_assert(offsetof(UEndNaviMapOctagon, MaskTexture) == 0x000120, "Member 'UEndNaviMapOctagon::MaskTexture' has a wrong offset!");
static_assert(offsetof(UEndNaviMapOctagon, IconWidgets) == 0x000148, "Member 'UEndNaviMapOctagon::IconWidgets' has a wrong offset!");

// Class EndGame.EndNaviMapSettings
// 0x0028 (0x0050 - 0x0028)
class UEndNaviMapSettings final : public UObject
{
public:
	float                                         PixelPerCm;                                        // 0x0028(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartWallTraceZOffset;                             // 0x002C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FirstWallTraceHalfExtent;                          // 0x0030(0x000C)(Edit, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SecondWallTraceHalfExtent;                         // 0x003C(0x000C)(Edit, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDrawCollideCache;                           // 0x0048(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDrawCollideCacheLine;                       // 0x0049(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNaviMapSettings">();
	}
	static class UEndNaviMapSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNaviMapSettings>();
	}
};
static_assert(alignof(UEndNaviMapSettings) == 0x000008, "Wrong alignment on UEndNaviMapSettings");
static_assert(sizeof(UEndNaviMapSettings) == 0x000050, "Wrong size on UEndNaviMapSettings");
static_assert(offsetof(UEndNaviMapSettings, PixelPerCm) == 0x000028, "Member 'UEndNaviMapSettings::PixelPerCm' has a wrong offset!");
static_assert(offsetof(UEndNaviMapSettings, StartWallTraceZOffset) == 0x00002C, "Member 'UEndNaviMapSettings::StartWallTraceZOffset' has a wrong offset!");
static_assert(offsetof(UEndNaviMapSettings, FirstWallTraceHalfExtent) == 0x000030, "Member 'UEndNaviMapSettings::FirstWallTraceHalfExtent' has a wrong offset!");
static_assert(offsetof(UEndNaviMapSettings, SecondWallTraceHalfExtent) == 0x00003C, "Member 'UEndNaviMapSettings::SecondWallTraceHalfExtent' has a wrong offset!");
static_assert(offsetof(UEndNaviMapSettings, bEnableDrawCollideCache) == 0x000048, "Member 'UEndNaviMapSettings::bEnableDrawCollideCache' has a wrong offset!");
static_assert(offsetof(UEndNaviMapSettings, bEnableDrawCollideCacheLine) == 0x000049, "Member 'UEndNaviMapSettings::bEnableDrawCollideCacheLine' has a wrong offset!");

// Class EndGame.EndNaviMapVolume
// 0x0030 (0x03E0 - 0x03B0)
class AEndNaviMapVolume final : public AVolume
{
public:
	EEndNaviMapLayer                              LayerNumber;                                       // 0x03B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndNaviMapOpenGroup                          OpenGroupNumber;                                   // 0x03B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndNaviMapVisitGroup                         VisitGroupNumber;                                  // 0x03B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndNaviMapSplitNum                           SplitNum;                                          // 0x03BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndNaviMapUniqueIndexOffset                  UniqueIndexOffset;                                 // 0x03C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreOverlap;                                    // 0x03C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreGenetateTexture;                            // 0x03C5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C6[0x2];                                      // 0x03C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UniqueIndex;                                       // 0x03C8(0x0004)(Edit, ZeroConstructor, EditConst, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UniqueIndex2nd;                                    // 0x03CC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEndNaviMapVolumePoly>          VolumePolys;                                       // 0x03D0(0x0010)(Edit, ZeroConstructor, EditConst, DuplicateTransient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNaviMapVolume">();
	}
	static class AEndNaviMapVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndNaviMapVolume>();
	}
};
static_assert(alignof(AEndNaviMapVolume) == 0x000008, "Wrong alignment on AEndNaviMapVolume");
static_assert(sizeof(AEndNaviMapVolume) == 0x0003E0, "Wrong size on AEndNaviMapVolume");
static_assert(offsetof(AEndNaviMapVolume, LayerNumber) == 0x0003B0, "Member 'AEndNaviMapVolume::LayerNumber' has a wrong offset!");
static_assert(offsetof(AEndNaviMapVolume, OpenGroupNumber) == 0x0003B4, "Member 'AEndNaviMapVolume::OpenGroupNumber' has a wrong offset!");
static_assert(offsetof(AEndNaviMapVolume, VisitGroupNumber) == 0x0003B8, "Member 'AEndNaviMapVolume::VisitGroupNumber' has a wrong offset!");
static_assert(offsetof(AEndNaviMapVolume, SplitNum) == 0x0003BC, "Member 'AEndNaviMapVolume::SplitNum' has a wrong offset!");
static_assert(offsetof(AEndNaviMapVolume, UniqueIndexOffset) == 0x0003C0, "Member 'AEndNaviMapVolume::UniqueIndexOffset' has a wrong offset!");
static_assert(offsetof(AEndNaviMapVolume, bIgnoreOverlap) == 0x0003C4, "Member 'AEndNaviMapVolume::bIgnoreOverlap' has a wrong offset!");
static_assert(offsetof(AEndNaviMapVolume, bIgnoreGenetateTexture) == 0x0003C5, "Member 'AEndNaviMapVolume::bIgnoreGenetateTexture' has a wrong offset!");
static_assert(offsetof(AEndNaviMapVolume, UniqueIndex) == 0x0003C8, "Member 'AEndNaviMapVolume::UniqueIndex' has a wrong offset!");
static_assert(offsetof(AEndNaviMapVolume, UniqueIndex2nd) == 0x0003CC, "Member 'AEndNaviMapVolume::UniqueIndex2nd' has a wrong offset!");
static_assert(offsetof(AEndNaviMapVolume, VolumePolys) == 0x0003D0, "Member 'AEndNaviMapVolume::VolumePolys' has a wrong offset!");

// Class EndGame.EndNavLeftWayStreetQueryFilter
// 0x0000 (0x0048 - 0x0048)
class UEndNavLeftWayStreetQueryFilter final : public UEndNavQueryFilterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavLeftWayStreetQueryFilter">();
	}
	static class UEndNavLeftWayStreetQueryFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavLeftWayStreetQueryFilter>();
	}
};
static_assert(alignof(UEndNavLeftWayStreetQueryFilter) == 0x000008, "Wrong alignment on UEndNavLeftWayStreetQueryFilter");
static_assert(sizeof(UEndNavLeftWayStreetQueryFilter) == 0x000048, "Wrong size on UEndNavLeftWayStreetQueryFilter");

// Class EndGame.EndNavMeshRenderingComponent
// 0x0000 (0x0700 - 0x0700)
class UEndNavMeshRenderingComponent final : public UNavMeshRenderingComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavMeshRenderingComponent">();
	}
	static class UEndNavMeshRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavMeshRenderingComponent>();
	}
};
static_assert(alignof(UEndNavMeshRenderingComponent) == 0x000010, "Wrong alignment on UEndNavMeshRenderingComponent");
static_assert(sizeof(UEndNavMeshRenderingComponent) == 0x000700, "Wrong size on UEndNavMeshRenderingComponent");

// Class EndGame.EndNavModifierComponent
// 0x0018 (0x0168 - 0x0150)
class UEndNavModifierComponent final : public UNavModifierComponent
{
public:
	uint8                                         Pad_150[0x18];                                     // 0x0150(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavModifierComponent">();
	}
	static class UEndNavModifierComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavModifierComponent>();
	}
};
static_assert(alignof(UEndNavModifierComponent) == 0x000008, "Wrong alignment on UEndNavModifierComponent");
static_assert(sizeof(UEndNavModifierComponent) == 0x000168, "Wrong size on UEndNavModifierComponent");

// Class EndGame.EndNavModifierFlatlandsVolume
// 0x0000 (0x0428 - 0x0428)
class AEndNavModifierFlatlandsVolume final : public AEndNavModifierVolumeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavModifierFlatlandsVolume">();
	}
	static class AEndNavModifierFlatlandsVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndNavModifierFlatlandsVolume>();
	}
};
static_assert(alignof(AEndNavModifierFlatlandsVolume) == 0x000008, "Wrong alignment on AEndNavModifierFlatlandsVolume");
static_assert(sizeof(AEndNavModifierFlatlandsVolume) == 0x000428, "Wrong size on AEndNavModifierFlatlandsVolume");

// Class EndGame.EndNavModifierWaterSurfaceVolume
// 0x0000 (0x0428 - 0x0428)
class AEndNavModifierWaterSurfaceVolume final : public AEndNavModifierVolumeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavModifierWaterSurfaceVolume">();
	}
	static class AEndNavModifierWaterSurfaceVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndNavModifierWaterSurfaceVolume>();
	}
};
static_assert(alignof(AEndNavModifierWaterSurfaceVolume) == 0x000008, "Wrong alignment on AEndNavModifierWaterSurfaceVolume");
static_assert(sizeof(AEndNavModifierWaterSurfaceVolume) == 0x000428, "Wrong size on AEndNavModifierWaterSurfaceVolume");

// Class EndGame.EndNavModifierMountainVolume
// 0x0000 (0x0428 - 0x0428)
class AEndNavModifierMountainVolume final : public AEndNavModifierVolumeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavModifierMountainVolume">();
	}
	static class AEndNavModifierMountainVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndNavModifierMountainVolume>();
	}
};
static_assert(alignof(AEndNavModifierMountainVolume) == 0x000008, "Wrong alignment on AEndNavModifierMountainVolume");
static_assert(sizeof(AEndNavModifierMountainVolume) == 0x000428, "Wrong size on AEndNavModifierMountainVolume");

// Class EndGame.EndNavModifierLockOnSiteVolume
// 0x0088 (0x0400 - 0x0378)
class AEndNavModifierLockOnSiteVolume final : public AActor
{
public:
	uint8                                         Pad_378[0x10];                                     // 0x0378(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SendTriggerName;                                   // 0x0388(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ResponseAreaID;                                    // 0x0390(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ResponseAreaPlayerID;                              // 0x0398(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          RangeComponent;                                    // 0x03A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          TargetIconComponent;                               // 0x03A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndTextRenderComponent*                TextRenderComponent;                               // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C0[0x18];                                     // 0x03C0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNavPriorRegistInfo                    NavPriorInfo;                                      // 0x03D8(0x0028)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavModifierLockOnSiteVolume">();
	}
	static class AEndNavModifierLockOnSiteVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndNavModifierLockOnSiteVolume>();
	}
};
static_assert(alignof(AEndNavModifierLockOnSiteVolume) == 0x000008, "Wrong alignment on AEndNavModifierLockOnSiteVolume");
static_assert(sizeof(AEndNavModifierLockOnSiteVolume) == 0x000400, "Wrong size on AEndNavModifierLockOnSiteVolume");
static_assert(offsetof(AEndNavModifierLockOnSiteVolume, SendTriggerName) == 0x000388, "Member 'AEndNavModifierLockOnSiteVolume::SendTriggerName' has a wrong offset!");
static_assert(offsetof(AEndNavModifierLockOnSiteVolume, ResponseAreaID) == 0x000390, "Member 'AEndNavModifierLockOnSiteVolume::ResponseAreaID' has a wrong offset!");
static_assert(offsetof(AEndNavModifierLockOnSiteVolume, ResponseAreaPlayerID) == 0x000398, "Member 'AEndNavModifierLockOnSiteVolume::ResponseAreaPlayerID' has a wrong offset!");
static_assert(offsetof(AEndNavModifierLockOnSiteVolume, RangeComponent) == 0x0003A0, "Member 'AEndNavModifierLockOnSiteVolume::RangeComponent' has a wrong offset!");
static_assert(offsetof(AEndNavModifierLockOnSiteVolume, TargetIconComponent) == 0x0003A8, "Member 'AEndNavModifierLockOnSiteVolume::TargetIconComponent' has a wrong offset!");
static_assert(offsetof(AEndNavModifierLockOnSiteVolume, ModifierVolume) == 0x0003B0, "Member 'AEndNavModifierLockOnSiteVolume::ModifierVolume' has a wrong offset!");
static_assert(offsetof(AEndNavModifierLockOnSiteVolume, TextRenderComponent) == 0x0003B8, "Member 'AEndNavModifierLockOnSiteVolume::TextRenderComponent' has a wrong offset!");
static_assert(offsetof(AEndNavModifierLockOnSiteVolume, NavPriorInfo) == 0x0003D8, "Member 'AEndNavModifierLockOnSiteVolume::NavPriorInfo' has a wrong offset!");

// Class EndGame.EndNavModifierPeekCameraVolume
// 0x0088 (0x0400 - 0x0378)
class AEndNavModifierPeekCameraVolume final : public AActor
{
public:
	uint8                                         Pad_378[0x10];                                     // 0x0378(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseDuctBlendIn;                                   // 0x0388(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_389[0x3];                                      // 0x0389(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SendStartTriggerName;                              // 0x038C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SendEndTriggerName;                                // 0x0394(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ResponseAreaID;                                    // 0x039C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ResponseAreaPlayerID;                              // 0x03A4(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3AC[0x4];                                      // 0x03AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          RangeComponent;                                    // 0x03B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          TargetIconComponent;                               // 0x03B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          CameraComponent;                                   // 0x03C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndNavModifierComponent*               ModifierVolume;                                    // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D0[0x8];                                      // 0x03D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNavPriorRegistInfo                    NavPriorInfo;                                      // 0x03D8(0x0028)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavModifierPeekCameraVolume">();
	}
	static class AEndNavModifierPeekCameraVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndNavModifierPeekCameraVolume>();
	}
};
static_assert(alignof(AEndNavModifierPeekCameraVolume) == 0x000008, "Wrong alignment on AEndNavModifierPeekCameraVolume");
static_assert(sizeof(AEndNavModifierPeekCameraVolume) == 0x000400, "Wrong size on AEndNavModifierPeekCameraVolume");
static_assert(offsetof(AEndNavModifierPeekCameraVolume, bUseDuctBlendIn) == 0x000388, "Member 'AEndNavModifierPeekCameraVolume::bUseDuctBlendIn' has a wrong offset!");
static_assert(offsetof(AEndNavModifierPeekCameraVolume, SendStartTriggerName) == 0x00038C, "Member 'AEndNavModifierPeekCameraVolume::SendStartTriggerName' has a wrong offset!");
static_assert(offsetof(AEndNavModifierPeekCameraVolume, SendEndTriggerName) == 0x000394, "Member 'AEndNavModifierPeekCameraVolume::SendEndTriggerName' has a wrong offset!");
static_assert(offsetof(AEndNavModifierPeekCameraVolume, ResponseAreaID) == 0x00039C, "Member 'AEndNavModifierPeekCameraVolume::ResponseAreaID' has a wrong offset!");
static_assert(offsetof(AEndNavModifierPeekCameraVolume, ResponseAreaPlayerID) == 0x0003A4, "Member 'AEndNavModifierPeekCameraVolume::ResponseAreaPlayerID' has a wrong offset!");
static_assert(offsetof(AEndNavModifierPeekCameraVolume, RangeComponent) == 0x0003B0, "Member 'AEndNavModifierPeekCameraVolume::RangeComponent' has a wrong offset!");
static_assert(offsetof(AEndNavModifierPeekCameraVolume, TargetIconComponent) == 0x0003B8, "Member 'AEndNavModifierPeekCameraVolume::TargetIconComponent' has a wrong offset!");
static_assert(offsetof(AEndNavModifierPeekCameraVolume, CameraComponent) == 0x0003C0, "Member 'AEndNavModifierPeekCameraVolume::CameraComponent' has a wrong offset!");
static_assert(offsetof(AEndNavModifierPeekCameraVolume, ModifierVolume) == 0x0003C8, "Member 'AEndNavModifierPeekCameraVolume::ModifierVolume' has a wrong offset!");
static_assert(offsetof(AEndNavModifierPeekCameraVolume, NavPriorInfo) == 0x0003D8, "Member 'AEndNavModifierPeekCameraVolume::NavPriorInfo' has a wrong offset!");

// Class EndGame.EndNavModifierVolume
// 0x0040 (0x0468 - 0x0428)
class AEndNavModifierVolume final : public AEndNavModifierVolumeBase
{
public:
	uint8                                         Pad_428[0x1];                                      // 0x0428(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EModifierVolumeType                           Type;                                              // 0x0429(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42A[0x2];                                      // 0x042A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WallAffiliationID;                                 // 0x042C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Wall;                                              // 0x0430(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Group;                                             // 0x0434(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           AfiliationBattleScene;                             // 0x0438(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UEndEnvQueryComponent*                  EnvironmentQueryComponent;                         // 0x0448(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FWallManageParam>               WallGroup;                                         // 0x0450(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          WallBorder;                                        // 0x0460(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SemiWallBorder;                                    // 0x0461(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCeil;                                             // 0x0462(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWallJumpAcceptFree;                               // 0x0463(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallJumpExtentHeight;                              // 0x0464(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavModifierVolume">();
	}
	static class AEndNavModifierVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndNavModifierVolume>();
	}
};
static_assert(alignof(AEndNavModifierVolume) == 0x000008, "Wrong alignment on AEndNavModifierVolume");
static_assert(sizeof(AEndNavModifierVolume) == 0x000468, "Wrong size on AEndNavModifierVolume");
static_assert(offsetof(AEndNavModifierVolume, Type) == 0x000429, "Member 'AEndNavModifierVolume::Type' has a wrong offset!");
static_assert(offsetof(AEndNavModifierVolume, WallAffiliationID) == 0x00042C, "Member 'AEndNavModifierVolume::WallAffiliationID' has a wrong offset!");
static_assert(offsetof(AEndNavModifierVolume, Wall) == 0x000430, "Member 'AEndNavModifierVolume::Wall' has a wrong offset!");
static_assert(offsetof(AEndNavModifierVolume, Group) == 0x000434, "Member 'AEndNavModifierVolume::Group' has a wrong offset!");
static_assert(offsetof(AEndNavModifierVolume, AfiliationBattleScene) == 0x000438, "Member 'AEndNavModifierVolume::AfiliationBattleScene' has a wrong offset!");
static_assert(offsetof(AEndNavModifierVolume, EnvironmentQueryComponent) == 0x000448, "Member 'AEndNavModifierVolume::EnvironmentQueryComponent' has a wrong offset!");
static_assert(offsetof(AEndNavModifierVolume, WallGroup) == 0x000450, "Member 'AEndNavModifierVolume::WallGroup' has a wrong offset!");
static_assert(offsetof(AEndNavModifierVolume, WallBorder) == 0x000460, "Member 'AEndNavModifierVolume::WallBorder' has a wrong offset!");
static_assert(offsetof(AEndNavModifierVolume, SemiWallBorder) == 0x000461, "Member 'AEndNavModifierVolume::SemiWallBorder' has a wrong offset!");
static_assert(offsetof(AEndNavModifierVolume, bCeil) == 0x000462, "Member 'AEndNavModifierVolume::bCeil' has a wrong offset!");
static_assert(offsetof(AEndNavModifierVolume, bWallJumpAcceptFree) == 0x000463, "Member 'AEndNavModifierVolume::bWallJumpAcceptFree' has a wrong offset!");
static_assert(offsetof(AEndNavModifierVolume, WallJumpExtentHeight) == 0x000464, "Member 'AEndNavModifierVolume::WallJumpExtentHeight' has a wrong offset!");

// Class EndGame.EndNavNoCostQueryFilter
// 0x0000 (0x0048 - 0x0048)
class UEndNavNoCostQueryFilter final : public UEndNavQueryFilterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavNoCostQueryFilter">();
	}
	static class UEndNavNoCostQueryFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavNoCostQueryFilter>();
	}
};
static_assert(alignof(UEndNavNoCostQueryFilter) == 0x000008, "Wrong alignment on UEndNavNoCostQueryFilter");
static_assert(sizeof(UEndNavNoCostQueryFilter) == 0x000048, "Wrong size on UEndNavNoCostQueryFilter");

// Class EndGame.EndNavNoFieldActionQueryFilter
// 0x0000 (0x0048 - 0x0048)
class UEndNavNoFieldActionQueryFilter final : public UEndNavQueryFilterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavNoFieldActionQueryFilter">();
	}
	static class UEndNavNoFieldActionQueryFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavNoFieldActionQueryFilter>();
	}
};
static_assert(alignof(UEndNavNoFieldActionQueryFilter) == 0x000008, "Wrong alignment on UEndNavNoFieldActionQueryFilter");
static_assert(sizeof(UEndNavNoFieldActionQueryFilter) == 0x000048, "Wrong size on UEndNavNoFieldActionQueryFilter");

// Class EndGame.EndNavRightWayStreetQueryFilter
// 0x0000 (0x0048 - 0x0048)
class UEndNavRightWayStreetQueryFilter final : public UEndNavQueryFilterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNavRightWayStreetQueryFilter">();
	}
	static class UEndNavRightWayStreetQueryFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNavRightWayStreetQueryFilter>();
	}
};
static_assert(alignof(UEndNavRightWayStreetQueryFilter) == 0x000008, "Wrong alignment on UEndNavRightWayStreetQueryFilter");
static_assert(sizeof(UEndNavRightWayStreetQueryFilter) == 0x000048, "Wrong size on UEndNavRightWayStreetQueryFilter");

// Class EndGame.EndSwitchAreaBoxComponent
// 0x0000 (0x0720 - 0x0720)
class UEndSwitchAreaBoxComponent final : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndSwitchAreaBoxComponent">();
	}
	static class UEndSwitchAreaBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndSwitchAreaBoxComponent>();
	}
};
static_assert(alignof(UEndSwitchAreaBoxComponent) == 0x000010, "Wrong alignment on UEndSwitchAreaBoxComponent");
static_assert(sizeof(UEndSwitchAreaBoxComponent) == 0x000720, "Wrong size on UEndSwitchAreaBoxComponent");

// Class EndGame.EndNewOptionsMenu
// 0x0230 (0x0590 - 0x0360)
class UEndNewOptionsMenu : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x158];                                    // 0x0360(0x0158)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         _CategoryItems;                                    // 0x04B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<EMenuItemCategory, struct FOptionInfos>  _OptionItems;                                      // 0x04C8(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSoftObjectPath>                _BillboardImagePaths;                              // 0x0518(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class UEndDescriptionWindow*                  DescriptionWindow;                                 // 0x0528(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_530[0x60];                                     // 0x0530(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnButtonTypeListPressedItem(int32 CellIndex);
	void OnButtonTypeListSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnCategoryListPressedItem(int32 CellIndex);
	void OnCategoryListSelectedIndexChanged(int32 CellIndex);
	void OnCategoryListSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnControllerListPressedItem(int32 CellIndex);
	void OnControllerListSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnHoverSelectButton();
	struct FVector2D OnOptionListKeyboardMeasureItem(int32 ItemIndex);
	void OnOptionListKeyboardPressedItem(int32 CellIndex);
	void OnOptionListKeyboardSelectedIndexChanged(int32 CellIndex);
	void OnOptionListKeyboardSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnOptionListPressedItem(int32 CellIndex);
	void OnOptionListSelectedIndexChanged(int32 CellIndex);
	void OnOptionListSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnSelectListPressedItem(int32 CellIndex);
	void OnSelectListSelectedIndexChanged(int32 CellIndex);
	void OnSelectListSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnSetupGaugeItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnUnhoverSelectButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNewOptionsMenu">();
	}
	static class UEndNewOptionsMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNewOptionsMenu>();
	}
};
static_assert(alignof(UEndNewOptionsMenu) == 0x000008, "Wrong alignment on UEndNewOptionsMenu");
static_assert(sizeof(UEndNewOptionsMenu) == 0x000590, "Wrong size on UEndNewOptionsMenu");
static_assert(offsetof(UEndNewOptionsMenu, _CategoryItems) == 0x0004B8, "Member 'UEndNewOptionsMenu::_CategoryItems' has a wrong offset!");
static_assert(offsetof(UEndNewOptionsMenu, _OptionItems) == 0x0004C8, "Member 'UEndNewOptionsMenu::_OptionItems' has a wrong offset!");
static_assert(offsetof(UEndNewOptionsMenu, _BillboardImagePaths) == 0x000518, "Member 'UEndNewOptionsMenu::_BillboardImagePaths' has a wrong offset!");
static_assert(offsetof(UEndNewOptionsMenu, DescriptionWindow) == 0x000528, "Member 'UEndNewOptionsMenu::DescriptionWindow' has a wrong offset!");

// Class EndGame.EndNumberLabel
// 0x0058 (0x0150 - 0x00F8)
class UEndNumberLabel final : public UWidget
{
public:
	TArray<struct FSlateBrush>                    Images;                                            // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorAndOpacity;                                   // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ColorAndOpacityDelegate;                           // 0x0118(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	EBlendMode                                    BlendMode;                                         // 0x0128(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x3];                                      // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextJustify                                  Justification;                                     // 0x0130(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x3];                                      // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinDigits;                                         // 0x0134(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FontIndex;                                         // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Spacing;                                           // 0x013C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_140[0x10];                                     // 0x0140(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBlendMode(EBlendMode InBlendMode);
	void SetColorAndOpacity(const struct FLinearColor& InColorAndOpacity);
	void SetFontIndex(int32 InFontIndex);
	void SetJustification(ETextJustify InJustification);
	void SetMinDigits(int32 InMinDigits);
	void SetOpacity(float InOpacity);
	void SetSpacing(int32 InSpacing);
	void SetValue(int32 InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndNumberLabel">();
	}
	static class UEndNumberLabel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndNumberLabel>();
	}
};
static_assert(alignof(UEndNumberLabel) == 0x000008, "Wrong alignment on UEndNumberLabel");
static_assert(sizeof(UEndNumberLabel) == 0x000150, "Wrong size on UEndNumberLabel");
static_assert(offsetof(UEndNumberLabel, Images) == 0x0000F8, "Member 'UEndNumberLabel::Images' has a wrong offset!");
static_assert(offsetof(UEndNumberLabel, ColorAndOpacity) == 0x000108, "Member 'UEndNumberLabel::ColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UEndNumberLabel, ColorAndOpacityDelegate) == 0x000118, "Member 'UEndNumberLabel::ColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UEndNumberLabel, BlendMode) == 0x000128, "Member 'UEndNumberLabel::BlendMode' has a wrong offset!");
static_assert(offsetof(UEndNumberLabel, Value) == 0x00012C, "Member 'UEndNumberLabel::Value' has a wrong offset!");
static_assert(offsetof(UEndNumberLabel, Justification) == 0x000130, "Member 'UEndNumberLabel::Justification' has a wrong offset!");
static_assert(offsetof(UEndNumberLabel, MinDigits) == 0x000134, "Member 'UEndNumberLabel::MinDigits' has a wrong offset!");
static_assert(offsetof(UEndNumberLabel, FontIndex) == 0x000138, "Member 'UEndNumberLabel::FontIndex' has a wrong offset!");
static_assert(offsetof(UEndNumberLabel, Spacing) == 0x00013C, "Member 'UEndNumberLabel::Spacing' has a wrong offset!");

// Class EndGame.EndParticleModuleCircleLocation
// 0x00A8 (0x00E0 - 0x0038)
class UEndParticleModuleCircleLocation final : public UParticleModuleLocationBase
{
public:
	EVfxCircleLocationKind                        m_Kind;                                            // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  m_Radius;                                          // 0x0040(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         m_RadiusRandom;                                    // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_BeginAngle;                                      // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_BeginAngleRandom;                                // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_StepAngle;                                       // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_StepAngleRandom;                                 // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  m_Velocity;                                        // 0x0098(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         m_VelocityRandom;                                  // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         m_bReverseAngle : 1;                               // 0x00DC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndParticleModuleCircleLocation">();
	}
	static class UEndParticleModuleCircleLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndParticleModuleCircleLocation>();
	}
};
static_assert(alignof(UEndParticleModuleCircleLocation) == 0x000008, "Wrong alignment on UEndParticleModuleCircleLocation");
static_assert(sizeof(UEndParticleModuleCircleLocation) == 0x0000E0, "Wrong size on UEndParticleModuleCircleLocation");
static_assert(offsetof(UEndParticleModuleCircleLocation, m_Kind) == 0x000038, "Member 'UEndParticleModuleCircleLocation::m_Kind' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleCircleLocation, m_Radius) == 0x000040, "Member 'UEndParticleModuleCircleLocation::m_Radius' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleCircleLocation, m_RadiusRandom) == 0x000080, "Member 'UEndParticleModuleCircleLocation::m_RadiusRandom' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleCircleLocation, m_BeginAngle) == 0x000084, "Member 'UEndParticleModuleCircleLocation::m_BeginAngle' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleCircleLocation, m_BeginAngleRandom) == 0x000088, "Member 'UEndParticleModuleCircleLocation::m_BeginAngleRandom' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleCircleLocation, m_StepAngle) == 0x00008C, "Member 'UEndParticleModuleCircleLocation::m_StepAngle' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleCircleLocation, m_StepAngleRandom) == 0x000090, "Member 'UEndParticleModuleCircleLocation::m_StepAngleRandom' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleCircleLocation, m_Velocity) == 0x000098, "Member 'UEndParticleModuleCircleLocation::m_Velocity' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleCircleLocation, m_VelocityRandom) == 0x0000D8, "Member 'UEndParticleModuleCircleLocation::m_VelocityRandom' has a wrong offset!");

// Class EndGame.EndParticleModuleKillSphere
// 0x0060 (0x0098 - 0x0038)
class UEndParticleModuleKillSphere final : public UParticleModuleKillBase
{
public:
	class FName                                   m_RefPointName;                                    // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         m_EnableIfHitRayCastPoint : 1;                     // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  m_Radius;                                          // 0x0048(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         m_KillOutSize : 1;                                 // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         m_ParticleLoopOff : 1;                             // 0x0088(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         m_SendTrigger : 1;                                 // 0x0088(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         m_SendTriggerParticleCount;                        // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         m_EffectLoopOff : 1;                               // 0x0090(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndParticleModuleKillSphere">();
	}
	static class UEndParticleModuleKillSphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndParticleModuleKillSphere>();
	}
};
static_assert(alignof(UEndParticleModuleKillSphere) == 0x000008, "Wrong alignment on UEndParticleModuleKillSphere");
static_assert(sizeof(UEndParticleModuleKillSphere) == 0x000098, "Wrong size on UEndParticleModuleKillSphere");
static_assert(offsetof(UEndParticleModuleKillSphere, m_RefPointName) == 0x000038, "Member 'UEndParticleModuleKillSphere::m_RefPointName' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleKillSphere, m_Radius) == 0x000048, "Member 'UEndParticleModuleKillSphere::m_Radius' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleKillSphere, m_SendTriggerParticleCount) == 0x00008C, "Member 'UEndParticleModuleKillSphere::m_SendTriggerParticleCount' has a wrong offset!");

// Class EndGame.EndParticleModuleLight
// 0x0170 (0x01A8 - 0x0038)
class UEndParticleModuleLight final : public UParticleModuleLightBase
{
public:
	EVfxEffectLightKind                           m_LightKind;                                       // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 m_Color;                                           // 0x0040(0x0060)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_Intensity;                                       // 0x00A0(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_SourceRadius;                                    // 0x00E0(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_AttenuationRadius;                               // 0x0120(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_SourceLength;                                    // 0x0160(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         m_SourceLengthOffsetRate;                          // 0x01A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         m_bIsBeamLight : 1;                                // 0x01A4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         m_bRenderVolumetricFogOnly : 1;                    // 0x01A4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1A5[0x3];                                      // 0x01A5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndParticleModuleLight">();
	}
	static class UEndParticleModuleLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndParticleModuleLight>();
	}
};
static_assert(alignof(UEndParticleModuleLight) == 0x000008, "Wrong alignment on UEndParticleModuleLight");
static_assert(sizeof(UEndParticleModuleLight) == 0x0001A8, "Wrong size on UEndParticleModuleLight");
static_assert(offsetof(UEndParticleModuleLight, m_LightKind) == 0x000038, "Member 'UEndParticleModuleLight::m_LightKind' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleLight, m_Color) == 0x000040, "Member 'UEndParticleModuleLight::m_Color' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleLight, m_Intensity) == 0x0000A0, "Member 'UEndParticleModuleLight::m_Intensity' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleLight, m_SourceRadius) == 0x0000E0, "Member 'UEndParticleModuleLight::m_SourceRadius' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleLight, m_AttenuationRadius) == 0x000120, "Member 'UEndParticleModuleLight::m_AttenuationRadius' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleLight, m_SourceLength) == 0x000160, "Member 'UEndParticleModuleLight::m_SourceLength' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleLight, m_SourceLengthOffsetRate) == 0x0001A0, "Member 'UEndParticleModuleLight::m_SourceLengthOffsetRate' has a wrong offset!");

// Class EndGame.EndParticleModulePoint
// 0x0138 (0x0170 - 0x0038)
class UEndParticleModulePoint final : public UEndParticleModuleBase
{
public:
	class FName                                   m_PointName;                                       // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndEffectLocationKind                        m_Kind;                                            // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 m_Location;                                        // 0x0048(0x0060)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 m_Rotation;                                        // 0x00A8(0x0060)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EVfxRotationMatrixOrder                       m_RotationMatrixOrder;                             // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEndEffectSocketName                   m_SocketName;                                      // 0x010C(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         m_BlendTime;                                       // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_BlendExp;                                        // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         m_bIsWorldRayCast : 1;                             // 0x0120(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_121[0x3];                                      // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                m_RayCastFrom;                                     // 0x0124(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                m_RayCastTo;                                       // 0x0130(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                m_RayCastExtent;                                   // 0x013C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      m_CollisionTypes;                                  // 0x0148(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         m_bUseHitNormal : 1;                               // 0x0160(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_161[0x3];                                      // 0x0161(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         m_fRayCastSpawnParticleScale;                      // 0x0164(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_fHitRayCastSpawnParticleScale;                   // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndParticleModulePoint">();
	}
	static class UEndParticleModulePoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndParticleModulePoint>();
	}
};
static_assert(alignof(UEndParticleModulePoint) == 0x000008, "Wrong alignment on UEndParticleModulePoint");
static_assert(sizeof(UEndParticleModulePoint) == 0x000170, "Wrong size on UEndParticleModulePoint");
static_assert(offsetof(UEndParticleModulePoint, m_PointName) == 0x000038, "Member 'UEndParticleModulePoint::m_PointName' has a wrong offset!");
static_assert(offsetof(UEndParticleModulePoint, m_Kind) == 0x000040, "Member 'UEndParticleModulePoint::m_Kind' has a wrong offset!");
static_assert(offsetof(UEndParticleModulePoint, m_Location) == 0x000048, "Member 'UEndParticleModulePoint::m_Location' has a wrong offset!");
static_assert(offsetof(UEndParticleModulePoint, m_Rotation) == 0x0000A8, "Member 'UEndParticleModulePoint::m_Rotation' has a wrong offset!");
static_assert(offsetof(UEndParticleModulePoint, m_RotationMatrixOrder) == 0x000108, "Member 'UEndParticleModulePoint::m_RotationMatrixOrder' has a wrong offset!");
static_assert(offsetof(UEndParticleModulePoint, m_SocketName) == 0x00010C, "Member 'UEndParticleModulePoint::m_SocketName' has a wrong offset!");
static_assert(offsetof(UEndParticleModulePoint, m_BlendTime) == 0x000118, "Member 'UEndParticleModulePoint::m_BlendTime' has a wrong offset!");
static_assert(offsetof(UEndParticleModulePoint, m_BlendExp) == 0x00011C, "Member 'UEndParticleModulePoint::m_BlendExp' has a wrong offset!");
static_assert(offsetof(UEndParticleModulePoint, m_RayCastFrom) == 0x000124, "Member 'UEndParticleModulePoint::m_RayCastFrom' has a wrong offset!");
static_assert(offsetof(UEndParticleModulePoint, m_RayCastTo) == 0x000130, "Member 'UEndParticleModulePoint::m_RayCastTo' has a wrong offset!");
static_assert(offsetof(UEndParticleModulePoint, m_RayCastExtent) == 0x00013C, "Member 'UEndParticleModulePoint::m_RayCastExtent' has a wrong offset!");
static_assert(offsetof(UEndParticleModulePoint, m_CollisionTypes) == 0x000148, "Member 'UEndParticleModulePoint::m_CollisionTypes' has a wrong offset!");
static_assert(offsetof(UEndParticleModulePoint, m_fRayCastSpawnParticleScale) == 0x000164, "Member 'UEndParticleModulePoint::m_fRayCastSpawnParticleScale' has a wrong offset!");
static_assert(offsetof(UEndParticleModulePoint, m_fHitRayCastSpawnParticleScale) == 0x000168, "Member 'UEndParticleModulePoint::m_fHitRayCastSpawnParticleScale' has a wrong offset!");

// Class EndGame.EndParticleModuleTypeDataBeam
// 0x00C0 (0x0248 - 0x0188)
class UEndParticleModuleTypeDataBeam final : public UParticleModuleTypeDataBeam2
{
public:
	struct FRawDistributionVector                 m_RandomUV;                                        // 0x0188(0x0060)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 m_RandomUVSpeed;                                   // 0x01E8(0x0060)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndParticleModuleTypeDataBeam">();
	}
	static class UEndParticleModuleTypeDataBeam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndParticleModuleTypeDataBeam>();
	}
};
static_assert(alignof(UEndParticleModuleTypeDataBeam) == 0x000008, "Wrong alignment on UEndParticleModuleTypeDataBeam");
static_assert(sizeof(UEndParticleModuleTypeDataBeam) == 0x000248, "Wrong size on UEndParticleModuleTypeDataBeam");
static_assert(offsetof(UEndParticleModuleTypeDataBeam, m_RandomUV) == 0x000188, "Member 'UEndParticleModuleTypeDataBeam::m_RandomUV' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleTypeDataBeam, m_RandomUVSpeed) == 0x0001E8, "Member 'UEndParticleModuleTypeDataBeam::m_RandomUVSpeed' has a wrong offset!");

// Class EndGame.EndParticleModuleTypeDataEffect
// 0x0060 (0x0098 - 0x0038)
class UEndParticleModuleTypeDataEffect final : public UParticleModuleTypeDataBase
{
public:
	uint8                                         Pad_38[0x30];                                      // 0x0038(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        m_CreateEffectPath;                                // 0x0068(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         m_bAttachment : 1;                                 // 0x0080(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEndEffectAttachInfo                   m_AttachInfo;                                      // 0x0084(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         m_bSyncParticle : 1;                               // 0x008C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         m_bApplyRotation : 1;                              // 0x008C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_8D[0xB];                                       // 0x008D(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndParticleModuleTypeDataEffect">();
	}
	static class UEndParticleModuleTypeDataEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndParticleModuleTypeDataEffect>();
	}
};
static_assert(alignof(UEndParticleModuleTypeDataEffect) == 0x000008, "Wrong alignment on UEndParticleModuleTypeDataEffect");
static_assert(sizeof(UEndParticleModuleTypeDataEffect) == 0x000098, "Wrong size on UEndParticleModuleTypeDataEffect");
static_assert(offsetof(UEndParticleModuleTypeDataEffect, m_CreateEffectPath) == 0x000068, "Member 'UEndParticleModuleTypeDataEffect::m_CreateEffectPath' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleTypeDataEffect, m_AttachInfo) == 0x000084, "Member 'UEndParticleModuleTypeDataEffect::m_AttachInfo' has a wrong offset!");

// Class EndGame.EndParticleModuleTypeDataRibbon
// 0x0110 (0x0178 - 0x0068)
class UEndParticleModuleTypeDataRibbon final : public UParticleModuleTypeDataRibbon
{
public:
	uint8                                         m_VfxMode : 1;                                     // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         m_bFitRootLocation : 1;                            // 0x0068(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        m_LocationBufferCount;                             // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_fMaxTrailLength;                                 // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  m_Injection;                                       // 0x0078(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 m_RandomUV;                                        // 0x00B8(0x0060)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 m_RandomUVSpeed;                                   // 0x0118(0x0060)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndParticleModuleTypeDataRibbon">();
	}
	static class UEndParticleModuleTypeDataRibbon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndParticleModuleTypeDataRibbon>();
	}
};
static_assert(alignof(UEndParticleModuleTypeDataRibbon) == 0x000008, "Wrong alignment on UEndParticleModuleTypeDataRibbon");
static_assert(sizeof(UEndParticleModuleTypeDataRibbon) == 0x000178, "Wrong size on UEndParticleModuleTypeDataRibbon");
static_assert(offsetof(UEndParticleModuleTypeDataRibbon, m_LocationBufferCount) == 0x00006C, "Member 'UEndParticleModuleTypeDataRibbon::m_LocationBufferCount' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleTypeDataRibbon, m_fMaxTrailLength) == 0x000070, "Member 'UEndParticleModuleTypeDataRibbon::m_fMaxTrailLength' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleTypeDataRibbon, m_Injection) == 0x000078, "Member 'UEndParticleModuleTypeDataRibbon::m_Injection' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleTypeDataRibbon, m_RandomUV) == 0x0000B8, "Member 'UEndParticleModuleTypeDataRibbon::m_RandomUV' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleTypeDataRibbon, m_RandomUVSpeed) == 0x000118, "Member 'UEndParticleModuleTypeDataRibbon::m_RandomUVSpeed' has a wrong offset!");

// Class EndGame.EndParticleModuleTypeDataTrail
// 0x0128 (0x0178 - 0x0050)
class UEndParticleModuleTypeDataTrail final : public UParticleModuleTypeDataAnimTrail
{
public:
	struct FRawDistributionVector                 m_PointA;                                          // 0x0050(0x0060)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 m_PointB;                                          // 0x00B0(0x0060)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_TrailWidth;                                      // 0x0110(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint16                                        m_MaxParticle;                                     // 0x0150(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_152[0x2];                                      // 0x0152(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         m_EnableFlipV : 1;                                 // 0x0154(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_155[0x3];                                      // 0x0155(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   m_SocketNameA;                                     // 0x0158(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   m_SocketNameB;                                     // 0x0160(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   m_RefPointNameA;                                   // 0x0168(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   m_RefPointNameB;                                   // 0x0170(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndParticleModuleTypeDataTrail">();
	}
	static class UEndParticleModuleTypeDataTrail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndParticleModuleTypeDataTrail>();
	}
};
static_assert(alignof(UEndParticleModuleTypeDataTrail) == 0x000008, "Wrong alignment on UEndParticleModuleTypeDataTrail");
static_assert(sizeof(UEndParticleModuleTypeDataTrail) == 0x000178, "Wrong size on UEndParticleModuleTypeDataTrail");
static_assert(offsetof(UEndParticleModuleTypeDataTrail, m_PointA) == 0x000050, "Member 'UEndParticleModuleTypeDataTrail::m_PointA' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleTypeDataTrail, m_PointB) == 0x0000B0, "Member 'UEndParticleModuleTypeDataTrail::m_PointB' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleTypeDataTrail, m_TrailWidth) == 0x000110, "Member 'UEndParticleModuleTypeDataTrail::m_TrailWidth' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleTypeDataTrail, m_MaxParticle) == 0x000150, "Member 'UEndParticleModuleTypeDataTrail::m_MaxParticle' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleTypeDataTrail, m_SocketNameA) == 0x000158, "Member 'UEndParticleModuleTypeDataTrail::m_SocketNameA' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleTypeDataTrail, m_SocketNameB) == 0x000160, "Member 'UEndParticleModuleTypeDataTrail::m_SocketNameB' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleTypeDataTrail, m_RefPointNameA) == 0x000168, "Member 'UEndParticleModuleTypeDataTrail::m_RefPointNameA' has a wrong offset!");
static_assert(offsetof(UEndParticleModuleTypeDataTrail, m_RefPointNameB) == 0x000170, "Member 'UEndParticleModuleTypeDataTrail::m_RefPointNameB' has a wrong offset!");

// Class EndGame.EndParticleModuleVelocityWind
// 0x0068 (0x00A0 - 0x0038)
class UEndParticleModuleVelocityWind final : public UEndParticleModuleBase
{
public:
	struct FRawDistributionFloat                  m_WindScale;                                       // 0x0038(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x28];                                      // 0x0078(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndParticleModuleVelocityWind">();
	}
	static class UEndParticleModuleVelocityWind* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndParticleModuleVelocityWind>();
	}
};
static_assert(alignof(UEndParticleModuleVelocityWind) == 0x000008, "Wrong alignment on UEndParticleModuleVelocityWind");
static_assert(sizeof(UEndParticleModuleVelocityWind) == 0x0000A0, "Wrong size on UEndParticleModuleVelocityWind");
static_assert(offsetof(UEndParticleModuleVelocityWind, m_WindScale) == 0x000038, "Member 'UEndParticleModuleVelocityWind::m_WindScale' has a wrong offset!");

// Class EndGame.EndPathWayBoxActor
// 0x0050 (0x03C8 - 0x0378)
class AEndPathWayBoxActor final : public AActor
{
public:
	uint8                                         Pad_378[0x8];                                      // 0x0378(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PathWayDirection;                                  // 0x0380(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38C[0x4];                                      // 0x038C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          PathWayBoxComponent;                               // 0x0390(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndNavModifierComponent*               PathWayModifierVolume;                             // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A0[0x28];                                     // 0x03A0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndPathWayBoxActor">();
	}
	static class AEndPathWayBoxActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndPathWayBoxActor>();
	}
};
static_assert(alignof(AEndPathWayBoxActor) == 0x000008, "Wrong alignment on AEndPathWayBoxActor");
static_assert(sizeof(AEndPathWayBoxActor) == 0x0003C8, "Wrong size on AEndPathWayBoxActor");
static_assert(offsetof(AEndPathWayBoxActor, PathWayDirection) == 0x000380, "Member 'AEndPathWayBoxActor::PathWayDirection' has a wrong offset!");
static_assert(offsetof(AEndPathWayBoxActor, PathWayBoxComponent) == 0x000390, "Member 'AEndPathWayBoxActor::PathWayBoxComponent' has a wrong offset!");
static_assert(offsetof(AEndPathWayBoxActor, PathWayModifierVolume) == 0x000398, "Member 'AEndPathWayBoxActor::PathWayModifierVolume' has a wrong offset!");

// Class EndGame.EndPathWaySplineActor
// 0x0030 (0x03A8 - 0x0378)
class AEndPathWaySplineActor final : public AActor
{
public:
	float                                         PathWayBaseWidth;                                  // 0x0378(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PathWayOffsetWidth;                                // 0x037C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PathWaySpace;                                      // 0x0380(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ArrowLength;                                       // 0x0384(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ArrowSize;                                         // 0x0388(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ArrowThickness;                                    // 0x038C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USplineComponent*                       PathWayComponent;                                  // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           PathWayActorsName;                                 // 0x0398(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndPathWaySplineActor">();
	}
	static class AEndPathWaySplineActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndPathWaySplineActor>();
	}
};
static_assert(alignof(AEndPathWaySplineActor) == 0x000008, "Wrong alignment on AEndPathWaySplineActor");
static_assert(sizeof(AEndPathWaySplineActor) == 0x0003A8, "Wrong size on AEndPathWaySplineActor");
static_assert(offsetof(AEndPathWaySplineActor, PathWayBaseWidth) == 0x000378, "Member 'AEndPathWaySplineActor::PathWayBaseWidth' has a wrong offset!");
static_assert(offsetof(AEndPathWaySplineActor, PathWayOffsetWidth) == 0x00037C, "Member 'AEndPathWaySplineActor::PathWayOffsetWidth' has a wrong offset!");
static_assert(offsetof(AEndPathWaySplineActor, PathWaySpace) == 0x000380, "Member 'AEndPathWaySplineActor::PathWaySpace' has a wrong offset!");
static_assert(offsetof(AEndPathWaySplineActor, ArrowLength) == 0x000384, "Member 'AEndPathWaySplineActor::ArrowLength' has a wrong offset!");
static_assert(offsetof(AEndPathWaySplineActor, ArrowSize) == 0x000388, "Member 'AEndPathWaySplineActor::ArrowSize' has a wrong offset!");
static_assert(offsetof(AEndPathWaySplineActor, ArrowThickness) == 0x00038C, "Member 'AEndPathWaySplineActor::ArrowThickness' has a wrong offset!");
static_assert(offsetof(AEndPathWaySplineActor, PathWayComponent) == 0x000390, "Member 'AEndPathWaySplineActor::PathWayComponent' has a wrong offset!");
static_assert(offsetof(AEndPathWaySplineActor, PathWayActorsName) == 0x000398, "Member 'AEndPathWaySplineActor::PathWayActorsName' has a wrong offset!");

// Class EndGame.EndPauseMenu
// 0x00B0 (0x0410 - 0x0360)
class UEndPauseMenu : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0xA0];                                     // 0x0360(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndVirtualScrollBox*                   OptionScrollBox;                                   // 0x0400(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_408[0x8];                                      // 0x0408(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnListMenuPressedItem(int32 ItemIndex);
	void OnListMenuSetupItem(class UWidget* ItemWidget, int32 ItemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndPauseMenu">();
	}
	static class UEndPauseMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndPauseMenu>();
	}
};
static_assert(alignof(UEndPauseMenu) == 0x000008, "Wrong alignment on UEndPauseMenu");
static_assert(sizeof(UEndPauseMenu) == 0x000410, "Wrong size on UEndPauseMenu");
static_assert(offsetof(UEndPauseMenu, OptionScrollBox) == 0x000400, "Member 'UEndPauseMenu::OptionScrollBox' has a wrong offset!");

// Class EndGame.EndPeekCameraDrawComponent
// 0x0000 (0x00F8 - 0x00F8)
class UEndPeekCameraDrawComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndPeekCameraDrawComponent">();
	}
	static class UEndPeekCameraDrawComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndPeekCameraDrawComponent>();
	}
};
static_assert(alignof(UEndPeekCameraDrawComponent) == 0x000008, "Wrong alignment on UEndPeekCameraDrawComponent");
static_assert(sizeof(UEndPeekCameraDrawComponent) == 0x0000F8, "Wrong size on UEndPeekCameraDrawComponent");

// Class EndGame.EndPhysicalConstraintSetting
// 0x00B0 (0x00E0 - 0x0030)
class UEndPhysicalConstraintSetting final : public UDataAsset
{
public:
	TArray<struct FEndPhysicalConstraintBoneSetting> BoneSettings;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         PositionIterationCount;                            // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VelocityIterationCount;                            // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimulateComponentSpace;                           // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTwoStageOrientRotation;                           // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreActorVelocity;                              // 0x004A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseConstantDeltaTime;                             // 0x004B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimulationDeltaTimePowBias;                        // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ContactTargetRadius;                               // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateKinematicBonesToAnim;                       // 0x0054(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyBoneBlendRate;                               // 0x0055(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56[0x2];                                       // 0x0056(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   UniqueEvalName;                                    // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEndPhysicalConstraintSetting_LastPosition> LastPositionSettings;                              // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FEndPhysicalConstraintSetting_AnimPosition> AnimPositionSettings;                              // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FEndPhysicalConstraintSetting_AnimPositionVelocity> AnimPositionVelocitySettings;                      // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FEndPhysicalConstraintSetting_Distance> DistanceSettings;                                  // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FEndPhysicalConstraintSetting_RandomImpulse> RandomImpulseSettings;                             // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FEndPhysicalConstraintSetting_AnimPosition> PostAnimPositionSettings;                          // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FEndPhysicalConstraintSetting_Distance> PostDistanceSettings;                              // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FEndPhysicalConstraintSetting_ContactCharacter> ContactCharacterSettings;                          // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndPhysicalConstraintSetting">();
	}
	static class UEndPhysicalConstraintSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndPhysicalConstraintSetting>();
	}
};
static_assert(alignof(UEndPhysicalConstraintSetting) == 0x000008, "Wrong alignment on UEndPhysicalConstraintSetting");
static_assert(sizeof(UEndPhysicalConstraintSetting) == 0x0000E0, "Wrong size on UEndPhysicalConstraintSetting");
static_assert(offsetof(UEndPhysicalConstraintSetting, BoneSettings) == 0x000030, "Member 'UEndPhysicalConstraintSetting::BoneSettings' has a wrong offset!");
static_assert(offsetof(UEndPhysicalConstraintSetting, PositionIterationCount) == 0x000040, "Member 'UEndPhysicalConstraintSetting::PositionIterationCount' has a wrong offset!");
static_assert(offsetof(UEndPhysicalConstraintSetting, VelocityIterationCount) == 0x000044, "Member 'UEndPhysicalConstraintSetting::VelocityIterationCount' has a wrong offset!");
static_assert(offsetof(UEndPhysicalConstraintSetting, bSimulateComponentSpace) == 0x000048, "Member 'UEndPhysicalConstraintSetting::bSimulateComponentSpace' has a wrong offset!");
static_assert(offsetof(UEndPhysicalConstraintSetting, bTwoStageOrientRotation) == 0x000049, "Member 'UEndPhysicalConstraintSetting::bTwoStageOrientRotation' has a wrong offset!");
static_assert(offsetof(UEndPhysicalConstraintSetting, bIgnoreActorVelocity) == 0x00004A, "Member 'UEndPhysicalConstraintSetting::bIgnoreActorVelocity' has a wrong offset!");
static_assert(offsetof(UEndPhysicalConstraintSetting, bUseConstantDeltaTime) == 0x00004B, "Member 'UEndPhysicalConstraintSetting::bUseConstantDeltaTime' has a wrong offset!");
static_assert(offsetof(UEndPhysicalConstraintSetting, SimulationDeltaTimePowBias) == 0x00004C, "Member 'UEndPhysicalConstraintSetting::SimulationDeltaTimePowBias' has a wrong offset!");
static_assert(offsetof(UEndPhysicalConstraintSetting, ContactTargetRadius) == 0x000050, "Member 'UEndPhysicalConstraintSetting::ContactTargetRadius' has a wrong offset!");
static_assert(offsetof(UEndPhysicalConstraintSetting, bUpdateKinematicBonesToAnim) == 0x000054, "Member 'UEndPhysicalConstraintSetting::bUpdateKinematicBonesToAnim' has a wrong offset!");
static_assert(offsetof(UEndPhysicalConstraintSetting, bApplyBoneBlendRate) == 0x000055, "Member 'UEndPhysicalConstraintSetting::bApplyBoneBlendRate' has a wrong offset!");
static_assert(offsetof(UEndPhysicalConstraintSetting, UniqueEvalName) == 0x000058, "Member 'UEndPhysicalConstraintSetting::UniqueEvalName' has a wrong offset!");
static_assert(offsetof(UEndPhysicalConstraintSetting, LastPositionSettings) == 0x000060, "Member 'UEndPhysicalConstraintSetting::LastPositionSettings' has a wrong offset!");
static_assert(offsetof(UEndPhysicalConstraintSetting, AnimPositionSettings) == 0x000070, "Member 'UEndPhysicalConstraintSetting::AnimPositionSettings' has a wrong offset!");
static_assert(offsetof(UEndPhysicalConstraintSetting, AnimPositionVelocitySettings) == 0x000080, "Member 'UEndPhysicalConstraintSetting::AnimPositionVelocitySettings' has a wrong offset!");
static_assert(offsetof(UEndPhysicalConstraintSetting, DistanceSettings) == 0x000090, "Member 'UEndPhysicalConstraintSetting::DistanceSettings' has a wrong offset!");
static_assert(offsetof(UEndPhysicalConstraintSetting, RandomImpulseSettings) == 0x0000A0, "Member 'UEndPhysicalConstraintSetting::RandomImpulseSettings' has a wrong offset!");
static_assert(offsetof(UEndPhysicalConstraintSetting, PostAnimPositionSettings) == 0x0000B0, "Member 'UEndPhysicalConstraintSetting::PostAnimPositionSettings' has a wrong offset!");
static_assert(offsetof(UEndPhysicalConstraintSetting, PostDistanceSettings) == 0x0000C0, "Member 'UEndPhysicalConstraintSetting::PostDistanceSettings' has a wrong offset!");
static_assert(offsetof(UEndPhysicalConstraintSetting, ContactCharacterSettings) == 0x0000D0, "Member 'UEndPhysicalConstraintSetting::ContactCharacterSettings' has a wrong offset!");

// Class EndGame.EndPhysicsSEUserData
// 0x0058 (0x0080 - 0x0028)
class UEndPhysicsSEUserData final : public UPhysicsSEUserData
{
public:
	struct FEndRagdollSEData                      SEData;                                            // 0x0028(0x0058)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndPhysicsSEUserData">();
	}
	static class UEndPhysicsSEUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndPhysicsSEUserData>();
	}
};
static_assert(alignof(UEndPhysicsSEUserData) == 0x000008, "Wrong alignment on UEndPhysicsSEUserData");
static_assert(sizeof(UEndPhysicsSEUserData) == 0x000080, "Wrong size on UEndPhysicsSEUserData");
static_assert(offsetof(UEndPhysicsSEUserData, SEData) == 0x000028, "Member 'UEndPhysicsSEUserData::SEData' has a wrong offset!");

// Class EndGame.EndPlayerCameraManager
// 0x0C20 (0x2A60 - 0x1E40)
class AEndPlayerCameraManager final : public APlayerCameraManager
{
public:
	class ACameraActor*                           MainCameraActor;                                   // 0x1E38(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E40[0xC20];                                   // 0x1E40(0x0C20)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndPlayerCameraManager">();
	}
	static class AEndPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndPlayerCameraManager>();
	}
};
static_assert(alignof(AEndPlayerCameraManager) == 0x000010, "Wrong alignment on AEndPlayerCameraManager");
static_assert(sizeof(AEndPlayerCameraManager) == 0x002A60, "Wrong size on AEndPlayerCameraManager");
static_assert(offsetof(AEndPlayerCameraManager, MainCameraActor) == 0x001E38, "Member 'AEndPlayerCameraManager::MainCameraActor' has a wrong offset!");

// Class EndGame.EndPlayerExistNavAreaComponent
// 0x00A8 (0x01A0 - 0x00F8)
class UEndPlayerExistNavAreaComponent final : public UActorComponent
{
public:
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class AActor*>              NavModifierMap;                                    // 0x0100(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_150[0x50];                                     // 0x0150(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndPlayerExistNavAreaComponent">();
	}
	static class UEndPlayerExistNavAreaComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndPlayerExistNavAreaComponent>();
	}
};
static_assert(alignof(UEndPlayerExistNavAreaComponent) == 0x000008, "Wrong alignment on UEndPlayerExistNavAreaComponent");
static_assert(sizeof(UEndPlayerExistNavAreaComponent) == 0x0001A0, "Wrong size on UEndPlayerExistNavAreaComponent");
static_assert(offsetof(UEndPlayerExistNavAreaComponent, NavModifierMap) == 0x000100, "Member 'UEndPlayerExistNavAreaComponent::NavModifierMap' has a wrong offset!");

// Class EndGame.EndPreviewLauncherActor
// 0x0008 (0x0380 - 0x0378)
class AEndPreviewLauncherActor final : public AActor
{
public:
	uint8                                         Pad_378[0x8];                                      // 0x0378(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndPreviewLauncherActor">();
	}
	static class AEndPreviewLauncherActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndPreviewLauncherActor>();
	}
};
static_assert(alignof(AEndPreviewLauncherActor) == 0x000008, "Wrong alignment on AEndPreviewLauncherActor");
static_assert(sizeof(AEndPreviewLauncherActor) == 0x000380, "Wrong size on AEndPreviewLauncherActor");

// Class EndGame.EndQuickMateriaList
// 0x02E0 (0x0640 - 0x0360)
class UEndQuickMateriaList : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x8];                                      // 0x0360(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndMainMateriaListBoxWindow*           Materia_List1;                                     // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndMainMateriaListBoxWindow*           Materia_List2;                                     // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndCanvasPanel*                        SummonPnl;                                         // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndUserWidget*                         Materia_Summon_Cell;                               // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndImageSet*                           Icon_Equip1;                                       // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndImageSet*                           Icon_Equip2;                                       // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndTextBlock*                          Txt_Name;                                          // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A0[0x2A0];                                    // 0x03A0(0x02A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndQuickMateriaList">();
	}
	static class UEndQuickMateriaList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndQuickMateriaList>();
	}
};
static_assert(alignof(UEndQuickMateriaList) == 0x000008, "Wrong alignment on UEndQuickMateriaList");
static_assert(sizeof(UEndQuickMateriaList) == 0x000640, "Wrong size on UEndQuickMateriaList");
static_assert(offsetof(UEndQuickMateriaList, Materia_List1) == 0x000368, "Member 'UEndQuickMateriaList::Materia_List1' has a wrong offset!");
static_assert(offsetof(UEndQuickMateriaList, Materia_List2) == 0x000370, "Member 'UEndQuickMateriaList::Materia_List2' has a wrong offset!");
static_assert(offsetof(UEndQuickMateriaList, SummonPnl) == 0x000378, "Member 'UEndQuickMateriaList::SummonPnl' has a wrong offset!");
static_assert(offsetof(UEndQuickMateriaList, Materia_Summon_Cell) == 0x000380, "Member 'UEndQuickMateriaList::Materia_Summon_Cell' has a wrong offset!");
static_assert(offsetof(UEndQuickMateriaList, Icon_Equip1) == 0x000388, "Member 'UEndQuickMateriaList::Icon_Equip1' has a wrong offset!");
static_assert(offsetof(UEndQuickMateriaList, Icon_Equip2) == 0x000390, "Member 'UEndQuickMateriaList::Icon_Equip2' has a wrong offset!");
static_assert(offsetof(UEndQuickMateriaList, Txt_Name) == 0x000398, "Member 'UEndQuickMateriaList::Txt_Name' has a wrong offset!");

// Class EndGame.EndQuickMateriaMenu
// 0x0310 (0x0670 - 0x0360)
class UEndQuickMateriaMenu : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x1F8];                                    // 0x0360(0x01F8)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndQuickMateriaList*                   list_0;                                            // 0x0558(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndQuickMateriaList*                   list_1;                                            // 0x0560(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndQuickMateriaList*                   list_2;                                            // 0x0568(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndQuickMateriaList*                   list_3;                                            // 0x0570(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndUserWidget*                         EquipCell_Top;                                     // 0x0578(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndUserWidget*                         MateriaListMenu;                                   // 0x0580(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndImage*                              Billboard_Materia;                                 // 0x0588(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndBillboard*                          Billboard_CharaImg;                                // 0x0590(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndEquipmentMateriaInfoWindow*         SkillList;                                         // 0x0598(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndCanvasPanel*                        BtnPnl2;                                           // 0x05A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndCanvasPanel*                        BtnPnl3;                                           // 0x05A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndTextBlock*                          Txt_Btn3;                                          // 0x05B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEndSortWindow*                         SortList;                                          // 0x05B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UTexture2D*>                     _MateriaImages;                                    // 0x05C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<EPlayerType, struct FSoftObjectPath>     _CharaImagePaths;                                  // 0x05D0(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<EPlayerType, struct FSoftObjectPath>     _AnotherCharaImagePaths;                           // 0x0620(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	struct FVector2D OnMateriaMenuMeasureItem(int32 CellIndex);
	void OnMateriaMenuPressedItem(int32 CellIndex);
	void OnMateriaMenuSelectedIndexChanged(int32 CellIndex);
	void OnMateriaMenuSetupItem(class UWidget* ItemWidget, int32 CellIndex);
	void OnSlotIndexChanged();
	void OnSlotPressed();
	void OnSortListPressedItem(int32 CellIndex);
	void OnSummonMateriaSlotPressed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndQuickMateriaMenu">();
	}
	static class UEndQuickMateriaMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndQuickMateriaMenu>();
	}
};
static_assert(alignof(UEndQuickMateriaMenu) == 0x000008, "Wrong alignment on UEndQuickMateriaMenu");
static_assert(sizeof(UEndQuickMateriaMenu) == 0x000670, "Wrong size on UEndQuickMateriaMenu");
static_assert(offsetof(UEndQuickMateriaMenu, list_0) == 0x000558, "Member 'UEndQuickMateriaMenu::list_0' has a wrong offset!");
static_assert(offsetof(UEndQuickMateriaMenu, list_1) == 0x000560, "Member 'UEndQuickMateriaMenu::list_1' has a wrong offset!");
static_assert(offsetof(UEndQuickMateriaMenu, list_2) == 0x000568, "Member 'UEndQuickMateriaMenu::list_2' has a wrong offset!");
static_assert(offsetof(UEndQuickMateriaMenu, list_3) == 0x000570, "Member 'UEndQuickMateriaMenu::list_3' has a wrong offset!");
static_assert(offsetof(UEndQuickMateriaMenu, EquipCell_Top) == 0x000578, "Member 'UEndQuickMateriaMenu::EquipCell_Top' has a wrong offset!");
static_assert(offsetof(UEndQuickMateriaMenu, MateriaListMenu) == 0x000580, "Member 'UEndQuickMateriaMenu::MateriaListMenu' has a wrong offset!");
static_assert(offsetof(UEndQuickMateriaMenu, Billboard_Materia) == 0x000588, "Member 'UEndQuickMateriaMenu::Billboard_Materia' has a wrong offset!");
static_assert(offsetof(UEndQuickMateriaMenu, Billboard_CharaImg) == 0x000590, "Member 'UEndQuickMateriaMenu::Billboard_CharaImg' has a wrong offset!");
static_assert(offsetof(UEndQuickMateriaMenu, SkillList) == 0x000598, "Member 'UEndQuickMateriaMenu::SkillList' has a wrong offset!");
static_assert(offsetof(UEndQuickMateriaMenu, BtnPnl2) == 0x0005A0, "Member 'UEndQuickMateriaMenu::BtnPnl2' has a wrong offset!");
static_assert(offsetof(UEndQuickMateriaMenu, BtnPnl3) == 0x0005A8, "Member 'UEndQuickMateriaMenu::BtnPnl3' has a wrong offset!");
static_assert(offsetof(UEndQuickMateriaMenu, Txt_Btn3) == 0x0005B0, "Member 'UEndQuickMateriaMenu::Txt_Btn3' has a wrong offset!");
static_assert(offsetof(UEndQuickMateriaMenu, SortList) == 0x0005B8, "Member 'UEndQuickMateriaMenu::SortList' has a wrong offset!");
static_assert(offsetof(UEndQuickMateriaMenu, _MateriaImages) == 0x0005C0, "Member 'UEndQuickMateriaMenu::_MateriaImages' has a wrong offset!");
static_assert(offsetof(UEndQuickMateriaMenu, _CharaImagePaths) == 0x0005D0, "Member 'UEndQuickMateriaMenu::_CharaImagePaths' has a wrong offset!");
static_assert(offsetof(UEndQuickMateriaMenu, _AnotherCharaImagePaths) == 0x000620, "Member 'UEndQuickMateriaMenu::_AnotherCharaImagePaths' has a wrong offset!");

// Class EndGame.EndRagdollSEComponent
// 0x0100 (0x01F8 - 0x00F8)
class UEndRagdollSEComponent final : public UActorComponent
{
public:
	struct FEndRagdollSEData                      SEData;                                            // 0x00F8(0x0058)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_150[0xA8];                                     // 0x0150(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHitRagdoll(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndRagdollSEComponent">();
	}
	static class UEndRagdollSEComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndRagdollSEComponent>();
	}
};
static_assert(alignof(UEndRagdollSEComponent) == 0x000008, "Wrong alignment on UEndRagdollSEComponent");
static_assert(sizeof(UEndRagdollSEComponent) == 0x0001F8, "Wrong size on UEndRagdollSEComponent");
static_assert(offsetof(UEndRagdollSEComponent, SEData) == 0x0000F8, "Member 'UEndRagdollSEComponent::SEData' has a wrong offset!");

// Class EndGame.EndRig
// 0x0208 (0x0230 - 0x0028)
class UEndRig final : public UObject
{
public:
	class FName                                   CenterBoneName;                                    // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HeadBoneName;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAxis                                  HeadBoneForwardAxis;                               // 0x0038(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   LookAtTargetBoneName;                              // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AimBaseBoneName;                                   // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AimAngleBasedVelocityBiasAngleRange;               // 0x0058(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AimAngleBasedVelocityBiasValueRange;               // 0x0060(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimAngleBasedVelocityBiasInterpSpeed;              // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VibrationRestoreSpeed;                             // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VibrationImpactBias;                               // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VibrationAttenuationRate;                          // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           FullBodyBoneBlendTargets;                          // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           UpperBodyBoneBlendTargets;                         // 0x0088(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FEndBoneBlendRateGroup> BoneBlendRateGroups;                               // 0x0098(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FEndAdjustOrientationSetting           AdjustOrientationSetting;                          // 0x00E8(0x0090)(Edit, NativeAccessSpecifierPublic)
	struct FEndPhysicalDamageReactionSetting      PhysicalDamageReactionSetting;                     // 0x0178(0x0038)(Edit, NativeAccessSpecifierPublic)
	TMap<class FName, class UEndJoint*>           Joints;                                            // 0x01B0(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UEndLookAtSolver*                       LookAtSolver;                                      // 0x0200(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndAimSolver*                          AimSolver;                                         // 0x0208(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndBalancingSolver*                    BalancingSolver;                                   // 0x0210(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFootEffectorSolver*                 FootEffectorSolver;                                // 0x0218(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndHandEffectorSolver*                 HandEffectorSolver;                                // 0x0220(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndLipSyncSolver*                      LipSyncSolver;                                     // 0x0228(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndRig">();
	}
	static class UEndRig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndRig>();
	}
};
static_assert(alignof(UEndRig) == 0x000008, "Wrong alignment on UEndRig");
static_assert(sizeof(UEndRig) == 0x000230, "Wrong size on UEndRig");
static_assert(offsetof(UEndRig, CenterBoneName) == 0x000028, "Member 'UEndRig::CenterBoneName' has a wrong offset!");
static_assert(offsetof(UEndRig, HeadBoneName) == 0x000030, "Member 'UEndRig::HeadBoneName' has a wrong offset!");
static_assert(offsetof(UEndRig, HeadBoneForwardAxis) == 0x000038, "Member 'UEndRig::HeadBoneForwardAxis' has a wrong offset!");
static_assert(offsetof(UEndRig, LookAtTargetBoneName) == 0x000048, "Member 'UEndRig::LookAtTargetBoneName' has a wrong offset!");
static_assert(offsetof(UEndRig, AimBaseBoneName) == 0x000050, "Member 'UEndRig::AimBaseBoneName' has a wrong offset!");
static_assert(offsetof(UEndRig, AimAngleBasedVelocityBiasAngleRange) == 0x000058, "Member 'UEndRig::AimAngleBasedVelocityBiasAngleRange' has a wrong offset!");
static_assert(offsetof(UEndRig, AimAngleBasedVelocityBiasValueRange) == 0x000060, "Member 'UEndRig::AimAngleBasedVelocityBiasValueRange' has a wrong offset!");
static_assert(offsetof(UEndRig, AimAngleBasedVelocityBiasInterpSpeed) == 0x000068, "Member 'UEndRig::AimAngleBasedVelocityBiasInterpSpeed' has a wrong offset!");
static_assert(offsetof(UEndRig, VibrationRestoreSpeed) == 0x00006C, "Member 'UEndRig::VibrationRestoreSpeed' has a wrong offset!");
static_assert(offsetof(UEndRig, VibrationImpactBias) == 0x000070, "Member 'UEndRig::VibrationImpactBias' has a wrong offset!");
static_assert(offsetof(UEndRig, VibrationAttenuationRate) == 0x000074, "Member 'UEndRig::VibrationAttenuationRate' has a wrong offset!");
static_assert(offsetof(UEndRig, FullBodyBoneBlendTargets) == 0x000078, "Member 'UEndRig::FullBodyBoneBlendTargets' has a wrong offset!");
static_assert(offsetof(UEndRig, UpperBodyBoneBlendTargets) == 0x000088, "Member 'UEndRig::UpperBodyBoneBlendTargets' has a wrong offset!");
static_assert(offsetof(UEndRig, BoneBlendRateGroups) == 0x000098, "Member 'UEndRig::BoneBlendRateGroups' has a wrong offset!");
static_assert(offsetof(UEndRig, AdjustOrientationSetting) == 0x0000E8, "Member 'UEndRig::AdjustOrientationSetting' has a wrong offset!");
static_assert(offsetof(UEndRig, PhysicalDamageReactionSetting) == 0x000178, "Member 'UEndRig::PhysicalDamageReactionSetting' has a wrong offset!");
static_assert(offsetof(UEndRig, Joints) == 0x0001B0, "Member 'UEndRig::Joints' has a wrong offset!");
static_assert(offsetof(UEndRig, LookAtSolver) == 0x000200, "Member 'UEndRig::LookAtSolver' has a wrong offset!");
static_assert(offsetof(UEndRig, AimSolver) == 0x000208, "Member 'UEndRig::AimSolver' has a wrong offset!");
static_assert(offsetof(UEndRig, BalancingSolver) == 0x000210, "Member 'UEndRig::BalancingSolver' has a wrong offset!");
static_assert(offsetof(UEndRig, FootEffectorSolver) == 0x000218, "Member 'UEndRig::FootEffectorSolver' has a wrong offset!");
static_assert(offsetof(UEndRig, HandEffectorSolver) == 0x000220, "Member 'UEndRig::HandEffectorSolver' has a wrong offset!");
static_assert(offsetof(UEndRig, LipSyncSolver) == 0x000228, "Member 'UEndRig::LipSyncSolver' has a wrong offset!");

// Class EndGame.EndRouteSearchComponentBase
// 0x0048 (0x0140 - 0x00F8)
class UEndRouteSearchComponentBase final : public UActorComponent
{
public:
	uint8                                         Pad_F8[0x48];                                      // 0x00F8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndRouteSearchComponentBase">();
	}
	static class UEndRouteSearchComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndRouteSearchComponentBase>();
	}
};
static_assert(alignof(UEndRouteSearchComponentBase) == 0x000008, "Wrong alignment on UEndRouteSearchComponentBase");
static_assert(sizeof(UEndRouteSearchComponentBase) == 0x000140, "Wrong size on UEndRouteSearchComponentBase");

// Class EndGame.EndSaveDataBootMenuAPI
// 0x0000 (0x0028 - 0x0028)
class UEndSaveDataBootMenuAPI final : public UBlueprintFunctionLibrary
{
public:
	static void GatherSaveData(class UObject* WorldContextObject, EEndGameScenarioType ScenarioType, TArray<class FString>* OutSaveDataList, const struct FLatentActionInfo& LatentInfo);
	static bool GetLoadingSaveData();
	static void LoadSaveData(class UObject* WorldContextObject, EEndGameScenarioType ScenarioType, const class FString& DataName, const struct FLatentActionInfo& LatentInfo);
	static void SetLoadingSaveData(bool bLoading);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndSaveDataBootMenuAPI">();
	}
	static class UEndSaveDataBootMenuAPI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndSaveDataBootMenuAPI>();
	}
};
static_assert(alignof(UEndSaveDataBootMenuAPI) == 0x000008, "Wrong alignment on UEndSaveDataBootMenuAPI");
static_assert(sizeof(UEndSaveDataBootMenuAPI) == 0x000028, "Wrong size on UEndSaveDataBootMenuAPI");

// Class EndGame.EndSaveDataCell
// 0x0048 (0x03A8 - 0x0360)
class UEndSaveDataCell : public UEndUserWidget
{
public:
	struct FLinearColor                           SaveDataColor;                                     // 0x0360(0x0010)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AutoSaveColor;                                     // 0x0370(0x0010)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_380[0x28];                                     // 0x0380(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndSaveDataCell">();
	}
	static class UEndSaveDataCell* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndSaveDataCell>();
	}
};
static_assert(alignof(UEndSaveDataCell) == 0x000008, "Wrong alignment on UEndSaveDataCell");
static_assert(sizeof(UEndSaveDataCell) == 0x0003A8, "Wrong size on UEndSaveDataCell");
static_assert(offsetof(UEndSaveDataCell, SaveDataColor) == 0x000360, "Member 'UEndSaveDataCell::SaveDataColor' has a wrong offset!");
static_assert(offsetof(UEndSaveDataCell, AutoSaveColor) == 0x000370, "Member 'UEndSaveDataCell::AutoSaveColor' has a wrong offset!");

// Class EndGame.EndSceneAPI
// 0x0000 (0x0028 - 0x0028)
class UEndSceneAPI final : public UObject
{
public:
	static void BindActor(class FName Parent, class FName child, class FName socket, EWeaponSlot Slot);
	static void CancelOverwirttenEnvironmentSet(EEndEnvironmentSetOverritePriority Priority);
	static int32 CreateActorBP(class FName Name_0, class FName CharaSpec, const struct FVector& Location, const struct FRotator& Rotation);
	static int32 DestroyActorBP(class FName Name_0);
	static bool FollowToTargetActor(class FName TargetActorName, class FName FollowTargetActorName);
	static class AEndNavModifierVolume* GetNavFromName(class FName Name_0);
	static class AEndNavModifierVolume* GetNavFromNameAndLevel(class FName Level, class FName Name_0);
	static struct FVector GetNavLocation(class FName Name_0);
	static struct FVector GetNavLocationFromLevel(class FName Level, class FName Name_0);
	static struct FRotator GetNavRotation(class FName Name_0);
	static struct FRotator GetNavRotationFromLevel(class FName Level, class FName Name_0);
	static struct FTransform GetNavTransform(class FName Name_0);
	static struct FTransform GetNavTransformFromLevel(class FName Level, class FName Name_0);
	static bool InvalidateSimpleCameraWall(class FName TargetActorName);
	static bool IsDrawPause(class AActor* Actor);
	static bool IsStableEnvironmentSet();
	static bool MoveToTargetPoint(class FName TargetActorName, const struct FVector& TargetLocation);
	static void SetOverwriteEnvinronment(const class FName& EnvironmentSetKeyName, EEndEnvironmentSetOverritePriority Priority);
	static bool TeleportActor(class FName LevelName, class FName ActorName, class AActor* TargetActor, bool bApplyDestRotation);
	static void UnBindActor(class FName Parent, EWeaponSlot Slot);
	static bool ValidateSimpleCameraWall(class FName TargetActorName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndSceneAPI">();
	}
	static class UEndSceneAPI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndSceneAPI>();
	}
};
static_assert(alignof(UEndSceneAPI) == 0x000008, "Wrong alignment on UEndSceneAPI");
static_assert(sizeof(UEndSceneAPI) == 0x000028, "Wrong size on UEndSceneAPI");

// Class EndGame.EndShopListItemPane
// 0x00A0 (0x0400 - 0x0360)
class UEndShopListItemPane : public UEndUserWidget
{
public:
	struct FLinearColor                           _FoucsedColor;                                     // 0x0360(0x0010)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _UnFoucsedColor;                                   // 0x0370(0x0010)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _UnSelectedColor;                                  // 0x0380(0x0010)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_390[0x70];                                     // 0x0390(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndShopListItemPane">();
	}
	static class UEndShopListItemPane* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndShopListItemPane>();
	}
};
static_assert(alignof(UEndShopListItemPane) == 0x000008, "Wrong alignment on UEndShopListItemPane");
static_assert(sizeof(UEndShopListItemPane) == 0x000400, "Wrong size on UEndShopListItemPane");
static_assert(offsetof(UEndShopListItemPane, _FoucsedColor) == 0x000360, "Member 'UEndShopListItemPane::_FoucsedColor' has a wrong offset!");
static_assert(offsetof(UEndShopListItemPane, _UnFoucsedColor) == 0x000370, "Member 'UEndShopListItemPane::_UnFoucsedColor' has a wrong offset!");
static_assert(offsetof(UEndShopListItemPane, _UnSelectedColor) == 0x000380, "Member 'UEndShopListItemPane::_UnSelectedColor' has a wrong offset!");

// Class EndGame.EndShopMenu
// 0x00D8 (0x0438 - 0x0360)
class UEndShopMenu : public UEndUserWidget
{
public:
	float                                         _SelectNumberSpan;                                 // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEndShopMenuPriceColors                _PriceColor;                                       // 0x0364(0x0030)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_394[0xA4];                                     // 0x0394(0x00A4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnShopChadolyCellSetup(class UWidget* ItemWidget, int32 ItemIndex);
	void OnShopDefaultCellSetup(class UWidget* ItemWidget, int32 ItemIndex);
	void OnShopListCellCliked();
	void OnShopListCellSetup(class UWidget* ItemWidget, int32 ItemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndShopMenu">();
	}
	static class UEndShopMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndShopMenu>();
	}
};
static_assert(alignof(UEndShopMenu) == 0x000008, "Wrong alignment on UEndShopMenu");
static_assert(sizeof(UEndShopMenu) == 0x000438, "Wrong size on UEndShopMenu");
static_assert(offsetof(UEndShopMenu, _SelectNumberSpan) == 0x000360, "Member 'UEndShopMenu::_SelectNumberSpan' has a wrong offset!");
static_assert(offsetof(UEndShopMenu, _PriceColor) == 0x000364, "Member 'UEndShopMenu::_PriceColor' has a wrong offset!");

// Class EndGame.EndSimpleCameraWallVolume
// 0x0010 (0x03C0 - 0x03B0)
class AEndSimpleCameraWallVolume final : public AVolume
{
public:
	ESimpleCameraCollisionProfileType             CollisionProfileType;                              // 0x03B0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B1[0x7];                                      // 0x03B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndTextRenderComponent*                TextRenderComponent;                               // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndSimpleCameraWallVolume">();
	}
	static class AEndSimpleCameraWallVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndSimpleCameraWallVolume>();
	}
};
static_assert(alignof(AEndSimpleCameraWallVolume) == 0x000008, "Wrong alignment on AEndSimpleCameraWallVolume");
static_assert(sizeof(AEndSimpleCameraWallVolume) == 0x0003C0, "Wrong size on AEndSimpleCameraWallVolume");
static_assert(offsetof(AEndSimpleCameraWallVolume, CollisionProfileType) == 0x0003B0, "Member 'AEndSimpleCameraWallVolume::CollisionProfileType' has a wrong offset!");
static_assert(offsetof(AEndSimpleCameraWallVolume, TextRenderComponent) == 0x0003B8, "Member 'AEndSimpleCameraWallVolume::TextRenderComponent' has a wrong offset!");

// Class EndGame.EndSimpleWallActor
// 0x0008 (0x0380 - 0x0378)
class AEndSimpleWallActor final : public AActor
{
public:
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0378(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndSimpleWallActor">();
	}
	static class AEndSimpleWallActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndSimpleWallActor>();
	}
};
static_assert(alignof(AEndSimpleWallActor) == 0x000008, "Wrong alignment on AEndSimpleWallActor");
static_assert(sizeof(AEndSimpleWallActor) == 0x000380, "Wrong size on AEndSimpleWallActor");
static_assert(offsetof(AEndSimpleWallActor, StaticMeshComponent) == 0x000378, "Member 'AEndSimpleWallActor::StaticMeshComponent' has a wrong offset!");

// Class EndGame.EndSlu5bArmCameraVisualizerComponent
// 0x0000 (0x00F8 - 0x00F8)
class UEndSlu5bArmCameraVisualizerComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndSlu5bArmCameraVisualizerComponent">();
	}
	static class UEndSlu5bArmCameraVisualizerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndSlu5bArmCameraVisualizerComponent>();
	}
};
static_assert(alignof(UEndSlu5bArmCameraVisualizerComponent) == 0x000008, "Wrong alignment on UEndSlu5bArmCameraVisualizerComponent");
static_assert(sizeof(UEndSlu5bArmCameraVisualizerComponent) == 0x0000F8, "Wrong size on UEndSlu5bArmCameraVisualizerComponent");

// Class EndGame.EndSlu5bArmCameraActor
// 0x0040 (0x03B8 - 0x0378)
class AEndSlu5bArmCameraActor final : public AActor
{
public:
	uint8                                         Pad_378[0x18];                                     // 0x0378(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ReverseAngle;                                      // 0x0390(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_391[0x3];                                      // 0x0391(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChangeSequenceSeconds;                             // 0x0394(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelSequence*                         DefaultVerticalRCS;                                // 0x0398(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelSequence*                         DefaultHorizontalRCS;                              // 0x03A0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelSequence*                         CharacterVerticalRCS;                              // 0x03A8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelSequence*                         CharacterHorizontalRCS;                            // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndSlu5bArmCameraActor">();
	}
	static class AEndSlu5bArmCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndSlu5bArmCameraActor>();
	}
};
static_assert(alignof(AEndSlu5bArmCameraActor) == 0x000008, "Wrong alignment on AEndSlu5bArmCameraActor");
static_assert(sizeof(AEndSlu5bArmCameraActor) == 0x0003B8, "Wrong size on AEndSlu5bArmCameraActor");
static_assert(offsetof(AEndSlu5bArmCameraActor, ReverseAngle) == 0x000390, "Member 'AEndSlu5bArmCameraActor::ReverseAngle' has a wrong offset!");
static_assert(offsetof(AEndSlu5bArmCameraActor, ChangeSequenceSeconds) == 0x000394, "Member 'AEndSlu5bArmCameraActor::ChangeSequenceSeconds' has a wrong offset!");
static_assert(offsetof(AEndSlu5bArmCameraActor, DefaultVerticalRCS) == 0x000398, "Member 'AEndSlu5bArmCameraActor::DefaultVerticalRCS' has a wrong offset!");
static_assert(offsetof(AEndSlu5bArmCameraActor, DefaultHorizontalRCS) == 0x0003A0, "Member 'AEndSlu5bArmCameraActor::DefaultHorizontalRCS' has a wrong offset!");
static_assert(offsetof(AEndSlu5bArmCameraActor, CharacterVerticalRCS) == 0x0003A8, "Member 'AEndSlu5bArmCameraActor::CharacterVerticalRCS' has a wrong offset!");
static_assert(offsetof(AEndSlu5bArmCameraActor, CharacterHorizontalRCS) == 0x0003B0, "Member 'AEndSlu5bArmCameraActor::CharacterHorizontalRCS' has a wrong offset!");

// Class EndGame.EndSlu5bArmDisableBounceTriggerBox
// 0x0000 (0x0380 - 0x0380)
class AEndSlu5bArmDisableBounceTriggerBox final : public ATriggerBox
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndSlu5bArmDisableBounceTriggerBox">();
	}
	static class AEndSlu5bArmDisableBounceTriggerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndSlu5bArmDisableBounceTriggerBox>();
	}
};
static_assert(alignof(AEndSlu5bArmDisableBounceTriggerBox) == 0x000008, "Wrong alignment on AEndSlu5bArmDisableBounceTriggerBox");
static_assert(sizeof(AEndSlu5bArmDisableBounceTriggerBox) == 0x000380, "Wrong size on AEndSlu5bArmDisableBounceTriggerBox");

// Class EndGame.EndSlu5bArmTriggerBox
// 0x0038 (0x03B8 - 0x0380)
class AEndSlu5bArmTriggerBox final : public ATriggerBox
{
public:
	class FName                                   TargetPointName;                                   // 0x0380(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ForGround;                                         // 0x0388(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_389[0x3];                                      // 0x0389(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OwnerArmName;                                      // 0x038C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CeilingSearchLength;                               // 0x0394(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          UseRoute;                                          // 0x0398(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_399[0x7];                                      // 0x0399(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           RouteTargetPointNameList;                          // 0x03A0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	bool                                          FitFloor;                                          // 0x03B0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B1[0x3];                                      // 0x03B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OverlapCount;                                      // 0x03B4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndSlu5bArmTriggerBox">();
	}
	static class AEndSlu5bArmTriggerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndSlu5bArmTriggerBox>();
	}
};
static_assert(alignof(AEndSlu5bArmTriggerBox) == 0x000008, "Wrong alignment on AEndSlu5bArmTriggerBox");
static_assert(sizeof(AEndSlu5bArmTriggerBox) == 0x0003B8, "Wrong size on AEndSlu5bArmTriggerBox");
static_assert(offsetof(AEndSlu5bArmTriggerBox, TargetPointName) == 0x000380, "Member 'AEndSlu5bArmTriggerBox::TargetPointName' has a wrong offset!");
static_assert(offsetof(AEndSlu5bArmTriggerBox, ForGround) == 0x000388, "Member 'AEndSlu5bArmTriggerBox::ForGround' has a wrong offset!");
static_assert(offsetof(AEndSlu5bArmTriggerBox, OwnerArmName) == 0x00038C, "Member 'AEndSlu5bArmTriggerBox::OwnerArmName' has a wrong offset!");
static_assert(offsetof(AEndSlu5bArmTriggerBox, CeilingSearchLength) == 0x000394, "Member 'AEndSlu5bArmTriggerBox::CeilingSearchLength' has a wrong offset!");
static_assert(offsetof(AEndSlu5bArmTriggerBox, UseRoute) == 0x000398, "Member 'AEndSlu5bArmTriggerBox::UseRoute' has a wrong offset!");
static_assert(offsetof(AEndSlu5bArmTriggerBox, RouteTargetPointNameList) == 0x0003A0, "Member 'AEndSlu5bArmTriggerBox::RouteTargetPointNameList' has a wrong offset!");
static_assert(offsetof(AEndSlu5bArmTriggerBox, FitFloor) == 0x0003B0, "Member 'AEndSlu5bArmTriggerBox::FitFloor' has a wrong offset!");
static_assert(offsetof(AEndSlu5bArmTriggerBox, OverlapCount) == 0x0003B4, "Member 'AEndSlu5bArmTriggerBox::OverlapCount' has a wrong offset!");

// Class EndGame.EndSplineActorPreviewControllerTickable
// 0x0008 (0x0030 - 0x0028)
class UEndSplineActorPreviewControllerTickable final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndSplineActorPreviewControllerTickable">();
	}
	static class UEndSplineActorPreviewControllerTickable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndSplineActorPreviewControllerTickable>();
	}
};
static_assert(alignof(UEndSplineActorPreviewControllerTickable) == 0x000008, "Wrong alignment on UEndSplineActorPreviewControllerTickable");
static_assert(sizeof(UEndSplineActorPreviewControllerTickable) == 0x000030, "Wrong size on UEndSplineActorPreviewControllerTickable");

// Class EndGame.EndAutoTalkSpotLight
// 0x0010 (0x03A0 - 0x0390)
class AEndAutoTalkSpotLight final : public ASpotLight
{
public:
	uint8                                         Pad_390[0x10];                                     // 0x0390(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndAutoTalkSpotLight">();
	}
	static class AEndAutoTalkSpotLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndAutoTalkSpotLight>();
	}
};
static_assert(alignof(AEndAutoTalkSpotLight) == 0x000008, "Wrong alignment on AEndAutoTalkSpotLight");
static_assert(sizeof(AEndAutoTalkSpotLight) == 0x0003A0, "Wrong size on AEndAutoTalkSpotLight");

// Class EndGame.EndStaticMeshActor
// 0x0170 (0x0518 - 0x03A8)
class AEndStaticMeshActor final : public AStaticMeshActor
{
public:
	uint8                                         Pad_3A8[0x170];                                    // 0x03A8(0x0170)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndStaticMeshActor">();
	}
	static class AEndStaticMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndStaticMeshActor>();
	}
};
static_assert(alignof(AEndStaticMeshActor) == 0x000008, "Wrong alignment on AEndStaticMeshActor");
static_assert(sizeof(AEndStaticMeshActor) == 0x000518, "Wrong size on AEndStaticMeshActor");

// Class EndGame.EndStaticMeshSet
// 0x0018 (0x0040 - 0x0028)
class UEndStaticMeshSet final : public UObject
{
public:
	class UStaticMesh*                            BaseStaticMesh;                                    // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStaticMesh*>                    OtherStaticMeshs;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndStaticMeshSet">();
	}
	static class UEndStaticMeshSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndStaticMeshSet>();
	}
};
static_assert(alignof(UEndStaticMeshSet) == 0x000008, "Wrong alignment on UEndStaticMeshSet");
static_assert(sizeof(UEndStaticMeshSet) == 0x000040, "Wrong size on UEndStaticMeshSet");
static_assert(offsetof(UEndStaticMeshSet, BaseStaticMesh) == 0x000028, "Member 'UEndStaticMeshSet::BaseStaticMesh' has a wrong offset!");
static_assert(offsetof(UEndStaticMeshSet, OtherStaticMeshs) == 0x000030, "Member 'UEndStaticMeshSet::OtherStaticMeshs' has a wrong offset!");

// Class EndGame.EndStoryDetailWindow
// 0x00D0 (0x0430 - 0x0360)
class UEndStoryDetailWindow : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0xD0];                                     // 0x0360(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector2D OnQuestInfoListMeasureItem(int32 ItemIndex);
	void OnQuestInfoListSetupItem(class UWidget* ItemWidget, int32 ItemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndStoryDetailWindow">();
	}
	static class UEndStoryDetailWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndStoryDetailWindow>();
	}
};
static_assert(alignof(UEndStoryDetailWindow) == 0x000008, "Wrong alignment on UEndStoryDetailWindow");
static_assert(sizeof(UEndStoryDetailWindow) == 0x000430, "Wrong size on UEndStoryDetailWindow");

// Class EndGame.EndStoryMenu
// 0x0158 (0x05E0 - 0x0488)
class UEndStoryMenu : public UEndMapJournalMenuWindow
{
public:
	uint8                                         Pad_488[0x148];                                    // 0x0488(0x0148)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       CurrentAnimation;                                  // 0x05D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D8[0x8];                                      // 0x05D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLeftMenuPressedItem(int32 ItemIndex);
	void OnLeftMenuSelectedIndexChanged(int32 ItemIndex);
	void OnLeftMenuSetupItem(class UWidget* ItemWidget, int32 ItemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndStoryMenu">();
	}
	static class UEndStoryMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndStoryMenu>();
	}
};
static_assert(alignof(UEndStoryMenu) == 0x000008, "Wrong alignment on UEndStoryMenu");
static_assert(sizeof(UEndStoryMenu) == 0x0005E0, "Wrong size on UEndStoryMenu");
static_assert(offsetof(UEndStoryMenu, CurrentAnimation) == 0x0005D0, "Member 'UEndStoryMenu::CurrentAnimation' has a wrong offset!");

// Class EndGame.EndStringScrollBox
// 0x0728 (0x0820 - 0x00F8)
class UEndStringScrollBox final : public UWidget
{
public:
	struct FScrollBoxStyle                        WidgetStyle;                                       // 0x00F8(0x01E8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FScrollBarStyle                        WidgetBarStyle;                                    // 0x02E0(0x0440)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ESlateVisibility                              ScrollBarVisibility;                               // 0x0720(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_721[0x3];                                      // 0x0721(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ScrollbarThickness;                                // 0x0724(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AlwaysShowScrollbar;                               // 0x072C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndMenuScrollBarPosition                     ScrollBarPosition;                                 // 0x072D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72E[0x2];                                      // 0x072E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMargin                                ClippingPadding;                                   // 0x0730(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         WrapTextAt;                                        // 0x0740(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_744[0x4];                                      // 0x0744(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Text;                                              // 0x0748(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            ColorAndOpacity;                                   // 0x0758(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FLinearColor                           OutlineColorAndOpacity;                            // 0x0780(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndFont*                               Font;                                              // 0x0790(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ShadowOffset;                                      // 0x0798(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ShadowColorAndOpacity;                             // 0x07A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Outline;                                           // 0x07B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B1[0x3];                                      // 0x07B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DesiredCount;                                      // 0x07B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                SlotPadding;                                       // 0x07B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FMargin                                CullingBoundsExtension;                            // 0x07C8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D8[0x18];                                     // 0x07D8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UWidget*>                        ContentWidgets;                                    // 0x07F0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UWidget*>                        CachedWidgets;                                     // 0x0800(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_810[0x10];                                     // 0x0810(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RefreshItems();
	void ScrollToEnd();
	void ScrollToStart();
	void SetColorAndOpacity(const struct FSlateColor& InColorAndOpacity);
	void SetCullingBoundsExtension(const struct FMargin& InCullingBoundsExtension);
	void SetDesiredCount(int32 InDesiredCount);
	void SetFont(class UEndFont* InFont);
	void SetOutline(bool bInOutline);
	void SetOutlineColorAndOpacity(const struct FLinearColor& InOutlineColorAndOpacity);
	void SetPadding(const struct FMargin& InPadding);
	void SetScrollBarPosition(EEndMenuScrollBarPosition InScrollBarPosition);
	void SetScrollOffset(float NewScrollOffset);
	void SetShadowColorAndOpacity(const struct FLinearColor& InShadowColorAndOpacity);
	void SetShadowOffset(const struct FVector2D& InShadowOffset);
	void SetText(const class FString& InText);
	void SetWrapTextAt(float InWrapTextAt);

	int32 GetLineCount() const;
	float GetMaxScrollOffset(float InScrollHeight) const;
	ESlateVisibility GetScrollBarVisibility() const;
	float GetScrollOffset() const;
	class FString GetText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndStringScrollBox">();
	}
	static class UEndStringScrollBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndStringScrollBox>();
	}
};
static_assert(alignof(UEndStringScrollBox) == 0x000008, "Wrong alignment on UEndStringScrollBox");
static_assert(sizeof(UEndStringScrollBox) == 0x000820, "Wrong size on UEndStringScrollBox");
static_assert(offsetof(UEndStringScrollBox, WidgetStyle) == 0x0000F8, "Member 'UEndStringScrollBox::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UEndStringScrollBox, WidgetBarStyle) == 0x0002E0, "Member 'UEndStringScrollBox::WidgetBarStyle' has a wrong offset!");
static_assert(offsetof(UEndStringScrollBox, ScrollBarVisibility) == 0x000720, "Member 'UEndStringScrollBox::ScrollBarVisibility' has a wrong offset!");
static_assert(offsetof(UEndStringScrollBox, ScrollbarThickness) == 0x000724, "Member 'UEndStringScrollBox::ScrollbarThickness' has a wrong offset!");
static_assert(offsetof(UEndStringScrollBox, AlwaysShowScrollbar) == 0x00072C, "Member 'UEndStringScrollBox::AlwaysShowScrollbar' has a wrong offset!");
static_assert(offsetof(UEndStringScrollBox, ScrollBarPosition) == 0x00072D, "Member 'UEndStringScrollBox::ScrollBarPosition' has a wrong offset!");
static_assert(offsetof(UEndStringScrollBox, ClippingPadding) == 0x000730, "Member 'UEndStringScrollBox::ClippingPadding' has a wrong offset!");
static_assert(offsetof(UEndStringScrollBox, WrapTextAt) == 0x000740, "Member 'UEndStringScrollBox::WrapTextAt' has a wrong offset!");
static_assert(offsetof(UEndStringScrollBox, Text) == 0x000748, "Member 'UEndStringScrollBox::Text' has a wrong offset!");
static_assert(offsetof(UEndStringScrollBox, ColorAndOpacity) == 0x000758, "Member 'UEndStringScrollBox::ColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UEndStringScrollBox, OutlineColorAndOpacity) == 0x000780, "Member 'UEndStringScrollBox::OutlineColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UEndStringScrollBox, Font) == 0x000790, "Member 'UEndStringScrollBox::Font' has a wrong offset!");
static_assert(offsetof(UEndStringScrollBox, ShadowOffset) == 0x000798, "Member 'UEndStringScrollBox::ShadowOffset' has a wrong offset!");
static_assert(offsetof(UEndStringScrollBox, ShadowColorAndOpacity) == 0x0007A0, "Member 'UEndStringScrollBox::ShadowColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UEndStringScrollBox, Outline) == 0x0007B0, "Member 'UEndStringScrollBox::Outline' has a wrong offset!");
static_assert(offsetof(UEndStringScrollBox, DesiredCount) == 0x0007B4, "Member 'UEndStringScrollBox::DesiredCount' has a wrong offset!");
static_assert(offsetof(UEndStringScrollBox, SlotPadding) == 0x0007B8, "Member 'UEndStringScrollBox::SlotPadding' has a wrong offset!");
static_assert(offsetof(UEndStringScrollBox, CullingBoundsExtension) == 0x0007C8, "Member 'UEndStringScrollBox::CullingBoundsExtension' has a wrong offset!");
static_assert(offsetof(UEndStringScrollBox, ContentWidgets) == 0x0007F0, "Member 'UEndStringScrollBox::ContentWidgets' has a wrong offset!");
static_assert(offsetof(UEndStringScrollBox, CachedWidgets) == 0x000800, "Member 'UEndStringScrollBox::CachedWidgets' has a wrong offset!");

// Class EndGame.EndSwitchableSkeletalMeshComponent
// 0x0010 (0x14E0 - 0x14D0)
class UEndSwitchableSkeletalMeshComponent final : public UEndSkeletalMeshComponent
{
public:
	TArray<struct FEndSwitchableSkeletalMeshPair> SkeletalMeshes;                                    // 0x14C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bAttachParentIsMasterPose : 1;                     // 0x14D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_14D9[0x7];                                     // 0x14D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSkeletalMeshByIndex(int32 Index_0, bool bReinitPose);
	void SetSkeletalMeshByLabel(class FName Label, bool bReinitPose);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndSwitchableSkeletalMeshComponent">();
	}
	static class UEndSwitchableSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndSwitchableSkeletalMeshComponent>();
	}
};
static_assert(alignof(UEndSwitchableSkeletalMeshComponent) == 0x000010, "Wrong alignment on UEndSwitchableSkeletalMeshComponent");
static_assert(sizeof(UEndSwitchableSkeletalMeshComponent) == 0x0014E0, "Wrong size on UEndSwitchableSkeletalMeshComponent");
static_assert(offsetof(UEndSwitchableSkeletalMeshComponent, SkeletalMeshes) == 0x0014C8, "Member 'UEndSwitchableSkeletalMeshComponent::SkeletalMeshes' has a wrong offset!");

// Class EndGame.EndSwitchHiddenActor
// 0x0028 (0x03A0 - 0x0378)
class AEndSwitchHiddenActor final : public AActor
{
public:
	uint8                                         Pad_378[0x10];                                     // 0x0378(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         TargetActors;                                      // 0x0388(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bUnregisterTickOnHideEnvSetWrapper : 1;            // 0x0398(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_399[0x7];                                      // 0x0399(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndSwitchHiddenActor">();
	}
	static class AEndSwitchHiddenActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndSwitchHiddenActor>();
	}
};
static_assert(alignof(AEndSwitchHiddenActor) == 0x000008, "Wrong alignment on AEndSwitchHiddenActor");
static_assert(sizeof(AEndSwitchHiddenActor) == 0x0003A0, "Wrong size on AEndSwitchHiddenActor");
static_assert(offsetof(AEndSwitchHiddenActor, TargetActors) == 0x000388, "Member 'AEndSwitchHiddenActor::TargetActors' has a wrong offset!");

// Class EndGame.EndSwitchHiddenPrimitiveActor
// 0x0028 (0x03A0 - 0x0378)
class AEndSwitchHiddenPrimitiveActor final : public AActor
{
public:
	uint8                                         Pad_378[0x10];                                     // 0x0378(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         TargetActors;                                      // 0x0388(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndSwitchHiddenPrimitiveActor">();
	}
	static class AEndSwitchHiddenPrimitiveActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndSwitchHiddenPrimitiveActor>();
	}
};
static_assert(alignof(AEndSwitchHiddenPrimitiveActor) == 0x000008, "Wrong alignment on AEndSwitchHiddenPrimitiveActor");
static_assert(sizeof(AEndSwitchHiddenPrimitiveActor) == 0x0003A0, "Wrong size on AEndSwitchHiddenPrimitiveActor");
static_assert(offsetof(AEndSwitchHiddenPrimitiveActor, TargetActors) == 0x000388, "Member 'AEndSwitchHiddenPrimitiveActor::TargetActors' has a wrong offset!");

// Class EndGame.EndSystemAPI
// 0x0000 (0x0028 - 0x0028)
class UEndSystemAPI final : public UObject
{
public:
	static void CheckAppContents(const class UObject* WorldContextObject, int32 taskid, const struct FLatentActionInfo& LatentInfo);
	static void ClearReservedPVPreviewName();
	static void ForceGarbageCollection();
	static class FString GetActiveLocation();
	static TArray<int32> GetAddedAppContents();
	static class FString GetBuildRevisionString();
	static class FString GetBuildTimeString();
	static class FString GetCommandLineOptionValue(const class FString& Option);
	static TArray<class FString> GetDebugPVPreviewNameList(class FName Level);
	static TArray<class FString> GetDebugSaveDataNameList(class FName Level);
	static class FName GetFacialMode();
	static class FName GetFontMode();
	static float GetInputAnalogKeyValue(const struct FKey& Key);
	static class FName GetLanguageMode();
	static class FString GetLoadedLocation();
	static int32 GetLocationIndex(const class FString& Location);
	static class FString GetLocationString(int32 Location);
	static class FString GetOriginalLocation();
	static class FString GetPrevActiveLocation();
	static class FName GetReservedPVPreviewName();
	static int32 GetSaveLocationIndex(const class FString& Location);
	static int32 GetSaveLocationIndexFromCurrentLocation(int32 LocationID);
	static int32 GetTaskIdBP(const class FString& Comment);
	static class FName GetVoiceMode();
	static void InitActivateLocationFromSaveData();
	static void InitAppContents(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	static bool IsAppContentsAdded();
	static bool IsAppContentsChanged();
	static bool IsEndGameMode();
	static bool IsExistTaskIdBP(int32 taskid);
	static bool IsGameStatus(EGameStatus Status);
	static bool IsInputKeyDown(const struct FKey& Key);
	static bool IsInputKeyPressed(const struct FKey& Key);
	static bool IsInputKeyReleased(const struct FKey& Key);
	static bool IsInputKeyRepeat(const struct FKey& Key);
	static bool IsMaster();
	static int32 LoadLevelSpecBP(EEndLoadLevelPriority Priority, class FName SpecName);
	static void ReleaseTaskIdBP(int32 taskid);
	static void ReloadPVPreviewData();
	static void RequestActiveLocation(const class FString& TargetLocation);
	static void SetActiveLocation(const class FString& TargetLocation);
	static void SetGameStatus(EGameStatus Status, bool Set);
	static void SetLoadedLocation(const class FString& Location);
	static void SetReservedPVPreviewName(class FName Name_0);
	static bool SetUpDebugPVPreviewFromName(class FName Level, const class FString& Name_0);
	static void SetUpDebugResidentSaveDataFromName(const class FString& Name_0);
	static void SetUpDebugSaveDataFromName(class FName Level, const class FString& Name_0, bool isSetupResident);
	static void StableCallBoot();
	static void SwitchActiveLocation();
	static void SwitchTruthLocation();
	static int32 UnLoadLevelSpecBP(EEndLoadLevelPriority Priority, class FName SpecName);
	static void UpdateAppContentsStatus();
	static void UpdateTrophy(class FName trophyId);
	static void WaitTaskId(const class UObject* WorldContextObject, int32 taskid, const struct FLatentActionInfo& LatentInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndSystemAPI">();
	}
	static class UEndSystemAPI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndSystemAPI>();
	}
};
static_assert(alignof(UEndSystemAPI) == 0x000008, "Wrong alignment on UEndSystemAPI");
static_assert(sizeof(UEndSystemAPI) == 0x000028, "Wrong size on UEndSystemAPI");

// Class EndGame.EndTalkAPI
// 0x0000 (0x0028 - 0x0028)
class UEndTalkAPI final : public UObject
{
public:
	static void DisableBattleTalkEventBox(class FName TriggerBoxName);
	static void EnableBattleTalkEventBox(class FName TriggerBoxName);
	static void PlayBattleTalkStateByBP(class FName TalkStateId, bool bForced, bool bEnableToStable);
	static void SendBattleTalkPlayTriggerByBP(const class FName TalkPlayTriggerId, const class FString& StringArgument00, const class FString& StringArgument01, const class FString& StringArgument02);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndTalkAPI">();
	}
	static class UEndTalkAPI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndTalkAPI>();
	}
};
static_assert(alignof(UEndTalkAPI) == 0x000008, "Wrong alignment on UEndTalkAPI");
static_assert(sizeof(UEndTalkAPI) == 0x000028, "Wrong size on UEndTalkAPI");

// Class EndGame.EndTerminalActor
// 0x0008 (0x0EC0 - 0x0EB8)
class AEndTerminalActor final : public AEndSkeletalMeshActor
{
public:
	class UEndBoneAttachComponent*                BoneAttach;                                        // 0x0EB8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndTerminalActor">();
	}
	static class AEndTerminalActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndTerminalActor>();
	}
};
static_assert(alignof(AEndTerminalActor) == 0x000008, "Wrong alignment on AEndTerminalActor");
static_assert(sizeof(AEndTerminalActor) == 0x000EC0, "Wrong size on AEndTerminalActor");
static_assert(offsetof(AEndTerminalActor, BoneAttach) == 0x000EB8, "Member 'AEndTerminalActor::BoneAttach' has a wrong offset!");

// Class EndGame.EndTestCoverBox
// 0x0018 (0x0390 - 0x0378)
class AEndTestCoverBox final : public AActor
{
public:
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          WallComponent;                                     // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          CameraWallComponent;                               // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndTestCoverBox">();
	}
	static class AEndTestCoverBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndTestCoverBox>();
	}
};
static_assert(alignof(AEndTestCoverBox) == 0x000008, "Wrong alignment on AEndTestCoverBox");
static_assert(sizeof(AEndTestCoverBox) == 0x000390, "Wrong size on AEndTestCoverBox");
static_assert(offsetof(AEndTestCoverBox, StaticMeshComponent) == 0x000378, "Member 'AEndTestCoverBox::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AEndTestCoverBox, WallComponent) == 0x000380, "Member 'AEndTestCoverBox::WallComponent' has a wrong offset!");
static_assert(offsetof(AEndTestCoverBox, CameraWallComponent) == 0x000388, "Member 'AEndTestCoverBox::CameraWallComponent' has a wrong offset!");

// Class EndGame.EndTestPlayPauseMenu
// 0x0058 (0x03C0 - 0x0368)
class UEndTestPlayPauseMenu final : public UEndSimpleMenu
{
public:
	uint8                                         Pad_368[0x58];                                     // 0x0368(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndTestPlayPauseMenu">();
	}
	static class UEndTestPlayPauseMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndTestPlayPauseMenu>();
	}
};
static_assert(alignof(UEndTestPlayPauseMenu) == 0x000008, "Wrong alignment on UEndTestPlayPauseMenu");
static_assert(sizeof(UEndTestPlayPauseMenu) == 0x0003C0, "Wrong size on UEndTestPlayPauseMenu");

// Class EndGame.EndTestPlaySimpleMenu
// 0x0038 (0x03A0 - 0x0368)
class UEndTestPlaySimpleMenu final : public UEndSimpleMenu
{
public:
	struct FKey                                   DecideKey;                                         // 0x0368(0x0018)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateSound                            DecideSound;                                       // 0x0380(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndTestPlaySimpleMenu">();
	}
	static class UEndTestPlaySimpleMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndTestPlaySimpleMenu>();
	}
};
static_assert(alignof(UEndTestPlaySimpleMenu) == 0x000008, "Wrong alignment on UEndTestPlaySimpleMenu");
static_assert(sizeof(UEndTestPlaySimpleMenu) == 0x0003A0, "Wrong size on UEndTestPlaySimpleMenu");
static_assert(offsetof(UEndTestPlaySimpleMenu, DecideKey) == 0x000368, "Member 'UEndTestPlaySimpleMenu::DecideKey' has a wrong offset!");
static_assert(offsetof(UEndTestPlaySimpleMenu, DecideSound) == 0x000380, "Member 'UEndTestPlaySimpleMenu::DecideSound' has a wrong offset!");

// Class EndGame.EndTextBlock
// 0x0128 (0x0220 - 0x00F8)
class UEndTextBlock final : public UWidget
{
public:
	ETextJustify                                  Justification;                                     // 0x00F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoWrapText;                                      // 0x00F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoShrinkText;                                    // 0x00FA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FB[0x1];                                       // 0x00FB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WrapTextAt;                                        // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                Margin;                                            // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         LineHeightPercentage;                              // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Text;                                              // 0x0118(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             TextDelegate;                                      // 0x0128(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FSlateColor                            ColorAndOpacity;                                   // 0x0138(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ColorAndOpacityDelegate;                           // 0x0160(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Gradient;                                          // 0x0170(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateColor                            BottomColorAndOpacity;                             // 0x0178(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TDelegate<void()>                             BottomColorAndOpacityDelegate;                     // 0x01A0(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           OutlineColorAndOpacity;                            // 0x01B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OutlineColorAndOpacityDelegate;                    // 0x01C0(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	class UEndFont*                               Font;                                              // 0x01D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ShadowOffset;                                      // 0x01D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ShadowColorAndOpacity;                             // 0x01E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ShadowColorAndOpacityDelegate;                     // 0x01F0(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinDesiredWidth;                                   // 0x0200(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBlendMode                                    BlendMode;                                         // 0x0204(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Outline;                                           // 0x0205(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowMacro;                                        // 0x0206(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LeftAlignedCenter;                                 // 0x0207(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoUpdateButtons;                                 // 0x0208(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ColoredButtons;                                    // 0x0209(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20A[0x16];                                     // 0x020A(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAllowMacro(bool bInAllowMacro);
	void SetAutoShrinkText(bool bInAutoShrinkText);
	void SetAutoUpdateButtons(bool bInAutoUpdateButtons);
	void SetAutoWrapText(bool bInAutoWrapText);
	void SetBlendMode(EBlendMode InBlendMode);
	void SetBottomColorAndOpacity(const struct FSlateColor& InColorAndOpacity);
	void SetBottomOpacity(float InOpacity);
	void SetColorAndOpacity(const struct FSlateColor& InColorAndOpacity);
	void SetColoredButtons(bool bInColoredButtons);
	void SetFont(class UEndFont* InFont);
	void SetJustification(ETextJustify InJustification);
	void SetLeftAlignedCenter(bool bInLeftAlignedCenter);
	void SetMinDesiredWidth(float InMinDesiredWidth);
	void SetOpacity(float InOpacity);
	void SetOutline(bool bInOutline);
	void SetOutlineColorAndOpacity(const struct FLinearColor& InOutlineColorAndOpacity);
	void SetShadowColorAndOpacity(const struct FLinearColor& InShadowColorAndOpacity);
	void SetShadowOffset(const struct FVector2D& InShadowOffset);
	void SetText(const class FString& InText);
	void SetWrapTextAt(float InWrapTextAt);

	class FString GetText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndTextBlock">();
	}
	static class UEndTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndTextBlock>();
	}
};
static_assert(alignof(UEndTextBlock) == 0x000008, "Wrong alignment on UEndTextBlock");
static_assert(sizeof(UEndTextBlock) == 0x000220, "Wrong size on UEndTextBlock");
static_assert(offsetof(UEndTextBlock, Justification) == 0x0000F8, "Member 'UEndTextBlock::Justification' has a wrong offset!");
static_assert(offsetof(UEndTextBlock, AutoWrapText) == 0x0000F9, "Member 'UEndTextBlock::AutoWrapText' has a wrong offset!");
static_assert(offsetof(UEndTextBlock, AutoShrinkText) == 0x0000FA, "Member 'UEndTextBlock::AutoShrinkText' has a wrong offset!");
static_assert(offsetof(UEndTextBlock, WrapTextAt) == 0x0000FC, "Member 'UEndTextBlock::WrapTextAt' has a wrong offset!");
static_assert(offsetof(UEndTextBlock, Margin) == 0x000100, "Member 'UEndTextBlock::Margin' has a wrong offset!");
static_assert(offsetof(UEndTextBlock, LineHeightPercentage) == 0x000110, "Member 'UEndTextBlock::LineHeightPercentage' has a wrong offset!");
static_assert(offsetof(UEndTextBlock, Text) == 0x000118, "Member 'UEndTextBlock::Text' has a wrong offset!");
static_assert(offsetof(UEndTextBlock, TextDelegate) == 0x000128, "Member 'UEndTextBlock::TextDelegate' has a wrong offset!");
static_assert(offsetof(UEndTextBlock, ColorAndOpacity) == 0x000138, "Member 'UEndTextBlock::ColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UEndTextBlock, ColorAndOpacityDelegate) == 0x000160, "Member 'UEndTextBlock::ColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UEndTextBlock, Gradient) == 0x000170, "Member 'UEndTextBlock::Gradient' has a wrong offset!");
static_assert(offsetof(UEndTextBlock, BottomColorAndOpacity) == 0x000178, "Member 'UEndTextBlock::BottomColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UEndTextBlock, BottomColorAndOpacityDelegate) == 0x0001A0, "Member 'UEndTextBlock::BottomColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UEndTextBlock, OutlineColorAndOpacity) == 0x0001B0, "Member 'UEndTextBlock::OutlineColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UEndTextBlock, OutlineColorAndOpacityDelegate) == 0x0001C0, "Member 'UEndTextBlock::OutlineColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UEndTextBlock, Font) == 0x0001D0, "Member 'UEndTextBlock::Font' has a wrong offset!");
static_assert(offsetof(UEndTextBlock, ShadowOffset) == 0x0001D8, "Member 'UEndTextBlock::ShadowOffset' has a wrong offset!");
static_assert(offsetof(UEndTextBlock, ShadowColorAndOpacity) == 0x0001E0, "Member 'UEndTextBlock::ShadowColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UEndTextBlock, ShadowColorAndOpacityDelegate) == 0x0001F0, "Member 'UEndTextBlock::ShadowColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UEndTextBlock, MinDesiredWidth) == 0x000200, "Member 'UEndTextBlock::MinDesiredWidth' has a wrong offset!");
static_assert(offsetof(UEndTextBlock, BlendMode) == 0x000204, "Member 'UEndTextBlock::BlendMode' has a wrong offset!");
static_assert(offsetof(UEndTextBlock, Outline) == 0x000205, "Member 'UEndTextBlock::Outline' has a wrong offset!");
static_assert(offsetof(UEndTextBlock, AllowMacro) == 0x000206, "Member 'UEndTextBlock::AllowMacro' has a wrong offset!");
static_assert(offsetof(UEndTextBlock, LeftAlignedCenter) == 0x000207, "Member 'UEndTextBlock::LeftAlignedCenter' has a wrong offset!");
static_assert(offsetof(UEndTextBlock, AutoUpdateButtons) == 0x000208, "Member 'UEndTextBlock::AutoUpdateButtons' has a wrong offset!");
static_assert(offsetof(UEndTextBlock, ColoredButtons) == 0x000209, "Member 'UEndTextBlock::ColoredButtons' has a wrong offset!");

// Class EndGame.EndTextRenderComponent
// 0x0000 (0x0740 - 0x0740)
class UEndTextRenderComponent final : public UTextRenderComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndTextRenderComponent">();
	}
	static class UEndTextRenderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndTextRenderComponent>();
	}
};
static_assert(alignof(UEndTextRenderComponent) == 0x000010, "Wrong alignment on UEndTextRenderComponent");
static_assert(sizeof(UEndTextRenderComponent) == 0x000740, "Wrong size on UEndTextRenderComponent");

// Class EndGame.EndTexturePump
// 0x0070 (0x00A0 - 0x0030)
class UEndTexturePump final : public UDataAsset
{
public:
	int32                                         InitialLoadNum;                                    // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         InAdvance;                                         // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FEndTextureStream>              TextureStream;                                     // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x58];                                      // 0x0048(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndTexturePump">();
	}
	static class UEndTexturePump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndTexturePump>();
	}
};
static_assert(alignof(UEndTexturePump) == 0x000008, "Wrong alignment on UEndTexturePump");
static_assert(sizeof(UEndTexturePump) == 0x0000A0, "Wrong size on UEndTexturePump");
static_assert(offsetof(UEndTexturePump, InitialLoadNum) == 0x000030, "Member 'UEndTexturePump::InitialLoadNum' has a wrong offset!");
static_assert(offsetof(UEndTexturePump, InAdvance) == 0x000034, "Member 'UEndTexturePump::InAdvance' has a wrong offset!");
static_assert(offsetof(UEndTexturePump, TextureStream) == 0x000038, "Member 'UEndTexturePump::TextureStream' has a wrong offset!");

// Class EndGame.EndTiledImage
// 0x00F0 (0x01E8 - 0x00F8)
class UEndTiledImage final : public UWidget
{
public:
	int32                                         HorizontalCount;                                   // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VerticalCount;                                     // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            Brush;                                             // 0x0100(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TDelegate<void()>                             BrushDelegate;                                     // 0x0178(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorAndOpacity;                                   // 0x0188(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ColorAndOpacityDelegate;                           // 0x0198(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	EBlendMode                                    BlendMode;                                         // 0x01A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x3];                                      // 0x01A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              TileSize;                                          // 0x01AC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B4[0x34];                                     // 0x01B4(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMaterialInstanceDynamic* GetDynamicMaterial();
	void SetBlendMode(EBlendMode InBlendMode);
	void SetBrush(const struct FSlateBrush& InBrush);
	void SetBrushFromAsset(class USlateBrushAsset* Asset);
	void SetBrushFromMaterial(class UMaterialInterface* Material);
	void SetBrushFromTexture(class UTexture2D* Texture, bool bMatchSize);
	void SetBrushFromTextureDynamic(class UTexture2DDynamic* Texture, bool bMatchSize);
	void SetColorAndOpacity(const struct FLinearColor& InColorAndOpacity);
	void SetOpacity(float InOpacity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndTiledImage">();
	}
	static class UEndTiledImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndTiledImage>();
	}
};
static_assert(alignof(UEndTiledImage) == 0x000008, "Wrong alignment on UEndTiledImage");
static_assert(sizeof(UEndTiledImage) == 0x0001E8, "Wrong size on UEndTiledImage");
static_assert(offsetof(UEndTiledImage, HorizontalCount) == 0x0000F8, "Member 'UEndTiledImage::HorizontalCount' has a wrong offset!");
static_assert(offsetof(UEndTiledImage, VerticalCount) == 0x0000FC, "Member 'UEndTiledImage::VerticalCount' has a wrong offset!");
static_assert(offsetof(UEndTiledImage, Brush) == 0x000100, "Member 'UEndTiledImage::Brush' has a wrong offset!");
static_assert(offsetof(UEndTiledImage, BrushDelegate) == 0x000178, "Member 'UEndTiledImage::BrushDelegate' has a wrong offset!");
static_assert(offsetof(UEndTiledImage, ColorAndOpacity) == 0x000188, "Member 'UEndTiledImage::ColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UEndTiledImage, ColorAndOpacityDelegate) == 0x000198, "Member 'UEndTiledImage::ColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UEndTiledImage, BlendMode) == 0x0001A8, "Member 'UEndTiledImage::BlendMode' has a wrong offset!");
static_assert(offsetof(UEndTiledImage, TileSize) == 0x0001AC, "Member 'UEndTiledImage::TileSize' has a wrong offset!");

// Class EndGame.EndTitleMembershipWindow
// 0x0050 (0x03B0 - 0x0360)
class UEndTitleMembershipWindow : public UEndUserWidget
{
public:
	uint8                                         Pad_360[0x50];                                     // 0x0360(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndTitleMembershipWindow">();
	}
	static class UEndTitleMembershipWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndTitleMembershipWindow>();
	}
};
static_assert(alignof(UEndTitleMembershipWindow) == 0x000008, "Wrong alignment on UEndTitleMembershipWindow");
static_assert(sizeof(UEndTitleMembershipWindow) == 0x0003B0, "Wrong size on UEndTitleMembershipWindow");

// Class EndGame.EndTitleMenu
// 0x0098 (0x0400 - 0x0368)
class UEndTitleMenu : public UEndSimpleMenu
{
public:
	TSubclassOf<class UUserWidget>                StartMenuWidgetClass;                              // 0x0368(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                StartMenu00WidgetClass;                            // 0x0370(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                StartMenu01WidgetClass;                            // 0x0378(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_380[0x78];                                     // 0x0380(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndUserWidget*                         Throbber;                                          // 0x03F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnPressedAnyButton();
	void OnStartMenuEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndTitleMenu">();
	}
	static class UEndTitleMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndTitleMenu>();
	}
};
static_assert(alignof(UEndTitleMenu) == 0x000008, "Wrong alignment on UEndTitleMenu");
static_assert(sizeof(UEndTitleMenu) == 0x000400, "Wrong size on UEndTitleMenu");
static_assert(offsetof(UEndTitleMenu, StartMenuWidgetClass) == 0x000368, "Member 'UEndTitleMenu::StartMenuWidgetClass' has a wrong offset!");
static_assert(offsetof(UEndTitleMenu, StartMenu00WidgetClass) == 0x000370, "Member 'UEndTitleMenu::StartMenu00WidgetClass' has a wrong offset!");
static_assert(offsetof(UEndTitleMenu, StartMenu01WidgetClass) == 0x000378, "Member 'UEndTitleMenu::StartMenu01WidgetClass' has a wrong offset!");
static_assert(offsetof(UEndTitleMenu, Throbber) == 0x0003F8, "Member 'UEndTitleMenu::Throbber' has a wrong offset!");

// Class EndGame.EndVE0003CarriageCharacter
// 0x0020 (0x22E0 - 0x22C0)
class AEndVE0003CarriageCharacter final : public AEndCharacter
{
public:
	class UEndBoneAttachComponent*                BoneAttachL;                                       // 0x22B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEndBoneAttachComponent*                BoneAttachR;                                       // 0x22C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AEndVE0009ChocoboCharacter*             Chocobo;                                           // 0x22C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AEndCharacter*                          Rider;                                             // 0x22D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22D8[0x8];                                     // 0x22D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndVE0003CarriageCharacter">();
	}
	static class AEndVE0003CarriageCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndVE0003CarriageCharacter>();
	}
};
static_assert(alignof(AEndVE0003CarriageCharacter) == 0x000010, "Wrong alignment on AEndVE0003CarriageCharacter");
static_assert(sizeof(AEndVE0003CarriageCharacter) == 0x0022E0, "Wrong size on AEndVE0003CarriageCharacter");
static_assert(offsetof(AEndVE0003CarriageCharacter, BoneAttachL) == 0x0022B8, "Member 'AEndVE0003CarriageCharacter::BoneAttachL' has a wrong offset!");
static_assert(offsetof(AEndVE0003CarriageCharacter, BoneAttachR) == 0x0022C0, "Member 'AEndVE0003CarriageCharacter::BoneAttachR' has a wrong offset!");
static_assert(offsetof(AEndVE0003CarriageCharacter, Chocobo) == 0x0022C8, "Member 'AEndVE0003CarriageCharacter::Chocobo' has a wrong offset!");
static_assert(offsetof(AEndVE0003CarriageCharacter, Rider) == 0x0022D0, "Member 'AEndVE0003CarriageCharacter::Rider' has a wrong offset!");

// Class EndGame.EndVirtualScrollBox
// 0x0720 (0x0818 - 0x00F8)
class UEndVirtualScrollBox final : public UWidget
{
public:
	struct FScrollBoxStyle                        WidgetStyle;                                       // 0x00F8(0x01E8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FScrollBarStyle                        WidgetBarStyle;                                    // 0x02E0(0x0440)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EOrientation                                  Orientation;                                       // 0x0720(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              ScrollBarVisibility;                               // 0x0721(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_722[0x2];                                      // 0x0722(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ScrollbarThickness;                                // 0x0724(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AlwaysShowScrollbar;                               // 0x072C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndMenuScrollBarPosition                     ScrollBarPosition;                                 // 0x072D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72E[0x2];                                      // 0x072E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMargin                                ClippingPadding;                                   // 0x0730(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          SupportsPageScroll;                                // 0x0740(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SupportsKeyDown;                                   // 0x0741(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VariableSizeItem;                                  // 0x0742(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_743[0x5];                                      // 0x0743(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UWidget>                    ContentClass;                                      // 0x0748(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWidget>                    CursorClass;                                       // 0x0750(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount;                                         // 0x0758(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DesiredCount;                                      // 0x075C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                SlotPadding;                                       // 0x0760(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FMargin                                CursorBoundsExtension;                             // 0x0770(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FMargin                                CullingBoundsExtension;                            // 0x0780(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class UWidget* ItemWidget, int32 ItemIndex)> OnSetupItem;                                       // 0x0790(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(int32 ItemIndex)>              OnMeasureItem;                                     // 0x07A0(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPressedItem;                                     // 0x07B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnSelectedIndexChanged;                            // 0x07C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D0[0x18];                                     // 0x07D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UWidget*>                        ContentWidgets;                                    // 0x07E8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UWidget*>                        CachedWidgets;                                     // 0x07F8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UWidget*                                CursorWidget;                                      // 0x0808(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                CachedCursor;                                      // 0x0810(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void RefreshItem(int32 Index_0);
	void RefreshItems();
	void ScrollToEnd();
	void ScrollToStart();
	void ScrollWidgetIntoView(class UWidget* WidgetToFind, bool AnimateScroll);
	void SetCullingBoundsExtension(const struct FMargin& InCullingBoundsExtension);
	void SetCursorBoundsExtension(const struct FMargin& InCursorBoundsExtension);
	void SetDesiredCount(int32 InDesiredCount);
	void SetHasVariableSizeItem(bool bInVariableSizeItem);
	void SetItemCount(int32 InItemCount);
	void SetPadding(const struct FMargin& InPadding);
	void SetScrollBarPosition(EEndMenuScrollBarPosition InScrollBarPosition);
	void SetScrollOffset(float NewScrollOffset);
	void SetSelectedIndex(int32 UserIndex, int32 SlotIndex, bool InAnimateScroll, bool ForceCallback, class UWidget* InRootWidget);
	void SetSelectedIndexWithCause(int32 UserIndex, int32 SlotIndex, EFocusCause FocusCause, bool InAnimateScroll, bool ForceCallback, class UWidget* InRootWidget);
	void SetSupportsKeyDown(bool bInSupportsKeyDown);
	void SetSupportsPageScroll(bool bInSupportsPageScroll);

	class UWidget* GetChildAt(int32 Index_0) const;
	class UWidget* GetCursorWidget() const;
	float GetMaxScrollOffset() const;
	ESlateVisibility GetScrollBarVisibility() const;
	float GetScrollOffset() const;
	int32 GetSelectedIndex(int32 UserIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndVirtualScrollBox">();
	}
	static class UEndVirtualScrollBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndVirtualScrollBox>();
	}
};
static_assert(alignof(UEndVirtualScrollBox) == 0x000008, "Wrong alignment on UEndVirtualScrollBox");
static_assert(sizeof(UEndVirtualScrollBox) == 0x000818, "Wrong size on UEndVirtualScrollBox");
static_assert(offsetof(UEndVirtualScrollBox, WidgetStyle) == 0x0000F8, "Member 'UEndVirtualScrollBox::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UEndVirtualScrollBox, WidgetBarStyle) == 0x0002E0, "Member 'UEndVirtualScrollBox::WidgetBarStyle' has a wrong offset!");
static_assert(offsetof(UEndVirtualScrollBox, Orientation) == 0x000720, "Member 'UEndVirtualScrollBox::Orientation' has a wrong offset!");
static_assert(offsetof(UEndVirtualScrollBox, ScrollBarVisibility) == 0x000721, "Member 'UEndVirtualScrollBox::ScrollBarVisibility' has a wrong offset!");
static_assert(offsetof(UEndVirtualScrollBox, ScrollbarThickness) == 0x000724, "Member 'UEndVirtualScrollBox::ScrollbarThickness' has a wrong offset!");
static_assert(offsetof(UEndVirtualScrollBox, AlwaysShowScrollbar) == 0x00072C, "Member 'UEndVirtualScrollBox::AlwaysShowScrollbar' has a wrong offset!");
static_assert(offsetof(UEndVirtualScrollBox, ScrollBarPosition) == 0x00072D, "Member 'UEndVirtualScrollBox::ScrollBarPosition' has a wrong offset!");
static_assert(offsetof(UEndVirtualScrollBox, ClippingPadding) == 0x000730, "Member 'UEndVirtualScrollBox::ClippingPadding' has a wrong offset!");
static_assert(offsetof(UEndVirtualScrollBox, SupportsPageScroll) == 0x000740, "Member 'UEndVirtualScrollBox::SupportsPageScroll' has a wrong offset!");
static_assert(offsetof(UEndVirtualScrollBox, SupportsKeyDown) == 0x000741, "Member 'UEndVirtualScrollBox::SupportsKeyDown' has a wrong offset!");
static_assert(offsetof(UEndVirtualScrollBox, VariableSizeItem) == 0x000742, "Member 'UEndVirtualScrollBox::VariableSizeItem' has a wrong offset!");
static_assert(offsetof(UEndVirtualScrollBox, ContentClass) == 0x000748, "Member 'UEndVirtualScrollBox::ContentClass' has a wrong offset!");
static_assert(offsetof(UEndVirtualScrollBox, CursorClass) == 0x000750, "Member 'UEndVirtualScrollBox::CursorClass' has a wrong offset!");
static_assert(offsetof(UEndVirtualScrollBox, ItemCount) == 0x000758, "Member 'UEndVirtualScrollBox::ItemCount' has a wrong offset!");
static_assert(offsetof(UEndVirtualScrollBox, DesiredCount) == 0x00075C, "Member 'UEndVirtualScrollBox::DesiredCount' has a wrong offset!");
static_assert(offsetof(UEndVirtualScrollBox, SlotPadding) == 0x000760, "Member 'UEndVirtualScrollBox::SlotPadding' has a wrong offset!");
static_assert(offsetof(UEndVirtualScrollBox, CursorBoundsExtension) == 0x000770, "Member 'UEndVirtualScrollBox::CursorBoundsExtension' has a wrong offset!");
static_assert(offsetof(UEndVirtualScrollBox, CullingBoundsExtension) == 0x000780, "Member 'UEndVirtualScrollBox::CullingBoundsExtension' has a wrong offset!");
static_assert(offsetof(UEndVirtualScrollBox, OnSetupItem) == 0x000790, "Member 'UEndVirtualScrollBox::OnSetupItem' has a wrong offset!");
static_assert(offsetof(UEndVirtualScrollBox, OnMeasureItem) == 0x0007A0, "Member 'UEndVirtualScrollBox::OnMeasureItem' has a wrong offset!");
static_assert(offsetof(UEndVirtualScrollBox, OnPressedItem) == 0x0007B0, "Member 'UEndVirtualScrollBox::OnPressedItem' has a wrong offset!");
static_assert(offsetof(UEndVirtualScrollBox, OnSelectedIndexChanged) == 0x0007C0, "Member 'UEndVirtualScrollBox::OnSelectedIndexChanged' has a wrong offset!");
static_assert(offsetof(UEndVirtualScrollBox, ContentWidgets) == 0x0007E8, "Member 'UEndVirtualScrollBox::ContentWidgets' has a wrong offset!");
static_assert(offsetof(UEndVirtualScrollBox, CachedWidgets) == 0x0007F8, "Member 'UEndVirtualScrollBox::CachedWidgets' has a wrong offset!");
static_assert(offsetof(UEndVirtualScrollBox, CursorWidget) == 0x000808, "Member 'UEndVirtualScrollBox::CursorWidget' has a wrong offset!");
static_assert(offsetof(UEndVirtualScrollBox, CachedCursor) == 0x000810, "Member 'UEndVirtualScrollBox::CachedCursor' has a wrong offset!");

// Class EndGame.EndWallPathEditorDrawComponent
// 0x0000 (0x00F8 - 0x00F8)
class UEndWallPathEditorDrawComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndWallPathEditorDrawComponent">();
	}
	static class UEndWallPathEditorDrawComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndWallPathEditorDrawComponent>();
	}
};
static_assert(alignof(UEndWallPathEditorDrawComponent) == 0x000008, "Wrong alignment on UEndWallPathEditorDrawComponent");
static_assert(sizeof(UEndWallPathEditorDrawComponent) == 0x0000F8, "Wrong size on UEndWallPathEditorDrawComponent");

// Class EndGame.FA0222_AnimInstance
// 0x0098 (0x04C0 - 0x0428)
class UFA0222_AnimInstance final : public UAnimInstance
{
public:
	struct FBoneReference                         LeftHandleBone;                                    // 0x0428(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightHandleBone;                                   // 0x043C(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimSequence*                          PoseReferenceAnimation;                            // 0x0450(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EFA0222_PoseReference, int32>            PoseReferenceFrames;                               // 0x0458(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         PoseReferenceAnimationFrameRate;                   // 0x04A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LeftHandleInput;                                   // 0x04AC(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RightHandleInput;                                  // 0x04B4(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4BC[0x4];                                      // 0x04BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FA0222_AnimInstance">();
	}
	static class UFA0222_AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFA0222_AnimInstance>();
	}
};
static_assert(alignof(UFA0222_AnimInstance) == 0x000008, "Wrong alignment on UFA0222_AnimInstance");
static_assert(sizeof(UFA0222_AnimInstance) == 0x0004C0, "Wrong size on UFA0222_AnimInstance");
static_assert(offsetof(UFA0222_AnimInstance, LeftHandleBone) == 0x000428, "Member 'UFA0222_AnimInstance::LeftHandleBone' has a wrong offset!");
static_assert(offsetof(UFA0222_AnimInstance, RightHandleBone) == 0x00043C, "Member 'UFA0222_AnimInstance::RightHandleBone' has a wrong offset!");
static_assert(offsetof(UFA0222_AnimInstance, PoseReferenceAnimation) == 0x000450, "Member 'UFA0222_AnimInstance::PoseReferenceAnimation' has a wrong offset!");
static_assert(offsetof(UFA0222_AnimInstance, PoseReferenceFrames) == 0x000458, "Member 'UFA0222_AnimInstance::PoseReferenceFrames' has a wrong offset!");
static_assert(offsetof(UFA0222_AnimInstance, PoseReferenceAnimationFrameRate) == 0x0004A8, "Member 'UFA0222_AnimInstance::PoseReferenceAnimationFrameRate' has a wrong offset!");
static_assert(offsetof(UFA0222_AnimInstance, LeftHandleInput) == 0x0004AC, "Member 'UFA0222_AnimInstance::LeftHandleInput' has a wrong offset!");
static_assert(offsetof(UFA0222_AnimInstance, RightHandleInput) == 0x0004B4, "Member 'UFA0222_AnimInstance::RightHandleInput' has a wrong offset!");

// Class EndGame.UEndEQTest_SummonPreciseAngle
// 0x0000 (0x01C0 - 0x01C0)
class UUEndEQTest_SummonPreciseAngle final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UEndEQTest_SummonPreciseAngle">();
	}
	static class UUEndEQTest_SummonPreciseAngle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUEndEQTest_SummonPreciseAngle>();
	}
};
static_assert(alignof(UUEndEQTest_SummonPreciseAngle) == 0x000008, "Wrong alignment on UUEndEQTest_SummonPreciseAngle");
static_assert(sizeof(UUEndEQTest_SummonPreciseAngle) == 0x0001C0, "Wrong size on UUEndEQTest_SummonPreciseAngle");

// Class EndGame.VfxDistributionVectorNonUniform
// 0x0028 (0x00A8 - 0x0080)
class UVfxDistributionVectorNonUniform final : public UDistributionVectorUniform
{
public:
	struct FVfxNonUniformRandom                   m_NonUniformRandomX;                               // 0x0080(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FVfxNonUniformRandom                   m_NonUniformRandomY;                               // 0x008C(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FVfxNonUniformRandom                   m_NonUniformRandomZ;                               // 0x0098(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VfxDistributionVectorNonUniform">();
	}
	static class UVfxDistributionVectorNonUniform* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVfxDistributionVectorNonUniform>();
	}
};
static_assert(alignof(UVfxDistributionVectorNonUniform) == 0x000008, "Wrong alignment on UVfxDistributionVectorNonUniform");
static_assert(sizeof(UVfxDistributionVectorNonUniform) == 0x0000A8, "Wrong size on UVfxDistributionVectorNonUniform");
static_assert(offsetof(UVfxDistributionVectorNonUniform, m_NonUniformRandomX) == 0x000080, "Member 'UVfxDistributionVectorNonUniform::m_NonUniformRandomX' has a wrong offset!");
static_assert(offsetof(UVfxDistributionVectorNonUniform, m_NonUniformRandomY) == 0x00008C, "Member 'UVfxDistributionVectorNonUniform::m_NonUniformRandomY' has a wrong offset!");
static_assert(offsetof(UVfxDistributionVectorNonUniform, m_NonUniformRandomZ) == 0x000098, "Member 'UVfxDistributionVectorNonUniform::m_NonUniformRandomZ' has a wrong offset!");

// Class EndGame.VfxParticleModuleActorDithreFade
// 0x0090 (0x00C8 - 0x0038)
class UVfxParticleModuleActorDithreFade final : public UEndParticleModuleBase
{
public:
	struct FRawDistributionFloat                  m_BlendScale;                                      // 0x0038(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_BlendAdd;                                        // 0x0078(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class FName>                           m_MaterialSlotNames;                               // 0x00B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VfxParticleModuleActorDithreFade">();
	}
	static class UVfxParticleModuleActorDithreFade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVfxParticleModuleActorDithreFade>();
	}
};
static_assert(alignof(UVfxParticleModuleActorDithreFade) == 0x000008, "Wrong alignment on UVfxParticleModuleActorDithreFade");
static_assert(sizeof(UVfxParticleModuleActorDithreFade) == 0x0000C8, "Wrong size on UVfxParticleModuleActorDithreFade");
static_assert(offsetof(UVfxParticleModuleActorDithreFade, m_BlendScale) == 0x000038, "Member 'UVfxParticleModuleActorDithreFade::m_BlendScale' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleActorDithreFade, m_BlendAdd) == 0x000078, "Member 'UVfxParticleModuleActorDithreFade::m_BlendAdd' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleActorDithreFade, m_MaterialSlotNames) == 0x0000B8, "Member 'UVfxParticleModuleActorDithreFade::m_MaterialSlotNames' has a wrong offset!");

// Class EndGame.VfxParticleModuleBeamLocation
// 0x0118 (0x0150 - 0x0038)
class UVfxParticleModuleBeamLocation final : public UParticleModuleLocationBase
{
public:
	float                                         m_SpawnBaseLength;                                 // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  m_SpawnStartRatio;                                 // 0x0040(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_SpawnEndRatio;                                   // 0x0080(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_Radius;                                          // 0x00C0(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_Velocity;                                        // 0x0100(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FName                                   m_RefPointNameA;                                   // 0x0140(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   m_RefPointNameB;                                   // 0x0148(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VfxParticleModuleBeamLocation">();
	}
	static class UVfxParticleModuleBeamLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVfxParticleModuleBeamLocation>();
	}
};
static_assert(alignof(UVfxParticleModuleBeamLocation) == 0x000008, "Wrong alignment on UVfxParticleModuleBeamLocation");
static_assert(sizeof(UVfxParticleModuleBeamLocation) == 0x000150, "Wrong size on UVfxParticleModuleBeamLocation");
static_assert(offsetof(UVfxParticleModuleBeamLocation, m_SpawnBaseLength) == 0x000038, "Member 'UVfxParticleModuleBeamLocation::m_SpawnBaseLength' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleBeamLocation, m_SpawnStartRatio) == 0x000040, "Member 'UVfxParticleModuleBeamLocation::m_SpawnStartRatio' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleBeamLocation, m_SpawnEndRatio) == 0x000080, "Member 'UVfxParticleModuleBeamLocation::m_SpawnEndRatio' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleBeamLocation, m_Radius) == 0x0000C0, "Member 'UVfxParticleModuleBeamLocation::m_Radius' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleBeamLocation, m_Velocity) == 0x000100, "Member 'UVfxParticleModuleBeamLocation::m_Velocity' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleBeamLocation, m_RefPointNameA) == 0x000140, "Member 'UVfxParticleModuleBeamLocation::m_RefPointNameA' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleBeamLocation, m_RefPointNameB) == 0x000148, "Member 'UVfxParticleModuleBeamLocation::m_RefPointNameB' has a wrong offset!");

// Class EndGame.VfxParticleModuleCameraControl
// 0x0120 (0x0158 - 0x0038)
class UVfxParticleModuleCameraControl final : public UParticleModuleCameraBase
{
public:
	uint8                                         m_DebugSetPreviewCamera : 1;                       // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   m_RefPointName;                                    // 0x003C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  m_Fov;                                             // 0x0048(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_Distance;                                        // 0x0088(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 m_Rotation;                                        // 0x00C8(0x0060)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         m_BlendTime;                                       // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_BlendExp;                                        // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         m_EnableGamePad : 1;                               // 0x0130(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_131[0x3];                                      // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              m_LocationOffset;                                  // 0x0134(0x0008)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              m_RotationOffset;                                  // 0x013C(0x0008)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_DampingScale;                                    // 0x0144(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_Rstick_RotationSpeed;                            // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_Rstick_ZoomSpeed;                                // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_Rstick_ZoomMin;                                  // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_Rstick_ZoomMax;                                  // 0x0154(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VfxParticleModuleCameraControl">();
	}
	static class UVfxParticleModuleCameraControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVfxParticleModuleCameraControl>();
	}
};
static_assert(alignof(UVfxParticleModuleCameraControl) == 0x000008, "Wrong alignment on UVfxParticleModuleCameraControl");
static_assert(sizeof(UVfxParticleModuleCameraControl) == 0x000158, "Wrong size on UVfxParticleModuleCameraControl");
static_assert(offsetof(UVfxParticleModuleCameraControl, m_RefPointName) == 0x00003C, "Member 'UVfxParticleModuleCameraControl::m_RefPointName' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleCameraControl, m_Fov) == 0x000048, "Member 'UVfxParticleModuleCameraControl::m_Fov' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleCameraControl, m_Distance) == 0x000088, "Member 'UVfxParticleModuleCameraControl::m_Distance' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleCameraControl, m_Rotation) == 0x0000C8, "Member 'UVfxParticleModuleCameraControl::m_Rotation' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleCameraControl, m_BlendTime) == 0x000128, "Member 'UVfxParticleModuleCameraControl::m_BlendTime' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleCameraControl, m_BlendExp) == 0x00012C, "Member 'UVfxParticleModuleCameraControl::m_BlendExp' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleCameraControl, m_LocationOffset) == 0x000134, "Member 'UVfxParticleModuleCameraControl::m_LocationOffset' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleCameraControl, m_RotationOffset) == 0x00013C, "Member 'UVfxParticleModuleCameraControl::m_RotationOffset' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleCameraControl, m_DampingScale) == 0x000144, "Member 'UVfxParticleModuleCameraControl::m_DampingScale' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleCameraControl, m_Rstick_RotationSpeed) == 0x000148, "Member 'UVfxParticleModuleCameraControl::m_Rstick_RotationSpeed' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleCameraControl, m_Rstick_ZoomSpeed) == 0x00014C, "Member 'UVfxParticleModuleCameraControl::m_Rstick_ZoomSpeed' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleCameraControl, m_Rstick_ZoomMin) == 0x000150, "Member 'UVfxParticleModuleCameraControl::m_Rstick_ZoomMin' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleCameraControl, m_Rstick_ZoomMax) == 0x000154, "Member 'UVfxParticleModuleCameraControl::m_Rstick_ZoomMax' has a wrong offset!");

// Class EndGame.VfxParticleModuleCameraDistance
// 0x0158 (0x0190 - 0x0038)
class UVfxParticleModuleCameraDistance final : public UParticleModuleCameraBase
{
public:
	float                                         m_fBeginDistance;                                  // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_fBlendDistance;                                  // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         m_bIgnoreHeight : 1;                               // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 m_Scale;                                           // 0x0048(0x0060)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 m_ColorScale;                                      // 0x00A8(0x0060)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_AlphaScale;                                      // 0x0108(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         m_bLuminanceScale : 1;                             // 0x0148(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  m_LuminanceScale;                                  // 0x0150(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VfxParticleModuleCameraDistance">();
	}
	static class UVfxParticleModuleCameraDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVfxParticleModuleCameraDistance>();
	}
};
static_assert(alignof(UVfxParticleModuleCameraDistance) == 0x000008, "Wrong alignment on UVfxParticleModuleCameraDistance");
static_assert(sizeof(UVfxParticleModuleCameraDistance) == 0x000190, "Wrong size on UVfxParticleModuleCameraDistance");
static_assert(offsetof(UVfxParticleModuleCameraDistance, m_fBeginDistance) == 0x000038, "Member 'UVfxParticleModuleCameraDistance::m_fBeginDistance' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleCameraDistance, m_fBlendDistance) == 0x00003C, "Member 'UVfxParticleModuleCameraDistance::m_fBlendDistance' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleCameraDistance, m_Scale) == 0x000048, "Member 'UVfxParticleModuleCameraDistance::m_Scale' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleCameraDistance, m_ColorScale) == 0x0000A8, "Member 'UVfxParticleModuleCameraDistance::m_ColorScale' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleCameraDistance, m_AlphaScale) == 0x000108, "Member 'UVfxParticleModuleCameraDistance::m_AlphaScale' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleCameraDistance, m_LuminanceScale) == 0x000150, "Member 'UVfxParticleModuleCameraDistance::m_LuminanceScale' has a wrong offset!");

// Class EndGame.VfxParticleModuleFadeByEmitterAngle
// 0x0018 (0x0058 - 0x0040)
class UVfxParticleModuleFadeByEmitterAngle final : public UParticleModuleColorBase
{
public:
	float                                         m_LimitAngle;                                      // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_BlendAngle;                                      // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_VisibleDistance;                                 // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_BlendDistance;                                   // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VfxParticleModuleFadeByEmitterAngle">();
	}
	static class UVfxParticleModuleFadeByEmitterAngle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVfxParticleModuleFadeByEmitterAngle>();
	}
};
static_assert(alignof(UVfxParticleModuleFadeByEmitterAngle) == 0x000008, "Wrong alignment on UVfxParticleModuleFadeByEmitterAngle");
static_assert(sizeof(UVfxParticleModuleFadeByEmitterAngle) == 0x000058, "Wrong size on UVfxParticleModuleFadeByEmitterAngle");
static_assert(offsetof(UVfxParticleModuleFadeByEmitterAngle, m_LimitAngle) == 0x000040, "Member 'UVfxParticleModuleFadeByEmitterAngle::m_LimitAngle' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleFadeByEmitterAngle, m_BlendAngle) == 0x000044, "Member 'UVfxParticleModuleFadeByEmitterAngle::m_BlendAngle' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleFadeByEmitterAngle, m_VisibleDistance) == 0x000048, "Member 'UVfxParticleModuleFadeByEmitterAngle::m_VisibleDistance' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleFadeByEmitterAngle, m_BlendDistance) == 0x00004C, "Member 'UVfxParticleModuleFadeByEmitterAngle::m_BlendDistance' has a wrong offset!");

// Class EndGame.VfxParticleModuleForceFeedback
// 0x0008 (0x0040 - 0x0038)
class UVfxParticleModuleForceFeedback final : public UEndParticleModuleBase
{
public:
	EEndForceFeedbackTrack                        m_PriorityTrack;                                   // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndForceFeedbackEffect                       m_Effect;                                          // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         m_bWithPriorityControl : 1;                        // 0x003C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         m_bDisableVibrationVolumeSE : 1;                   // 0x003C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VfxParticleModuleForceFeedback">();
	}
	static class UVfxParticleModuleForceFeedback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVfxParticleModuleForceFeedback>();
	}
};
static_assert(alignof(UVfxParticleModuleForceFeedback) == 0x000008, "Wrong alignment on UVfxParticleModuleForceFeedback");
static_assert(sizeof(UVfxParticleModuleForceFeedback) == 0x000040, "Wrong size on UVfxParticleModuleForceFeedback");
static_assert(offsetof(UVfxParticleModuleForceFeedback, m_PriorityTrack) == 0x000038, "Member 'UVfxParticleModuleForceFeedback::m_PriorityTrack' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleForceFeedback, m_Effect) == 0x000039, "Member 'UVfxParticleModuleForceFeedback::m_Effect' has a wrong offset!");

// Class EndGame.VfxParticleModuleLensFlareLocation
// 0x0028 (0x0060 - 0x0038)
class UVfxParticleModuleLensFlareLocation final : public UParticleModuleLocationBase
{
public:
	struct FVector2D                              m_vCenterOffset;                                   // 0x0038(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_fCentralMagnificationArea;                       // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_fCentralMagnificationCurvedStartDirection;       // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_fCentralMagnificationCurvedEndDirection;         // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVfxLensFlareObjectData>        m_ObjectDataList;                                  // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VfxParticleModuleLensFlareLocation">();
	}
	static class UVfxParticleModuleLensFlareLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVfxParticleModuleLensFlareLocation>();
	}
};
static_assert(alignof(UVfxParticleModuleLensFlareLocation) == 0x000008, "Wrong alignment on UVfxParticleModuleLensFlareLocation");
static_assert(sizeof(UVfxParticleModuleLensFlareLocation) == 0x000060, "Wrong size on UVfxParticleModuleLensFlareLocation");
static_assert(offsetof(UVfxParticleModuleLensFlareLocation, m_vCenterOffset) == 0x000038, "Member 'UVfxParticleModuleLensFlareLocation::m_vCenterOffset' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleLensFlareLocation, m_fCentralMagnificationArea) == 0x000040, "Member 'UVfxParticleModuleLensFlareLocation::m_fCentralMagnificationArea' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleLensFlareLocation, m_fCentralMagnificationCurvedStartDirection) == 0x000044, "Member 'UVfxParticleModuleLensFlareLocation::m_fCentralMagnificationCurvedStartDirection' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleLensFlareLocation, m_fCentralMagnificationCurvedEndDirection) == 0x000048, "Member 'UVfxParticleModuleLensFlareLocation::m_fCentralMagnificationCurvedEndDirection' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleLensFlareLocation, m_ObjectDataList) == 0x000050, "Member 'UVfxParticleModuleLensFlareLocation::m_ObjectDataList' has a wrong offset!");

// Class EndGame.VfxParticleModulePostProcessImageEffects
// 0x0328 (0x0360 - 0x0038)
class UVfxParticleModulePostProcessImageEffects final : public UVfxParticleModulePostProcessBase
{
public:
	uint8                                         bOverride_VignetteIntensity : 1;                   // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_GrainIntensity : 1;                      // 0x0038(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_GrainPosition : 1;                       // 0x0038(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ChromaticAberrationIntensity : 1;        // 0x0038(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ChromaticSaturation : 1;                 // 0x0038(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_NormalizedTintIntensity : 1;             // 0x0038(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_NormalizedTintColor : 1;                 // 0x0038(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_NormalizedTintGradient : 1;              // 0x0038(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_NormalizedTintField : 1;                 // 0x0039(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_NormalizedTintGain : 1;                  // 0x0039(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ContrastIntensity : 1;                   // 0x0039(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_CompositeSDRIntensity : 1;               // 0x0039(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  m_VignetteIntensity;                               // 0x0040(0x0040)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_GrainIntensity;                                  // 0x0080(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_GrainPosition;                                   // 0x00C0(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_ChromaticAberrationIntensity;                    // 0x0100(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_ChromaticSaturation;                             // 0x0140(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_NormalizedTintIntensity;                         // 0x0180(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 m_NormalizedTintColor;                             // 0x01C0(0x0060)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_NormalizedTintGradient;                          // 0x0220(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_NormalizedTintField;                             // 0x0260(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_NormalizedTintGain;                              // 0x02A0(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_ContrastIntensity;                               // 0x02E0(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_CompositeSDRIntensity;                           // 0x0320(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VfxParticleModulePostProcessImageEffects">();
	}
	static class UVfxParticleModulePostProcessImageEffects* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVfxParticleModulePostProcessImageEffects>();
	}
};
static_assert(alignof(UVfxParticleModulePostProcessImageEffects) == 0x000008, "Wrong alignment on UVfxParticleModulePostProcessImageEffects");
static_assert(sizeof(UVfxParticleModulePostProcessImageEffects) == 0x000360, "Wrong size on UVfxParticleModulePostProcessImageEffects");
static_assert(offsetof(UVfxParticleModulePostProcessImageEffects, m_VignetteIntensity) == 0x000040, "Member 'UVfxParticleModulePostProcessImageEffects::m_VignetteIntensity' has a wrong offset!");
static_assert(offsetof(UVfxParticleModulePostProcessImageEffects, m_GrainIntensity) == 0x000080, "Member 'UVfxParticleModulePostProcessImageEffects::m_GrainIntensity' has a wrong offset!");
static_assert(offsetof(UVfxParticleModulePostProcessImageEffects, m_GrainPosition) == 0x0000C0, "Member 'UVfxParticleModulePostProcessImageEffects::m_GrainPosition' has a wrong offset!");
static_assert(offsetof(UVfxParticleModulePostProcessImageEffects, m_ChromaticAberrationIntensity) == 0x000100, "Member 'UVfxParticleModulePostProcessImageEffects::m_ChromaticAberrationIntensity' has a wrong offset!");
static_assert(offsetof(UVfxParticleModulePostProcessImageEffects, m_ChromaticSaturation) == 0x000140, "Member 'UVfxParticleModulePostProcessImageEffects::m_ChromaticSaturation' has a wrong offset!");
static_assert(offsetof(UVfxParticleModulePostProcessImageEffects, m_NormalizedTintIntensity) == 0x000180, "Member 'UVfxParticleModulePostProcessImageEffects::m_NormalizedTintIntensity' has a wrong offset!");
static_assert(offsetof(UVfxParticleModulePostProcessImageEffects, m_NormalizedTintColor) == 0x0001C0, "Member 'UVfxParticleModulePostProcessImageEffects::m_NormalizedTintColor' has a wrong offset!");
static_assert(offsetof(UVfxParticleModulePostProcessImageEffects, m_NormalizedTintGradient) == 0x000220, "Member 'UVfxParticleModulePostProcessImageEffects::m_NormalizedTintGradient' has a wrong offset!");
static_assert(offsetof(UVfxParticleModulePostProcessImageEffects, m_NormalizedTintField) == 0x000260, "Member 'UVfxParticleModulePostProcessImageEffects::m_NormalizedTintField' has a wrong offset!");
static_assert(offsetof(UVfxParticleModulePostProcessImageEffects, m_NormalizedTintGain) == 0x0002A0, "Member 'UVfxParticleModulePostProcessImageEffects::m_NormalizedTintGain' has a wrong offset!");
static_assert(offsetof(UVfxParticleModulePostProcessImageEffects, m_ContrastIntensity) == 0x0002E0, "Member 'UVfxParticleModulePostProcessImageEffects::m_ContrastIntensity' has a wrong offset!");
static_assert(offsetof(UVfxParticleModulePostProcessImageEffects, m_CompositeSDRIntensity) == 0x000320, "Member 'UVfxParticleModulePostProcessImageEffects::m_CompositeSDRIntensity' has a wrong offset!");

// Class EndGame.VfxParticleModuleRandomUV
// 0x0180 (0x01B8 - 0x0038)
class UVfxParticleModuleRandomUV final : public UEndParticleModuleBase
{
public:
	struct FRawDistributionVector                 m_Init;                                            // 0x0038(0x0060)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 m_Speed;                                           // 0x0098(0x0060)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 m_ScaleInit;                                       // 0x00F8(0x0060)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 m_ScaleSpeed;                                      // 0x0158(0x0060)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VfxParticleModuleRandomUV">();
	}
	static class UVfxParticleModuleRandomUV* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVfxParticleModuleRandomUV>();
	}
};
static_assert(alignof(UVfxParticleModuleRandomUV) == 0x000008, "Wrong alignment on UVfxParticleModuleRandomUV");
static_assert(sizeof(UVfxParticleModuleRandomUV) == 0x0001B8, "Wrong size on UVfxParticleModuleRandomUV");
static_assert(offsetof(UVfxParticleModuleRandomUV, m_Init) == 0x000038, "Member 'UVfxParticleModuleRandomUV::m_Init' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleRandomUV, m_Speed) == 0x000098, "Member 'UVfxParticleModuleRandomUV::m_Speed' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleRandomUV, m_ScaleInit) == 0x0000F8, "Member 'UVfxParticleModuleRandomUV::m_ScaleInit' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleRandomUV, m_ScaleSpeed) == 0x000158, "Member 'UVfxParticleModuleRandomUV::m_ScaleSpeed' has a wrong offset!");

// Class EndGame.VfxParticleModuleSocketLocation
// 0x0068 (0x00A0 - 0x0038)
class UVfxParticleModuleSocketLocation final : public UParticleModuleLocationBase
{
public:
	class FName                                   m_WildcardSocketName;                              // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           m_SocketNameArray;                                 // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                m_VelocityDir;                                     // 0x0050(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  m_VelocityScale;                                   // 0x0060(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VfxParticleModuleSocketLocation">();
	}
	static class UVfxParticleModuleSocketLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVfxParticleModuleSocketLocation>();
	}
};
static_assert(alignof(UVfxParticleModuleSocketLocation) == 0x000008, "Wrong alignment on UVfxParticleModuleSocketLocation");
static_assert(sizeof(UVfxParticleModuleSocketLocation) == 0x0000A0, "Wrong size on UVfxParticleModuleSocketLocation");
static_assert(offsetof(UVfxParticleModuleSocketLocation, m_WildcardSocketName) == 0x000038, "Member 'UVfxParticleModuleSocketLocation::m_WildcardSocketName' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleSocketLocation, m_SocketNameArray) == 0x000040, "Member 'UVfxParticleModuleSocketLocation::m_SocketNameArray' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleSocketLocation, m_VelocityDir) == 0x000050, "Member 'UVfxParticleModuleSocketLocation::m_VelocityDir' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleSocketLocation, m_VelocityScale) == 0x000060, "Member 'UVfxParticleModuleSocketLocation::m_VelocityScale' has a wrong offset!");

// Class EndGame.VfxParticleModuleTypeDataActor
// 0x0000 (0x0038 - 0x0038)
class UVfxParticleModuleTypeDataActor final : public UParticleModuleTypeDataBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VfxParticleModuleTypeDataActor">();
	}
	static class UVfxParticleModuleTypeDataActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVfxParticleModuleTypeDataActor>();
	}
};
static_assert(alignof(UVfxParticleModuleTypeDataActor) == 0x000008, "Wrong alignment on UVfxParticleModuleTypeDataActor");
static_assert(sizeof(UVfxParticleModuleTypeDataActor) == 0x000038, "Wrong size on UVfxParticleModuleTypeDataActor");

// Class EndGame.VfxParticleModuleTypeDataTrajectory
// 0x0350 (0x0388 - 0x0038)
class UVfxParticleModuleTypeDataTrajectory final : public UParticleModuleTypeDataBase
{
public:
	int32                                         m_MaxTrailCount;                                   // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  m_MaxTrailLength;                                  // 0x0040(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_TrailFadeAlpha;                                  // 0x0080(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 m_BaseVelocity;                                    // 0x00C0(0x0060)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 m_BaseAcceleration;                                // 0x0120(0x0060)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_SrcVelocityScale;                                // 0x0180(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EVfxTrajectoryRenderAxisOption                m_RenderAxisOption;                                // 0x01C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  m_TrailWidth;                                      // 0x01C8(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 m_TrailColor;                                      // 0x0208(0x0060)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  m_TrailAlpha;                                      // 0x0268(0x0040)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         m_fTextureTileDistance;                            // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 m_TrailRandomUv;                                   // 0x02B0(0x0060)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 m_TrailRandomUvScroll;                             // 0x0310(0x0060)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         m_bRenderGeometry : 1;                             // 0x0370(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         m_bApplyMatrixScaleVelocity : 1;                   // 0x0370(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         m_bIgnoreLimitTrailLength : 1;                     // 0x0370(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_371[0x3];                                      // 0x0371(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         m_fTrailDivDistance;                               // 0x0374(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         m_BufferCount;                                     // 0x0378(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         m_UpdateBufferFPS;                                 // 0x037C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         m_bDebugDrawBufferPoint : 1;                       // 0x0380(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         m_bDebugDrawPointCoordinate : 1;                   // 0x0380(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         m_bDebugDrawPolygonLine : 1;                       // 0x0380(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         m_bDebugDrawInterpPoint : 1;                       // 0x0380(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         m_bDebugDrawTangent : 1;                           // 0x0380(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_381[0x7];                                      // 0x0381(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VfxParticleModuleTypeDataTrajectory">();
	}
	static class UVfxParticleModuleTypeDataTrajectory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVfxParticleModuleTypeDataTrajectory>();
	}
};
static_assert(alignof(UVfxParticleModuleTypeDataTrajectory) == 0x000008, "Wrong alignment on UVfxParticleModuleTypeDataTrajectory");
static_assert(sizeof(UVfxParticleModuleTypeDataTrajectory) == 0x000388, "Wrong size on UVfxParticleModuleTypeDataTrajectory");
static_assert(offsetof(UVfxParticleModuleTypeDataTrajectory, m_MaxTrailCount) == 0x000038, "Member 'UVfxParticleModuleTypeDataTrajectory::m_MaxTrailCount' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleTypeDataTrajectory, m_MaxTrailLength) == 0x000040, "Member 'UVfxParticleModuleTypeDataTrajectory::m_MaxTrailLength' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleTypeDataTrajectory, m_TrailFadeAlpha) == 0x000080, "Member 'UVfxParticleModuleTypeDataTrajectory::m_TrailFadeAlpha' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleTypeDataTrajectory, m_BaseVelocity) == 0x0000C0, "Member 'UVfxParticleModuleTypeDataTrajectory::m_BaseVelocity' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleTypeDataTrajectory, m_BaseAcceleration) == 0x000120, "Member 'UVfxParticleModuleTypeDataTrajectory::m_BaseAcceleration' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleTypeDataTrajectory, m_SrcVelocityScale) == 0x000180, "Member 'UVfxParticleModuleTypeDataTrajectory::m_SrcVelocityScale' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleTypeDataTrajectory, m_RenderAxisOption) == 0x0001C0, "Member 'UVfxParticleModuleTypeDataTrajectory::m_RenderAxisOption' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleTypeDataTrajectory, m_TrailWidth) == 0x0001C8, "Member 'UVfxParticleModuleTypeDataTrajectory::m_TrailWidth' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleTypeDataTrajectory, m_TrailColor) == 0x000208, "Member 'UVfxParticleModuleTypeDataTrajectory::m_TrailColor' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleTypeDataTrajectory, m_TrailAlpha) == 0x000268, "Member 'UVfxParticleModuleTypeDataTrajectory::m_TrailAlpha' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleTypeDataTrajectory, m_fTextureTileDistance) == 0x0002A8, "Member 'UVfxParticleModuleTypeDataTrajectory::m_fTextureTileDistance' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleTypeDataTrajectory, m_TrailRandomUv) == 0x0002B0, "Member 'UVfxParticleModuleTypeDataTrajectory::m_TrailRandomUv' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleTypeDataTrajectory, m_TrailRandomUvScroll) == 0x000310, "Member 'UVfxParticleModuleTypeDataTrajectory::m_TrailRandomUvScroll' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleTypeDataTrajectory, m_fTrailDivDistance) == 0x000374, "Member 'UVfxParticleModuleTypeDataTrajectory::m_fTrailDivDistance' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleTypeDataTrajectory, m_BufferCount) == 0x000378, "Member 'UVfxParticleModuleTypeDataTrajectory::m_BufferCount' has a wrong offset!");
static_assert(offsetof(UVfxParticleModuleTypeDataTrajectory, m_UpdateBufferFPS) == 0x00037C, "Member 'UVfxParticleModuleTypeDataTrajectory::m_UpdateBufferFPS' has a wrong offset!");

}

